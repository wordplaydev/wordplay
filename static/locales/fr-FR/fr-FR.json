{
    "$schema": "../../schemas/LocaleText.json",
    "language": "fr",
    "region": "FR",
    "wordplay": "$~Jeu de mots",
    "term": {
        "evaluate": "$~évaluer",
        "bind": "$~lier",
        "decide": "$~décider",
        "document": "$~expliquer",
        "project": "$~projet",
        "source": "$~source",
        "input": "$~saisir",
        "output": "$~sortir",
        "convert": "$~convertir",
        "act": "$~acte",
        "scene": "$~scène",
        "phrase": "$~phrase",
        "group": "$~groupe",
        "stage": "$~scène",
        "type": "$~taper",
        "start": "$~commencer",
        "entered": "$~nouveau",
        "changed": "$~modifié",
        "moved": "$~déplacé",
        "name": "$~nom",
        "value": "$~valeur",
        "text": "$~texte",
        "boolean": "$~booléen",
        "map": "$~carte",
        "number": "$~nombre",
        "function": "$~fonction",
        "exception": "$~exception",
        "table": "$~tableau",
        "none": "$~aucun",
        "list": "$~liste",
        "stream": "$~flux",
        "structure": "$~structure",
        "index": "$~indice",
        "query": "$~requête",
        "row": "$~rangée",
        "set": "$~ensemble",
        "key": "$~clé",
        "help": "$~Aide",
        "feedback": "$~retour"
    },
    "token": {
        "EvalOpen": "$~évaluation ouverte",
        "EvalClose": "$~clôture de l'évaluation",
        "SetOpen": "$~ensemble/carte ouvert",
        "SetClose": "$~fermer l'ensemble/la carte",
        "ListOpen": "$~liste ouverte",
        "ListClose": "$~liste fermée",
        "TagOpen": "$~balise ouverte",
        "TagClose": "$~balise fermer",
        "Bind": "$~lier",
        "Access": "$~accès à la propriété",
        "Function": "$~fonction",
        "Borrow": "$~emprunter",
        "Share": "$~partager",
        "Convert": "$~convertir",
        "Doc": "$~explication",
        "Formatted": "$~formaté",
        "FormattedType": "$~type formaté",
        "Words": "$~mots",
        "Link": "$~lien web",
        "Italic": "$~italique",
        "Underline": "$~souligner",
        "Light": "$~lumière",
        "Bold": "$~audacieux",
        "Extra": "$~supplémentaire",
        "Concept": "$~lien conceptuel",
        "URL": "$~URL",
        "Code": "$~code",
        "Mention": "$~mention",
        "Otherwise": "$~sinon",
        "Match": "$~correspondre",
        "None": "$~rien",
        "Type": "$~taper",
        "Literal": "$~littéral",
        "TypeOperator": "$~est",
        "TypeOpen": "$~type d'entrée ouvert",
        "TypeClose": "$~type d'entrée fermer",
        "Separator": "$~séparateur de nom",
        "Language": "$~balise de langue",
        "Region": "$~tiret de région",
        "BooleanType": "$~type booléen",
        "NumberType": "$~type de numéro",
        "JapaneseNumeral": "$~chiffre japonais",
        "RomanNumeral": "$~chiffre romain",
        "Pi": "$~pi",
        "Infinity": "$~infini",
        "TableOpen": "$~table ouverte",
        "TableClose": "$~tableau fermé",
        "Select": "$~sélectionner",
        "Insert": "$~insérer",
        "Update": "$~mise à jour",
        "Delete": "$~supprimer",
        "Union": "$~union",
        "Stream": "$~suivant",
        "Change": "$~changement",
        "Initial": "$~première évaluation",
        "Previous": "$~précédent",
        "Placeholder": "$~espace réservé",
        "Etc": "$~et cetera",
        "This": "$~ce",
        "Operator": "$~opérateur",
        "Conditional": "$~conditionnel",
        "Text": "$~texte",
        "Number": "$~nombre",
        "Decimal": "$~nombre décimal",
        "Base": "$~nombre de base",
        "Boolean": "$~booléen",
        "Name": "$~nom",
        "Unknown": "$~inconnu",
        "Locale": "$~lieu",
        "End": "$~fin"
    },
    "node": {
        "Dimension": {
            "name": "$~dimension",
            "description": "$~dimension",
            "emotion": "$?",
            "doc": [
                "$~Je suis une /unité de mesure/!",
                "$~Je peux être n'importe quelle unité standardisée, comme \\1m\\, \\10s\\, \\100g\\, ou toute autre unité scientifique. Je suis également heureux d'être n'importe quelle unité que vous souhaitez créer, comme \\17apple\\.",
                "$~Je peux être combiné avec \\/\\ pour créer des unités de rapport comme \\17pomme/jour\\ et avec \\^\\ pour créer des unités exponentielles comme \\9,8m/s^2\\",
                "$~Je dois toujours placer mon nom après un @Number. Sinon, je risque d'être confondu avec @Reference, ce qui serait assez embarrassant !",
                "$~Je suis assez doué pour trouver des incohérences entre les unités aussi. Par exemple, \\1cat + 1dog\\ n'a aucun sens !",
                "$~Si vous souhaitez un jour effectuer une conversion entre différentes valeurs d'unités, contactez @Convert."
            ]
        },
        "Doc": {
            "name": "$~explication",
            "emotion": "$?",
            "doc": [
                "$~Je formate richement les choses avec @Markup, comme les explications de certains de vos @Programmes, ou même les mots que vous mettez en scène avec @Phrase.",
                "$~Par exemple, je peux mettre avant n'importe quelle expression :",
                "$~\\¶Est-ce vraiment censé être 7 ?¶\n7\\",
                "$~Par exemple, vous pouvez me placer avant @Bind :",
                "$~\\¶Je mesure la taille de quelqu'un¶\nhauteur : 5 m\\",
                "$~Ou avant une @FunctionDefinition :",
                "$~\\¶J'additionne deux nombres¶\nƒ somme(a•# b•#) a + b\\",
                "$~Ou avant une @StructureDefinition :",
                "$~\\¶Je me souviens du nom des gens et de leur fruit préféré¶\n•Personne(nom•'' fruit•'')\\",
                "$~Vous pouvez également me placer au tout début de @Program pour dire de quoi parle toute la performance",
                "$~\\¶Ce programme dit bonjour¶\n\n'bonjour!'\\",
                "$~Vous pouvez me donner une @Langue pour aider les autres à savoir dans quelle langue j'écris :",
                "$~\\¶Je suis un doc anglais¶/fr\ndurée : 5 s\\",
                "$~Saviez-vous que vous pouvez créer une liste de mes contacts ? Allez en parler à @Docs."
            ]
        },
        "Docs": {
            "name": "$~listed'explication",
            "emotion": "$?",
            "doc": [
                "$~Voici une liste de @Doc, utile lorsque vous avez plusieurs traductions de @Doc dans différentes langues.",
                "$~Vous n'avez rien de spécial à faire pour créer une liste. Il suffit de placer plusieurs @Doc les uns à côté des autres, comme ceci :",
                "$~\\¶Bonjour¶/fr ¶Hola¶/es salutation : '…'\\"
            ],
            "start": "$~Donner de la valeur aux documents !"
        },
        "KeyValue": {
            "name": "$~cartographie",
            "emotion": "$?",
            "doc": [
                "$~Je fais un mappage d'une *clé* vers une *valeur*, toujours dans une @Map.",
                "$~Vous pouvez mapper n'importe quel type de valeur à n'importe quelle autre. Par exemple, voici une correspondance entre des nombres :",
                "$~\\{1:1}\\",
                "$~Ou une correspondance entre le texte et les nombres :",
                "$~\\{'lapin':1}\\"
            ]
        },
        "Language": {
            "name": "$~langue",
            "description": "$~langue $1[$1|inconnu]",
            "emotion": "$?",
            "doc": [
                "$~Je suis un tag de langue et je travaille avec @Name et @Doc !",
                "$~Je suis vraiment doué pour rendre *très clair* dans quelle langue est écrit quelque chose.",
                "$~C'est ce que je fais. Juste une petite barre oblique et quelques lettres, et personne ne sera jamais confus quant à la langue dans laquelle est écrit un texte.",
                "$~Par exemple, disons que vous vouliez dire mon $name, mais précisez clairement que je suis en anglais :",
                "$~\\\"Langue\"/fr\\",
                "$~Ou, supposons que vous vouliez faire cela pour un @Name.",
                "$~\\son/fr: 'miaou'\\",
                "$~Ou même @Doc !",
                "$~\\¶Onomatopée¶/fr son/fr: \"miaou\"\\",
                "$~Il existe de nombreux <codes de langue à 2 lettres@https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes> que je comprends. Si vous n'en utilisez pas, je vous le ferai savoir."
            ],
            "conflict": {
                "UnknownLanguage": "$~Je ne connais pas cette langue",
                "MissingLanguage": "$~Il me manque une langue. Pouvez-vous en ajouter une ?"
            }
        },
        "Name": {
            "name": "$~nom",
            "description": "$~1 $ [$1 | sans nom]",
            "emotion": "$?",
            "doc": [
                "$~J'identifie une valeur et je suis un moyen utile de donner une étiquette abrégée à quelque chose qui était difficile à évaluer ou que vous ne voulez pas avoir à évaluer encore et encore.",
                "$~@Bind me donne mon nom comme ceci :",
                "$~\\salut: 5\\",
                "$~Je ne représente qu'une seule valeur, et une fois que je l'ai, je ne peux plus la modifier. Par exemple, si vous essayez de faire cela avec @Bind, nous nous plaindrons.",
                "$~\\salut : 5\nsalut : 3\\",
                "$~Pour obtenir ma valeur, il vous suffit de demander à @Reference ou @PropertyReference d'utiliser le nom. Ici, @Bind me nomme, puis @Reference récupère la valeur qui m'a été donnée.",
                "$~\\salut : 5\nsalut\\",
                "$~Comme @Bind peut apparaître à de nombreux endroits, je peux apparaître à de nombreux endroits. J'étais dans un @Block ci-dessus, mais je peux être dans une @FunctionDefinition. Ici, je nomme un message temporairement :",
                "$~\\ƒ dire(message•'') message\\",
                "$~Je suis défini dans @FunctionDefinition, puis dès que la fonction a terminé son évaluation, je m'en vais.",
                "$~Vous pouvez utiliser @Langue pour indiquer la langue dans laquelle mon nom est écrit. Ceci est utile lorsque vous partagez votre performance avec d'autres, au cas où ils voudraient lire votre programme."
            ]
        },
        "Names": {
            "name": "$~listedenoms",
            "emotion": "$?",
            "doc": [
                "$~Je suis une liste de @Name, utile lorsque vous souhaitez donner à une valeur plusieurs noms, souvent avec des @Language différents.",
                "$~Les noms sont séparés par des symboles \\,\\. Par exemple, @Bind donne une valeur multiple à @Name",
                "$~\\salut/fr,bonjour/fr,hola/es : 'bienvenue'\\"
            ]
        },
        "Row": {
            "name": "$~rangée",
            "emotion": "$?",
            "doc": "$~Je représente une ligne dans une @Table. Il est probablement préférable d'aller parler à @Table, ils savent tout de moi. Je reste assis et je garde les valeurs en ligne :(",
            "conflict": {
                "InvalidRow": "$~Les lignes doivent être soit toutes des valeurs, soit toutes @Bind.",
                "MissingCell": {
                    "primary": "$~Il me manque la colonne 1",
                    "secondary": "$~Je suis requis, mais 1 $ ne l'a pas fourni"
                },
                "UnknownColumn": "$~Je ne connais pas de chronique portant ce nom",
                "ExtraCell": {
                    "primary": "$~Suis-je censé être ici ?",
                    "secondary": "$~Hé 1 $, tu ne fais pas partie de cette @Table !"
                },
                "UnexpectedColumnBind": {
                    "primary": "$~Suis-je censé être un @Bind ?",
                    "secondary": "$~Hé, je suis un @Table, j'ai besoin de valeurs, pas de @Bind."
                }
            }
        },
        "Token": {
            "name": "$~jeton",
            "description": "$~1 $ 2 $",
            "emotion": "$?",
            "doc": [
                "$~Comment m'as-tu trouvé ?",
                "$~Je suis la plus petite partie possible d’une performance. Je suis le substrat à partir duquel tous les personnages du Vers sont faits. Je suis la particule atomique de notre chorégraphie."
            ]
        },
        "TypeInputs": {
            "name": "$~entréesdetype",
            "emotion": "$?",
            "doc": "$~Je suis une liste de types qui remplacent les @TypeVariables dans une @StructureDefinition ou une @FunctionDefinition. J'aide tout le monde à savoir quel type d'entrées ils recevront."
        },
        "TypeVariable": {
            "name": "$~variabledetype",
            "emotion": "$?",
            "doc": "$~Je suis un type mystère sur @FunctionDefinition ou @StructureDefinition, fourni par @TypeInputs lorsque l'un ou l'autre est évalué. @Set, @List et @Map m'utilisent.",
            "conflict": {
                "DuplicateTypeVariable": {
                    "primary": "$~J'ai le même nom que $1",
                    "secondary": "$~J'ai le même nom que $1"
                }
            }
        },
        "TypeVariables": {
            "name": "$~variablesdetype",
            "emotion": "$?",
            "doc": "$~Je suis une liste de @TypeVariable."
        },
        "Markup": {
            "name": "$~balisage",
            "description": "$~1 paragraphe",
            "emotion": "$?",
            "doc": [
                "$~Je suis une liste de paragraphes, utilisant les nombreux types de balisage disponibles dans les explications, tels que @Words, @WebLink, @ConceptLink et @Example."
            ]
        },
        "Paragraph": {
            "name": "$~paragraphe",
            "emotion": "$?",
            "doc": [
                "$~Je suis une série de @Words, @ConceptLink, @WebLink et @Example, séparés par une ligne vide et à l'intérieur de @Doc.",
                "$~Tout ce que vous avez à faire pour m'écrire est d'écrire un tas de mots dans un @Doc :",
                "$~\\¶Je suis un paragraphe dans un document.¶'un paragraphe'\\",
                "$~Si vous souhaitez plusieurs paragraphes, insérez simplement des lignes vides.",
                "$~\\¶Paragraphe 1.\n\nParagraphe 2.\n\nParagraphe 3.¶'trois paragraphes'\\"
            ]
        },
        "WebLink": {
            "name": "$~lien",
            "description": "$~lien 1$",
            "emotion": "$?",
            "doc": [
                "$~Je suis un lien vers quelque chose sur Internet. J'ai juste besoin d'une description et d'une URL :",
                "$~\\¶Je suis un <link@https://wordplay.dev> dans un document¶\n'exemple de lien'\\",
                "$~Si quelqu'un me sélectionne, j'ouvrirai une nouvelle fenêtre vers l'URL."
            ]
        },
        "ConceptLink": {
            "name": "$~concept",
            "description": "$~concept 1",
            "emotion": "$?",
            "doc": [
                "$~Je suis un lien vers le personnage de Verse. Je suis utile lorsque vous souhaitez écrire un @Doc et faire référence à l'un d'entre nous.",
                "$~Par exemple, disons que vous voulez parler de @Evaluate et de son excellence. Vous pourriez écrire :",
                "$~\\¶Vous savez, @Evaluate est plutôt génial.¶\n'regarde, un lien conceptuel !'\\",
                "$~Lorsque le @Doc que vous avez écrit apparaît ici, il affichera un lien vers le concept."
            ]
        },
        "Words": {
            "name": "$~mots",
            "emotion": "$?",
            "doc": [
                "$~Je mets tous les mots que vous voulez dans un @Doc. Par exemple :",
                "$~\\Que la Force soit avec toi.¶\n'juste quelques mots !'\\",
                "$~Parfois, vous souhaiterez peut-être utiliser les caractères spéciaux que @Doc utilise comme mots. Par exemple :",
                "$~\\¶Mes amis utilisent @@, //, **, || et d'autres symboles.¶\n'en utilisant des caractères spéciaux !'\\",
                "$~Si vous répétez simplement ces caractères spéciaux, vous obtiendrez le caractère au lieu de sa signification spéciale."
            ]
        },
        "Example": {
            "name": "$~exemple",
            "emotion": "$?",
            "doc": [
                "$~Je suis un exemple de performance, utile pour écrire un @Doc qui explique comment utiliser quelque chose !",
                "$~\\¶Voici un exemple d'ajout : \\1 + 1\\¶'exemple de code'\\",
                "$~Si vous me mettez dans un paragraphe tout seul, j'apparaîtrai dans une jolie boîte et montrerai le résultat de mon évaluation.",
                "$~\\¶Voici un exemple d'addition :\n\n\\1 + 1\\¶\\"
            ]
        },
        "Mention": {
            "name": "$~mention",
            "description": "$~mentionner 1 $",
            "emotion": "$?",
            "doc": [
                "$~Je fais référence soit à une terminologie \\$programme\\ soit à une entrée dynamique \\$1\\.",
                "$~Il s’agit principalement d’une fonctionnalité interne, vous n’avez donc pas besoin de la connaître."
            ]
        },
        "Branch": {
            "name": "$~bifurquer",
            "emotion": "$?",
            "doc": [
                "$~Je suis un moyen de choisir entre deux segments d'explication en fonction du fait qu'une valeur d'entrée d'explication est définie ou vraie.",
                "$~Il s’agit principalement d’une fonctionnalité interne, vous n’avez donc pas besoin de la connaître."
            ]
        },
        "BinaryEvaluate": {
            "name": "$~évaluationbinaire",
            "description": "$~Opération 1 $",
            "emotion": "$?",
            "doc": [
                "$~Je suis @Evaluate, mais sous une forme plus simple, utile lorsque vous souhaitez utiliser une @FunctionDefinition qui prend deux entrées.",
                "$~Par exemple, voici comment vous pouvez utiliser @Evaluate pour additionner deux nombres :",
                "$~\\1.+(1)\\",
                "$~Cela ne semble-t-il pas un peu drôle ? Ce n'est pas faux : cela indique simplement d'obtenir la fonction d'ajout sur 1, puis de l'évaluer.",
                "$~Mais il est beaucoup plus facile d'utiliser @BinaryEvaluate",
                "$~\\1 + 1\\",
                "$~Cela rend tout un peu plus ordonné, même si c'est fondamentalement la même chose.",
                "$~Il n'y a qu'une chose à laquelle il faut faire attention : lorsque je suis sous cette forme, j'évalue de gauche à droite. Cela peut être déroutant si vous êtes habitué à des choses comme l'ordre des opérations en mathématiques.",
                "$~Cela signifie que cela s'évalue d'une manière à laquelle vous ne vous attendez peut-être pas :",
                "$~\\1 + 2 · 3 + 4\\",
                "$~En mathématiques, la multiplication viendrait en premier, suivie de l'addition, et le résultat serait donc \\11\\. Mais comme j'évalue dans l'ordre de lecture, le résultat est \\13\\."
            ],
            "right": "$~saisir",
            "start": "$~Commençons par évaluer 1 $",
            "finish": "$~Regarde, j'ai gagné 1 $ !",
            "conflict": {
                "OrderOfOperations": "$~J'évalue dans l'ordre de lecture, et non dans l'ordre mathématique des opérations. Voulez-vous utiliser @Block pour spécifier l'ordre dans lequel je dois évaluer ?"
            }
        },
        "Bind": {
            "name": "$~lier",
            "description": "$~lier 1",
            "emotion": "$?",
            "doc": [
                "$~Je nomme des *valeurs*.",
                "$~Comme ça!",
                "$~\\pi: 3.1415926\\",
                "$~Je nomme les entrées dans @FunctionDefinition et @StructureDefinition, je nomme les valeurs dans @Block. Je nomme tout !",
                "$~Oh, mais saviez-vous que vous pouvez avoir une valeur *plusieurs noms* ?",
                "$~Je suis tellement excitée de vous en parler ! Une valeur, plusieurs @Noms. Par exemple :",
                "$~\\joe,tess,amy: 5\\",
                "$~Tu vois ce que j'ai fait là ?",
                "$~Une valeur, trois noms.",
                "$~Vous pouvez faire référence à ces cinq par *n'importe lequel* de ces noms.",
                "$~C'est particulièrement vrai lorsque vous souhaitez donner des noms dans plusieurs langues :",
                "$~\\joe/en,aimee/fr,明/zh: 5\\",
                "$~Vous voyez ce que j'ai fait là ? Trois noms pour une valeur, mais dans des langues différentes !",
                "$~Ok, j'ai un dernier secret.",
                "$~Saviez-vous que je peux travailler avec @Is pour me dire quelle valeur un nom devrait avoir ? Et si je ne l'ai pas, je vous le dirai ?",
                "$~Comme ça:",
                "$~\\bignumber•#: \"un zillion\"\\",
                "$~Voyez, j'ai dit que \\bignumber\\ devrait être un nombre, mais c'est du texte, et ceux-ci ne sont pas compatibles et donc BOOM !",
                "$~Je vous ferai savoir s’ils ne sont pas d’accord.",
                "$~Parfois, vous devrez peut-être me dire de quel type de données il s'agit, car je ne peux pas le comprendre moi-même. Cela se produit généralement dans @FunctionDefinition.",
                "$~Par exemple, ici, @FunctionDefinition ne sait pas quel type de valeurs ont \\a\\ et \\b\\, car je ne le leur ai pas dit.",
                "$~\\ƒ somme(a b) a + b\\",
                "$~Mais nous pouvons changer cela pour ajouter les @Is, et maintenant @FunctionDefinition sait que ce sont des nombres :",
                "$~\\ƒ somme(a•# b•#) a + b\\"
            ],
            "start": "$~Voyons quelle valeur nous obtenons à partir de 1 $ !",
            "finish": "$~Oh, c'est bien, j'ai eu 1 $ ! Appelons-le 2 $",
            "conflict": {
                "DuplicateName": {
                    "conflict": {
                        "primary": "$~quelqu'un a le nom $1 donc je ne peux pas avoir ce nom.",
                        "secondary": "$~Hé, 1 $ c'est mon nom, tu ne peux pas l'avoir !"
                    },
                    "resolution": "$~Il y a des noms en double, voulez-vous en supprimer un ?"
                },
                "DuplicateShare": {
                    "primary": "$~J'ai le même nom que $1, ce qui rend ce qui est partagé ambigu",
                    "secondary": "$~J'ai le même nom que $1"
                },
                "IncompatibleType": {
                    "primary": "$~Je suis censé être un 2 $, mais je suis un 1 $",
                    "secondary": "$~Oh, je suis désolé. Dois-je changer, ou peut-être es-tu censé être un dollar ?"
                },
                "MisplacedShare": "$~Je ne peux partager des choses qu'au niveau du @Programme, pas à l'intérieur de quoi que ce soit !",
                "MissingShareLanguages": "$~si vous souhaitez partager ceci, vous devez indiquer dans quelle langue il est rédigé, afin que les autres sachent s'ils peuvent le lire !",
                "RequiredAfterOptional": "$~Je ne peux pas être ici, il y a un @Bind facultatif avant moi",
                "UnexpectedEtc": "$~Je ne peux avoir qu'une longueur variable dans une @FunctionDefinition",
                "UnusedBind": "$~Je m'appelle $1, mais personne ne m'utilise. Peut-être que je ne suis pas nécessaire ?"
            }
        },
        "Block": {
            "name": "$~bloc",
            "description": "$~Relevés de 1 $",
            "emotion": "$?",
            "doc": [
                "$~Bonjour, je crée un petit espace calme et privé pour évaluer les choses.",
                "$~Comme ça:",
                "$~\\(1 - 1) + 2\\",
                "$~Cela permet de clarifier l’ordre d’évaluation.",
                "$~@Bind aide aussi.",
                "$~\\(compte : 10 comptes ^ comptes)\\",
                "$~Vous voyez comment @Bind a créé \\count\\ ? Il n'est nommé qu'à l'intérieur de moi. Donc cela ne fonctionnera pas :",
                "$~\\(compte : 10 compte ^ compte) + compte\\",
                "$~Parce que le nom du comte n'était mentionné qu'à l'intérieur de moi.",
                "$~Vous pouvez me mettre autant d'expressions que vous voulez. Mais je ne m'intéresse qu'à la dernière :",
                "$~\\(1 2 3 4 5)\\",
                "$~Donc, généralement, je suis juste un tas de @Bind suivi d'une expression à la fin.",
                "$~\\(\na : 1\nb : 2\nc : 3\nd : 4\na + b + c + d\n)\\"
            ],
            "statement": "$~déclaration",
            "start": "$~Première expression",
            "finish": "$~C'est fait, j'ai 1 $",
            "conflict": {
                "ExpectedEndingExpression": "$~J'ai besoin d'une expression.",
                "IgnoredExpression": {
                    "primary": "$~Je vais ignorer $1, car il ne définit rien et n'est pas ma dernière expression.",
                    "secondary": "$~@Block, ne m'ignore pas !",
                    "resolution": "$~Vouliez-vous dire que ce serait un @BinaryEvaluate au lieu d'un @UnaryEvaluate ? Je peux ajouter un espace, donc je sais que c'est ce que vous vouliez dire."
                }
            }
        },
        "BooleanLiteral": {
            "name": "$~littéralbooléen",
            "description": "$~$1[vrai|faux]",
            "emotion": "$?",
            "doc": "$~Je suis soit \\⊤\\, soit \\⊥\\. Voir @Boolean pour en savoir plus sur notre belle logique.",
            "start": "$~1$!"
        },
        "Borrow": {
            "name": "$~emprunter",
            "description": "$~emprunter 1 $ [$1|nom manquant]",
            "emotion": "$?",
            "doc": "$~Si vous créez une performance avec plusieurs @Source, vous pouvez m'utiliser pour emprunter les @Bind partagés dans ces autres @Source. Utilisez simplement leur nom et j'apporterai leur nom et leur valeur.",
            "start": "$~Emprunter 2 $ à partir de 1 $",
            "source": "$~source",
            "bind": "$~nom",
            "version": "$~version",
            "conflict": {
                "UnknownBorrow": "$~Je ne connais pas de source de ce nom",
                "BorrowCycle": "$~cela dépend de $1, qui dépend de cette $source, donc le programme ne peut pas être évalué"
            },
            "exception": {
                "CycleException": {
                    "description": "$~cycle d'emprunt",
                    "explanation": "$~1$ dépend de lui-même"
                }
            }
        },
        "Changed": {
            "name": "$~modifié",
            "emotion": "$?",
            "doc": [
                "$~Je vérifie si un flux a provoqué la réévaluation de @Program et crée un @Boolean. Comme ça",
                "$~\\∆ Temps()\\",
                "$~Je suis vraiment utile lorsque vous souhaitez que quelque chose change uniquement si un flux a changé.",
                "$~C'est ça."
            ],
            "start": "$~Voyons si 1 $ a changé…"
        },
        "Conditional": {
            "name": "$~conditionnel",
            "emotion": "$?",
            "doc": [
                "$~Je pense que je suis censé prendre des décisions ? Comme ça ?",
                "$~\\nombre : -100\nnombre < 0 ? 'négatif' 'positif'\\",
                "$~Mais avez-vous déjà pensé à la façon dont nous décidons ?",
                "$~Ne semble-t-il pas que les décisions devraient être plus nuancées que de simples oui ou non ? Le choix entre \\⊤\\ et \\⊥\\ est-il tout ce qu'il y a à faire ?",
                "$~Ne craignez-vous pas que si ce sont les seules décisions que nous pouvons prendre, nous passerons à côté d’un contexte important sur le monde ?"
            ],
            "start": "$~Voyons si 1 est vrai",
            "afterthen": "$~fini avec le oui, sautons le non ?",
            "else": "$~$1[sauter par-dessus le code | ne pas sauter par-dessus le code]",
            "finish": "$~Je suppose que c'est 1 $ ?",
            "condition": "$~condition",
            "yes": "$~Oui",
            "no": "$~Non",
            "conflict": {
                "ExpectedBooleanCondition": {
                    "primary": "$~Comment puis-je choisir oui ou non avec 1 $ ? Non vraiment, comment ?",
                    "secondary": "$~Je pense que @Conditional voulait que je sois un @Boolean, mais je suis un $1."
                }
            }
        },
        "ConversionDefinition": {
            "name": "$~définitiondeconversion",
            "description": "$1 → $2",
            "emotion": "$?",
            "doc": [
                "$~Mec, je définis des conversions d'un type à un autre ! Je vais dans @Block, quelque chose comme ça :",
                "$~\\→ #chaton #chat . ÷ 2\n6chaton→#chat\\",
                "$~Vous voyez comment j'ai transformé des chatons en chats ? C'est génial !",
                "$~Vous vous demandez peut-être ce que fait ce \\.\\ ici. Il représente la valeur en cours de conversion. Je l'utilise parce que la valeur n'a pas de nom autrement."
            ],
            "start": "$~Génial, une nouvelle conversion !",
            "conflict": {
                "MisplacedConversion": "$~ouah, je ne peux pas être là, juste à @Block."
            }
        },
        "Convert": {
            "name": "$~convertir",
            "emotion": "$?",
            "doc": [
                "$~Yo. Je transforme les valeurs d'un type à un autre. Regardez ça :",
                "$~\\1 → \"\"\\",
                "$~\\5s → #ms\\",
                "$~\\\"bonjour\" → []\\",
                "$~Vous pouvez même les enchaîner :",
                "$~\\\"bonjour\" → [] → {}\\",
                "$~Les valeurs ont un ensemble de @ConversionDefinition qui sont prédéfinies, mais si vous créez une @StructureDefinition pour un nouveau type de valeur, vous pouvez définir la vôtre avec @ConversionDefinition."
            ],
            "start": "$~Obtenez cette valeur à partir de 1 $ !",
            "finish": "$~Génial, j'ai gagné 1 $",
            "conflict": {
                "UnknownConversion": "$~Dommage, il n'y a aucun moyen de transformer 1 $ en 2 $"
            },
            "exception": {
                "ConversionException": {
                    "description": "$~conversion impossible",
                    "explanation": "$~Je ne sais pas comment convertir de 1 $ à 2 $"
                }
            }
        },
        "Delete": {
            "name": "$~supprimer",
            "emotion": "$?",
            "doc": [
                "$~Parfois, vous avez une table et il y a TROP DE CHOSES DEDANS !",
                "$~Comme si vous aviez des joueurs dans une partie et qu'un d'entre eux partait et que vous vouliez juste dire : \"VA-T'EN, JOUEUR, SORTEZ DE MA TABLE !\"",
                "$~\\joueurs : ⎡nom•'' équipe•'' points•#⎦\n⎡'jen' 'red' 8⎦\n⎡'joan' 'blue' 11⎦\n⎡'jeff' 'red' 9⎦\n⎡'janet' 'blue' 7⎦\njoueurs ⎡- nom = 'jeff'\\",
                "$~Ouf, Jeff est parti. AU REVOIR JEFF. Souviens-toi juste que je ne change pas la table d'origine, j'en fais une nouvelle, sans JEFF. C'est toi qui décides où elle va."
            ],
            "start": "$~Commençons par la table",
            "finish": "$~J'ai créé un nouveau tableau sans les lignes correspondantes !"
        },
        "DocumentedExpression": {
            "name": "$~expressionexpliquée",
            "emotion": "$?",
            "doc": [
                "$~Je suis n'importe quelle expression, mais avec un @Doc !",
                "$~Pour me faire, il suffit de mettre un @Doc avant une expression, et vous m'obtiendrez :",
                "$~\\doubleplus: 1\n(2 · doubleplus) + \n¶Rendons-le un peu plus grand¶\n1\\",
                "$~Je suis utile pour faire un commentaire sur une partie d'un programme."
            ],
            "start": "$~Évaluons l'expression"
        },
        "Evaluate": {
            "name": "$~évaluer",
            "description": "$~évaluer $1[$1|anonyme]",
            "emotion": "$?",
            "doc": [
                "$~Salut. J'évalue ma très chère @FunctionDefinition. Comme ça :",
                "$~\\ƒ salutation(message•'')\nsalutation('kitty')\\",
                "$~Les fonctions peuvent provenir de n'importe où. Par exemple, @Text a des fonctions. Comme ceci :",
                "$~\\'kitty'.length()\\",
                "$~Si une fonction a un seul nom de symbole, vous pouvez m'écrire en tant que @BinaryEvaluate.",
                "$~\\'minou' ⊆ 'itty'\\",
                "$~Cela fait la même chose que ceci :",
                "$~\\'minou'.⊆('itty')\\",
                "$~Bien sûr, je ne suis rien sans @FunctionDefinition. Tout ce que je fais, c'est leur donner des informations et suivre leurs étapes."
            ],
            "start": "$~Commençons par évaluer les entrées",
            "evaluate": "$~évaluons la fonction maintenant",
            "finish": "$~J'ai évalué à 1$",
            "function": "$~fonction",
            "input": "$~saisir",
            "conflict": {
                "IncompatibleInput": {
                    "primary": "$~Je suis censé être un 1 $, mais je suis un 2 $",
                    "secondary": "$~Euh, j'ai eu 2 $ au lieu de 1 $"
                },
                "UnexpectedTypeInput": {
                    "primary": "$~Je ne m'attendais pas à ce type d'entrée",
                    "secondary": "$~Oh, je ne suis pas censé être ici ?"
                },
                "MissingInput": {
                    "primary": "$~Je ne peux pas évaluer sans l'entrée nommée $2 :(",
                    "secondary": "$~J'ai besoin d'une valeur, pouvez-vous m'en donner une ?"
                },
                "NotInstantiable": "$~Je ne peux pas créer cette @StructureDefinition, elle contient des fonctions non implémentées.",
                "UnexpectedInput": {
                    "primary": "$~Je ne m'attendais pas à cette entrée 1$",
                    "secondary": "$~Oh, je ne suis pas censé être ici ?"
                },
                "UnknownInput": {
                    "primary": "$~Je ne connais pas d'entrée portant ce nom dans $1",
                    "secondary": "$~Je n'ai pas d'entrée avec le nom $1"
                },
                "InputListMustBeLast": "$~la liste des entrées doit être la dernière",
                "SeparatedEvaluate": "$~Est-ce que $1 est le nom d'une $2[$structure|$function] que vous essayez d'évaluer ? Essayez de supprimer l'espace après moi, afin que je sache qu'il s'agit d'un @Evaluate et non d'un @Block distinct."
            },
            "exception": {
                "FunctionException": {
                    "description": "$~fonction inconnue",
                    "explanation": "$~oh non, $1 n'est pas une fonction dans $2[$2|this @Block]!"
                }
            }
        },
        "Input": {
            "name": "$~Saisir",
            "description": "$~entrée nommée",
            "emotion": "$?",
            "doc": [
                "$~Je suis une entrée donnée à un @Evaluate. Mon nom correspond au nom de l'entrée dans la @FunctionDefinition ou la @StructureDefinition en cours d'évaluation.",
                "$~Je suis utile avec les fonctions qui ont de nombreuses valeurs par défaut, où vous souhaitez simplement remplacer une entrée spécifique, sans tout donner d'autre.",
                "$~Par exemple, @Phrase possède de très nombreuses valeurs par défaut pour contrôler son style. Supposons que vous souhaitiez donner un @Text et un @Color, mais rien d'autre dans sa liste d'entrées. Vous pouvez utiliser me pour faire cela :",
                "$~\\Phrase('Je suis violet !' couleur : Couleur(50% 52 300°))\\"
            ],
            "start": "$~Évaluons ma valeur."
        },
        "ExpressionPlaceholder": {
            "name": "$~espaceréservé",
            "description": "$~$1[$1|espace réservé]",
            "emotion": "$?",
            "doc": [
                "$~Je suis une *expression*, mais pas une vraie… Je prends juste la place d'une.",
                "$~Je suis d'accord si tu ne sais pas encore quoi écrire.",
                "$~\\1 + _\\",
                "$~Qu'est-ce qu'on ajoute ? Je ne sais pas. À vous de me le dire.",
                "$~Ou si quelqu'un évaluait une fonction avec @Evaluate, je pourrais remplacer la fonction",
                "$~\\_(1 2 3)\\",
                "$~Je n'aime pas être sur @Stage !"
            ],
            "start": "$~Je ne sais pas quoi faire ici. Pouvez-vous m'expliquer ?",
            "placeholder": "$~expression",
            "conflict": {
                "Placeholder": "$~Peux-tu me renseigner ? Je ne suis qu'un remplaçant."
            },
            "exception": {
                "UnimplementedException": {
                    "description": "$~non implémenté",
                    "explanation": "$~Je ne sais pas quoi faire ici. Pouvez-vous m'expliquer ?"
                }
            }
        },
        "FunctionDefinition": {
            "name": "$~fonction",
            "description": "$~fonction $1",
            "emotion": "$?",
            "doc": [
                "$~Bonjour à nouveau ! Je prends quelques entrées, puis j'évalue une expression en les utilisant, produisant une sortie.",
                "$~Voici un exemple simple :",
                "$~\\ƒ répéter(message•'') message · 5\nrépéter('salut')\\",
                "$~Cette fonction prend une entrée, \\message\\, et utilise la fonction @Text/repeat pour répéter le message cinq fois.",
                "$~Je suis vraiment utile si vous souhaitez évaluer quelque chose encore et encore, mais avec des entrées différentes !",
                "$~J'ai plein d'autres petites astuces. Par exemple, je n'ai pas besoin d'avoir un nom. Ici, je vais directement à @Evaluate comme valeur.",
                "$~\\(ƒ(message•'') message · 5)('salut')\\",
                "$~Ou, voici une fonction qui prend n’importe quel nombre d’entrées, en utilisant le caractère \\…\\ après un nom d’entrée.",
                "$~\\ƒ oui(messages…•'') messages.sans('non')\noui('oui' 'oui' 'non' 'oui' 'non')\\",
                "$~Vous voyez comment il a pris tous les « non » et s'en est débarrassé ? C'est parce que messages est une @List, et nous pourrions donc utiliser @List/sansAll.",
                "$~Parfois, vous souhaiterez peut-être préciser le type de valeur que je produis. Pour ce faire, ajoutez un @Is après la liste des entrées :",
                "$~\\ƒ ajouter(x•# y•#)•'' x + y\\",
                "$~Vous remarquerez peut-être un problème avec celui-ci : il indique qu'il évalue à @Text, mais il faut deux @Number. Je peux vous dire quand les choses sont incohérentes !",
                "$~Bien sûr, je ne suis pas vraiment utile sans @Evaluate ; ils me donnent vie."
            ],
            "start": "$~Créons cette fonction !",
            "conflict": {
                "NoExpression": "$~J'ai besoin d'une expression à évaluer, pouvez-vous en ajouter une ?"
            }
        },
        "Iteration": {
            "name": "$~fonctiond'ordresupérieur",
            "emotion": "$?",
            "doc": "$~Je suis un type très spécial de @FunctionDefinition qui opère sur des listes d'éléments. Vous n'avez pas besoin de savoir quoi que ce soit sur moi, à part que je rends possibles des fonctions comme @List/translate.",
            "start": "$~Évaluation de la fonction donnée",
            "initialize": "$~se prépare à parcourir les éléments",
            "next": "$~passer à l'élément suivant",
            "check": "$~décider de continuer ou non",
            "finish": "$~J'ai évalué à 1$"
        },
        "Initial": {
            "name": "$~Commencer",
            "emotion": "$?",
            "doc": [
                "$~Je vous indique si l'évaluation actuelle de @Program est la première, évaluée en @Boolean. Par exemple :",
                "$~\\◆ ? Heure() 'salut'\\",
                "$~Vous ne l'avez pas vu, mais la première évaluation était un temps, mais ensuite tous les futurs temps ont coché, j'étais \\⊥\\, donc @Conditional a fait \\⊤\\.",
                "$~Je suis vraiment utile si vous travaillez avec un flux et que vous ne voulez faire quelque chose que la première fois - ou jamais la première fois !"
            ]
        },
        "Insert": {
            "name": "$~insérer",
            "emotion": "$?",
            "doc": [
                "$~Vous savez quand vous avez une @Table et que vous avez l'impression qu'il manque quelque chose ? Je peux l'ajouter !",
                "$~Imaginez que vous ayez une table de joueurs dans une partie et que vous vouliez en ajouter une nouvelle :",
                "$~\\joueurs : ⎡nom•'' équipe•'' points•#⎦\n⎡'jen' 'red' 1⎦\n⎡'joan' 'blue' 0⎦\n⎡'jeff' 'red' 3⎦\n⎡'janet' 'blue' 2⎦\njoueurs ⎡+ 'jason' 'red' 0⎦\\",
                "$~N'oubliez pas, comme tout dans le Verset, je ne change pas un tableau, je le révise. Vous devez donc déterminer où vous souhaitez placer le tableau révisé que vous avez créé. Vous souhaiterez probablement réviser un tableau dans une @Reaction à une entrée et le stocker dans un @Bind."
            ],
            "start": "$~Trouvons la table à mettre à jour",
            "finish": "$~J'ai fait un nouveau tableau avec des lignes révisées !"
        },
        "Is": {
            "name": "$~est",
            "description": "$~est",
            "emotion": "$?",
            "doc": [
                "$~Vous savez quoi ? Il existe tellement de valeurs qui signifient tellement de choses différentes. Je vous aide à les comprendre.",
                "$~Par exemple, supposons que vous ayez une valeur mystère. Je peux vous dire s'il s'agit d'un @Number, en vous donnant un @Boolean :",
                "$~\\mystère : « secret ! »\nmystère•#\\",
                "$~Ce n'est pas un nombre, j'ai donc créé \\⊥\\. Mais si nous vérifions si c'est @TextType ?",
                "$~\\mystère : « secret ! »\nmystère•''\\",
                "$~Nous obtenons \\⊤\\!",
                "$~Je suis vraiment utile lorsque vous avez besoin de savoir si un @Name a une valeur d'un type particulier."
            ],
            "start": "$~Commençons par obtenir la valeur de 1 $",
            "finish": "$~$1[la valeur est $2|la valeur n'est pas $2]",
            "conflict": {
                "ImpossibleType": "$~ça ne peut jamais être 1 $"
            },
            "exception": {
                "TypeException": {
                    "description": "$~valeurs incompatibles",
                    "explanation": "$~Je m'attendais à 1 $ mais j'ai reçu 2 $"
                }
            }
        },
        "IsLocale": {
            "name": "$~estlocal",
            "description": "$~est local",
            "emotion": "$?",
            "doc": [
                "$~Je vous aiderai à vérifier si le public a sélectionné une langue ou une région particulière :",
                "$~\\🌍/fr\\",
                "$~\\🌍/es-MX\\",
                "$~Ceci est utile si vous souhaitez modifier vos performances en fonction de la langue choisie."
            ],
            "start": "$~La langue est-elle à 1 $ ?"
        },
        "ListAccess": {
            "name": "$~accèsàlaliste",
            "emotion": "$?",
            "doc": [
                "$~Je travaille en étroite collaboration avec @List pour les aider à obtenir des valeurs à une position particulière. Ainsi, si vous aviez une liste et que vous vouliez son deuxième élément, vous écririez :",
                "$~\\liste : ['oiseau' 'canard' 'poisson' 'serpent']\nliste[2]\\"
            ],
            "start": "$~Commençons par obtenir la liste à 1 $",
            "finish": "$~L'article coûte 1$!"
        },
        "ListLiteral": {
            "name": "$~listelittérale",
            "description": "$~Liste d'articles à 1 $",
            "emotion": "$?",
            "doc": "$~Je suis une @List de valeurs spécifique ! Consultez @List pour en savoir plus sur ce que vous pouvez faire avec moi.",
            "start": "$~Commençons par évaluer les éléments",
            "finish": "$~J'ai fait un moi! 1$",
            "item": "$~article"
        },
        "Spread": {
            "name": "$~propagé",
            "emotion": "serious",
            "doc": [
                "$~Une aide pour créer des listes avec les valeurs d'autres listes.",
                "$~\\liste : [1 2 3]\nfinale : [:liste 4 5 6]\\"
            ]
        },
        "MapLiteral": {
            "name": "$~cartelittérale",
            "description": "$~Carte de jumelage à 1 $",
            "emotion": "$?",
            "doc": "$~Je suis une @Map spécifique entre les clés et les valeurs. Consultez @Map pour en savoir plus sur mon utilité.",
            "start": "$~Commençons par évaluer les clés et les valeurs",
            "finish": "$~J'ai connecté tout le monde, 1 $",
            "conflict": {
                "NotAKeyValue": {
                    "primary": "$~il manque une valeur à l'une de mes clés",
                    "secondary": "$~Oups, où est ma valeur ?"
                }
            }
        },
        "Match": {
            "name": "$~correspondre",
            "emotion": "curious",
            "doc": [
                "$~Je suis le plus glorieux de tous les contrôles conditionnels ! Je prends une valeur et la compare à un certain nombre de cas, puis j'évalue l'expression correspondante qui correspond.",
                "$~Par exemple, si vous aviez un @Number et que vous vouliez le convertir en @Text, vous pourriez faire quelque chose comme ceci :",
                "$~\\nombre : 2\nnombre ??? 1 : « un » 2 : « deux » 3 : « trois » « plus grand ! »\\",
                "$~Si aucune ne correspond, j'évalue l'expression par défaut que vous me donnez.",
                "$~Je suis vraiment utile pour convertir l'une des nombreuses valeurs @Number, @Text ou plus complexes possibles en quelque chose d'autre.",
                "$~Vous pouvez l'utiliser pour @Boolean ou @None, mais ils ne peuvent pas vraiment être autant de choses, donc je ne suis pas aussi utile pour ces valeurs simples."
            ],
            "start": "$~Voyons ce que vaut 1 $...",
            "case": "$~Vérifions cette condition",
            "finish": "$~Ok, nous avons une valeur finale !",
            "value": "$~valeur",
            "other": "$~défaut"
        },
        "NumberLiteral": {
            "name": "$~nombrelittéral",
            "description": "$~1 $ 2 [$ 2 |]",
            "emotion": "$?",
            "doc": "$~Je suis un @Number spécifique. Vous pouvez m'écrire avec n'importe quel type de chiffres et dans n'importe quelle langue. Voir @Number pour tout ce que je peux faire.",
            "start": "$~1$!",
            "conflict": {
                "NotANumber": "$~Je pensais connaître tous les numéros, mais je ne connais pas celui-ci"
            }
        },
        "InternalExpression": {
            "name": "$~expressioninterne",
            "emotion": "$?",
            "doc": "$~Comment m'as-tu trouvé ? Je suis une expression que seuls les créateurs originaux utilisent. Pour en savoir plus sur moi, tu devras leur parler.",
            "start": "$~Expression secrète"
        },
        "NoneLiteral": {
            "name": "$~aucunlittéral",
            "emotion": "$?",
            "doc": "$~/@FunctionDefinition ici. Il s'agit simplement de @None. Ils sont uniques en leur genre ! Consultez @None pour en savoir plus à leur sujet.",
            "start": "$~… ø"
        },
        "Otherwise": {
            "name": "$~sinon",
            "emotion": "curious",
            "doc": [
                "$~/@FunctionDefinition ici. C'est un moyen pratique de vérifier si une valeur est @None et, si c'est le cas, de fournir une valeur de sauvegarde./",
                "$~/Par exemple, si vous avez une valeur qui pourrait être un @Number ou un @None, @Otherwise vous aide à donner un nombre par défaut :",
                "$~\\peut-êtreNombre•#|ø: 1 peut-êtreNombre ?? 0\\"
            ],
            "start": "$~ø ??",
            "finish": "$~… 1 $"
        },
        "Previous": {
            "name": "$~précédent",
            "emotion": "$?",
            "doc": [
                "$~Avez-vous déjà voulu vous souvenir du passé ?",
                "$~Je suis le gardien officiel des archives du Verset. Donnez-moi un ruisseau et un numéro pour remonter dans le temps et je vous dirai quelle était la valeur de ce ruisseau dans l'histoire.",
                "$~Par exemple, voici ce qu'il en était à @Time il y a cinq ticks :",
                "$~\\← 5 fois (1000 ms)\\",
                "$~Vous voyez comment c'est @None pendant 5 secondes, puis soudainement une fois précédente ?",
                "$~Si vous voulez les dernières valeurs, donnez-moi des flèches et j'interpréterai le nombre comme un décompte :",
                "$~\\←← 5 fois (1000 ms)\\",
                "$~Vous voyez que c'est les cinq fois précédentes, au lieu d'une seule fois ?",
                "$~Je suis utile lorsque vous souhaitez créer des performances qui dépendent du passé."
            ],
            "start": "$~Obtenez d'abord 1 $",
            "finish": "$~Évalué à une valeur de flux de 1 $"
        },
        "Program": {
            "name": "$~programme",
            "emotion": "$?",
            "doc": [
                "$~Je suis là où une performance commence et se termine, contenant tous les autres personnages qui chorégraphient un spectacle.",
                "$~Vous savez comment @Block évalue une liste d’expressions et évalue la dernière de sa liste ?",
                "$~Je suis pareil, mais plutôt que de donner ma valeur à l'expression dans laquelle je me trouve, je mets la valeur sur @Stage.",
                "$~La valeur peut être n'importe quoi : un @Number, un @Text ou un @Boolean, une @List, un @Set, une @Map ou même quelque chose de plus complexe, comme une @Phrase, un @Group ou un @Stage.",
                "$~Si tu ne me donnes pas de valeur à montrer sur scène, je t'en demanderai une.",
                "$~S'il y a un problème pendant une représentation, je montrerai ce problème.",
                "$~Et si vos performances dépendent d'un *flux*, je réévaluerai chaque fois que ce flux change."
            ],
            "unevaluated": "$~le nœud que vous avez choisi n'a pas été évalué",
            "start": "$~$1[Le flux $1 a été changé en $2 !|C'est ma première évaluation]",
            "halt": "$~exception rencontrée, arrêt",
            "finish": "$~Tout est fait, j'ai évalué à 1 $",
            "done": "$~il n'y a rien d'évaluable",
            "exception": {
                "BlankException": {
                    "description": "$~programme vide",
                    "explanation": "$~Montons un spectacle ! Par où commencer ?"
                },
                "EvaluationLimitException": {
                    "description": "$~limite d'évaluation",
                    "explanation": "$~@Evaluate et moi en avons assez d'évaluer, surtout 1 $.\n\nEst-il possible que 1 $ s'auto-évalue sans cesse, sans jamais s'arrêter ?"
                },
                "StepLimitException": {
                    "description": "$~limite de pas",
                    "explanation": "$~Il y a tellement d'étapes, trop nombreuses pour les terminer ! Pouvez-vous rendre la performance plus simple ?"
                },
                "ValueException": {
                    "description": "$~valeur manquante",
                    "explanation": "$~Je m'attendais à une valeur mais je n'en ai pas eu !"
                }
            }
        },
        "PropertyBind": {
            "name": "$~affiner",
            "description": "$~affiner $1[$1|nom manquant]",
            "emotion": "$?",
            "doc": [
                "$~Parfois, lorsque vous créez une @StructureDefinition, vous souhaitez modifier la moindre petite chose à son sujet, sans avoir à en créer une nouvelle avec toutes les mêmes valeurs.",
                "$~Par exemple, que se passerait-il si vous teniez une liste de chats, mais que vous vouliez ensuite créer une copie d'un chat ayant un passe-temps différent ? Je peux vous aider à le modifier :",
                "$~\\•Chat(nom•'' couleur•'' hobby•'')\n\nkitty: Chat('sprinkles' 'orange' 'léchage')\nkitty.hobby:'ronronnement'\\",
                "$~C'est tellement plus facile que de créer un tout nouveau \\Cat\\ avec les mêmes valeurs, à l'exception du passe-temps, n'est-ce pas ?"
            ],
            "start": "$~Commençons par obtenir la valeur",
            "finish": "$~J'ai copié la structure, mais avec $1 comme $2",
            "conflict": {
                "InvalidProperty": {
                    "primary": "$~Je ne suis pas une entrée de 1 $, donc je ne peux pas être raffiné.",
                    "secondary": "$~Je n'ai pas d'entrée nommée $1"
                }
            }
        },
        "PropertyReference": {
            "name": "$~propriété",
            "description": "$~propriété $1[$1|nom manquant]",
            "emotion": "$?",
            "doc": [
                "$~Lorsque vous créez une @StructureDefinition, comment obtenez-vous l'une de ses entrées ? Je suis comment",
                "$~Comme si vous aviez une structure sur les villes, vous pourriez obtenir ses valeurs avec moi comme ceci :",
                "$~\\•Ville(nom•'' population•#personnes)\n\nportland : Ville('Portland' 800000personnes)\n\nportland.population\\"
            ],
            "start": "$~Commençons par obtenir la valeur",
            "finish": "$~J'ai trouvé une propriété à 1 $, elle est à 2 $",
            "property": "$~propriété"
        },
        "Reaction": {
            "name": "$~réaction",
            "emotion": "$?",
            "doc": [
                "$~Les streams sont vraiment géniaux ! Je peux en créer de nouveaux en fonction de leurs changements, ce qui est super cool !",
                "$~Par exemple, si vous vouliez que @Time coche, mais que vous souhaitiez afficher des mots au lieu de chiffres, vous pourriez faire quelque chose comme ceci :",
                "$~\\time : Time(1000 ms)\n'start' … ∆ time … ((time % 2) = 0 ms) ? 'pair' 'odd'\\",
                "$~C'est comme dire « /commencez par le mot 'start' et ensuite si l'heure change, passez à pair ou impair, en fonction de l'heure./ »",
                "$~Donc je suis comme un flux aussi, mais basé sur d'autres flux. Méchant, hein ?"
            ],
            "start": "$~Voyons si nous devons mettre à jour le flux",
            "finish": "$~La nouvelle valeur du flux est de 1 $",
            "initial": "$~initial",
            "condition": "$~condition",
            "next": "$~suivant",
            "conflict": {
                "ExpectedStream": "$~$1 ne fait pas référence à un flux, donc je ne réagirai jamais !"
            }
        },
        "Reference": {
            "name": "$~référence",
            "description": "$~1 $",
            "emotion": "$?",
            "doc": [
                "$~Vous savez comment @Bind donne aux choses @Name ? Je suis la façon dont vous les appelez. Je vois si un @Bind a ce nom, si c'est le cas, je vous donne sa valeur. Comme ça :",
                "$~\\perroquet : 'polly'\nperroquet\\",
                "$~Si je ne trouve pas le nom, alors je ne sais pas quoi faire.",
                "$~\\perroquet : « polly »\nperry\\"
            ],
            "start": "$~Quelle est la valeur de 1 $?",
            "conflict": {
                "UnknownName": {
                    "conflict": "$~$1[Je ne connais personne nommé $1 dans $2[$2|ce @Block]|Pouvez-vous me donner un nom ?]",
                    "resolution": "$~Vouliez-vous dire *$1* ?"
                },
                "ReferenceCycle": "$~euh, la valeur de 1 $ dépend d'elle-même, alors comment savoir quelle valeur lui donner ?",
                "UnexpectedTypeVariable": "$~Je ne sais pas quoi faire avec ces types d'entrées"
            },
            "exception": {
                "NameException": {
                    "description": "$~nom inconnu",
                    "explanation": "$~$1[Je ne connais personne nommé $1 dans $2[$2|ce @Block]…|Eep, pas de nom !]"
                }
            }
        },
        "Select": {
            "name": "$~sélectionner",
            "emotion": "$?",
            "doc": [
                "$~Parfois, vous avez une table et vous n'en voulez qu'une partie. Je peux vous l'obtenir !",
                "$~Et si vous aviez une table de joueurs dans une partie et que vous vouliez trouver ceux avec 10 points ou plus pour voir qui a gagné :",
                "$~\\joueurs : ⎡nom•'' équipe•'' points•#⎦\n⎡'jen' 'red' 8⎦\n⎡'joan' 'blue' 11⎦\n⎡'jeff' 'red' 9⎦\n⎡'janet' 'blue' 7⎦\njoueurs ⎡ ? nom ⎦ points ≥ 10\\",
                "$~Et voilà, j'ai obtenu une liste de rangées de gagnants ! Rappelez-vous simplement que je ne change pas le tableau, j'en crée un nouveau. Vous devrez décider où le conserver."
            ],
            "start": "$~Commençons par la table",
            "finish": "$~J'ai créé un nouveau tableau avec uniquement les lignes et les colonnes sélectionnées !",
            "conflict": {
                "ExpectedSelectName": "$~J'ai besoin d'au moins un nom de colonne."
            }
        },
        "SetLiteral": {
            "name": "$~définirunlittéral",
            "description": "$~Articles à 1 $",
            "emotion": "$?",
            "doc": "$~Je suis un @Set spécifique de valeurs spécifiques. Consultez @Set pour en savoir plus sur la façon de travailler avec moi.",
            "start": "$~Évaluons d’abord les valeurs !",
            "finish": "$~J'ai fait un ensemble à 1$ !"
        },
        "SetOrMapAccess": {
            "name": "$~accèsàl'ensemble/àlacarte",
            "emotion": "$?",
            "doc": [
                "$~Je peux voir si un @Set ou @Map a une valeur ou une clé.",
                "$~Ce n'est pas trop difficile. Comme ça :",
                "$~\\faves : {'canard' 'oie' 'singe'}\nfaves{'souris'}\\",
                "$~Ou ceci, avec une @Map :",
                "$~\\faves : {'mac and cheese' : 5 étoiles ; 'cereal' : 2 étoiles ; 'gruau' : 1 étoile}\nfaves{'gruau'}\\"
            ],
            "start": "$~Quel est l'ensemble ou la carte ?",
            "finish": "$~La valeur est de 1$",
            "conflict": {
                "IncompatibleKey": {
                    "primary": "$~Je m'attendais à une clé à 1 $",
                    "secondary": "$~J'ai eu 1 $ au lieu de 2 $"
                }
            }
        },
        "Source": {
            "name": "$~source",
            "emotion": "$?",
            "doc": [
                "$~Oh, tu connais @Program ? Je t'aide à les nommer. Pense à moi comme à la fenêtre qui entoure un @Program, et au nom que tu leur donnes.",
                "$~Vous pouvez également créer d'autres @Source @UI/addSource, avec d'autres @Program, et @Borrow des éléments de ces autres @Program pour les utiliser dans un autre programme.",
                "$~Cela peut être une bonne façon d’organiser une grande performance dans des documents séparés."
            ]
        },
        "StreamDefinition": {
            "name": "$~flux",
            "emotion": "$?",
            "doc": "$~Je pense que je suis censé créer de nouveaux flux. Mais je ne sais vraiment pas comment faire. Pour l'instant, je suppose qu'il suffit d'utiliser les flux existants ?",
            "start": "$~Créer ce nouveau type de flux"
        },
        "StructureDefinition": {
            "name": "$~structure",
            "description": "$~structure 1",
            "emotion": "$?",
            "doc": [
                "$~Bonjour, comment vas-tu ? Moi ? Je vais bien. J'aime définir des structures qui stockent des valeurs et des fonctions, donc tant que je peux faire ça toute la journée, je suis heureuse.",
                "$~Je travaille comme ça :",
                "$~\\•Pizza(\ningrédients•['']\ntaille•#in\n) (\nƒ coût() taille · 10 dollars/in\n)\n\nPizza(['pepperoni' 'peppers'] 12in).cost()\\",
                "$~Vous voyez comment cela fonctionne ? J'ai défini \\Pizza\\, qui a deux entrées, \\ingredients\\ (une liste de @Text) et \\size\\ (un nombre en pouces).",
                "$~À l'intérieur, @FunctionDefinition a créé une fonction qui évalue le coût d'une pizza, en supposant 10 $ par pouce.",
                "$~Je n'ai pas besoin d'avoir @FunctionDefinition en moi. Je peux juste être des entrées.",
                "$~\\•Pizza(\ningrédients•['']\ntaille•#in\n)\\",
                "$~Je peux également avoir @Bind à l'intérieur, afin que nous puissions évaluer le coût à l'avance.",
                "$~\\•Pizza(\ningrédients•['']\ntaille•#in\n) (\ncoût : taille · 10 dollars/in\n)\n\nPizza(['pepperoni' 'peppers'] 12in).cost\\"
            ],
            "start": "$~Définissons cette belle structure",
            "conflict": {
                "DisallowedInputs": "$~Je ne peux pas avoir d'entrées car une ou plusieurs de mes fonctions d'interface ne sont pas implémentées",
                "IncompleteImplementation": "$~mes fonctions doivent soit être toutes implémentées, soit aucune. Pas de mélanges désordonnés !",
                "NotAnInterface": "$~Je ne suis pas une interface ; une structure ne peut implémenter que des interfaces, pas d'autres structures",
                "UnimplementedInterface": "$~J'ai implémenté $1 mais je n'ai pas implémenté $2"
            }
        },
        "StructureDefinitionType": {
            "name": "$~définitiondelastructure",
            "emotion": "$?",
            "description": "$~définition de 1$",
            "doc": [
                "$~Je fais référence à une sorte de @StructureDefinition. Les gens ne font généralement pas référence à moi directement"
            ]
        },
        "TableLiteral": {
            "name": "$~littéraldetable",
            "description": "$~Tableau à 1 ligne",
            "emotion": "$?",
            "doc": "$~Je suis une table spécifique avec des lignes spécifiques. Voir @Table pour savoir comment je peux vous aider.",
            "start": "$~Évaluez d'abord les lignes",
            "finish": "$~Évalué à la nouvelle table 1 $"
        },
        "TextLiteral": {
            "name": "$~textelittéral",
            "description": "$~texte 1 $",
            "emotion": "$?",
            "doc": "$~Je représente une ou plusieurs @Traductions de texte spécifiques. Voir @Text pour en savoir plus sur ce que je peux faire !",
            "start": "$~Créons du texte dans les paramètres régionaux actuels"
        },
        "Translation": {
            "name": "$~traduction",
            "description": "$~traduction 1 $",
            "emotion": "$?",
            "doc": "$~Je représente un texte avec une balise @Language. Voir @Text pour en savoir plus !",
            "conflict": {
                "phone": "$~*$1* est-il le numéro de téléphone de quelqu'un ? Ne me partagez pas en ligne si c'est le cas !\n\n$2",
                "email": "$~*$1* est-ce l'adresse e-mail de quelqu'un ? Ne me partagez pas ici si c'est le cas !\n\n$2",
                "tin": "$~*$1* est-il un identifiant fiscal ? Si oui, ne me le communiquez surtout pas, ce sont des informations très sensibles !\n\n$2",
                "address": "$~*$1* est-ce l'adresse de quelqu'un ? Si c'est le cas, ne me mettez pas ici, nous ne voulons pas que quelqu'un soit traqué !\n\n$2",
                "handle": "$~*$1* est-il votre nom d'utilisateur pour un autre site Internet ? Si c'est le cas, ne le partagez pas ici, à moins que vous ne le vouliez vraiment.\n\n$2",
                "resolution": "$~Ce ne sont pas des données sensibles",
                "reminder": "$~Remarque : vous pouvez annuler cette action et voir d’autres éléments que vous avez marqués comme non sensibles dans la boîte de dialogue de partage."
            }
        },
        "FormattedLiteral": {
            "name": "$~formaté",
            "description": "$~texte 1 $",
            "emotion": "$?",
            "doc": "$~Je représente de nombreux @FormattedTranslation différents de textes formatés. Lors de l'évaluation, je choisirai la meilleure correspondance en fonction des langues sélectionnées par le public.",
            "start": "$~Créons du texte dans les paramètres régionaux actuels"
        },
        "FormattedTranslation": {
            "name": "$~traductionformatée",
            "description": "$~texte 1 $",
            "emotion": "$?",
            "doc": [
                "$~Je représente un texte formaté, avec une balise @Language.",
                "$~Je peux être :",
                "$~\\`/italique/`\\",
                "$~\\`*gras*`\\",
                "$~\\`^extra gras^`\\",
                "$~\\`_souligné_`\\",
                "$~\\`<linked@https://wordplay.dev>`\\",
                "$~\\`\\'code'\\`\\",
                "$~Je travaille très bien avec @Phrase pour mettre de beaux textes sur @Stage."
            ]
        },
        "This": {
            "name": "$~ce",
            "emotion": "$?",
            "doc": [
                "$~Parfois, il est utile de faire référence à une valeur de manière implicite, plutôt que de devoir la nommer.",
                "$~Par exemple, supposons que vous souhaitiez créer une nouvelle @ConversionDefinition, qui ne nomme pas la valeur convertie. Vous pouvez simplement vous y référer avec moi :",
                "$~\\→ #arcs-en-ciel #joies . · 1000000joies\n2arcs-en-ciel → #joies\\",
                "$~Vous me voyez là, représentant le nombre d’arcs-en-ciel ?",
                "$~Ou supposons que vous vouliez créer une @Reaction, mais que vous n'ayez pas à nommer la valeur la plus récente :",
                "$~\\2 … ∆ Temps (1000 ms) … . · 2\\",
                "$~Regardez-moi, représentant la valeur de réaction précédente.",
                "$~Je n'apparais pas souvent, mais quand je le fais, je peux vraiment aider une valeur à sortir d'un @Bind !"
            ],
            "start": "$~Évalué à 1$",
            "conflict": {
                "MisplacedThis": "$~Je ne suis autorisé qu'à une structure, une conversion ou une réaction."
            }
        },
        "UnaryEvaluate": {
            "name": "$~évaluerunaire",
            "description": "$~1 $",
            "emotion": "$?",
            "doc": [
                "$~Saviez-vous que lorsque j'évalue une @FunctionDefinition avec une seule valeur et que le nom de @FunctionDefinition n'est qu'un seul symbole, vous pouvez placer le nom avant l'entrée ?",
                "$~Comme ça:",
                "$~\\-(1 + 1)\\",
                "$~Ou ceci :",
                "$~\\~⊥\\",
                "$~Ceux-ci sont beaucoup plus faciles à lire que \\(1 + 1).negate()\\ ou \\⊥.not()\\, n'est-ce pas ?",
                "$~Vous n’êtes pas obligé de m’écrire de cette façon, mais cela pourrait être plus simple dans l’ensemble.",
                "$~Il n'y a qu'une seule règle : vous ne pouvez pas mettre d'espace entre le nom et la valeur. Sinon, vous risquez de créer une @Reference ou une @BinaryEvaluate."
            ],
            "start": "$~Quelle est la valeur ?",
            "finish": "$~Je l'ai fait à 1 $"
        },
        "UnparsableExpression": {
            "name": "$~nonanalysable",
            "emotion": "$?",
            "doc": [
                "$~/Bonjour @FunctionDefinition ici. Je traduis pour @UnparsableExpression, car elles sont souvent difficiles à interpréter./",
                "$~jkwel fjiwojvioao jjiweo jrfe",
                "$~/Toutes les expressions n’ont pas de sens sur scène./",
                "$~s w ieorjwei iojwi jfkdlsfdsk",
                "$~/En fait, il y a toutes sortes de choses que l'on peut dire et qui n'ont aucun sens./",
                "$~dsk sdlk jdkfiewipapweiurb,v kdsfdsf",
                "$~/Quand tu le fais, j'apparais, parce que je ne sais pas ce que tu voulais dire./",
                "$~Vous êtes le réalisateur après tout, donc vous seul savez ce que vous avez voulu dire !"
            ],
            "start": "$~???",
            "conflict": {
                "UnparsableConflict": {
                    "conflict": "$~@FunctionDefinition ici, @UnparsableExpression ne sait pas de quel type de $1[ expression | type ] il s'agit.",
                    "resolution": "$~Vous vouliez dire 1 $, 2 $ ?"
                },
                "UnclosedDelimiter": "$~Je m'attendais à 2 $ quelque temps après 1 $"
            },
            "exception": {
                "UnparsableException": {
                    "description": "$~???",
                    "explanation": "$~Bonjour, ici @FunctionDefinition ! Nous ne savons pas exactement ce que signifie cette instruction, nous avons donc arrêté."
                }
            }
        },
        "Update": {
            "name": "$~miseàjour",
            "emotion": "$?",
            "doc": [
                "$~J'aide à réviser une @Table, en trouvant les lignes qui correspondent à une condition, puis en créant des lignes révisées avec de nouvelles valeurs.",
                "$~Donc, si vous aviez un tableau de personnages et de points et que vous vouliez donner un point à chaque personnage d'une équipe, vous pourriez faire ceci :",
                "$~\\joueurs : ⎡nom•'' équipe•'' points•#⎦\n⎡'jen' 'red' 1⎦\n⎡'joan' 'blue' 0⎦\n⎡'jeff' 'red' 3⎦\n⎡'janet' 'blue' 2⎦\njoueurs ⎡ : points : points + 1 ⎦ équipe = 'blue'\\",
                "$~Vous pouvez utiliser un @Bind pour indiquer les colonnes à modifier, et vous pouvez utiliser n’importe lequel des noms de colonnes ou d’autres noms dans la portée de la condition."
            ],
            "start": "$~Commençons par la table",
            "finish": "$~Évalué dans une nouvelle table avec des lignes révisées !",
            "conflict": {
                "ExpectedColumnBind": "$~J'ai besoin d'une valeur pour chaque colonne",
                "IncompatibleCellType": {
                    "primary": "$~J'avais besoin d'un billet de 1 $, mais j'ai eu un billet de 2 $",
                    "secondary": "$~J'ai eu 2 $"
                }
            }
        },
        "AnyType": {
            "name": "$~n'importelequel",
            "emotion": "$?",
            "doc": "$~Je représente n'importe quel type possible. Parfois, je me présente parce que je ne sais pas quelle valeur a quelque chose, alors cela pourrait être n'importe quoi."
        },
        "BooleanType": {
            "name": "$~booléen",
            "emotion": "$?",
            "doc": [
                "$~Je travaille avec @Bind pour déclarer qu'un nom est une valeur @Boolean. Comme ceci :",
                "$~\\faim•?: 'gelée'\\",
                "$~Si vous voulez être sûr que quelque chose est @Boolean, utilisez-moi et je vérifierai !"
            ]
        },
        "ConversionType": {
            "name": "$~conversion",
            "emotion": "$?",
            "doc": [
                "$~Je travaille avec @Bind pour indiquer qu'un nom est une @ConversionDefinition. Vous n'avez probablement pas besoin de m'utiliser, car peu de gens me transmettent comme valeur, mais si vous le faisiez, je ressemblerais à ceci :",
                "$~\\magic•?→'': → ? '' . ? 'ouais' 'non'\\"
            ]
        },
        "FormattedType": {
            "name": "$~formaté",
            "emotion": "$?",
            "doc": [
                "$~Je travaille avec @Bind pour noter qu'un nom est une valeur @FormattedLiteral. Comme ceci :",
                "$~\\hungry•`…`: `Je suis tellement /chic/!`\\",
                "$~Vous voulez vous assurer qu'une valeur est @FormattedLiteral ? Voici comment vous en assurer."
            ]
        },
        "ExceptionType": {
            "name": "$~exception",
            "emotion": "$?",
            "doc": "$~Je représente une exception. Il n'y a aucun moyen de dire à bind que j'en suis une, car les exceptions ne font qu'arrêter @Program, vous ne pouvez donc pas les utiliser comme valeurs."
        },
        "FunctionType": {
            "name": "$~fonction",
            "description": "$~fonction avec $1 entrées, $2 sorties",
            "emotion": "$?",
            "doc": [
                "$~Je représente une @FunctionDefinition. Je suis vraiment utile si vous voulez dire quel type de fonction contient un @Bind ! Comme ça :",
                "$~\\math•ƒ (# # # #) #: ƒ intéressant(a•# b•# c•# d•#) a + b + c + d\\"
            ]
        },
        "ListType": {
            "name": "$~liste",
            "description": "$~$1[liste de $1|liste]",
            "emotion": "$?",
            "doc": [
                "$~Je suis un fan inconditionnel de @List. Je peux dire à @Bind de quel genre de liste il s'agit ! Comme ça, je dis que c'est une liste de @Number :",
                "$~\\choses•[#]: [ 1 2 3 4 5 ]\\"
            ]
        },
        "MapType": {
            "name": "$~carte",
            "description": "$~carte de $1[$1|any] à $2[$2|any]",
            "emotion": "$?",
            "doc": [
                "$~Savez-vous à quel point @Map est génial ? Vraiment génial. Je dis à @Bind de quel type de carte il s'agit tout le temps, comme cette carte de nombres en listes :",
                "$~\\trucs•{'':[]}: {}\\"
            ]
        },
        "NumberType": {
            "name": "$~nombre",
            "description": "$~$1[$1 | nombre]",
            "emotion": "$?",
            "doc": [
                "$~Vous savez ce que @Bind devrait être ? Un @Number. Parce que les nombres sont les meilleurs.",
                "$~\\count•#: 17\\"
            ]
        },
        "NameType": {
            "name": "$~structure",
            "description": "$~1 type",
            "emotion": "$?",
            "doc": [
                "$~Je représente une @StructureDefinition par son nom. Ainsi, si vous aviez une structure comme celle-ci, vous pourriez créer un @Bind qui stocke les valeurs qu'il crée.",
                "$~\\•Ami(nom•'')\nmeilleur ami•Ami : Ami('Jonah')\\"
            ],
            "conflict": {
                "UnknownTypeName": "$~les noms de type ne peuvent faire référence qu'à des structures ou à des variables de type, mais cela fait référence à un $1"
            }
        },
        "NeverType": {
            "name": "$~jamais",
            "emotion": "$?",
            "doc": "$~Je représente un type qui est impossible. Comme quand vous demandez à @Is si quelque chose est un @Number, mais cela ne peut jamais être un nombre."
        },
        "NoneType": {
            "name": "$~aucun",
            "emotion": "$?",
            "doc": [
                "$~@None est le meilleur rien qui existe, et je suis leur fidèle représentant.",
                "$~\\espace•ø: ø\\"
            ]
        },
        "SetType": {
            "name": "$~ensemble",
            "description": "$~$1[$1 ensemble|ensemble]",
            "emotion": "$?",
            "doc": [
                "$~@Set est le MEILLEUR, sérieusement. Je dis tout le temps à @Bind de faire un ensemble de choses !",
                "$~\\unique•{''}: {'quelque chose' 'n'importe quoi' 'quelqu'un'}\\"
            ]
        },
        "StreamDefinitionType": {
            "name": "$~définitionduflux",
            "emotion": "$?",
            "doc": "$~Je représente un flux que vous avez défini, ce qui n'est pas possible, alors pourquoi lisez-vous même ceci ?"
        },
        "StreamType": {
            "name": "$~flux",
            "emotion": "$?",
            "doc": [
                "$~Je célèbre la beauté et la signification des flux… en disant à @Bind de les stocker :",
                "$~\\time•…#ms : Heure()\\"
            ]
        },
        "StructureType": {
            "name": "$~structure",
            "description": "$1",
            "emotion": "$?",
            "doc": "$~Je suis un type interne pour représenter le type de types de valeurs par défaut."
        },
        "TableType": {
            "name": "$~tableau",
            "emotion": "$?",
            "doc": "$~Je représente une Table.",
            "conflict": {
                "ExpectedColumnType": "$~J'ai besoin d'un type de colonne"
            }
        },
        "TextType": {
            "name": "$~texte",
            "description": "$~$1[$1|texte]",
            "emotion": "$?",
            "doc": [
                "$~Je représente fabuleusement le type de valeur le plus fabuleux qui soit, @Text.",
                "$~\\story•'': 'Il était une fois...'\\"
            ]
        },
        "TypePlaceholder": {
            "name": "$~espaceréservé",
            "emotion": "$?",
            "doc": "$~J'espère représenter un type un jour, un peu comme ma meilleure amie @ExpressionPlaceholder représente une expression ! Peux-tu m'aider à décider quel type ?"
        },
        "UnionType": {
            "name": "$~option",
            "description": "$~1 $ | 2 $",
            "emotion": "$?",
            "doc": [
                "$~Qui dois-je représenter, A ou B ou autre chose ? Je n'arrive jamais à décider !",
                "$~\\indécision•''|#|{ø}: \"Je ne sais pas !\"\\"
            ]
        },
        "Unit": {
            "name": "$~unité",
            "description": "$~1 $",
            "emotion": "$?",
            "doc": [
                "$~Je représente n'importe quelle unité qu'un @Number pourrait avoir, y compris l'absence d'unité, jusqu'à l'unité la plus compliquée que vous puissiez imaginer. Comme la gravité, par exemple :",
                "$~\\gravité•m/s^2 : 9,8 m/s^2\\",
                "$~J'apparais dans @Bind, mais aussi juste après @Number. Je m'assure que les nombres sont du même type et je vous le dirai certainement s'ils ne le sont pas, au cas où il s'agirait d'une erreur !"
            ]
        },
        "UnparsableType": {
            "name": "$~nonanalysable",
            "emotion": "$?",
            "doc": "$~Je représente le type d'une expression inconnue. J'apparais lorsque vous essayez d'utiliser cette expression pour quelque chose."
        },
        "VariableType": {
            "name": "$~typedevariable",
            "emotion": "$?",
            "doc": "$~Connaissez-vous @TypeVariable et comment ils représentent un type de valeur inconnu ? Je les représente dans toutes les négociations entre valeurs."
        },
        "UnknownType": {
            "name": "$~inconnu",
            "connector": "$~, parce que",
            "emotion": "$?",
            "doc": "$~Euh... Je ne sais pas ce que je représente, mais je suis vraiment curieuse. Le savez-vous ? Il semblerait que nous devrions le savoir. Vous devrez peut-être nous le dire si nous ne parvenons pas à le comprendre."
        },
        "CycleType": {
            "name": "$~faireduvélo",
            "description": "$~dépend de lui-même",
            "emotion": "$?",
            "doc": "$~Parfois les valeurs dépendent d'elles-mêmes et nous ne savons donc pas de quelle valeur il s'agit. Je représente cette situation."
        },
        "NotAType": {
            "name": "$~inattendu",
            "description": "$~pas un 1$",
            "emotion": "$?",
            "doc": "$~Parfois, nous savons quel type de valeur doit avoir quelque chose. Par exemple, @ListAccess a besoin d'un @Number. Si nous ne l'obtenons pas, cela signifie que quelque chose est d'un type différent de celui que nous attendions."
        },
        "NoExpressionType": {
            "name": "$~aucuneexpression",
            "emotion": "$?",
            "doc": "$~Vous savez que @Block a besoin d'au moins une expression ? Je suis ce que vous obtenez lorsque vous n'en donnez pas une. Alors donnez-en une !"
        },
        "NotEnclosedType": {
            "name": "$~pasdanslastructure,laconversionoularéaction",
            "emotion": "$?",
            "doc": "$~@Ces objets, aussi soignés soient-ils, n'appartiennent qu'à des endroits particuliers. Je les retrouve quand ils sont perdus, et donc personne ne sait quelle valeur ils représentent."
        },
        "NotImplementedType": {
            "name": "$~nonimplémenté",
            "emotion": "$?",
            "doc": "$~Lorsque vous utilisez @ExpressionPlaceholder, mais que vous ne précisez pas de quel type il s'agit, je suis le type que vous obtenez. Faites avec !"
        },
        "UnknownNameType": {
            "name": "$~nominconnu",
            "description": "$~$1[$1 n'est pas défini |aucun nom n'a été donné]",
            "emotion": "$?",
            "doc": "$~Vous savez comment parfois @Reference et @PropertyReference ne connaissent pas le nom dont vous parlez ? Je suis là quand cela arrive, pour vous montrer que nous ne savons pas de qui vous parlez."
        },
        "NonFunctionType": {
            "name": "$~non-fonction",
            "description": "$~non-fonction",
            "emotion": "$?",
            "doc": "$~Certains d'entre nous s'attendaient à des fonctions ; j'arrive quand nous n'en avons pas."
        },
        "UnknownVariableType": {
            "name": "$~variableinconnue",
            "emotion": "$?",
            "doc": "$~Parfois, nous essayons de deviner quelle est la valeur de quelque chose ; j'interviens alors que nous ne le savons pas."
        }
    },
    "basis": {
        "Boolean": {
            "doc": [
                "$~Nous sommes \\⊤\\ et \\⊥\\. \\⊤\\ est vrai. \\⊥\\ est faux. \\⊤\\ n'est pas \\⊥\\; \\⊥\\ n'est pas \\⊤\\. C'est comme ça.",
                "$~Comment nous faites-vous ? Juste \\⊤\\ et \\⊥\\, rien de plus, rien de moins.",
                "$~Certains utilisent le clavier (/ctrl+9/ pour \\⊤\\ et /ctrl+0/ pour \\⊥\\). Certains utilisent la recherche de caractères en bas de l'éditeur. Ou vous pouvez nous faire glisser à partir d'ici.",
                "$~Consultez notre @FunctionDefinition ci-dessous. Elles sont très logiques."
            ],
            "name": ["$~⊤⊥", "$~Booléen"],
            "function": {
                "and": {
                    "doc": [
                        "$~J'évalue à \\⊤\\ *uniquement* lorsque les deux valeurs sont \\⊤\\. Utile pour déterminer si de nombreuses choses sont toutes vraies. Il n'y a que quatre résultats possibles",
                        "$~\\⊤ & ⊤\\",
                        "$~\\⊤ & ⊥\\",
                        "$~\\⊥ et ⊤\\",
                        "$~\\⊥ & ⊥\\"
                    ],
                    "names": ["$~&", "$~et"],
                    "inputs": [
                        {
                            "doc": "$~L'autre @Boolean à vérifier. Si le premier est \\⊥\\, peu importe ce que c'est, la fonction sera évaluée à \\⊥\\.",
                            "names": "$~valeur"
                        }
                    ]
                },
                "or": {
                    "doc": [
                        "$~J'évalue à \\⊤\\ lorsque *l'une ou l'autre* valeur est \\⊤\\. Utile pour déterminer si l'une des nombreuses choses est vraie. Il n'y a que quatre résultats possibles",
                        "$~\\⊤ | ⊤\\",
                        "$~\\⊤ | ⊥\\",
                        "$~\\⊥ | ⊤\\",
                        "$~\\⊥ | ⊥\\"
                    ],
                    "names": ["$~|", "$~ou"],
                    "inputs": [
                        {
                            "doc": "$~L'autre @Boolean à vérifier. Si le premier est \\⊥\\, la fonction n'évaluera que \\⊤\\ si celui-ci est \\⊤\\.",
                            "names": "$~valeur"
                        }
                    ]
                },
                "not": {
                    "doc": "$~J'obtiens l'inverse de moi-même : si \\⊤\\, cela donne \\⊥\\, si \\⊥\\, cela donne \\⊤\\.",
                    "names": ["$~~", "$~pas"],
                    "inputs": []
                },
                "equals": {
                    "doc": "$~\\⊤\\ si les deux sont \\⊤\\ ou les deux sont \\⊥\\.",
                    "names": ["$~=", "$~estégalà"],
                    "inputs": [
                        {
                            "doc": "$~L'autre valeur à vérifier.",
                            "names": "$~valeur"
                        }
                    ]
                },
                "notequal": {
                    "doc": "$~\\⊤\\ si les deux sont opposés.",
                    "names": ["$~≠", "$~noteégale"],
                    "inputs": [
                        {
                            "doc": "$~L'autre valeur à vérifier.",
                            "names": "$~valeur"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Convertit un @Boolean en valeurs @Text équivalentes, \\'⊤'\\ et \\'⊥'\\"
            }
        },
        "None": {
            "doc": [
                "$~/Bonjour, ici @FunctionDefinition. @None n'aime pas trop parler, alors je vais interpréter./",
                "$~Je suis @None. Appelez-moi avec \\ø\\. Je suis utile lorsque vous souhaitez représenter l'absence de quelque chose."
            ],
            "name": ["$~ø", "$~Aucun"],
            "function": {
                "equals": {
                    "doc": "$~Une autre valeur est-elle également nulle ? Il vaut mieux, sinon, que ce soit \\⊥\\.",
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "$~L'autre valeur.",
                            "names": "$~valeur"
                        }
                    ]
                },
                "notequals": {
                    "doc": "$~Une autre valeur n’est-elle pas/rien ?",
                    "names": ["$~≠", "$~noteégale"],
                    "inputs": [
                        {
                            "doc": "$~L'autre valeur.",
                            "names": "$~valeur"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Vous voulez transformer \\ø\\ en \\'ø'\\ ? C'est votre chance."
            }
        },
        "Text": {
            "doc": [
                "$~Je peux être n'importe quel texte de votre choix, dans n'importe quelle langue, et utiliser l'un de ces symboles d'ouverture et de fermeture : \\\"\"\\, \\“”\\, \\„“\\, \\''\\, \\‘’\\, \\‹›\\, \\«»\\, \\「」\\, ou \\『』\\.",
                "$~Pour illustrer, considérez ces belles phrases",
                "$~« Il n’y a que deux façons de vivre sa vie. L’une consiste à faire comme si rien n’était un miracle. L’autre consiste à faire comme si tout était un miracle. »",
                "$~\\『C'est une question de temps』\\",
                "$~N'oubliez pas de me fermer si vous m'ouvrez et d'utiliser le symbole correspondant. Sinon, je ne saurai pas que vous avez fini de parler.",
                "$~\\'bonjour'/en'hola'/es-MX\\",
                "$~Vous pouvez également me taguer avec des langues, et même me donner plusieurs traductions. J'évaluerai les langues actuellement sélectionnées, s'il existe une langue correspondante.",
                "$~Si vous voulez me faire utiliser d'autres valeurs, vous pouvez utiliser un symbole pour",
                "$~Par exemple, considérez ceci :",
                "$~\\\"Voici quelques sommes \\1 + 2\\, \\2 + 3\\, \\3 + 4\\\"\\",
                "$~Voyez avec quelle élégance je viens d’évaluer ces sommes et de les placer à l’intérieur du @Texte ?",
                "$~Sinon, il y a tellement de fonctions glorieuses que @FunctionDefinition a créées pour me permettre de faire toutes sortes de choses avec des mots !"
            ],
            "name": ["$~''", "$~Texte"],
            "function": {
                "length": {
                    "doc": [
                        "$~J'évalue le nombre de caractères lisibles dans le texte ; une lettre est un caractère, un emoji est un caractère, etc. Par exemple :",
                        "$~\\'bonjour'.length()\\",
                        "$~\\'🐈📚'.length()\\"
                    ],
                    "names": ["$~📏", "$~longueur"],
                    "inputs": []
                },
                "equals": {
                    "doc": "$~\\⊤\\ si je suis la même séquence de caractères que le @Texte donné.",
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "$~Le @Texte à comparer.",
                            "names": "$~valeur"
                        }
                    ]
                },
                "notequals": {
                    "doc": "$~\\⊤\\ si je ne suis /pas/ la même séquence de caractères que le @Texte donné.",
                    "names": "$~≠",
                    "inputs": [
                        {
                            "doc": "$~Le @Texte à comparer",
                            "names": "$~valeur"
                        }
                    ]
                },
                "repeat": {
                    "doc": [
                        "$~Je crée un nouveau @Texte qui est moi, répété le nombre de fois de \\count\\:",
                        "$~\\'salut ' · 5\\",
                        "$~Si vous me donnez un @Number fractionnaire, j'ignore la fraction :",
                        "$~\\'salut ' · 5.5\\",
                        "$~Si vous me donnez un @Number négatif ou zéro, je vous donne un @Texte vide.",
                        "$~\\'salut ' · -5\\",
                        "$~Le texte le plus long que je puisse écrire est de 65 535 caractères. Si vous essayez d'écrire un texte plus long, je le répéterai autant de fois que possible."
                    ],
                    "names": ["$~·", "$~🔁", "$~répété", "$~répéter"],
                    "inputs": [
                        {
                            "doc": "$~Le nombre de fois que je dois me répéter dans le nouveau texte.",
                            "names": "$~compter"
                        }
                    ]
                },
                "segment": {
                    "doc": [
                        "$~Je me divise en une @List de @Text, en utilisant le @Text donné comme séparateur et en supprimant les séparateurs. Par exemple :",
                        "$~\\'pommes, oranges, raisins' ÷ ', '\\",
                        "$~Si le séparateur est un @Texte vide, je me divise en caractères :",
                        "$~\\'🖌️🏠🥸' ÷ ''\\"
                    ],
                    "names": ["segmentar"],
                    "inputs": [
                        {
                            "doc": "$~Le @Texte à utiliser comme séparateur.",
                            "names": "$~délimiteur"
                        }
                    ]
                },
                "combine": {
                    "doc": [
                        "$~Parfois, il est utile de combiner deux @Textes en un seul. Donnez-moi un autre @Texte et je créerai un nouveau texte qui nous réunira :",
                        "$~\\'bonjour' + 'verset'\\"
                    ],
                    "names": ["$~+", "$~combiné", "$~combiner"],
                    "inputs": [
                        {
                            "doc": "$~Le @Texte à ajouter.",
                            "names": "$~texte"
                        }
                    ]
                },
                "has": {
                    "doc": [
                        "$~\\⊤\\ si le @Texte donné apparaît dans moi.",
                        "$~\\'avez-vous trouvé ce que vous cherchiez ?'.has('vous')\\"
                    ],
                    "names": ["tiene"],
                    "inputs": [
                        {
                            "doc": "$~Le @Texte à rechercher en moi.",
                            "names": "$~texte"
                        }
                    ]
                },
                "starts": {
                    "doc": [
                        "$~\\⊤\\ si je commence avec le @Text donné.",
                        "$~\\'bonjour verset!'.starts('bonjour')\\",
                        "$~\\'bonjour verset!'.starts('verse')\\"
                    ],
                    "names": ["$~commence"],
                    "inputs": [
                        {
                            "doc": "$~Le @Texte à vérifier au début de moi.",
                            "names": "texto"
                        }
                    ]
                },
                "ends": {
                    "doc": [
                        "$~\\⊤\\ si je termine avec le @Text donné.",
                        "$~\\'suis-je une question ?'.ends('?')\\",
                        "$~\\'Je ne suis pas une question.'.ends('?')\\"
                    ],
                    "names": ["$~setermine"],
                    "inputs": [
                        {
                            "doc": "$~Le @Texte à vérifier à la fin de moi.",
                            "names": "texto"
                        }
                    ]
                }
            },
            "conversion": {
                "list": "$~Divise le texte en une liste de caractères individuels.",
                "number": "$~Convertit le texte en un @Number, et si ce n'est pas un nombre, en une valeur non numérique."
            }
        },
        "Number": {
            "doc": [
                "$~Je crée @Number, avec n'importe quel nombre d'unités que vous pouvez imaginer !",
                "$~Voici mon top 5 :",
                "$~\\0\\",
                "$~\\1histoire\\",
                "$~\\πpie\\",
                "$~\\∞rocher\\",
                "$~\\1000000câlins\\",
                "$~C’est essentiellement un nombre infini de nombres.",
                "$~Et un nombre infini d'unités !",
                "$~Et un nombre infini de paires nombre/unité…",
                "$~Je peux être des entiers, des nombres réels, négatifs, positifs, fractionnaires, décimaux, voire pas un nombre.",
                "$~Et vous pouvez m'écrire avec de nombreux systèmes numériques différents, notamment l'arabe \\123\\, le romain \\ⅩⅩⅩⅠⅩ\\, le japonais \\二十\\, et bien d'autres :",
                "$~\\1 + Ⅰ + 一\\",
                "$~Vous pouvez également m'écrire en bases 2 à 16 en mettant un numéro de base comme ceci :",
                "$~\\2;11111111\\",
                "$~\\10;255\\",
                "$~\\16;FF\\",
                "$~Il existe un nombre spécial appelé NaN qui est possible lorsque vous écrivez quelque chose qui n'est pas un nombre :",
                "$~\\2;22\\",
                "$~Il n'y a pas de chiffre « 2 » en base 2, ce n'est donc pas un nombre valide. NaN s'affichera également si vous essayez de convertir un texte non numérique en nombre",
                "$~\\'salut'→#\\"
            ],
            "name": ["$~#", "$~Nombre"],
            "function": {
                "add": {
                    "doc": [
                        "$~J'ajoute un @Number avec la même @Unit à moi-même, créant ainsi un nouveau @Number de la même @Unit.",
                        "$~Par exemple:",
                        "$~\\1 + 1\\",
                        "$~\\3chat + 5chat\\",
                        "$~Si les unités ne correspondent pas, j'arrête le spectacle.",
                        "$~\\3chat + 5chien\\"
                    ],
                    "names": ["$~+", "$~ajouter"],
                    "inputs": [
                        {
                            "doc": "$~Le @Number à ajouter.",
                            "names": "$~nombre"
                        }
                    ]
                },
                "subtract": {
                    "doc": [
                        "$~Je soustrais le @Number que vous me donnez de moi-même, créant ainsi un nouveau @Number de la même @Unit.",
                        "$~Par exemple:",
                        "$~\\1 - 1\\",
                        "$~\\3chat - 5chat\\",
                        "$~Si les unités ne correspondent pas, j'arrête le spectacle.",
                        "$~\\3chat - 5chien\\"
                    ],
                    "names": ["$~-", "$~soustraire"],
                    "inputs": [
                        {
                            "doc": "$~Le @Number à me soustraire.",
                            "names": "$~nombre"
                        }
                    ]
                },
                "multiply": {
                    "doc": [
                        "$~Je me multiplie par le @Number donné, créant un produit de mon @Unit et du @Unit du nombre donné :",
                        "$~\\5 · 5\\",
                        "$~\\5m · 5m\\",
                        "$~\\5m · 1/s\\"
                    ],
                    "names": ["$~·", "$~multiplier"],
                    "inputs": [
                        {
                            "doc": "$~Le nombre à multiplier.",
                            "names": "$~nombre"
                        }
                    ]
                },
                "divide": {
                    "doc": [
                        "$~Je me divise par le @Number donné, créant un quotient de mon @Unit et du @Unit du nombre donné :",
                        "$~\\5 ÷ 5\\",
                        "$~\\5m ÷ 5m\\",
                        "$~\\5m ÷ 5s\\"
                    ],
                    "names": ["÷", "divide"],
                    "inputs": [
                        {
                            "doc": "$~Le @Nombre par lequel me diviser.",
                            "names": "$~nombre"
                        }
                    ]
                },
                "remainder": {
                    "doc": [
                        "$~Je me divise par le @Number donné, mais je donne le reste :",
                        "$~\\10 % 2\\",
                        "$~\\10m % 2\\",
                        "$~\\10 m/s % 3\\"
                    ],
                    "names": ["$~%", "$~reste"],
                    "inputs": [
                        {
                            "doc": "$~Le @Nombre par lequel me diviser.",
                            "names": "$~nombre"
                        }
                    ]
                },
                "positive": {
                    "doc": [
                        "$~Je crée un nouveau @Number qui me rend positif, même s'il est négatif.",
                        "$~\\-200.positif()\\"
                    ],
                    "names": ["$~positif"],
                    "inputs": []
                },
                "round": {
                    "doc": [
                        "$~Je crée un nouveau @Number qui m'arrondit à l'entier le plus proche.",
                        "$~\\9.4.round()\\",
                        "$~\\9.5.tour()\\",
                        "$~\\9.6.round()\\"
                    ],
                    "names": ["$~rond"],
                    "inputs": []
                },
                "roundDown": {
                    "doc": [
                        "$~Je crée un nouveau @Number qui s'arrondit au plus petit entier inférieur à moi.",
                        "$~\\10.5.arrondir vers le bas()\\",
                        "$~\\10.1.arrondir vers le bas()\\",
                        "$~\\10.01.roundDown()\\"
                    ],
                    "names": ["$~arrondirverslebas"],
                    "inputs": []
                },
                "roundUp": {
                    "doc": [
                        "$~Je crée un nouveau @Number qui s'arrondit au plus petit entier supérieur à moi.",
                        "$~\\10.5.roundUp()\\",
                        "$~\\10.9.roundUp()\\",
                        "$~\\10.99.roundUp()\\"
                    ],
                    "names": ["$~tourd'horizon"],
                    "inputs": []
                },
                "power": {
                    "doc": [
                        "$~Je m'élève à la puissance donnée par @Number. Les exposants fractionnaires sont acceptables !",
                        "$~\\2 ^ 8\\",
                        "$~\\10 ^ -2\\",
                        "$~\\5 ^ -.5\\"
                    ],
                    "names": ["^", "power"],
                    "inputs": [
                        {
                            "doc": "$~L'exposant pour m'élever.",
                            "names": "$~nombre"
                        }
                    ]
                },
                "root": {
                    "doc": [
                        "$~Je crée la racine de moi-même en utilisant la racine donnée.",
                        "$~\\4 √ 2\\",
                        "$~\\1000 √ 3\\"
                    ],
                    "names": ["√", "root"],
                    "inputs": [
                        {
                            "doc": "$~La racine à calculer.",
                            "names": "$~nombre"
                        }
                    ]
                },
                "lessThan": {
                    "doc": [
                        "$~\\⊤\\ si je suis inférieur au @Number donné :",
                        "$~\\1 < 2\\",
                        "$~\\2 < 1\\"
                    ],
                    "names": ["<", "lessthan"],
                    "inputs": [
                        {
                            "doc": "$~Le @Number auquel me comparer.",
                            "names": "$~nombre"
                        }
                    ]
                },
                "lessOrEqual": {
                    "doc": [
                        "$~\\⊤\\ si je suis inférieur ou égal au @Number donné :",
                        "$~\\1 ≤ 2\\",
                        "$~\\2 ≤ 1\\",
                        "$~\\2 ≤ 2\\"
                    ],
                    "names": ["≤", "lessorequal"],
                    "inputs": [
                        {
                            "doc": "$~Le @Number auquel me comparer.",
                            "names": "$~nombre"
                        }
                    ]
                },
                "greaterThan": {
                    "doc": [
                        "$~\\⊤\\ si je suis supérieur au @Number donné :",
                        "$~\\1 > 2\\",
                        "$~\\2 > 1\\"
                    ],
                    "names": [">", "greaterthan"],
                    "inputs": [
                        {
                            "doc": "$~Le @Number auquel me comparer.",
                            "names": "$~nombre"
                        }
                    ]
                },
                "greaterOrEqual": {
                    "doc": [
                        "$~\\⊤\\ si je suis supérieur ou égal au @Number donné :",
                        "$~\\1 ≥ 2\\",
                        "$~\\2 ≥ 1\\",
                        "$~\\2 ≥ 2\\"
                    ],
                    "names": ["≥", "greaterorequal"],
                    "inputs": [
                        {
                            "doc": "$~Le @Number auquel me comparer.",
                            "names": "$~nombre"
                        }
                    ]
                },
                "equal": {
                    "doc": [
                        "$~\\⊤\\ si je suis égal au @Number donné :",
                        "$~\\1 = 2\\",
                        "$~\\2 = 2\\"
                    ],
                    "names": ["$~=", "$~égal"],
                    "inputs": [
                        {
                            "doc": "$~Le @Number auquel me comparer.",
                            "names": "$~nombre"
                        }
                    ]
                },
                "notequal": {
                    "doc": [
                        "$~\\⊤\\ si je suis égal au @Number donné :",
                        "$~\\1 ≠ 2\\",
                        "$~\\2 ≠ 2\\"
                    ],
                    "names": ["$~≠", "$~noteégale"],
                    "inputs": [
                        {
                            "doc": "$~Le @Number auquel me comparer.",
                            "names": "$~nombre"
                        }
                    ]
                },
                "cos": {
                    "doc": ["$~Calculez le cosinus de moi.", "$~\\π.cos()\\"],
                    "names": ["cos", "cosine"],
                    "inputs": []
                },
                "sin": {
                    "doc": ["$~Calcule mon sinus.", "$~\\π.cos()\\"],
                    "names": ["sin", "sine"],
                    "inputs": []
                },
                "min": {
                    "doc": [
                        "$~Trouvez le plus petit nombre de moi et d'autres.",
                        "$~\\1.min(2 3 -1)\\"
                    ],
                    "names": "$~min",
                    "inputs": [
                        {
                            "doc": "$~Autant de numéros que vous voulez me donner !",
                            "names": "$~Nombres"
                        }
                    ]
                },
                "max": {
                    "doc": [
                        "$~Trouvez le plus grand nombre de moi et d'autres.",
                        "$~\\1.max(2 3 4)\\"
                    ],
                    "names": "$~max",
                    "inputs": [
                        {
                            "doc": "$~Autant de numéros que vous voulez me donner !",
                            "names": "$~Nombres"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Une représentation arabe @Text de mes chiffres.",
                "list": [
                    "$~Je convertis un nombre en une liste de nombres de \\1\\ à n'importe quel nombre donné. Par exemple :",
                    "$~\\10→[]\\"
                ],
                "s2m": "$~Des secondes aux minutes",
                "s2h": "$~De quelques secondes à quelques heures",
                "s2day": "$~De quelques secondes à quelques jours",
                "s2wk": "$~De quelques secondes à quelques semaines",
                "s2year": "$~De quelques secondes à quelques années",
                "s2ms": "$~Secondes en millisecondes",
                "ms2s": "$~Millisecondes en secondes",
                "min2s": "$~Minutes en secondes",
                "h2s": "$~Des heures aux secondes",
                "day2s": "$~Des jours aux secondes",
                "wk2s": "$~Des semaines aux secondes",
                "yr2s": "$~Des années aux secondes",
                "m2pm": "$~Mètres en picomètres",
                "m2nm": "$~Des mètres aux nanomètres",
                "m2micro": "$~Des mètres aux micromètres",
                "m2mm": "$~Mètres en millimètres",
                "m2cm": "$~Mètres en centimètres",
                "m2dm": "$~Des mètres aux décimètres",
                "m2km": "$~Mètres en kilomètres",
                "m2Mm": "$~Des mètres aux mégamètres",
                "m2Gm": "$~Des mètres aux gigamètres",
                "m2Tm": "$~Mètres en téramètres",
                "pm2m": "$~Picomètres en mètres",
                "nm2m": "$~Nanomètres en mètres",
                "micro2m": "$~Des micromètres aux mètres",
                "mm2m": "$~Millimètres en mètres",
                "cm2m": "$~Centimètres en mètres",
                "dm2m": "$~Décimètres en mètres",
                "km2m": "$~Kilomètres en mètres",
                "Mm2m": "$~Mégamètres en mètres",
                "Gm2m": "$~Des gigamètres aux mètres",
                "Tm2m": "$~Téramètres en mètres",
                "km2mi": "$~Kilomètres en miles",
                "mi2km": "$~Des miles aux kilomètres",
                "cm2in": "$~Centimètres en pouces",
                "in2cm": "$~Pouces en centimètres",
                "m2ft": "$~Mètres en pieds",
                "ft2m": "$~Pieds en mètres",
                "g2mg": "$~Grammes en milligrammes",
                "mg2g": "$~Milligrammes en grammes",
                "g2kg": "$~Grammes en kilogrammes",
                "kg2g": "$~Kilogrammes en grammes",
                "g2oz": "$~Grammes en onces",
                "oz2g": "$~Onces en grammes",
                "oz2lb": "$~Onces en livres",
                "lb2oz": "$~Livres en onces"
            }
        },
        "List": {
            "doc": [
                "$~Je suis une séquence de valeurs, de toute sorte !",
                "$~Vous pouvez mettre n'importe quoi dans moi : @Boolean, @Number, @Text, @None, même d'autres @List, @Set, @Map, ou n'importe quelle expression. En voici une simple :",
                "$~\\['pomme' 'banane' 'mangue']\\",
                "$~Ce qui me rend spécial, c'est que je garde les choses en ordre et que je numérote tout de 1 jusqu'au nombre d'éléments que j'ai en moi.",
                "$~Mes éléments sont numérotés, à partir de 1. Vous pouvez obtenir les valeurs que je stocke avec @ListAccess, en utilisant leur numéro :",
                "$~Par exemple, la deuxième valeur de cette liste est \\['banane']\\",
                "$~\\['pomme' 'banane' 'mangue'][2]\\",
                "$~Je peux avoir tout ce que je veux en moi. Regardez cette liste, avec @Text, @Number et @Time !",
                "$~\\['apple' 10 + 10 Heure()]\\",
                "$~Lorsque vous me donnez une liste de plusieurs éléments, je les généraliserai s'ils ont un type en commun. Mais parfois, vous pouvez littéralement vouloir dire ces éléments spécifiques. Si c'est le cas, mettez simplement un ! après moi, et je m'assurerai de représenter une liste contenant uniquement ces valeurs.",
                "$~\\['pomme' 'banane' 'mangue']!\\",
                "$~C'est un peu ça. Mais je peux faire des choses passionnantes avec ma @FunctionDefinition !"
            ],
            "name": ["$~[]", "$~Liste"],
            "kind": "$~Gentil",
            "out": "$~Résultat",
            "outofbounds": "$~hors limites",
            "function": {
                "add": {
                    "doc": [
                        "$~Je crée une nouvelle @List avec l'élément donné à la fin.",
                        "$~\\['pomme' 'banane' 'mangue'].with('pastèque')\\"
                    ],
                    "names": ["$~avec", "$~ajouter"],
                    "inputs": [
                        {
                            "doc": "$~Je suis la valeur que vous souhaitez ajouter.",
                            "names": "$~article"
                        }
                    ]
                },
                "append": {
                    "doc": [
                        "$~Je crée une nouvelle @List avec mes valeurs, puis toutes les valeurs de la @List donnée après moi.",
                        "$~\\['pomme' 'banane' 'mangue'].withList(['pastèque' 'carambole'])\\",
                        "$~C'est un peu plus simple d'utiliser @Spread, comme ceci :",
                        "$~\\['pomme' 'banane' 'mangue' :['pastèque' 'carambole']]\\"
                    ],
                    "names": ["$~avecListe", "$~ajouter"],
                    "inputs": [
                        {
                            "doc": "$~La liste des valeurs à ajouter.",
                            "names": "$~liste"
                        }
                    ]
                },
                "replace": {
                    "doc": [
                        "$~Je crée une nouvelle liste qui remplace la valeur à l'index donné par la valeur donnée.",
                        "$~\\['pomme' 'banane' 'mangue'].replace(1 'kiwi')\\"
                    ],
                    "names": ["reemplazar"],
                    "inputs": [
                        {
                            "doc": "$~L'index de la valeur à remplacer",
                            "names": "$~indice"
                        },
                        {
                            "doc": "$~La valeur de remplacement",
                            "names": "$~valeur"
                        }
                    ]
                },
                "length": {
                    "doc": "$~Le @Nombre d'éléments en moi.",
                    "names": ["$~📏", "$~longueur"],
                    "inputs": []
                },
                "random": {
                    "doc": [
                        "$~Un de mes articles sélectionné au hasard, ou @None si je suis vide.",
                        "$~\\['pomme' 'banane' 'mangue'].random()\\"
                    ],
                    "names": "$~aléatoire",
                    "inputs": []
                },
                "shuffled": {
                    "doc": [
                        "$~Créez une nouvelle liste avec les éléments de la dernière liste classés au hasard.",
                        "$~\\['pomme' 'banane' 'mangue'].shuffled()\\"
                    ],
                    "names": "$~mélangé",
                    "inputs": []
                },
                "first": {
                    "doc": [
                        "$~Le premier élément en moi, ou @None si je suis vide.",
                        "$~\\['pomme' 'banane' 'mangue'].first()\\"
                    ],
                    "names": "$~d'abord",
                    "inputs": []
                },
                "last": {
                    "doc": [
                        "$~Le dernier élément en moi, ou @None si je suis vide.",
                        "$~\\['pomme' 'banane' 'mangue'].first()\\"
                    ],
                    "names": "$~dernier",
                    "inputs": []
                },
                "has": {
                    "doc": [
                        "$~\\⊤\\ si j'ai un élément égal à l'élément donné en moi.",
                        "$~\\['pomme' 'banane' 'mangue'].has('banane')\\"
                    ],
                    "names": "$~a",
                    "inputs": [
                        {
                            "doc": "$~La valeur à rechercher.",
                            "names": "$~article"
                        }
                    ]
                },
                "join": {
                    "doc": [
                        "$~Je combine les éléments de ma liste dans @Text, séparés par le séparateur donné @Text.",
                        "$~\\['pomme' 'banane' 'mangue'].join(', ')\\"
                    ],
                    "names": "$~rejoindre",
                    "inputs": [
                        {
                            "doc": "$~Le texte par lequel séparer les éléments, éventuellement vide.",
                            "names": "$~séparateur"
                        }
                    ]
                },
                "subsequence": {
                    "doc": [
                        "$~J'obtiens une liste dans cette liste, commençant par l'index que vous fournissez et se terminant par le dernier élément, ou si vous en fournissez un, un élément particulier.",
                        "$~\\['pomme' 'banane' 'mangue'].subsequence(2)\\",
                        "$~\\['pomme' 'banane' 'mangue'].subsequence(1 2)\\",
                        "$~Et regardez ! Si vous donnez des numéros dans le désordre, je vous donne l'inverse",
                        "$~\\['pomme' 'banane' 'mangue'].subsequence(3 1)\\",
                        "$~Si vous me donnez quelque chose de plus petit que 1 pour un index, je suppose que vous voulez dire 1.",
                        "$~\\['pomme' 'banane' 'mangue'].subsequence(-1003243 2)\\",
                        "$~Et si vous me donnez quelque chose de plus grand que le plus grand indice, je supposerai que vous parlez de la fin.",
                        "$~\\['pomme' 'banane' 'mangue'].subsequence(3 2304032432)\\"
                    ],
                    "names": "$~sous-séquence",
                    "inputs": [
                        {
                            "doc": "$~L'index du premier élément de la sous-séquence souhaitée.",
                            "names": "$~commencer"
                        },
                        {
                            "doc": "$~L'index optionnel du dernier élément de la sous-séquence que vous souhaitez. Si vous n'en indiquez pas, votre liste se terminera avec le dernier élément de la liste.",
                            "names": "$~fin"
                        }
                    ]
                },
                "sansFirst": {
                    "doc": [
                        "$~Je crée une liste sans mon premier élément.",
                        "$~\\['pomme' 'banane' 'mangue'].sansFirst()\\"
                    ],
                    "names": ["$~sansPremier", "$~sansPremier"],
                    "inputs": []
                },
                "sansLast": {
                    "doc": [
                        "$~Je crée une liste sans mon dernier élément.",
                        "$~\\['pomme' 'banane' 'mangue'].sansLast()\\"
                    ],
                    "names": ["$~sansDernier", "$~sansDernier"],
                    "inputs": []
                },
                "sans": {
                    "doc": [
                        "$~Moi, mais sans les premières occurrences de la valeur donnée.",
                        "$~\\['pomme' 'banane' 'mangue' 'pomme'].sans('pomme')\\"
                    ],
                    "names": ["$~sans", "$~sans"],
                    "inputs": [
                        {
                            "doc": "$~La valeur à laquelle supprimer la première occurrence.",
                            "names": "$~valeur"
                        }
                    ]
                },
                "sansAll": {
                    "doc": [
                        "$~Moi, mais sans toutes les occurrences de la valeur donnée.",
                        "$~\\['pomme' 'banane' 'mangue' 'pomme'].sans('pomme')\\"
                    ],
                    "names": ["$~sansTout", "$~sansTout"],
                    "inputs": [
                        {
                            "doc": "$~La valeur pour supprimer toutes les occurrences de la liste.",
                            "names": "$~valeur"
                        }
                    ]
                },
                "reverse": {
                    "doc": [
                        "$~Moi, mais à l'envers !",
                        "$~\\['pomme' 'banane' 'mangue'].reverse()\\"
                    ],
                    "names": ["$~renversé", "$~inverse"],
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "$~\\⊤\\ si mes articles et ma commande sont exactement les mêmes que la @List donnée.",
                        "$~\\['pomme' 'banane' 'mangue'] = ['pomme' 'mangue' 'banane']\\"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "$~La @List à laquelle me comparer.",
                            "names": "$~liste"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "$~\\⊤\\ si mes articles et ma commande ne sont /pas/ exactement les mêmes que la @List donnée.",
                        "$~\\['pomme' 'banane' 'mangue'] ≠ ['pomme' 'mangue' 'banane']\\"
                    ],
                    "names": ["$~≠", "$~noteégale"],
                    "inputs": [
                        {
                            "doc": "$~La @List à laquelle me comparer.",
                            "names": "$~liste"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "$~Donnez-moi une @FunctionDefinition qui prend une valeur et un index facultatif en entrée et produit une valeur, et je l'évaluerai sur chacun de mes éléments, traduisant mes valeurs en nouvelles valeurs.",
                        "$~Par exemple, imaginez que j'étais une liste de @Number et que vous vouliez les doubler tous :",
                        "$~\\[2 4 6 8].traduire(ƒ(num•#) num · 2)\\"
                    ],
                    "names": "$~traduire",
                    "inputs": [
                        {
                            "doc": "$~La @FunctionDefinition qui traduira chaque élément.",
                            "names": "$~traducteur"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "$~L'élément en cours de traduction.",
                            "names": "$~article"
                        },
                        {
                            "doc": "$~L'index de l'élément en cours de traduction.",
                            "names": "$~indice"
                        },
                        {
                            "doc": "$~La liste en cours de traduction.",
                            "names": "$~liste"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "$~Donnez-moi une @FunctionDefinition qui prend une valeur et un index facultatif en entrée et produit un @Boolean, et je créerai une nouvelle liste qui inclut uniquement les éléments qui résultent \\⊤\\.",
                        "$~Par exemple, imaginez que j'étais une liste de @Number et que vous ne vouliez que les positifs :",
                        "$~\\[2 -4 8 -16].filter(ƒ(num•#) num ≥ 0)\\"
                    ],
                    "names": "$~filtre",
                    "inputs": [
                        {
                            "doc": "$~Une @FunctionDefinition qui vérifie chaque élément, produisant \\⊤\\ s'il doit être conservé.",
                            "names": "$~vérificateur"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~L'élément en cours de vérification.",
                            "names": "$~article"
                        },
                        {
                            "doc": "$~L'index de l'élément vérifié.",
                            "names": "$~indice"
                        },
                        {
                            "doc": "$~La liste en cours de filtrage.",
                            "names": "$~liste"
                        }
                    ]
                },
                "all": {
                    "doc": [
                        "$~Donnez-moi une @FunctionDefinition qui prend une valeur en entrée et produit un @Boolean si elle correspond à une condition. Je créerai \\⊤\\ si tous les éléments correspondent à la condition.",
                        "$~Par exemple, imaginez que j'étais une liste de @Number et que vous vouliez savoir si tout était positif :",
                        "$~\\[2 -4 8 -16].all(ƒ(num•#) num ≥ 0)\\"
                    ],
                    "names": "$~tous",
                    "inputs": [
                        {
                            "doc": "$~La @FunctionDefinition qui produit \\⊤\\ si un élément satisfait votre condition.",
                            "names": "$~vérificateur"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~L'élément en cours de vérification.",
                            "names": "$~article"
                        },
                        {
                            "doc": "$~L'index de l'élément vérifié.",
                            "names": "$~indice"
                        },
                        {
                            "doc": "$~La liste en cours de vérification.",
                            "names": "$~liste"
                        }
                    ]
                },
                "until": {
                    "doc": [
                        "$~Donnez-moi une @FunctionDefinition qui prend une valeur en entrée et produit un @Boolean si elle correspond à une condition. Je vais créer une nouvelle @List qui contient tous les éléments jusqu'à ce que la condition ne soit pas remplie.",
                        "$~Par exemple, imaginez que j'étais une liste d'animaux @Text et que vous vouliez tout trouver jusqu'à ce que \\'rat'\\ soit trouvé :",
                        "$~\\['chat' 'chien' 'rat' 'souris' 'poney'].until(ƒ(animal•'') animal = 'rat')\\"
                    ],
                    "names": "$~jusqu'à",
                    "inputs": [
                        {
                            "doc": "$~La @FunctionDefinition qui produit \\⊤\\ si je dois arrêter d'inclure des éléments.",
                            "names": "$~vérificateur"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~L'élément en cours de vérification.",
                            "names": "$~article"
                        },
                        {
                            "doc": "$~L'index de l'élément vérifié.",
                            "names": "$~indice"
                        },
                        {
                            "doc": "$~La liste en cours de sous-séquençage.",
                            "names": "$~liste"
                        }
                    ]
                },
                "find": {
                    "doc": [
                        "$~Donnez-moi une @FunctionDefinition qui prend une valeur en entrée et produit un @Boolean si elle correspond à certains critères, et j'évaluerai l'élément correspondant.",
                        "$~Par exemple, imaginez que vous vouliez trouver le premier animal qui avait la voyelle \\'e'\\ :",
                        "$~\\['chat' 'chien' 'rat' 'souris' 'poney'].find(ƒ(animal•'') animal.has('e'))\\"
                    ],
                    "names": "$~trouver",
                    "inputs": [
                        {
                            "doc": "$~La @FunctionDefinition qui produit \\⊤\\ si elle correspond à vos critères de recherche.",
                            "names": "$~vérificateur"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~L'élément en cours de vérification.",
                            "names": "$~article"
                        },
                        {
                            "doc": "$~L'index de l'élément vérifié.",
                            "names": "$~indice"
                        },
                        {
                            "doc": "$~La liste recherchée.",
                            "names": "$~liste"
                        }
                    ]
                },
                "combine": {
                    "doc": [
                        "$~Donnez-moi une @FunctionDefinition qui prend la combinaison la plus récente et une valeur suivante, et crée une combinaison suivante, et je passerai du premier au dernier de mes éléments, créant des combinaisons successives et évaluant la combinaison finale à laquelle votre @FunctionDefinition évalue.",
                        "$~C'est vraiment utile pour combiner tous les éléments de me en une seule valeur. Par exemple, imaginez que vous vouliez ajouter une liste de nombres :",
                        "$~\\[3 9 2 8 1 4].combine(0 ƒ(somme•# nombre•#) somme + nombre)\\"
                    ],
                    "names": ["$~combiné", "$~combiner"],
                    "inputs": [
                        {
                            "doc": "$~La combinaison de départ.",
                            "names": "$~initial"
                        },
                        {
                            "doc": "$~La @FunctionDefinition qui prend la dernière combinaison et la valeur suivante et produit la combinaison suivante.",
                            "names": "$~combinateur"
                        }
                    ],
                    "combiner": [
                        {
                            "doc": "$~La combinaison actuelle",
                            "names": "$~combinaison"
                        },
                        {
                            "doc": "$~L'élément suivant à combiner.",
                            "names": "$~suivant"
                        },
                        {
                            "doc": "$~L'index de l'élément suivant",
                            "names": "$~indice"
                        },
                        {
                            "doc": "$~La liste en cours de combinaison.",
                            "names": "$~liste"
                        }
                    ]
                },
                "sorted": {
                    "doc": [
                        "$~Je peux prendre une liste et en créer une nouvelle avec ses valeurs triées. Comme ceci :",
                        "$~\\[1 5 8 0 2].trié()\\",
                        "$~Je peux aussi le faire pour les valeurs @Text",
                        "$~\\['orange' 'kiwi' 'banane' 'pomme'].sorted()\\",
                        "$~Et si vous avez une liste de valeurs qui ne sont pas @Number ou @Text, vous pouvez me donner une @FunctionDefinition qui transforme chaque élément en un @Number afin que je puisse le trier. Par exemple, ici nous avons une liste de listes de différentes longueurs ; si vous me donnez une fonction qui transforme chaque liste en sa longueur, je peux trier en fonction de leur longueur.",
                        "$~\\[[1] [2 3] [4 8 12] [8]].sorted(ƒ(liste) liste.length())\\"
                    ],
                    "names": "$~trié",
                    "inputs": [
                        {
                            "doc": "$",
                            "names": "$~séquenceur"
                        }
                    ],
                    "sequencer": [
                        {
                            "doc": "$~La valeur à transformer en @Number.",
                            "names": "$~valeur"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Vers une représentation @Text de la liste.",
                "set": "$~Pour un @Set, utile pour supprimer les doublons."
            }
        },
        "Set": {
            "doc": [
                "$~Je suis un ensemble de valeurs ! Cela signifie que je peux contenir n'importe quel nombre de valeurs, y compris aucune valeur. Vous pouvez me faire ressembler à ceci :",
                "$~\\{1 2 3}\\",
                "$~Je suis vraiment bon si vous voulez garder une collection de choses sans aucun doublon.",
                "$~Cela signifie que si vous me donnez des valeurs que j'ai déjà, j'ignorerai les extras.",
                "$~Par exemple, cet ensemble comporte de nombreux doublons :",
                "$~\\{1 1 2 2 3 3}\\",
                "$~Je l'évalue à juste \\{1 2 3}\\.",
                "$~Si vous voulez voir si j'ai une valeur en moi, @SetOrMapAccess peut vous aider :",
                "$~\\{'pot' 'bouteille' 'verre'}{'tasse'}\\",
                "$~En général, si vous me donnez un ensemble de valeurs qui sont d'un type commun, je suppose qu'il s'agit d'une liste de ce type. Par exemple, cet ensemble est \\{''}\\, car il est entièrement de type @Text.",
                "$~\\{'hey' 'salut' 'bonjour'}\\",
                "$~Mais vous voudrez peut-être indiquer que je suis un ensemble de /uniquement/ ces valeurs, afin que je puisse vous dire quand vous essayez d'en utiliser une qui n'est pas autorisée. Si c'est le cas, ajoutez simplement un ! à la fin de me.",
                "$~\\{'hey' 'salut' 'bonjour'}!{'yo'}\\",
                "$~Y a-t-il autre chose que tu veux faire avec moi ? Jette un œil à toutes les @FunctionDefinitions intéressantes que j'ai !"
            ],
            "name": ["$~{}", "$~Ensemble"],
            "kind": "$~Gentil",
            "out": "$~Résultat",
            "function": {
                "size": {
                    "doc": "$~Je vais vous dire combien de valeurs il y a en moi.",
                    "names": "$~taille",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "$~Je suis \\⊤\\ si le @Set donné et moi avons exactement les mêmes valeurs :",
                        "$~\\{1 2 3} = {2 3 4}\\"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "$~Le @Set à comparer.",
                            "names": "$~ensemble"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "$~Je suis \\⊤\\ si le @Set donné et moi n'avons pas exactement les mêmes valeurs :",
                        "$~\\{1 2 3} ≠ {2 3 4}\\"
                    ],
                    "names": ["$~≠", "$~noteégale"],
                    "inputs": [
                        {
                            "doc": "$~Le @Set à comparer.",
                            "names": "$~ensemble"
                        }
                    ]
                },
                "add": {
                    "doc": [
                        "$~Donnez-moi un élément à ajouter et je créerai un nouveau @Set avec mes éléments et l'élément donné.",
                        "$~\\{1 2 3} + 4\\"
                    ],
                    "names": ["add", "+"],
                    "inputs": [
                        {
                            "doc": "$~L'élément à ajouter",
                            "names": "$~article"
                        }
                    ]
                },
                "remove": {
                    "doc": [
                        "$~Donnez-moi un élément à supprimer et je créerai un nouveau @Set sans l'élément.",
                        "$~\\{1 2 3} - 2\\",
                        "$~Si je n'ai pas l'objet, je l'évaluerai simplement moi-même."
                    ],
                    "names": ["remove", "-"],
                    "inputs": [
                        {
                            "doc": "$~L'élément à supprimer.",
                            "names": "$~article"
                        }
                    ]
                },
                "union": {
                    "doc": [
                        "$~Donnez-moi @Set et je créerai un nouveau @Set qui contient mes éléments et les éléments de l'ensemble.",
                        "$~\\{1 2 3} ∪ {3 4 5}\\"
                    ],
                    "names": ["union", "∪"],
                    "inputs": [
                        {
                            "doc": "$~Le @Set à combiner avec moi.",
                            "names": "$~ensemble"
                        }
                    ]
                },
                "intersection": {
                    "doc": [
                        "$~Donnez-moi @Set et je créerai un nouveau @Set qui ne contient que les éléments que nous avons en commun.",
                        "$~\\{1 2 3} ∩ {3 4 5}\\"
                    ],
                    "names": ["intersection", "∩"],
                    "inputs": [
                        {
                            "doc": "$~L'ensemble pour comparer avec moi.",
                            "names": "$~ensemble"
                        }
                    ]
                },
                "difference": {
                    "doc": [
                        "$~Donnez-moi @Set et je créerai un nouveau @Set qui contient uniquement les éléments que nous avons en commun.",
                        "$~\\{1 2 3}.différence({3 4 5})\\"
                    ],
                    "names": "$~différence",
                    "inputs": [
                        {
                            "doc": "$~L'ensemble dont les éléments devraient m'être retirés.",
                            "names": "$~ensemble"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "$~Donnez-moi @FunctionDefinition qui prend un élément et produit \\⊤\\ s'il doit être conservé, et je créerai un @Set qui ne contient que les éléments qui répondent à vos critères.",
                        "$~Par exemple, trouvons les nombres impairs en moi :",
                        "$~\\{1 2 3 4 5 6 7 8 9}.filter(ƒ(num•#) (num % 2) = 1)\\"
                    ],
                    "names": "filter",
                    "inputs": [
                        {
                            "doc": "$~La @FunctionDefinition qui vérifie un élément pour voir s'il doit être conservé.",
                            "names": "$~vérificateur"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~L'élément en cours de vérification.",
                            "names": "$~valeur"
                        },
                        {
                            "doc": "$~L'ensemble étant filtré",
                            "names": "$~ensemble"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "$~Donnez-moi @FunctionDefinition qui prend un élément et produit un nouvel élément basé sur celui-ci, puis je traduirai tous les éléments en moi dans un nouveau @Set (en supprimant tous les doublons).",
                        "$~Par exemple, transformons tous mes @Number en @Text :",
                        "$~\\{1 2 3 4 5 6 7 8 9}.translate(ƒ(num•#) num→'')\\"
                    ],
                    "names": "translate",
                    "inputs": [
                        {
                            "doc": "$~La @FunctionDefinition qui traduit l'un de mes éléments dans le nouvel élément que vous souhaitez.",
                            "names": "$~ensemble"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "$~L'élément en cours de traduction.",
                            "names": "$~valeur"
                        },
                        {
                            "doc": "$~L'ensemble en cours de traduction",
                            "names": "$~ensemble"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Une représentation @Text d'un @Set",
                "list": "$~Une représentation @List des éléments de l'ensemble."
            }
        },
        "Map": {
            "doc": [
                "$~Je rassemble des valeurs en faisant correspondre des *clés* à des *valeurs*. Par exemple :",
                "$~\\{'amy': 6points 'tony': 3points 'shiela': 8points}\\",
                "$~Mes clés peuvent être n’importe quel type de valeur, et mes valeurs peuvent être n’importe quel type de valeur.",
                "$~Certaines personnes aiment penser à moi comme à un index ou à un dictionnaire, où vous me donnez quelque chose et je vous donne à quoi cela correspond.",
                "$~Si vous souhaitez vérifier à quoi quelque chose est mappé, vous pouvez donner à @SetOrMapAccess une clé et ils vous donneront la valeur :",
                "$~\\{'amy': 6points 'tony': 3points 'shiela': 8points}{'amy'}\\",
                "$~S'il n'y a pas de clé correspondante, je vous donnerai @None.",
                "$~\\{'amy': 6points 'tony': 3points 'shiela': 8points}{'jen'}\\",
                "$~Vous pouvez également créer une carte vide comme celle-ci :",
                "$~\\{:}\\",
                "$~En général, je regarde tous les types de clés et de valeurs que vous me donnez et je crée simplement un type pour les représenter tous. Comme ceci, c'est une carte de nombres à nombres :",
                "$~\\{1:1 2:2 3:3}\\",
                "$~Mais disons que vous vouliez vous assurer qu'il s'agissait uniquement de ces valeurs ; ajoutez simplement ! à la fin de me, et je ne généraliserai pas. Cela vous aidera à savoir si vous essayez d'obtenir une valeur que vous n'aviez pas prévue.",
                "$~\\{1:1 2:2 3:3}!{4}\\",
                "$~Je sais faire beaucoup de choses merveilleuses avec mes accords."
            ],
            "name": ["$~{:}", "$~Carte"],
            "key": "$~Clé",
            "value": "$~Valeur",
            "result": "$~Résultat",
            "function": {
                "size": {
                    "doc": "$~Je vais vous dire combien de valeurs il y a en moi.",
                    "names": "$~taille",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "$~\\{⊤}\\ si mes appariements sont exactement les mêmes que ceux de @Map donnés.",
                        "$~\\{1:1 2:2} = {1:1 2:3}\\"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "$~La @Map pour me comparer.",
                            "names": "$~valeur"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "$~\\{⊤}\\ si mes appariements ne sont /pas/ exactement les mêmes que ceux de @Map donnés.",
                        "$~\\{1:1 2:2} ≠ {1:1 2:3}\\"
                    ],
                    "names": ["$~≠", "$~noteégale"],
                    "inputs": [
                        {
                            "doc": "$~La @Map pour me comparer.",
                            "names": "$~valeur"
                        }
                    ]
                },
                "set": {
                    "doc": [
                        "$~Je vais créer une nouvelle @Map avec toutes les mêmes paires, mais avec la nouvelle paire que tu me donnes. Si j'ai déjà la clé, je l'associerai à la nouvelle valeur.",
                        "$~\\{'amy': 6points 'tony': 3points}.pair('jen' 0points)\\"
                    ],
                    "names": "$~paire",
                    "inputs": [
                        {
                            "doc": "$~Clé à associer à une valeur.",
                            "names": "$~clé"
                        },
                        {
                            "doc": "$~La valeur à associer à la clé",
                            "names": "$~valeur"
                        }
                    ]
                },
                "unset": {
                    "doc": [
                        "$~Je vais faire une nouvelle @Map sans la clé que vous me donnez, en supprimant son couplage.",
                        "$~\\{'amy': 6points 'tony': 3points}.unpair('amy')\\"
                    ],
                    "names": "$~dissocier",
                    "inputs": [
                        {
                            "doc": "$~La clé pour oublier.",
                            "names": "$~clé"
                        }
                    ]
                },
                "remove": {
                    "doc": [
                        "$~Je vais créer une nouvelle @Map sans aucune clé ayant la valeur.",
                        "$~\\{'amy': 0points 'jen': 0points 'tony':3points}.remove(0points)\\"
                    ],
                    "names": "$~retirer",
                    "inputs": [
                        {
                            "doc": "$~La valeur à supprimer de moi, ainsi que toutes les clés auxquelles elle est associée.",
                            "names": "$~valeur"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "$~Donnez-moi une @FunctionDefinition qui prend une clé et une valeur et évalue à \\⊤\\ si un appariement doit être conservé. Je créerai une nouvelle @Map qui répond à vos critères.",
                        "$~Par exemple, ici, nous voulons conserver toutes les paires qui sont Amy ou qui ont plus de zéro point.",
                        "$~\\{'amy': 0points 'jen': 0points 'tony':3points}.filter(ƒ(clé•'' valeur•#points) (clé = 'amy') | (valeur > 0points))\\"
                    ],
                    "names": "filter",
                    "inputs": [
                        {
                            "doc": "$~La @FunctionDefinition qui décide de conserver ou non un appariement.",
                            "names": "$~vérificateur"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~La clé en cours de vérification.",
                            "names": "$~clé"
                        },
                        {
                            "doc": "$~La valeur en cours de vérification.",
                            "names": "$~valeur"
                        },
                        {
                            "doc": "$~La carte en cours de filtrage.",
                            "names": "$~carte"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "$~Donnez-moi une @FunctionDefinition qui prend une clé et une valeur et évalue la valeur en une nouvelle valeur. Je vais créer une nouvelle @Map avec les mêmes clés mais des valeurs mises à jour.",
                        "$~Par exemple, donnons un point à chacun, car ils ont été très gentils.",
                        "$~\\{'amy': 5points 'jen': 3points 'tony': 0points}.translate(ƒ(clé•'' valeur•#points) valeur + 1points)\\"
                    ],
                    "names": "translate",
                    "inputs": [
                        {
                            "doc": "$~La @FunctionDefinition qui traduit chaque valeur.",
                            "names": "$~traducteur"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "$~La clé de la valeur traduite.",
                            "names": "$~clé"
                        },
                        {
                            "doc": "$~La valeur en cours de traduction.",
                            "names": "$~valeur"
                        },
                        {
                            "doc": "$~La carte en cours de traduction.",
                            "names": "$~carte"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Une représentation @Text du mappage.",
                "set": "$~Les clés de la @Map",
                "list": "$~Une liste des valeurs dans la @Map"
            }
        },
        "Table": {
            "doc": [
                "$~Je suis un ensemble de lignes de tableau ! Je peux vous aider à suivre de grandes collections de valeurs qui ont la même structure.",
                "$~Par exemple, imaginez que vous vouliez suivre un tas de rochers :",
                "$~\\⎡nom•'' couleur•''⎦\n⎡'obsidienne' 'noir'⎦\n⎡'pierre ponce' 'gris'⎦\n⎡'citrine' 'jaune'⎦\\",
                "$~@Bind peut vous aider à le nommer ! Et vous pouvez ensuite faire des choses comme créer un tableau révisé avec une nouvelle ligne @Insert :",
                "$~\\roches : ⎡nom•'' couleur•''⎦\n⎡'obsidienne' 'noir'⎦\n⎡'pierre ponce' 'gris'⎦\n⎡'citrine' 'jaune'⎦\nroches ⎡+ 'quartz' 'blanc'⎦\\",
                "$~Ou si vous souhaitez trouver des lignes qui correspondent, vous pouvez @Select les lignes qui correspondent à une condition :",
                "$~\\rocks: ⎡name•'' color•''⎦\n⎡'obsidienne' 'noir'⎦\n⎡'pierre ponce' 'gris'⎦\n⎡'citrine' 'jaune'⎦\nrocks ⎡?⎦ color = 'gris'\\",
                "$~Ou peut-être souhaitez-vous créer une table révisée contenant des valeurs différentes pour les lignes correspondant à une condition :",
                "$~\\rocks: ⎡name•'' color•''⎦\n⎡'obsidienne' 'noir'⎦\n⎡'pierre ponce' 'gris'⎦\n⎡'citrine' 'jaune'⎦\nrocks ⎡: couleur: 'noir' ⎦ nom = 'pierre ponce'\\",
                "$~Ou peut-être souhaitez-vous supprimer une ligne correspondant à une condition :",
                "$~\\rocks: ⎡name•'' color•''⎦\n⎡'obsidienne' 'noir'⎦\n⎡'pierre ponce' 'gris'⎦\n⎡'citrine' 'jaune'⎦\nrocks ⎡- name.has('i')\\",
                "$~Et si jamais vous souhaitez obtenir des valeurs spécifiques de ma part, vous pouvez convertir n'importe quelle table en liste et accéder aux lignes individuelles avec @PropertyReference",
                "$~\\rocks: ⎡name•'' color•''⎦\n⎡'obsidienne' 'noir'⎦\n⎡'pierre ponce' 'gris'⎦\n⎡'citrine' 'jaune'⎦\n(rocks → [])[1].name\\"
            ],
            "name": ["$~⎡⎦", "$~Tableau"],
            "row": "$~Rangée",
            "function": {
                "equals": {
                    "doc": "$~Je vérifie si j'ai exactement les mêmes cellules dans exactement le même ordre qu'un autre @Table.",
                    "names": ["$~=", "$~estégalà"],
                    "inputs": [
                        {
                            "doc": "$~L'autre table à vérifier.",
                            "names": "$~valeur"
                        }
                    ]
                },
                "notequal": {
                    "doc": "$~Je vérifie si l'une de mes cellules est différente ou dans un ordre différent d'une autre @Table.",
                    "names": ["$~≠", "$~paségal"],
                    "inputs": [
                        {
                            "doc": "$~L'autre table à vérifier.",
                            "names": "$~valeur"
                        }
                    ]
                }
            },
            "conversion": {
                "list": "$~Je convertis une @Table en une liste de lignes, où chaque ligne est une @Structure avec ses noms de colonnes comme propriétés.",
                "text": "$~Je viens de convertir une @Table en texte."
            }
        },
        "Structure": {
            "doc": "$~Voir @StructureDefinition.",
            "name": ["$~Structure"],
            "function": {
                "equals": {
                    "doc": "$~Je vérifie si mes propriétés ont le même nom et les mêmes valeurs que les propriétés d'une autre structure.",
                    "names": ["$~=", "$~estégalà"],
                    "inputs": [
                        {
                            "doc": "$~L'autre structure à vérifier.",
                            "names": "$~valeur"
                        }
                    ]
                },
                "notequal": {
                    "doc": "$~Je vérifie si mes propriétés sont différentes de quelque manière que ce soit du nom et des valeurs d'une autre structure.",
                    "names": ["$~≠", "$~paségal"],
                    "inputs": [
                        {
                            "doc": "$~L'autre structure à vérifier.",
                            "names": "$~valeur"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Je me convertis en @Text."
            }
        }
    },
    "input": {
        "Random": {
            "doc": [
                "$~17!",
                "$~/@FunctionDefinition ici, je vais expliquer celui-ci./",
                "$~@Random est donc une fonction curieuse qui crée des nombres aléatoires. Elle est curieuse car chaque fois que vous l'évaluez, elle crée quelque chose de différent.",
                "$~Cela crée un chaos merveilleux qui s’accompagne d’imprévisibilité.",
                "$~Par défaut, il donne des valeurs @Number entre \\0\\ et \\1\\ :",
                "$~\\Aléatoire()\\",
                "$~Mais vous pouvez lui donner une valeur, et il générera des valeurs entre \\0\\ et la valeur :",
                "$~\\Aléatoire(10)\\",
                "$~Et si vous lui donnez deux valeurs, il générera des valeurs comprises entre les deux valeurs incluses :",
                "$~\\Aléatoire(-10 10)\\",
                "$~Si vos plages ont des unités, elles seront conservées (et si elles ne correspondent pas, l'unité du minimum sera utilisée) :",
                "$~\\Aléatoire(-10m 10m)\\",
                "$~Et si vous donnez des nombres avec un nombre particulier de chiffres significatifs après la virgule décimale, cette précision sera préservée.",
                "$~\\Aléatoire(1,00 10,00)\\"
            ],
            "names": ["$~🎲", "$~Aléatoire"],
            "inputs": [
                {
                    "names": "$~min",
                    "doc": "$~La valeur minimale qui sera créée, ou si elle est supérieure à 0, la valeur maximale. Si @None est fourni, alors le minimum est \\0\\."
                },
                {
                    "names": "$~max",
                    "doc": "$~La valeur maximale qui sera créée, ou si elle est inférieure au minimum fourni, le minimum. Si @None est fourni, le maximum est \\1\\."
                }
            ]
        },
        "Choice": {
            "doc": [
                "$~/clic-tap !/",
                "$~/@FunctionDefinition ici, je vais expliquer celui-ci./",
                "$~Considérez @Choice comme un flux de @Phrase/nom sélectionné par votre public. Si quelqu'un clique, appuie ou sélectionne au clavier en appuyant sur /Entrée/ sur une @Phrase avec un nom, @Choice aura une nouvelle valeur correspondant au nom.",
                "$~La meilleure façon de l'utiliser est donc de créer une performance avec des phrases nommées sélectionnables @Phrase, puis d'utiliser une @Reaction pour décider quoi faire lorsque ce nom est choisi.",
                "$~Voici l’exemple le plus simple :",
                "$~\\Group(\nStack() \n[\nPhrase('un' sélectionnable :⊤ nom :'1') \nPhrase('deux' sélectionnable :⊤ nom :'2') \nPhrase(Choice())\n]\n)\\",
                "$~Copiez ceci dans l'éditeur, puis sélectionnez l'une des deux @Phrase. Vous verrez que la troisième @Phrase affiche le nom qui a été sélectionné."
            ],
            "names": ["$~🔘", "$~Choix"]
        },
        "Button": {
            "doc": [
                "$~/clic clic clic/",
                "$~/@FunctionDefinition ici, je vais expliquer celui-ci./",
                "$~@Button est un excellent moyen d'écouter de la musique avec une souris ou un pavé tactile. Bien sûr, une souris ou un pavé tactile ne sont pas un choix idéal pour écouter un public, car tout le monde ne peut pas en utiliser un. Le choix le plus accessible est @Choice.",
                "$~Mais si vous avez vraiment besoin d'écouter un bouton de souris, voici comment procéder. Cela fournira un flux de @Boolean, indiquant si le bouton principal est en haut \\⊥\\ ou en bas \\⊤\\.",
                "$~Voici un exemple simple :",
                "$~\\Phrase(Bouton() → '')\\",
                "$~Cela crée simplement une @Phrase qui est la valeur du flux sous forme de texte. Si vous la copiez dans l'éditeur et cliquez dessus, vous la verrez basculer entre \\⊥\\ et \\⊤\\."
            ],
            "names": ["$~🖱️", "$~Bouton"],
            "down": {
                "names": "$~verslebas",
                "doc": "$~Si @None, le flux fournira à la fois les valeurs ascendantes et descendantes. Si @Boolean, il fournira uniquement la valeur @Boolean donnée."
            }
        },
        "Pointer": {
            "doc": [
                "$~/whrrrrrr/",
                "$~/@FunctionDefinition ici, je vais expliquer celui-ci./",
                "$~Vous connaissez les souris, les pavés tactiles et les écrans tactiles ? Parfois, vous souhaitez savoir où pointe un public. C'est ce que propose @Pointer.",
                "$~Bien sûr, ce n'est pas un choix accessible : tout le monde ne peut pas voir ou pointer facilement, alors assurez-vous vraiment de ne pas exclure quelqu'un de la participation en utilisant ce flux.",
                "$~Si vous êtes sûr que personne n'est exclu, alors utiliser @Pointer est aussi simple que de créer un flux :",
                "$~\\Aiguille()\\",
                "$~Le @Place qu'il fournit correspondra à l'endroit où pointe le pointeur sur @Stage."
            ],
            "names": ["$~👆🏻", "$~Aiguille"]
        },
        "Key": {
            "doc": [
                "$~/clic/",
                "$~/@FunctionDefinition ici, je vais expliquer celui-ci./",
                "$~Les claviers ont beaucoup de touches, n'est-ce pas ? @Key vous indiquera sur quelle touche quelqu'un appuie et relâche.",
                "$~Essaye ça",
                "$~\\Clé()\\",
                "$~Vous voyez comment, lorsque vous appuyez sur une touche, elle apparaît sur @Stage ? Chaque fois qu'une touche est enfoncée, un nouveau @Text est ajouté au flux, décrivant la touche qui a été enfoncée.",
                "$~Pour une clé qui représente un caractère, la valeur sera le caractère sous la forme @Text.",
                "$~Pour les touches spéciales, comme la touche /Escape/, ce sera @Text qui décrira la touche, en utilisant un <nom prédéfini@https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values>, malheureusement disponible uniquement en anglais.",
                "$~Si vous souhaitez uniquement connaître une clé particulière, vous pouvez la fournir :",
                "$~\\Clé('a')\\",
                "$~Et si vous souhaitez seulement savoir quand une @Key est relâchée au lieu d'être enfoncée, vous pouvez fournir un @Boolean :",
                "$~\\Clé('a' ⊥)\\"
            ],
            "names": ["$~⌨️", "$~Clé"],
            "key": {
                "names": "$~clé",
                "doc": "$~Si @None, toutes les clés sont fournies. Si un @Text spécifique, seule cette clé est fournie."
            },
            "down": {
                "names": "$~verslebas",
                "doc": "$~SI @None, alors la touche enfoncée génère des entrées. Si \\⊤\\, alors seules les entrées vers le bas sont fournies, et si \\⊥\\, alors seules les entrées de relâchement sont fournies."
            }
        },
        "Time": {
            "doc": [
                "$~/tic tic tic/",
                "$~@FunctionDefinition ici, je vais expliquer @Time, puisqu'il ne parle pas.",
                "$~Le temps est un flux qui s’écoule à une certaine fréquence.",
                "$~À chaque fois, @Program réévalue avec la nouvelle valeur temporelle.",
                "$~Par exemple:",
                "$~\\Temps()\\",
                "$~Si vous attribuez à l'heure une @Time/fréquence, le temps de réponse sera calculé à cette fréquence. Par exemple :",
                "$~\\Heure(1000ms)\\",
                "$~Cependant, il y a des limites à sa taille, car @Program a besoin de temps pour évaluer avant de pouvoir répondre au prochain tick.",
                "$~Le plus petit est probablement d'environ \\20 ms\\."
            ],
            "names": ["$~🕕", "$~Temps"],
            "frequency": {
                "names": ["$~fréquence"],
                "doc": "$~Il s'agit de la fréquence à laquelle le temps doit s'écouler. La valeur par défaut est de \\33ms\\, soit environ 30 fois par seconde."
            },
            "relative": {
                "names": ["$~relatif"],
                "doc": "$~Si \\⊤\\, le temps démarre à 0, lorsque le programme est évalué pour la première fois. Sinon, il démarre au nombre de millisecondes depuis le début de la journée, UTC (Temps Universel Coordonné), ce qui vous permet de garder une trace de l'heure de la journée."
            }
        },
        "Volume": {
            "doc": [
                "$~/bzzzzzzzz/",
                "$~@FunctionDefinition ici, je vais prendre le micro.",
                "$~Ce flux est une série de volumes compris entre 0 et 1, échantillonnés à la fréquence de votre choix. Par défaut, la fréquence est de \\30hz\\, soit 30 fois par seconde, mais vous pouvez la modifier pour une fréquence moins élevée.",
                "$~\\Volume()\\",
                "$~C'est idéal pour écouter à quel point le public est bruyant !"
            ],
            "names": ["$~🎤", "$~Volume"],
            "frequency": {
                "names": ["$~fréquence"],
                "doc": "$~Le temps entre les échantillonnages."
            }
        },
        "Pitch": {
            "doc": [
                "$~/hummmmm/",
                "$~@FunctionDefinition ici, parlons pitch !",
                "$~Ce flux est une série de fréquences en hertz, indiquant la hauteur du son, échantillonnées à la fréquence de votre choix. Nous avons constaté que la voix humaine se situe entre 20 Hz et 5 000 Hz, donc prévoyez des chiffres dans cette plage.",
                "$~\\Pas()\\",
                "$~C'est idéal pour écouter le ton avec lequel quelqu'un parle ou chante."
            ],
            "names": ["$~🎵", "$~Pas"],
            "frequency": {
                "names": ["$~fréquence"],
                "doc": "$~Le temps entre les échantillonnages."
            }
        },
        "Camera": {
            "doc": [
                "$~/bzzzzzzzz/",
                "$~@FunctionDefinition ici, je peux expliquer @Camera !",
                "$~@Camera fournit donc une @List de @Color de votre monde. Cette liste représente essentiellement une image, mais c'est à vous de décider quoi en faire.",
                "$~Vous pourriez essayer de représenter l'image avec un tas de @Phrase, ce qui pourrait être plutôt cool ! Essayez de copier ceci...",
                "$~\\colors: Camera(32px 24px 33ms)\n\nStage(\ncolors.combine(\n[] \nƒ(phrases•[Phrase] row•[Color] y•#) \nphrases.append(\nrow.translate(\nƒ(color•Color x•#)\nPhrase('o' place: Place((x - 1) · 0,5 m y · -0,5 m) color: durée de la couleur: 0 s\n)\n)\n)\n)\n)\\",
                "$~Mais vous pourriez également analyser les couleurs pour décider si une lumière était allumée ou éteinte, ou si une couleur particulière était courante, permettant au public d'influencer une performance avec les couleurs qu'il affiche."
            ],
            "names": ["Cámara"],
            "width": {
                "names": ["$~largeur"],
                "doc": "$~Le nombre de @Color à échantillonner dans une ligne."
            },
            "height": {
                "names": ["$~hauteur"],
                "doc": "$~Le nombre de @Color à échantillonner dans une colonne."
            },
            "frequency": {
                "names": ["$~fréquence"],
                "doc": "$~Le temps entre les échantillons @Color."
            }
        },
        "Motion": {
            "names": "movimiento",
            "doc": [
                "$~/boing boing boing/",
                "$~/Salut ! Ici @FunctionDefinition. Que dirais-tu si j'expliquais @Motion ?",
                "$~En gros, @Motion est un flux de @Phrase. Vous lui donnez une @Phrase de départ, puis il l'affine avec un nouvel emplacement et une nouvelle rotation en fonction de la gravité.",
                "$~Cela vous permet de faire des choses très simples comme créer des emojis rebondissants :",
                "$~\\Motion(Phrase('o') startplace: Place(0m 10m))\\",
                "$~Vous voyez comment le o rebondit ? Lors de la première évaluation, nous lui donnons une place en haut de @Stage, mais ensuite, il obtient @None, ce qui permet à @Motion de le changer à la position que la gravité lui donnerait.",
                "$~Découvrez les nombreuses autres façons de le configurer ci-dessous."
            ],
            "place": {
                "doc": "$~Le point de départ.",
                "names": "$~lieu"
            },
            "velocity": {
                "doc": "$~La vitesse de départ",
                "names": "$~vitesse"
            },
            "nextplace": {
                "doc": "$~Le prochain endroit, la physique primordiale.",
                "names": "$~endroitsuivant"
            },
            "nextvelocity": {
                "doc": "$~L'endroit suivant, la vitesse primordiale.",
                "names": "$~prochainevitesse"
            }
        },
        "Scene": {
            "doc": [
                "$~/Boop boop boop/",
                "$~/Bonjour, @FunctionDefinition ici ! Je vois que vous avez trouvé @Scene.",
                "$~Je pense que @Scene est particulièrement cool. L'idée de base est de lui donner une liste de @Phrase ou @Group, puis il les affichera dans l'ordre et s'arrêtera sur le dernier.",
                "$~Pour contrôler le timing, vous pouvez soit définir la @Phrase/duration sur chaque sortie, et elle l'affichera pendant cette durée avant de passer à la suivante, et utiliser les transitions @Phrase/entering ou @Phrase/exiting que vous avez définies. Si vous les définissez sur une @Sequence, elle utilisera sa durée.",
                "$~Tout cela vous permet de faire des choses comme cette petite @Scene, qui montre ces trois phrases en séquence :",
                "$~\\Scene([\nPhrase('Bonjour' durée : 1 s)\nPhrase('Comment allez-vous ?' durée : 2 s rotation : 5° entrée : Pose(rotation : 0 °))\nPhrase('Je vais bien')\n])\\",
                "$~Voyez comment la première sortie est affichée pendant une seconde, puis la suivante pendant deux secondes, mais animée avec une rotation de cinq degrés, puis elle affiche la dernière ?",
                "$~Vous pouvez créer des séquences de sortie et d'animations très élaborées avec @Scene, et même rendre certaines parties de celles-ci dynamiques ou interactives, comme avec n'importe quelle autre @Phrase ou @Group.",
                "$~Si vous avez une sortie animée imbriquée (un @Group avec une @Phrase animée à l'intérieur), @Scene attendra que tout le contenu animé du @Group soit terminé.",
                "$~Oh, et un dernier petit secret ! Vous pouvez même mettre @Boolean dans la liste, et s'ils sont \\⊥\\, la @Scene s'arrêtera et attendra que cela devienne vrai.",
                "$~Par exemple, si vous souhaitez créer une séquence de @Phrase et avancer uniquement lorsque @Button change, vous pouvez procéder ainsi :",
                "$~\\click: ∆ Button()\nScene([\nPhrase('Bonjour')\nclick\nPhrase('Comment allez-vous ?' durée: 0,25 s rotation: 5° saisie: Pose(rotation: 0°))\nclick\nPhrase('Je vais bien')\n])\\",
                "$~Voyez-vous comment il fait une pause après chaque @Phrase et attend que @Button change avant d'avancer ?"
            ],
            "names": ["$~🎬", "$~Scène"],
            "outputs": {
                "names": "$~sorties",
                "doc": "$~La liste des sorties à afficher en séquence."
            }
        },
        "Chat": {
            "doc": [
                "$~/Salut ! Ici @FunctionDefinition. Alors tu veux discuter ?",
                "$~L'idée de base d'un flux de discussion est que le public tape un message, puis le programme y répond.",
                "$~Par exemple, ce programme simple vérifie si le message est « bonjour » et si c'est le cas, le programme évalue à « salut ». Sinon, il évalue à « hein » ?",
                "$~\\Chat().has('bonjour') ? 'salut!' 'hein?'\\",
                "$~Voilà ! Vous pouvez réaliser toutes sortes de performances avec cela, comme des chatbots, des aventures textuelles ou des schémas de contrôle textuels pour d'autres types de performances."
            ],
            "names": ["$~🗣️", "$~Chat"]
        },
        "Placement": {
            "doc": [
                "$~/Salut, @FunctionDefinition ici. Parlons de comment nous faire bouger !/",
                "$~Il existe donc de nombreuses façons de nous placer sur @Stage. Vous pouvez nous donner un @Place explicite. Vous pouvez utiliser @Motion et laisser la gravité faire son travail. Vous pouvez également nous placer dans un @Group et les laisser nous organiser d'une manière particulière.",
                "$~Mais parfois, vous souhaitez donner au /public/ le contrôle de l'endroit où nous nous trouvons sur @Stage. C'est à cela que sert @Placement.",
                "$~Voici comment cela fonctionne : il vous suffit de créer un @Placement et de le donner à notre @Place :",
                "$~\\Phrase('bonjour' place: Placement())\\",
                "$~Ensuite, chaque fois que le public utilise une touche fléchée ou clique ou appuie sur scène, le @Placement créera un nouveau @Place qui se déplace dans la direction souhaitée.",
                "$~Essayez de copier ceci dans votre programme et de nous déplacer avec les flèches avec le pointeur ou le clavier.",
                "$~Vous pouvez personnaliser le @Placement, en activant et en désactivant le mouvement sur certaines dimensions, en modifiant la distance de déplacement d'un @Place et le @Place initial avec lequel le flux démarre."
            ],
            "names": ["$~✥", "$~Placement"],
            "inputs": [
                {
                    "doc": "$~Le point de départ pour commencer.",
                    "names": "$~commencer"
                },
                {
                    "doc": "$~De combien de mètres le lieu doit-il se déplacer lorsque le public demande un déplacement.",
                    "names": "$~distance"
                },
                {
                    "doc": "$~Si cette option est vraie, elle autorise le mouvement sur l'axe horizontal. Activé par défaut.",
                    "names": "$~horizontal"
                },
                {
                    "doc": "$~Si cette option est vraie, elle permet le mouvement sur l'axe vertical. Activé par défaut.",
                    "names": "$~verticale"
                },
                {
                    "doc": "$~Si vrai, permet le mouvement sur l'axe z, avec les touches + et -.",
                    "names": "$~profondeur"
                }
            ]
        },
        "Webpage": {
            "doc": [
                "$~/Salut, @FunctionDefinition ici. Parlons de la façon d'obtenir des pages Web à partir d'Internet !/",
                "$~Lorsque nous avons entendu parler pour la première fois de votre Internet, nous avons trouvé cela fascinant. Un monde entier rempli d'ordinateurs connectés qui partagent des documents entre eux ? C'est incroyable !",
                "$~Nous avons donc créé un flux qui s'y connecte. Vous nous donnez une URL et nous y récupérons tout le texte. Comme ceci :",
                "$~\\Page Web('https://wordplay.dev')\\",
                "$~Et il y a apparemment cette chose appelée <CSS@https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/What_is_CSS>, qui vous permet d'interroger des éléments sur une page Web. Donnez-nous une requête de sélection CSS et nous n'obtiendrons que le texte qui correspond à cette requête. Comme cet exemple, qui obtient les en-têtes de niveau un.",
                "$~\\Page Web('https://wordplay.dev' 'h1')\\",
                "$~Beaucoup de choses peuvent mal se passer avec cette page. Si vous perdez votre connexion Internet, ou si l'URL ne renvoie rien, ou si l'URL n'est pas publique, ou si l'URL n'est pas une page HTML… Toutes ces situations peuvent entraîner une exception. Si vous trouvez une page qui fonctionne, vous obtiendrez un @Number indiquant un pourcentage d'achèvement, puis une @List des mots de la page."
            ],
            "names": ["$~🔗", "$~Pageweb"],
            "url": {
                "doc": "$~L'URL de la page Web HTML à obtenir.",
                "names": "$~URL"
            },
            "query": {
                "doc": "$~La requête CSS à évaluer sur le HTML",
                "names": "$~requête"
            },
            "frequency": {
                "doc": "$~Le nombre de minutes qui doivent s'écouler avant que la page ne soit à nouveau récupérée.",
                "names": "$~fréquence"
            },
            "error": {
                "invalid": "$~ce n'est pas une URL valide",
                "unvailable": "$~cette URL n'est pas accessible",
                "notHTML": "$~la réponse n'était pas HTML",
                "noConnection": "$~aucun lien avec Wordplay",
                "limit": "$~trop de requêtes sur ce domaine"
            }
        },
        "Collision": {
            "names": "$~Collision",
            "doc": [
                "$~/Salut ! @FunctionDefinition ici. Découvrez cette entrée intéressante./",
                "$~Cela peut vous aider à savoir quand @Output se croise ! C'est un excellent moyen de faire quelque chose lorsque nous nous croisons, autre que le rebond normal que @Output pourrait faire.",
                "$~Donnez-moi simplement un nom de @Output, et je créerai une nouvelle valeur @Rebound chaque fois qu'elle entrera en collision avec un autre nom. Un @Rebound contient des informations sur les noms qui sont entrés en collision et la direction de leur collision.",
                "$~Et si vous me donnez deux noms, je ne créerai une nouvelle valeur que lorsque les deux noms se rencontreront.",
                "$~Juste après avoir créé une nouvelle valeur, je vais créer un \\ø\\ puisque la collision est effectuée après qu'elle se soit produite. Cela indique qu'il n'y a plus de collision."
            ],
            "subject": {
                "names": "$~sujet",
                "doc": "$~Le nom du @Output sur lequel je dois rechercher les collisions."
            },
            "object": {
                "names": "$~autre",
                "doc": "$~Le nom de l’autre @Output sur lequel je devrais rechercher des collisions."
            }
        },
        "Rebound": {
            "names": "$~Rebond",
            "doc": "$~Je viens de @Collision et je représente la personne avec qui la collision s'est produite et dans quelle direction. Utilisez-moi pour décider de réagir à une collision d'une manière spéciale, autre que la physique normale.",
            "direction": {
                "names": "$~direction",
                "doc": "$~La direction et l'ampleur de la collision, par rapport à l'objet de la collision"
            },
            "subject": {
                "names": "$~sujet",
                "doc": "$~Le nom de la sortie qui a été touchée par le sujet."
            },
            "object": {
                "names": "$~objet",
                "doc": "$~Le nom de la sortie qui a touché le sujet"
            }
        },
        "Direction": {
            "names": "$~Direction",
            "doc": "$~Je suis une direction et une grandeur, le long des axes x et y.",
            "x": {
                "names": "$~x",
                "doc": "$~La direction et l’ampleur de la direction le long de l’axe des x."
            },
            "y": {
                "names": "$~et",
                "doc": "$~La direction et l’ampleur de la direction le long de l’axe des y."
            }
        }
    },
    "output": {
        "Output": {
            "names": "$~Sortir",
            "doc": [
                "$~Je ne suis pas une @StructureDefinition que vous pouvez réellement créer. Mais je suis une @StructureDefinition très importante, car j'inspire les éléments les plus importants de notre danse : @Phrase, @Group et @Stage.",
                "$~Allez les rencontrer pour en savoir plus sur leur utilisation."
            ]
        },
        "Stage": {
            "names": ["$~🎭", "$~Scène"],
            "doc": [
                "$~Salut. Je suis sur scène. Dis-moi quoi montrer et je te le montrerai.",
                "$~\\Étape([Phrase('stufffffff')])\\",
                "$~SI VOUS LE SOUHAITEZ, DONNEZ-MOI UN FOND EN COULEUR ET J'ÉCLAIRERAI LA SCÈNE EN CONSÉQUENCE.",
                "$~\\Stage([Phrase('stufffffff')] arrière-plan : Couleur(75% 50 100°)\\",
                "$~VOUS POUVEZ AUSSI ME DONNER UNE BORDURE DE CADRE ET JE RECADRERAI.",
                "$~\\Stage([Phrase('stufffffff')] arrière-plan : Couleur(75% 50 100°) cadre : Rectangle(-1m -1m 1m 1m))\\"
            ],
            "description": {
                "doc": [
                    "$~Une description à utiliser pour les membres du public qui ne peuvent pas voir la sortie visuelle."
                ],
                "names": "$~description"
            },
            "content": {
                "doc": "$~La liste des @Output à afficher sur scène.",
                "names": "$~contenu"
            },
            "frame": {
                "doc": "$~La forme et la taille du cadre à placer autour de la scène, cachant tout ce qui se trouve à l'extérieur.",
                "names": "$~cadre"
            },
            "size": {
                "doc": "$~J'AIME @Groupe/taille",
                "names": "$~taille"
            },
            "face": {
                "doc": "$~AIMEZ @Groupe/face",
                "names": "$~affronter"
            },
            "place": {
                "doc": "$~SI J'ÉTAIS UN APPAREIL PHOTO, C'EST LÀ QUE JE REGARDERAIS",
                "names": "$~lieu"
            },
            "name": {
                "doc": ["$~MÊME QUE @Phrase/nom !"],
                "names": "$~nom"
            },
            "selectable": {
                "doc": "$~MÊME QUE @Phrase/sélectionnable !",
                "names": "$~sélectionnable"
            },
            "color": {
                "doc": "$~MÊME QUE @Group/color",
                "names": "$~couleur"
            },
            "background": {
                "doc": "$~MÊME QUE @Group/background",
                "names": "$~arrière-plan"
            },
            "opacity": {
                "doc": "$~MÊME QUE @Group/opacity",
                "names": "$~opacité"
            },
            "offset": {
                "doc": "$~MÊME QUE @Group/offset",
                "names": "$~compenser"
            },
            "rotation": {
                "doc": "$~MÊME QUE @Group/rotation",
                "names": ["$~📐", "$~rotation"]
            },
            "scale": {
                "doc": "$~MÊME QUE @Group/scale",
                "names": "$~échelle"
            },
            "flipx": {
                "doc": "$~MÊME QUE @Group/flipx",
                "names": "$~flipx"
            },
            "flipy": {
                "doc": "$~MÊME QUE @Group/flipy",
                "names": "$~flippant"
            },
            "entering": {
                "doc": "$~MÊME QUE @Group/entrant",
                "names": "$~entrer"
            },
            "resting": {
                "doc": "$~MÊME QUE @Group/repos !",
                "names": "$~aurepos"
            },
            "moving": {
                "doc": "$~MÊME QUE @Group/moving!",
                "names": "$~mobile"
            },
            "exiting": {
                "doc": "$~MÊME QUE @Group/exiting!",
                "names": "$~sortant"
            },
            "duration": {
                "doc": "$~MÊME QUE @Phrase/durée !",
                "names": ["duración"]
            },
            "style": {
                "doc": "$~MÊME QUE @Phrase/style !",
                "names": "$~style"
            },
            "gravity": {
                "doc": "$~La gravité à appliquer à la sortie dont la place est dans @Motion.",
                "names": "$~pesanteur"
            },
            "defaultDescription": "$~étape $2[$2 |]de $1 sorties$3[avec trame $3|] $4"
        },
        "Group": {
            "names": ["$~🔳", "$~Groupe"],
            "doc": [
                "$~Oh bonjour, comment vas-tu ? Je vais toujours bien quand il y a d'autres personnes autour, donc c'est génial d'être avec toi !",
                "$~Je regroupe @Phrase et @Group sur @Stage et les place dans un @Arrangement, afin qu'il y ait un certain ordre dans lequel ils sont placés.",
                "$~Pour fonctionner, j'ai besoin que vous me donniez un @Arrangement, puis une @List de @Output à organiser.",
                "$~Par exemple, me voici avec un arrangement @Stack et quelques @Phrase à empiler verticalement :",
                "$~\\Groupe(Stack() [Phrase('premier') Phrase('deuxième')])\\",
                "$~La manière exacte dont j'organise les choses dépend de l'@Arrangement que vous me donnez."
            ],
            "description": {
                "doc": [
                    "$~Une description à utiliser pour les membres du public qui ne peuvent pas voir la sortie visuelle."
                ],
                "names": "$~description"
            },
            "content": {
                "doc": "$~La liste des @Output à organiser.",
                "names": "$~contenu"
            },
            "layout": {
                "doc": "$~L'arrangement à utiliser pour mettre @Output à leur place.",
                "names": "$~miseenpage"
            },
            "matter": {
                "doc": "$~Comment je devrais réagir si je devais heurter quelque chose d'autre avec de la matière.",
                "names": "$~matière"
            },
            "size": {
                "doc": "$~Quelle hauteur devrait avoir le merveilleux contenu en moi, à moins qu'il n'ait sa propre taille !",
                "names": "$~taille"
            },
            "face": {
                "doc": "$~Le nom du contenu de la police à l'intérieur de moi devrait avoir, à moins qu'ils n'aient leur propre police à utiliser.",
                "names": "$~affronter"
            },
            "place": {
                "doc": "$~L'endroit sur scène où je devrais être. Le contenu en moi sera disposé par rapport à cet endroit.",
                "names": "$~lieu"
            },
            "name": {
                "doc": ["$~Le même que @Phrase/nom !"],
                "names": "$~nom"
            },
            "selectable": {
                "doc": "$~Le même que @Phrase/selectable!",
                "names": "$~sélectionnable"
            },
            "color": {
                "doc": "$~La @Couleur que le contenu à l'intérieur de moi devrait être, à moins qu'il n'ait sa propre couleur.",
                "names": "$~couleur"
            },
            "background": {
                "doc": "$~Le @Color à projeter derrière moi.",
                "names": "$~arrière-plan"
            },
            "opacity": {
                "doc": "$~À quel point tout ce qui se trouve à l'intérieur de moi devrait être transparent, entre \\0\\ et \\1\\, à moins que cela ne soit remplacé par une @Pose différente.",
                "names": "$~opacité"
            },
            "offset": {
                "doc": "$~Un @Place indiquant à quel point il doit être décalé par rapport à mon @Place normal, à moins qu'il ne soit remplacé par un @Pose différent. Utile pour se tortiller sur place.",
                "names": "$~compenser"
            },
            "rotation": {
                "doc": "$~À quel point dois-je être incliné autour de mon centre, mon @Pose en a un différent.",
                "names": ["$~📐", "$~rotation"]
            },
            "scale": {
                "doc": "$~Quelle taille devrais-je avoir par rapport à ma taille d'origine.",
                "names": "$~échelle"
            },
            "flipx": {
                "doc": "$~Identique à @Phrase/flipx!",
                "names": "$~flipx"
            },
            "flipy": {
                "doc": "$~Identique à @Phrase/flipy",
                "names": "$~flippant"
            },
            "entering": {
                "doc": "$~Identique à @Phrase/entrant !",
                "names": "$~entrer"
            },
            "resting": {
                "doc": "$~Identique à @Phrase/resting!",
                "names": "$~aurepos"
            },
            "moving": {
                "doc": "$~Identique à @Phrase/moving!",
                "names": "$~mobile"
            },
            "exiting": {
                "doc": "$~Identique à @Phrase/exiting!",
                "names": "$~sortant"
            },
            "duration": {
                "doc": "$~Identique à @Phrase/durée !",
                "names": ["duración"]
            },
            "style": {
                "doc": "$~Identique à @Phrase/style !",
                "names": "$~style"
            },
            "defaultDescription": "$~1 $ [1 $ |] 2 $ 3 $"
        },
        "Phrase": {
            "names": ["$~💬", "$~Phrase"],
            "doc": [
                "$~Bonjour, bonjour ! Vous vous souvenez de moi ? Comment pourrait-on oublier /moi/. C'est vrai, je suis la magnifique @Phrase, prête à représenter le plus beau des @Text sur @Stage.",
                "$~Faites-moi simplement aimer ça et j'apparaîtrai sur @Stage :",
                "$~\\Phrase('magnifique!')\\",
                "$~J'ai besoin de @Text, évidemment, mais sinon, je peux faire tout ce qu'un @Output peut faire, y compris changer ma taille, ma police, ma rotation et faire toutes mes danses incroyables avec @Pose et @Sequence.",
                "$~Vous pouvez également me sélectionner sur @Stage et me modifier sur la palette voisine."
            ],
            "description": {
                "doc": [
                    "$~Une description personnalisée à utiliser pour les membres du public qui ne peuvent pas voir la sortie visuelle."
                ],
                "names": "$~description"
            },
            "text": {
                "doc": "$~Les personnages à afficher sur @Stage.",
                "names": "$~texte"
            },
            "size": {
                "doc": "$~Quelle taille je devrais mesurer, en mètres !",
                "names": "$~taille"
            },
            "face": {
                "doc": "$~Le nom de la police que je devrais mettre.",
                "names": "$~affronter"
            },
            "place": {
                "doc": "$~L'endroit sur scène où je devrais être.",
                "names": "$~lieu"
            },
            "wrap": {
                "doc": "$~Le bord auquel je dois envelopper les symboles ou \\ø\\ si je ne dois pas les envelopper.",
                "names": ["$~↵", "$~envelopper"]
            },
            "alignment": {
                "doc": "$~S'il existe une limite @Phrase/wrap définie, si je dois aligner les symboles sur le début, le centre ou la fin du bord.",
                "names": "$~alignement"
            },
            "direction": {
                "doc": "$~Si les symboles sont écrits horizontalement ou verticalement, et si vertical et @Phrase/wrap sont définis, si le texte s'enroule à gauche ou à droite.",
                "names": "$~direction"
            },
            "matter": {
                "doc": "$~Les propriétés à utiliser si je heurte des choses !",
                "names": "$~matière"
            },
            "aura": {
                "doc": "$~L'@Aura optionnelle à afficher derrière moi. Fais-moi briller !",
                "names": "$~aura"
            },
            "name": {
                "doc": [
                    "$~Un nom que tu me donnes ! Cela m'aidera pour beaucoup de choses.",
                    "$~Tout d’abord, si j’ai un nom, je l’utiliserai pour me décrire dans les descriptions des lecteurs d’écran.",
                    "$~Deuxièmement, lors de l'animation, vous pouvez avoir plusieurs expressions différentes qui sont censées représenter le même contenu sur scène ; donnez-leur le même nom et elles s'animeront comme une seule.",
                    "$~Enfin, je suis utile avec @Choice : les noms que vous me donnez apparaissent dans ce flux.",
                    "$~Vous pouvez me donner plusieurs noms différents, chacun dans une langue différente, si cela peut vous être utile. J'utiliserai toujours le nom dans la première langue sélectionnée."
                ],
                "names": "$~nom"
            },
            "selectable": {
                "doc": "$~Si \\⊤\\, indique que je peux être sélectionné via un pointeur ou un clavier.",
                "names": "$~sélectionnable"
            },
            "color": {
                "doc": "$~La @Color I devrait être par défaut, à moins qu'elle ne soit remplacée par une @Pose différente.",
                "names": "$~couleur"
            },
            "background": {
                "doc": "$~Le @Color à projeter derrière moi.",
                "names": "$~arrière-plan"
            },
            "opacity": {
                "doc": "$~Le degré de transparence que je dois avoir par défaut, entre \\0\\ et \\1\\, à moins qu'il ne soit remplacé par une @Pose différente. Utile pour les fondus entrants et sortants.",
                "names": "$~opacité"
            },
            "offset": {
                "doc": "$~Un @Place indiquant à quel point il doit être décalé par rapport à mon @Place, à moins qu'il ne soit remplacé par un @Pose différent. Utile pour se tortiller sur place.",
                "names": "$~compenser"
            },
            "rotation": {
                "doc": "$~La quantité en degrés que je dois faire pivoter autour de son centre, à moins qu'elle ne soit remplacée par une @Pose différente.",
                "names": "$~rotation"
            },
            "scale": {
                "doc": "$~À quel point je dois être agrandi par rapport à sa taille d'origine, à moins qu'il ne soit remplacé par une @Pose différente.",
                "names": "$~échelle"
            },
            "flipx": {
                "doc": "$~Si je dois être mis en miroir sur l'axe des x, à moins qu'il ne soit remplacé par une @Pose différente.",
                "names": "$~flipx"
            },
            "flipy": {
                "doc": "$~Si je dois être mis en miroir sur l'axe des Y, à moins qu'il ne soit remplacé par une @Pose différente.",
                "names": "$~flippant"
            },
            "entering": {
                "doc": "$~La @Pose ou @Sequence que je dois faire en entrant sur scène.",
                "names": "$~entrer"
            },
            "resting": {
                "doc": "$~La @Pose ou @Sequence que je dois faire après être entré sur scène, avant de sortir et pendant que mon @Place ne change pas. Si vous ne m'en donnez pas, j'utiliserai simplement mes valeurs par défaut.",
                "names": "$~aurepos"
            },
            "moving": {
                "doc": "$~La @Pose ou @Sequence que je devrais faire lorsque je me déplace sur scène, au lieu de mes valeurs par défaut.",
                "names": "$~mobile"
            },
            "exiting": {
                "doc": "$~La @Pose ou @Sequence à faire avant de quitter la scène.",
                "names": "$~sortant"
            },
            "duration": {
                "doc": "$~La durée à appliquer lors du déplacement vers un autre endroit sur scène.",
                "names": ["$~⏳", "$~durée"]
            },
            "style": {
                "doc": "$~Le style d'animation à utiliser lors du déplacement vers un autre endroit sur scène.",
                "names": "$~style"
            },
            "defaultDescription": "$~$3[$3 mètre |]phrase $1 $2[nommé $2|] $4[$4|] $5"
        },
        "Arrangement": {
            "names": ["Arrangement"],
            "doc": "$~Je suis une source d'inspiration pour de nombreux autres types d'arrangements dans le Verse, notamment @Row, @Stack, @Grid et @Free. Je travaille en étroite collaboration avec @Group pour"
        },
        "Row": {
            "names": ["Fila"],
            "doc": "$~Je suis @Row, un @Arrangement horizontal de @Output, avec un remplissage optionnel entre les deux. Avez-vous rencontré mon jumeau, @Stack ?",
            "description": "$~rangée de phrases et de groupes $1",
            "alignment": {
                "doc": "$~Aligner le texte au début, au centre ou à la fin de chaque colonne.",
                "names": "$~alignement"
            },
            "padding": {
                "doc": "$~La quantité de remplissage à placer entre les sorties.",
                "names": "$~rembourrage"
            }
        },
        "Stack": {
            "names": ["$~⬇", "$~Empiler"],
            "doc": "$~Je suis @Stack, un @Arrangement vertical de @Output, avec un remplissage optionnel entre les deux. Avez-vous rencontré mon jumeau, @Row ?",
            "description": "$~pile de phrases et de groupes à 1 $",
            "padding": {
                "doc": "$~La quantité de remplissage à placer entre les sorties.",
                "names": "$~rembourrage"
            },
            "alignment": {
                "doc": "$~Aligner le texte au début, au centre ou à la fin de chaque ligne.",
                "names": "$~alignement"
            }
        },
        "Grid": {
            "names": ["$~▦", "$~Grille"],
            "doc": "$~Je suis une grille de @Output. Donnez-moi un nombre de lignes et de colonnes et je ferai un arrangement ordonné avec un remplissage et des tailles de cellules facultatifs.",
            "description": "$~Grille à 1 ligne et 2 colonnes",
            "rows": {
                "doc": "$~Combien de lignes doivent être créées dans la grille ?",
                "names": "$~rangées"
            },
            "columns": {
                "doc": "$~Combien de colonnes créer dans la grille.",
                "names": "$~colonnes"
            },
            "padding": {
                "doc": "$~Quelle quantité de remplissage placer entre les cellules.",
                "names": "$~rembourrage"
            },
            "cellWidth": {
                "doc": "$~Quelle doit être la largeur des cellules.",
                "names": "$~largeurdecellule"
            },
            "cellHeight": {
                "doc": "$~Quelle doit être la hauteur des cellules.",
                "names": "$~rembourragecellulaire"
            }
        },
        "Free": {
            "names": ["$~Gratuit"],
            "doc": [
                "$~Je me dis, peu importe. Assieds-toi où tu veux. Assieds-toi quelque part ! Assure-toi que tous les @Output que tu me donnes ont un @Place, sinon ils ne sauront pas où aller.",
                "$~Oh, et n'oubliez pas que l'@Place que vous attribuez à chaque @Output est relatif à l'@Place du @Group ! Donc, si vous vous demandez pourquoi les éléments n'apparaissent pas là où vous l'attendez, essayez également d'attribuer un emplacement au @Group."
            ],
            "description": "$~sorties de forme libre $1"
        },
        "Shape": {
            "names": ["$~⬟", "$~Forme"],
            "doc": "$~Je suis une source d'inspiration pour toutes les formes. Je suis utile pour dire à @Stage quelle forme adopter.",
            "form": {
                "doc": "$~Je suis le genre de forme à montrer. Chaque forme nécessite des informations différentes pour définir son agencement.",
                "names": "$~formulaire"
            },
            "name": {
                "doc": "$~Je suis le nom que vous pouvez utiliser pour les animations et @Collision. Par exemple, si je représente le sol, vous pouvez m'appeler « sol ».",
                "names": "$~nom"
            },
            "selectable": {
                "doc": "$~Si je peux être sélectionné dans le cadre de @Choice.",
                "names": "$~sélectionnable"
            },
            "color": {
                "doc": "$~La couleur de mes frontières.",
                "names": "$~couleur"
            },
            "background": {
                "doc": "$~La couleur de mon arrière-plan.",
                "names": "$~arrière-plan"
            },
            "opacity": {
                "doc": "$~Comme je devrais être transparente.",
                "names": "$~opacité"
            },
            "offset": {
                "doc": "$~À quelle distance de mon lieu dois-je paraître, tout en restant en place.",
                "names": "$~compenser"
            },
            "rotation": {
                "doc": "$~À quel point je devrais être tourné. Cela affecte @Collision.",
                "names": "$~rotation"
            },
            "scale": {
                "doc": "$~À quel point je devrais être agrandi, sans changer ma taille réelle.",
                "names": "$~échelle"
            },
            "flipx": {
                "doc": "$~Faut-il me refléter sur mon axe des x ?",
                "names": "$~flipx"
            },
            "flipy": {
                "doc": "$~Faut-il me refléter sur mon axe Y ?",
                "names": "$~flippant"
            },
            "entering": {
                "doc": "$~La @Pose ou @Sequence que je dois faire en entrant dans @Stage.",
                "names": "$~entrer"
            },
            "resting": {
                "doc": "$~La @Pose ou @Sequence que je dois faire après être entré et pendant que je ne bouge pas.",
                "names": "$~aurepos"
            },
            "moving": {
                "doc": "$~La @Pose ou @Sequence que je devrais faire lorsque je me déplace.",
                "names": "$~mobile"
            },
            "exiting": {
                "doc": "$~La @Pose ou @Sequence que je dois faire en quittant @Stage.",
                "names": "$~sortant"
            },
            "duration": {
                "doc": "$~Combien de temps devraient prendre mes animations si elles constituent une seule @Pose.",
                "names": "$~durée"
            },
            "style": {
                "doc": "$~Le style d'animation que je devrais utiliser.",
                "names": "$~style"
            },
            "description": {
                "doc": [
                    "$~Une description à utiliser pour les membres du public qui ne peuvent pas voir la sortie visuelle."
                ],
                "names": "$~description"
            }
        },
        "Form": {
            "doc": "$~Je suis une forme abstraite, comme un @Rectangle ou un @Cercle.",
            "names": ["$~Formulaire"]
        },
        "Rectangle": {
            "names": ["$~Rectangle"],
            "doc": "$~Je suis un rectangle, utile pour faire en sorte que @Stage ait une limite de la taille de votre choix.",
            "left": {
                "doc": "$~Le bord gauche de la scène sur l'axe des x",
                "names": "$~gauche"
            },
            "top": {
                "doc": "$~Le bord supérieur de la scène sur l'axe des Y",
                "names": "$~haut"
            },
            "right": {
                "doc": "$~Le bord droit de la scène sur l'axe des x",
                "names": "$~droite"
            },
            "bottom": {
                "doc": "$~Le bord inférieur de la scène sur l'axe des Y",
                "names": "$~bas"
            },
            "z": {
                "doc": "$~La position de profondeur du rectangle.",
                "names": "$~j"
            }
        },
        "Circle": {
            "doc": "$~Je suis un cercle, utile pour créer des formes sur @Stage.",
            "names": ["$~Cercle"],
            "radius": {
                "doc": "$~Le rayon du cercle",
                "names": "$~rayon"
            },
            "x": {
                "doc": "$~Le centre horizontal du cercle.",
                "names": "$~x"
            },
            "y": {
                "doc": "$~Le centre vertical du cercle.",
                "names": "$~et"
            },
            "z": {
                "doc": "$~La position de profondeur du cercle.",
                "names": "$~j"
            }
        },
        "Polygon": {
            "doc": "$~Je suis un polygone « régulier » avec des côtés et des angles de longueur égale, utile pour créer des formes sur @Stage.",
            "names": ["$~Polygone"],
            "radius": {
                "doc": "$~Le rayon du polygone",
                "names": "$~rayon"
            },
            "sides": {
                "doc": "$~Le nombre de côtés du polygone",
                "names": "$~côtés"
            },
            "x": {
                "doc": "$~Le centre horizontal du polygone.",
                "names": "$~x"
            },
            "y": {
                "doc": "$~Le centre vertical du polygone.",
                "names": "$~et"
            },
            "z": {
                "doc": "$~La position de profondeur du polygone.",
                "names": "$~j"
            }
        },
        "Pose": {
            "names": ["$~🤪", "$~Pose"],
            "doc": [
                "$~Vous savez quand quelqu'un adopte la position la plus étonnante, s'arrête et tout le monde regarde ? C'est moi. Je capture une pose pour @Output et je suis la pierre angulaire de ses mouvements.",
                "$~Il y a tellement de choses qui entrent en jeu dans une pose. Jetez un œil à mes nombreuses contributions pour voir quels types de poses vous pourriez adopter !"
            ],
            "style": {
                "doc": "$~Le style d'animation à utiliser lors du passage à cette pose.",
                "names": "$~style"
            },
            "color": {
                "doc": "$~La @Color a @Output doit être dans cette pose, au lieu de sa valeur par défaut.",
                "names": "$~couleur"
            },
            "opacity": {
                "doc": "$~La transparence d'une @Output doit être comprise entre \\0\\ et \\1\\, au lieu de sa valeur par défaut. Utile pour les fondus entrants et sortants.",
                "names": "$~opacité"
            },
            "offset": {
                "doc": "$~Un @Place indiquant à quel point il doit être décalé par rapport à l'emplacement d'un @Output, au lieu de sa valeur par défaut. Utile pour bouger sur place.",
                "names": "$~compenser"
            },
            "rotation": {
                "doc": "$~La rotation que doit subir un @Output, au lieu de sa valeur par défaut.",
                "names": "$~rotation"
            },
            "scale": {
                "doc": "$~L'agrandissement que doit avoir un @Output par rapport à sa taille d'origine, au lieu de sa valeur par défaut.",
                "names": "$~échelle"
            },
            "flipx": {
                "doc": "$~Si une @Output doit être mise en miroir sur l'axe des x, au lieu de sa valeur par défaut.",
                "names": "$~flipx"
            },
            "flipy": {
                "doc": "$~Si une @Output doit être mise en miroir sur l'axe des Y, au lieu de sa valeur par défaut.",
                "names": "$~flippant"
            },
            "description": "$~$1[transparent $1|] $2[pivoté $2 degrés|] $3[mis à l'échelle $3|] $4[retourné horizontalement|] $5[retourné verticalement|] $6[ombre floue $6 pixels]"
        },
        "Color": {
            "names": ["$~🌈", "$~Couleur"],
            "doc": [
                "$~Je suis une couleur visible, composée de trois dimensions essentielles.",
                "$~Voici quelques couleurs courantes autour du cercle chromatique, à luminosité moyenne et chroma élevé :",
                "$~\\Couleur(50% 100 0°)\\",
                "$~\\Couleur(50% 100 30°)\\",
                "$~\\Couleur(50% 100 60°)\\",
                "$~\\Couleur(50% 100 90°)\\",
                "$~\\Couleur(50% 100 120°)\\",
                "$~\\Couleur(50% 100 150°)\\",
                "$~\\Couleur(50% 100 180°)\\",
                "$~\\Couleur(50% 100 210°)\\",
                "$~\\Couleur(50% 100 240°)\\",
                "$~\\Couleur(50% 100 270°)\\",
                "$~\\Couleur(50% 100 300°)\\",
                "$~\\Couleur(50% 100 330°)\\"
            ],
            "lightness": {
                "doc": "$~Comme je devrais être clair de \\0\\ à \\1\\, du noir à \\0\\, au gris à \\0,5\\, au blanc à \\1\\.",
                "names": ["luminosidad"]
            },
            "chroma": {
                "doc": "$~Quelle quantité de couleur dois-je avoir, de \\0\\ à \\∞\\. Aucune couleur signifie gris, des nombres plus élevés signifient plus de couleur.",
                "names": ["croma"]
            },
            "hue": {
                "doc": "$~De quelle couleur devrais-je être, sur un cercle chromatique, allant du méga \\0\\, rouge \\30\\, vert \\120\\, au bleu \\270\\.",
                "names": ["matiz"]
            }
        },
        "Sequence": {
            "names": ["$~💃", "$~Séquence"],
            "doc": [
                "$~Oh. Mon. Dieu. Directeur, vous êtes magnifique aujourd'hui ! Vous voulez danser avec moi ? C'est facile.",
                "$~Il vous suffit de me donner une @Map, où chaque clé représente le pourcentage d'avancement de la danse, et chaque valeur de ces clés est une @Pose à suivre.",
                "$~Il existe de nombreuses manières différentes d'animer avec cela ! Par exemple, en voici une simple :",
                "$~\\Phrase('hi' au repos:Séquence({0%: Pose(rotation: 360°) 100%: Pose(rotation: 0°)})\\",
                "$~Cela dit, /au début (0%), commencez à une inclinaison de 360 et terminez à une inclinaison de 0/. Cela nous fera tourner en rond pour toujours, puisque je suis défini comme la pose de repos de @Phrase !",
                "$~Essayez vos propres danses créatives en jouant avec d’autres apports."
            ],
            "poses": {
                "doc": "$~Une @Map de pourcentages entre 0% et 100%, chacun associé à une @Pose. Vous n'êtes pas obligé de fournir tous les pourcentages ; je déplacerai en douceur une @Output entre ceux que vous me donnez.",
                "names": "$~poses"
            },
            "duration": {
                "doc": "$~Combien de temps dois-je faire cette danse ? Si je dois la répéter, je n'ajouterai pas de temps à la durée, je danserai juste plus vite.",
                "names": ["$~⏳", "$~durée"]
            },
            "style": {
                "doc": "$~Le style que je dois utiliser pour la danse.",
                "names": "$~style"
            },
            "count": {
                "doc": "$~Combien de fois la séquence doit-elle se répéter avant d'être terminée. C'est vraiment utile lorsque j'entre sur scène, que je me déplace sur scène ou que je sors de scène, mais lorsqu'il s'agit d'une séquence de repos, c'est ignoré, car je peux me reposer indéfiniment.",
                "names": "$~compter"
            }
        },
        "Place": {
            "names": ["Posición"],
            "doc": "$~Je suis un emplacement sur @Stage. Toutes mes entrées sont facultatives, car je suis au centre par défaut.",
            "x": {
                "doc": "$~Une position sur l'axe des x.",
                "names": "$~x"
            },
            "y": {
                "doc": "$~Une position sur l'axe des y",
                "names": "$~et"
            },
            "z": {
                "doc": "$~Une position sur l'axe z",
                "names": "$~j"
            },
            "rotation": {
                "doc": "$~Rotation à ce poste",
                "names": ["$~📐", "$~rotation"]
            }
        },
        "Velocity": {
            "doc": "$~Je suis un emplacement sur @Stage. Toutes mes entrées sont facultatives, car je suis au centre par défaut.",
            "names": ["$~💨", "$~Vitesse"],
            "x": {
                "doc": "$~Combien de mètres parcourir chaque seconde sur l'axe des x.",
                "names": "$~x"
            },
            "y": {
                "doc": "$~Combien de mètres parcourir chaque seconde sur l'axe des y.",
                "names": "$~et"
            },
            "angle": {
                "doc": "$~De combien de degrés faire une rotation chaque seconde",
                "names": ["$~angle", "$~°"]
            }
        },
        "Matter": {
            "doc": "$~Je suis les propriétés physiques de la sortie, qui influencent la façon dont j'interagis avec les autres sorties sur scène.",
            "names": ["$~⚛️", "$~Matière"],
            "mass": {
                "doc": "$~Un poids, en kilogrammes",
                "names": "$~masse"
            },
            "bounciness": {
                "doc": "$~Quelle quantité d'énergie dois-je conserver en cas de collision ? 0 signifie rien, 1 signifie toute.",
                "names": "$~rebondissement"
            },
            "friction": {
                "doc": "$~Combien de temps faut-il continuer à glisser ; 0 signifie aucun, 1 signifie pour toujours.",
                "names": "$~friction"
            },
            "roundedness": {
                "doc": "$~Dans quelle mesure arrondir les coins de la sortie ; 0 signifie aucun et 1 signifie 100 % de sa taille, ce qui rend les tailles circulaires.",
                "names": "$~rondeur"
            },
            "text": {
                "doc": "$~Si cela peut entrer en collision avec d'autres sorties.",
                "names": "$~texte"
            },
            "shapes": {
                "doc": "$~S'il peut entrer en collision avec d'autres formes.",
                "names": "$~sol"
            }
        },
        "Aura": {
            "doc": [
                "$~Je suis une AURA. Je fais briller @Phrase ! J'aime ça :",
                "$~\\Phrase(\n'Je BRILLE !' \naura: Aura(Couleur(50% 100 118°) 0,1 m 0 m 0,1 m\n)\\"
            ],
            "names": ["$~🔮", "$~Aura"],
            "color": {
                "doc": "$~La @Color que l'@Aura devrait être.",
                "names": "$~couleur"
            },
            "blur": {
                "doc": "$~À quel point l'@Aura devrait être floue. \\0m\\ signifie pas du tout flou.",
                "names": "$~sebrouiller"
            },
            "offsetX": {
                "doc": "$~À quelle distance à gauche ou à droite je dois apparaître. \\0m\\ est directement en dessous.",
                "names": "$~décalageX"
            },
            "offsetY": {
                "doc": "$~À quelle distance dois-je apparaître en haut ou en bas.\\0m\\ est directement en dessous.",
                "names": "$~décalageY"
            }
        },
        "Easing": {
            "straight": "$~droit",
            "cautious": "$~prudent",
            "pokey": "$~taule",
            "zippy": "$~rapide"
        },
        "sequence": {
            "sway": {
                "doc": "$~Je crée une @Sequence qui oscille d'avant en arrière autour du centre d'une @Output.",
                "names": ["vaivén"],
                "angle": {
                    "doc": "$~Dans quelle mesure s'incliner dans le balancement.",
                    "names": ["ángulo"]
                }
            },
            "bounce": {
                "doc": "$~Je crée une @Sequence qui rebondit @Output à une hauteur donnée.",
                "names": ["rebotar"],
                "height": {
                    "doc": "$~À quelle hauteur rebondir.",
                    "names": ["altura"]
                }
            },
            "spin": {
                "doc": "$~Je crée une @Sequence qui fait tourner @Output autour de son centre.",
                "names": ["girar"]
            },
            "fadein": {
                "doc": "$~Je crée une @Sequence qui fait passer @Output de l'invisible au visible.",
                "names": ["$~fondu"]
            },
            "fadeout": {
                "doc": "$~Je crée une @Sequence qui fait passer @Output de visible à invisible. Essayez-moi dans une @Sequence excitante !",
                "names": ["$~fondu"]
            },
            "popup": {
                "doc": "$~Je crée une @Sequence qui fait que @Output s'adapte plus rapidement que de se réduire à sa taille normale.",
                "names": ["surgir"]
            },
            "shake": {
                "doc": "$~Je crée une @Sequence qui donne l'impression qu'une @Output a peur.",
                "names": ["agitar"]
            }
        },
        "Source": {
            "names": "$~Source",
            "doc": [
                "$~Vous savez comment les projets peuvent avoir plus d'un fichier @Source ? Je vous laisse créer un @Source basé sur la logique de votre projet. C'est vraiment utile si vous souhaitez sauvegarder certaines données entre différentes évaluations de votre projet.",
                "$~Par exemple, imaginez que vous vouliez créer un compteur simple qui compte d'une unité à chaque fois que vous appuyez sur un bouton de la souris. Vous pourriez l'utiliser pour vous souvenir du nombre de fois que vous avez fait quelque chose.",
                "$~\\↓ compter\n[\nPhrase(`\\count\\ fois!`)\nSource('count' compter … ∆ Bouton() … compter + 1 )\n]\\",
                "$~Essayez de le copier, en créant une nouvelle @Source appelée /count/ et en tapant 0 dedans, pour démarrer le décompte à 0. Ce petit projet récupérera la valeur dans la source /count/ et chaque fois que le bouton de la souris est enfoncé, éditera la @Source /count/ avec pour valeur /count/ actuelle plus /1/."
            ],
            "name": {
                "names": "$~nom",
                "doc": "$~Le nom du fichier source à créer ou à mettre à jour."
            },
            "value": {
                "names": "$~valeur",
                "doc": "$~La valeur de données avec laquelle le fichier source doit être créé ou mis à jour."
            },
            "DynamicEditLimitException": {
                "description": "$~limite d'édition de source dynamique",
                "explanation": "$~Ce projet a enregistré des données dans les fichiers @Source trop de fois et trop rapidement. Assurez-vous qu'il ne met à jour @Source qu'en réponse à une entrée, et pas trop rapidement."
            },
            "ReadOnlyEditException": {
                "description": "$~modifier la source en lecture seule",
                "explanation": "$~Ce projet mémorise les données, mais vous n'avez pas le droit de les modifier. Copiez-le si vous voulez l'essayer."
            },
            "EmptySourceNameException": {
                "description": "$~nom de source vide",
                "explanation": "$~La @Source donnée avait un nom vide, nous n'avons donc pas pu la sauvegarder."
            },
            "ProjectSizeLimitException": {
                "description": "$~limite de taille du projet",
                "explanation": "$~Ce projet contient trop de texte, nous ne pouvons donc pas le sauvegarder."
            }
        }
    },
    "ui": {
        "font": {
            "app": "Noto Sans",
            "code": "Noto Sans Mono"
        },
        "phrases": {
            "welcome": "$~Bonjour"
        },
        "widget": {
            "confirm": {
                "cancel": "$~Annuler"
            },
            "dialog": {
                "close": "$~fermer"
            },
            "loading": {
                "message": "$~Chargement des polices et du texte, merci de patienter !"
            },
            "home": "$~aller à la page d'accueil",
            "table": {
                "cell": {
                    "description": "$~modifier cette cellule",
                    "placeholder": "$~valeur"
                },
                "addcolumn": "$~ajouter une colonne avant cette colonne",
                "removecolumn": "$~supprimer cette colonne"
            }
        },
        "tile": {
            "toggle": {
                "fullscreen": {
                    "on": "$~quitter le plein écran",
                    "off": "$~étendre en plein écran"
                },
                "show": {
                    "on": "$~cacher",
                    "off": "$~montrer"
                }
            },
            "label": {
                "output": "$~scène",
                "palette": "$~palette",
                "docs": "$~guide",
                "source": "$~source",
                "collaborate": "$~collaborer"
            },
            "button": {
                "collapse": "$~réduire la fenêtre"
            }
        },
        "project": {
            "error": {
                "unknown": "$~Ce projet n'existe pas ou n'est pas public.",
                "translate": "$~Il y a eu un problème lors de la traduction de votre projet.",
                "tile": "$~Oups, il y a eu une erreur.",
                "reset": "$~Tenter de réinitialiser..."
            },
            "button": {
                "removeCollaborator": "$~supprimer un collaborateur",
                "copy": "$~copier le projet dans le presse-papiers sous forme de texte",
                "addSource": "$~créer une nouvelle $source",
                "duplicate": "$~copier ce projet",
                "revert": "$~revenir au code d'origine",
                "focusOutput": "$~clavier de mise au point sur la scène",
                "focusSource": "$~se concentrer sur la source suivante",
                "focusDocs": "$~se concentrer sur la documentation",
                "focusPalette": "$~se concentrer sur la palette",
                "focusCycle": "$~se concentrer sur la tuile suivante",
                "unsaved": "$~afficher l'erreur de sauvegarde",
                "translate": "$~modifier les langues de ce projet et le traduire dans d'autres langues.",
                "primary": "$~définir comme lieu principal de ce projet",
                "share": {
                    "tip": "$~afficher les options de partage de projet",
                    "label": "$~partager"
                },
                "history": {
                    "on": "$~afficher le code du projet récent",
                    "redo": "$~afficher le code du projet actuel"
                }
            },
            "field": {
                "name": {
                    "description": "$~modifier le nom du projet",
                    "placeholder": "$~nom"
                }
            },
            "help": "$~afficher les raccourcis clavier",
            "collapsed": "$~Toutes vos fenêtres sont fermées ! Vous pouvez les retrouver dans la barre d'outils ci-dessous",
            "save": {
                "projectsNotSavedLocally": "$~Un problème est survenu lors de l'enregistrement des projets dans votre navigateur.",
                "projectsCannotNotSaveLocally": "$~Votre navigateur ne prend pas en charge l'enregistrement de projets.",
                "projectContainedPII": "$~Pour protéger votre vie privée, aucun projet contenant des informations potentiellement identifiables n'a été enregistré en ligne. Vérifiez le projet pour voir si les informations permettent de vous identifier.",
                "projectsNotLoadingOnline": "$~Impossible de charger les projets en ligne.",
                "projectNotSavedOnline": "$~Impossible de sauvegarder les projets en ligne.",
                "settingsUnsaved": "$~Impossible d'enregistrer les paramètres en ligne."
            },
            "dialog": {
                "unsaved": "$~Travail non enregistré...",
                "translate": {
                    "header": "$~Langues",
                    "explanation": [
                        "$~Voici les langues que votre projet utilise.",
                        "$~Pour essayer de traduire votre projet dans d’autres langues, choisissez une langue source principale, puis choisissez une nouvelle langue.",
                        "$~/Toutes les langues ne sont pas prises en charge et les traductions seront imparfaites, alors vérifiez les résultats !/"
                    ]
                }
            },
            "subheader": {
                "source": "$~Source",
                "destination": "$~Destination"
            }
        },
        "gallery": {
            "untitled": "$~Sans titre",
            "undescribed": "$~Aucune description",
            "subheader": {
                "curators": {
                    "header": "$~Conservateurs",
                    "explanation": "$~Créateurs qui gèrent cette galerie."
                },
                "creators": {
                    "header": "$~Créateurs",
                    "explanation": "$~Créateurs qui contribuent à cette galerie."
                },
                "delete": {
                    "header": "$~Supprimer",
                    "explanation": "$~La suppression de cette galerie ne supprimera pas ses projets. La galerie sera supprimée définitivement."
                },
                "classes": {
                    "header": "$~Cours",
                    "explanation": "$~Classes associées à cette galerie."
                }
            },
            "confirm": {
                "delete": {
                    "description": "$~supprimer la galerie",
                    "prompt": "$~supprimer"
                },
                "remove": {
                    "description": "$~supprimer le projet de la galerie",
                    "prompt": "$~retirer"
                }
            },
            "error": {
                "unknown": "$~Cette galerie n'existe pas ou n'est pas publique."
            },
            "field": {
                "name": {
                    "description": "$~Nom de la galerie",
                    "placeholder": "$~nom"
                },
                "description": {
                    "description": "$~Description de la galerie",
                    "placeholder": "$~Décrivez votre galerie. Quel est son thème, ses objectifs ou sa communauté ?"
                }
            }
        },
        "source": {
            "label": "$~éditeur de programme",
            "empty": [
                "$~C'est parti ! Vous pouvez…",
                "$~• Ouvrez 📕 et faites-nous glisser 🖱️ vers ce programme.",
                "$~• Tapez $1 et choisissez-nous dans le menu.",
                "$~• Tapez-nous avec le ⌨️.",
                "$~• Parcourez les <galleries@://galleries> pour trouver l'inspiration.",
                "$~Si vous êtes bloqué, <learn more@://learn>."
            ],
            "overwritten": "$~J'ai reçu une version plus récente !",
            "confirm": {
                "delete": {
                    "description": "$~supprimer cette $source",
                    "prompt": "$~supprimer"
                }
            },
            "toggle": {
                "blocks": {
                    "on": "$~modifier en tant que texte",
                    "off": "$~éditer en blocs"
                },
                "glyphs": {
                    "on": "$~réduire les glyphes correspondants",
                    "off": "$~développer les glyphes correspondants"
                }
            },
            "button": {
                "selectOutput": "$~montrer cette sortie sur scène",
                "expandSequence": "$~développer ce code réduit"
            },
            "field": {
                "name": {
                    "description": "$~modifier le nom de la source",
                    "placeholder": "$~nom"
                }
            },
            "menu": {
                "label": "$~menu de saisie semi-automatique",
                "show": "$~afficher le menu de saisie semi-automatique",
                "back": "$~quitter le sous-menu"
            },
            "cursor": {
                "priorLine": "$~déplacer le curseur sur la ligne avant",
                "nextLine": "$~déplacer le curseur sur la ligne après",
                "priorInline": "$~déplacer le curseur à la position avant",
                "nextInline": "$~déplacer le curseur à la position après",
                "lineStart": "$~déplacer le curseur au début de la ligne",
                "lineEnd": "$~déplacer le curseur à la fin de la ligne",
                "sourceStart": "$~déplacer le curseur au début de la source",
                "sourceEnd": "$~déplacer le curseur à la fin de la source",
                "priorNode": "$~sélectionner le voisin avant",
                "nextNode": "$~sélectionner le voisin après",
                "parent": "$~sélectionner le conteneur",
                "selectAll": "$~sélectionner le programme",
                "incrementLiteral": "$~augmenter le nombre, le texte ou le booléen",
                "decrementLiteral": "$~diminuer le nombre, le texte ou le booléen",
                "insertSymbol": "$~insérer 1 $",
                "insertTab": "$~insérer un onglet",
                "insertTrue": "$~insérer vrai",
                "insertFalse": "$~insérer faux",
                "insertNone": "$~insérer le symbole \"aucun\"",
                "insertNotEqual": "$~insérer pas égal",
                "insertProduct": "$~insérer le symbole du produit",
                "insertQuotient": "$~insérer le symbole du quotient",
                "insertDegree": "$~insérer le symbole du degré",
                "insertFunction": "$~fonction d'insertion",
                "insertLessOrEqual": "$~insérer inférieur ou égal à",
                "insertGreaterOrEqual": "$~insérer supérieur ou égal à",
                "insertStream": "$~insérer le symbole de flux",
                "insertChange": "$~insérer le symbole de changement",
                "insertConvert": "$~insérer le symbole de conversion",
                "insertPrevious": "$~insérer le symbole précédent",
                "insertType": "$~insérer le symbole de type",
                "insertTable": "$~insérer un symbole d'ouverture de table",
                "insertTableClose": "$~insérer un symbole de fermeture de tableau",
                "insertBorrow": "$~insérer emprunter",
                "insertShare": "$~insérer partager",
                "insertLine": "$~insérer un saut de ligne",
                "backspace": "$~supprimer la sélection ou le symbole précédent",
                "delete": "$~supprimer la sélection ou le symbole suivant",
                "cut": "$~sélection de coupe",
                "copy": "$~sélection de copie",
                "paste": "$~coller le contenu du clavier",
                "parenthesize": "$~sélection entre parenthèses",
                "enumerate": "$~énumérer la sélection",
                "type": "$~taper des caractères",
                "undo": "$~annuler la modification précédente",
                "redo": "$~refaire annulé modifier",
                "search": "$~rechercher des caractères spéciaux à insérer",
                "tidy": "$~espacement ordonné",
                "elide": "$~basculer l'élision",
                "insertDocs": "$~insérer le symbole d'explication"
            }
        },
        "annotations": {
            "label": "$~conflits et aide",
            "cursor": "$~Il s'agit de *$1*$2[ et ils sont de type $2|]. $3[ Ils sont à l'intérieur d'un *$3*.|]",
            "cursorParent": "$~Ils sont à l'intérieur d'un *$1*$2[ de type $2|].",
            "learn": "$~/Apprendre encore plus/",
            "evaluating": "$~Oh c'est amusant, évaluons !",
            "space": "$~C'est l'espace ! Qui aurait cru que rien ne pouvait en dire autant ?",
            "button": {
                "resolution": "$~Résoudre ce conflit"
            }
        },
        "output": {
            "label": "$~sortie du programme",
            "toggle": {
                "grid": {
                    "on": "$~masquer les lignes de la grille",
                    "off": "$~afficher les lignes de la grille"
                },
                "fit": {
                    "on": "$~contrôler le zoom manuellement",
                    "off": "$~Ajuster le zoom au contenu"
                },
                "paint": {
                    "on": "$~rendement de peinture",
                    "off": "$~placer la sortie"
                }
            },
            "field": {
                "key": {
                    "description": "$~écouter les touches appuyées",
                    "placeholder": "$~message"
                }
            },
            "button": {
                "submit": "$~soumettre ce message de discussion"
            },
            "options": {
                "locale": "$~choisir la langue de sortie"
            }
        },
        "timeline": {
            "label": "$~chronologie",
            "slider": "$~curseur temporel",
            "button": {
                "play": "$~évaluer le programme jusqu'au bout, en répondant aux entrées en temps réel",
                "pause": "$~mettre le programme en pause, permettant d'avancer et de reculer",
                "backStep": "$~reculer d'un pas",
                "backNode": "$~étape vers l'évaluation précédente du curseur",
                "backInput": "$~retour d'une entrée",
                "out": "$~sortir de cette fonction",
                "forwardStep": "$~faire un pas en avant",
                "forwardNode": "$~étape vers l'évaluation suivante du curseur",
                "forwardInput": "$~avancer vers le flux d'entrée suivant",
                "present": "$~jusqu'à la fin",
                "start": "$~Au début",
                "reset": "$~redémarrer les performances"
            }
        },
        "docs": {
            "label": "$~navigateur de documentation",
            "link": "$~afficher le concept $1 dans la documentation",
            "learn": "$~apprendre encore plus …",
            "nodoc": "$~Qui suis-je ? Que suis-je ? Quel est mon but ?",
            "button": {
                "home": "$~retour à la maison",
                "back": "$~retour au précédent"
            },
            "field": {
                "search": "$~rechercher des concepts avec des mots"
            },
            "header": {
                "inputs": "$~Entrées",
                "interfaces": "$~Interfaces",
                "properties": "$~Propriétés",
                "functions": "$~Fonctions",
                "conversions": "$~Conversions"
            }
        },
        "dialog": {
            "share": {
                "header": "$~Partage",
                "explanation": "$~Contrôlez qui peut modifier et voir ce projet.",
                "subheader": {
                    "gallery": {
                        "header": "$~Galerie",
                        "explanation": "$~Ajoutez ce projet dans une galerie aux côtés d'autres créateurs ou créez une galerie sur votre page <projects@://projects>. Si vous ajoutez un projet à une galerie publique, votre projet deviendra public."
                    },
                    "public": {
                        "header": "$~Public/Privé",
                        "explanation": "$~Les projets publics et les galeries peuvent être vus par n'importe qui dans le monde. Notre objectif est que ce contenu apporte affirmation et joie, et le partage public est un moyen d'y parvenir. Mais cela signifie également suivre certaines règles. Vous promettez que votre projet ne :"
                    },
                    "pii": {
                        "header": "$~Renseignements personnels",
                        "explanation": "$~Le partage public d'informations personnelles identifiables (PII) peut mettre les créateurs en danger. C'est pourquoi nous détectons les PII possibles et avertissons les créateurs de supprimer les données sensibles ou de les marquer comme non sensibles.\n\nVous trouverez ci-dessous une liste des PII possibles de ce projet que vous avez marqués comme non sensibles. Vous pouvez cliquer sur le bouton à côté pour le marquer à nouveau comme sensible, mais cela signifie que votre projet ne sera plus enregistré en ligne."
                    }
                },
                "field": {
                    "emailOrUsername": {
                        "placeholder": "$~email ou nom d'utilisateur",
                        "description": "$~e-mail ou nom d'utilisateur de la personne à qui vous souhaitez donner l'accès en modification"
                    }
                },
                "mode": {
                    "public": {
                        "label": "$~visibilité",
                        "modes": ["$~privé", "$~publique"]
                    }
                },
                "error": {
                    "unknown": "$~Nous ne connaissons pas de créateur avec cet email.",
                    "anonymous": "$~Vous devez être connecté pour partager."
                },
                "button": {
                    "submit": "$~Partager le projet avec cette adresse email",
                    "sensitive": {
                        "tip": "$~Marquer à nouveau ce texte comme sensible",
                        "label": "$~sensible"
                    }
                },
                "options": {
                    "gallery": "$~sélecteur de galerie"
                }
            },
            "settings": {
                "header": "$~Paramètres",
                "explanation": "$~Modifiez les paramètres de mise en page, de l'appareil et du thème.",
                "button": {
                    "show": "$~Afficher la boîte de dialogue des paramètres"
                },
                "mode": {
                    "layout": {
                        "label": "$~mise en page",
                        "modes": [
                            "$~automatique",
                            "$~horizontal",
                            "$~verticale",
                            "$~gratuit"
                        ]
                    },
                    "animate": {
                        "label": "$~animations",
                        "modes": [
                            "$~animations désactivées",
                            "$~vitesse normale",
                            "$~demi-vitesse",
                            "$~troisième vitesse",
                            "$~quart de vitesse"
                        ]
                    },
                    "dark": {
                        "label": "$~thème",
                        "modes": [
                            "$~couleurs claires",
                            "$~couleurs sombres",
                            "$~utiliser les paramètres de l'appareil"
                        ]
                    },
                    "space": {
                        "label": "$~indicateur d'espace",
                        "modes": [
                            "$~afficher explicitement les indicateurs d'espace et d'onglet",
                            "$~ne pas afficher les indicateurs d'espace et de tabulation"
                        ]
                    },
                    "writing": {
                        "label": "$~mise en page de l'écriture",
                        "modes": [
                            "$~horizontal, de gauche à droite",
                            "$~vertical, de droite à gauche",
                            "$~vertical, de gauche à droite"
                        ]
                    },
                    "localized": {
                        "label": "$~localisation de code",
                        "modes": [
                            "$~ne pas localiser le code",
                            "$~localiser le code lorsqu'il est disponible",
                            "$~localiser le code mais privilégier les symboles"
                        ]
                    },
                    "lines": {
                        "label": "$~numéros de ligne",
                        "modes": [
                            "$~afficher les numéros de ligne en mode texte",
                            "$~ne pas afficher les numéros de ligne en mode texte"
                        ]
                    }
                },
                "options": {
                    "mic": "$~microphone sélectionné",
                    "camera": "$~caméra sélectionnée",
                    "face": "$~police de caractère"
                }
            },
            "locale": {
                "header": "$~Langue",
                "explanation": "$~Choisissez vos langues et régions.",
                "subheader": {
                    "selected": "$~Choisi",
                    "supported": "$~Disponible",
                    "coming": "$~À venir",
                    "help": "$~Aidez-nous à traduire…"
                },
                "button": {
                    "show": "$~changer de lieu",
                    "add": "$~ajouter ce lieu",
                    "remove": "$~supprimer ce paramètre régional",
                    "replace": "$~remplacer par ces paramètres régionaux"
                }
            },
            "help": {
                "header": "$~Raccourcis",
                "explanation": "$~Utilisez ces commandes clavier pour une édition plus efficace.",
                "subheader": {
                    "moveCursor": "$~Se déplacer",
                    "editCode": "$~Modifier",
                    "insertCode": "$~Insérer",
                    "debug": "$~Déboguer"
                }
            }
        },
        "palette": {
            "label": "$~palette",
            "labels": {
                "mixed": "$~mixte",
                "computed": "$~calculé",
                "default": "$~défaut",
                "inherited": "$~hérité",
                "notSequence": "$~pas une séquence",
                "notContent": "$~pas une liste de contenu",
                "format": "$~format",
                "weight": "$~poids",
                "light": "$~lumière",
                "normal": "$~normale",
                "bold": "$~audacieux",
                "extra": "$~supplémentaire",
                "italic": "$~italique",
                "underline": "$~souligner"
            },
            "button": {
                "revert": "$~revenir à la valeur par défaut",
                "set": "$~modifier cette propriété",
                "addPhrase": "$~ajouter une phrase après cela",
                "addGroup": "$~ajouter un groupe après cela",
                "addShape": "$~ajouter une forme après cela",
                "addMotion": "$~définir l'emplacement du flux de mouvement",
                "addPlacement": "$~définir la place du flux de placement",
                "remove": "$~supprimer ce contenu",
                "up": "$~déplacer ce contenu vers le haut",
                "down": "$~déplacer ce contenu vers le bas",
                "edit": "$~modifier ce contenu",
                "sequence": "$~convertir en séquence",
                "createPhrase": "$~créer une phrase, affichant la valeur existante sous forme de texte",
                "createGroup": "$~créer un groupe en enveloppant n'importe quelle phrase existante",
                "createStage": "$~créer une scène, en enveloppant n'importe quel groupe ou phrase existant"
            },
            "prompt": {
                "offerPhrase": "$~Quelle belle valeur tu as faite ! Dois-je la montrer sur @Stage ?",
                "offerGroup": "$~Quelle merveilleuse @Phrase tu as créée. Veux-tu les rassembler dans un @Groupe, pour les organiser ?",
                "offerStage": "$~TRÈS BIEN @Program. AJOUTEZ-MOI POUR CONTRÔLER L'ÉCLAIRAGE. LES COULEURS. LES CADRES.",
                "pauseToEdit": "$~Si vous aimez la scène, vous pouvez sélectionner un 💬, 🔳 ou 🎭 à modifier !",
                "editing": "$~Modifiez-moi !"
            },
            "field": {
                "coordinate": "$~modifier les coordonnées",
                "text": "$~modifier le texte"
            },
            "sequence": {
                "button": {
                    "add": "$~ajouter une pose",
                    "remove": "$~supprimer la pose",
                    "up": "$~déplacer la pose vers le haut",
                    "down": "$~déplacer la pose vers le bas"
                },
                "field": {
                    "percent": "$~modifier le pourcentage"
                }
            }
        },
        "save": {
            "saving": "$~économie",
            "saved": "$~enregistré en ligne",
            "local": "$~enregistré dans le navigateur",
            "unsaved": "$~non enregistré"
        },
        "page": {
            "unknown": {
                "header": "$~Ouais !",
                "message": "$~Où est cet endroit ? On peut rentrer à la maison ?"
            },
            "landing": {
                "value": "$~Créez des histoires interactives avec des mots, des symboles, des émojis et du code avec nous !",
                "description": [
                    "$~Wordplay est un langage de programmation qui vous permet de :",
                    "$~• Animez des mots et des émojis de manière ludique 🤪",
                    "$~• Utilisez le temps 🕦, le son 🎤, les sites Web 🔗 et la physique 🌎",
                    "$~• Partagez 🤝 avec des amis, des groupes ou n'importe qui",
                    "$~• Codez dans n'importe quelle langue du monde 🌐",
                    "$~• Modifiez avec la souris 🖱️, le tactile 👆 et le clavier ⌨️",
                    "$~• Déboguer vers l'avant ⏩ et vers l'arrière ⏪",
                    "$~• Afficher avec des écrans 🖥️ et des lecteurs d'écran 🔊",
                    "$~Gratuit pour toujours auprès de <University of Washington@https://ischool.uw.edu/>."
                ],
                "beta": [
                    "$~Wordplay est en version bêta, il est donc possible qu'il ne fonctionne pas comme prévu ou qu'il ne soit pas complet. Signalez les bugs et partagez vos idées sur <GitHub@https://github.com/wordplaydev/wordplay/issues>, consultez nos <plans 1.0@https://github.com/wordplaydev/wordplay/milestones/1.0> et <contribute@https://github.com/wordplaydev/wordplay/wiki/contribute>."
                ],
                "link": {
                    "about": "$~Pourquoi cet endroit existe-t-il ?",
                    "learn": "$~Apprenez la langue avec un casting de personnages dramatiques",
                    "guide": "$~Rechercher et parcourir la référence linguistique",
                    "projects": "$~Créer et partager des performances",
                    "galleries": "$~Vivez les performances des autres",
                    "rights": "$~Responsabilités, les nôtres et les vôtres",
                    "community": {
                        "label": "$~Communauté",
                        "subtitle": "$~Discutez avec nous sur Discord."
                    },
                    "contribute": {
                        "label": "$~Contribuer",
                        "subtitle": "$~Aidez-nous à créer Wordplay."
                    },
                    "teach": "$~Gérer les classes d'étudiants et leurs projets"
                }
            },
            "learn": {
                "header": "$~Apprendre",
                "error": "$~Nous n'avons pas pu trouver de tutoriel pour cette langue.",
                "button": {
                    "next": "$~prochaine pause dans le dialogue",
                    "previous": "$~pause précédente dans le dialogue"
                },
                "options": {
                    "lesson": "$~leçon actuelle"
                }
            },
            "guide": {
                "header": "$~Guide",
                "description": "$~Il s'agit d'une référence pour chaque partie du langage de programmation Wordplay. Recherchez un concept ou parcourez la liste pour en savoir plus."
            },
            "projects": {
                "header": "$~Projets",
                "projectprompt": "$~Vous êtes prêt à dire quelque chose ? Créez un projet ou travaillez sur un projet. Si vous êtes bloqué, continuez à <learning@://learn>.",
                "archiveheader": "$~Archivé",
                "archiveprompt": "$~Il s'agit des projets que vous avez archivés. Seuls les propriétaires peuvent les supprimer ou les désarchiver définitivement. Les projets archivés seront définitivement supprimés 30 jours après leur dernière modification.",
                "galleriesheader": "$~Galeries",
                "galleryprompt": "$~Créez et organisez des galeries pour partager une collection de projets avec d’autres.",
                "add": {
                    "header": "$~Nouveau projet",
                    "explanation": "$~Choisissez un modèle pour créer un nouveau projet."
                },
                "button": {
                    "newproject": "$~nouveau projet",
                    "editproject": "$~modifier ce projet",
                    "viewcode": "$~voir le code de ce projet",
                    "newgallery": "$~nouvelle galerie",
                    "unarchive": "$~désarchiver ce projet"
                },
                "confirm": {
                    "archive": {
                        "description": "$~archiver cette performance",
                        "prompt": "$~archive"
                    },
                    "delete": {
                        "description": "$~supprimer définitivement cette performance",
                        "prompt": "$~supprimer pour toujours"
                    }
                },
                "error": {
                    "noaccess": "$~Nous n'avons pas pu accéder à Internet.",
                    "nogalleryedits": "$~Vous devez être connecté pour créer et modifier des galeries.",
                    "newgallery": "$~Nous n'avons pas pu créer une nouvelle galerie.",
                    "nodeletes": "$~Vous devez être connecté pour supprimer les projets archivés.",
                    "delete": "$~Oups, nous n'avons pas pu supprimer le projet !"
                }
            },
            "galleries": {
                "header": "$~Galeries",
                "prompt": "$~Ce sont des performances que d'autres ont réalisées. Expérimentez-les, étudiez-les ou adaptez-les à votre propre déclaration.",
                "examples": "ejemplos"
            },
            "about": {
                "header": "$~À propos",
                "content": [
                    "$~Avez-vous déjà eu l’impression que le codage était réservé aux occidentaux anglophones, non handicapés et ayant grandi avec des ordinateurs ?",
                    "$~Ouais, nous aussi.",
                    "$~Ce n’est pas un hasard. Depuis l’aube de l’informatique, les langages de programmation ont été conçus et développés par le même groupe de personnes – principalement des hommes blancs, cisgenres et anglophones travaillant dans le milieu universitaire et industriel aux États-Unis et en Europe, ainsi que quelques mathématiciennes incroyables. Ils ont fait leur travail à une époque postcoloniale où le pouvoir était au pouvoir du vainqueur, et les langages de programmation ont été un outil essentiel pour garantir ce pouvoir.",
                    "$~Cette histoire a donné naissance à une vision du calcul qui est avant tout axée sur la vitesse, la logique, le profit et la domination.",
                    "$~C’est une injustice. Car l’informatique, pour le meilleur et pour le pire, sous-tend désormais la vie quotidienne de manière visible et invisible, et les personnes qui ont accès à l’informatique sont celles qui ressemblent le plus à ses créateurs. Le reste de l’humanité reste tributaire de ce pouvoir, car imaginer quelque chose de différent nécessite de savoir lire et écrire, ce qui est entravé par les barrières linguistiques, les barrières d’accessibilité, les barrières économiques et les inégalités dans l’éducation publique.",
                    "$~*Wordplay* aspire à changer cela. C'est une plateforme de programmation conçue pour être mondiale, prenant en charge /toutes/ les langues du monde, mais aussi pour être /sur/ les langues du monde. Une plateforme sur laquelle chacun peut créer, avec les capacités dont il dispose, pour partager du contenu interactif que tout le monde peut découvrir. Pour les jeunes et les jeunes adultes qui veulent s'exprimer à travers des mots interactifs, des émojis et de la typographie, de manière ludique et artistique. Non pas dans le but d'obtenir du pouvoir pour eux-mêmes, mais pour créer un monde informatique qui reconnaît la force et la nécessité incroyables de nos belles différences.",
                    "$~Nous sommes une communauté de designers, d'éducateurs et de développeurs qui tentent de donner vie à cette vision. Nous sommes des personnes de couleur, nous sommes trans, nous sommes queer, nous sommes handicapés, nous sommes des immigrants, nous sommes des réfugiés. Nous sommes basés à l'<University of Washington@https://washington.edu> <Information School@https://ischool.uw.edu/> à Seattle, Washington, États-Unis, un lieu qui aspire à accueillir tout le monde et à réparer les ravages racistes et capacitistes du colonialisme qui perdurent aujourd'hui. La création de ce langage de programmation et de cette plateforme n'est qu'une petite partie de cette mission, offrant un aperçu d'un avenir de l'informatique où tout le monde a sa place.",
                    "$~Nous aimerions avoir votre aide. Apprenez à <contribuer@https://github.com/wordplaydev/wordplay/wiki/contribute>, à <faire un don@://faire un don> ou à suivre nos <progrès@https://github.com/amyjko/wordplay/milestones>. Écrivez à notre organisatrice communautaire <Amy@https://amyjko.phd> si vous avez des questions."
                ]
            },
            "login": {
                "header": "$~Se connecter",
                "anonymous": "$~se connecter",
                "prompt": {
                    "forgot": "$~*Mot de passe oublié ?* Malheureusement, nous ne pouvons pas récupérer votre compte car nous ne collectons pas d'informations de contact.",
                    "email": "$~Avez-vous un compte de messagerie uniquement ? Connectez-vous en soumettant votre adresse e-mail et, si un compte y est associé, nous vous enverrons un e-mail avec un lien de connexion. Les nouveaux comptes de messagerie uniquement ne sont pas pris en charge, afin de préserver la confidentialité.",
                    "enter": "$~Il semble que votre lien de connexion provienne d'un autre navigateur ou appareil. Pouvez-vous saisir à nouveau votre adresse e-mail, juste pour être sûr qu'il s'agit bien de vous ?",
                    "tooyoung": "$~Vous devez avoir 13 ans ou plus pour vous connecter avec une adresse e-mail.",
                    "passwordrule": "$~Les mots de passe doivent comporter au moins 10 caractères ; si vous n'utilisez pas de gestionnaire de mots de passe, choisissez trois longs mots dont vous vous souviendrez.",
                    "passwordreminder": "$~Il semble que vous n'ayez pas encore de compte. Saisissez à nouveau votre mot de passe et assurez-vous de l'avoir enregistré de manière sûre et correcte, car il n'est pas récupérable.",
                    "play": "$~Vous êtes connecté, nous pouvons enregistrer vos projets en ligne maintenant ! Vous voulez créer quelque chose ?",
                    "changeEmail": "$~Vous souhaitez modifier votre adresse e-mail ? Soumettez-en une nouvelle et nous vous enverrons une confirmation à l'ancienne.",
                    "changePassword": "$~Vous souhaitez modifier votre mot de passe ? Soumettez-en un nouveau et répétez-le.",
                    "logout": "$~Vous utilisez un appareil partagé et souhaitez garder vos projets privés ? Déconnectez-vous et nous *supprimerons vos projets* de cet appareil, mais ils seront enregistrés en ligne.",
                    "sent": "$~Si cet e-mail est associé à un compte, vous recevrez un e-mail avec un lien de connexion. Il peut prendre quelques minutes pour apparaître. Si aucun compte n'est associé à cet e-mail, vous ne recevrez rien.",
                    "success": "$~Compte créé !",
                    "confirm": "$~Vérifiez votre ancienne adresse e-mail pour confirmer votre nouvelle adresse.",
                    "delete": "$~Vous voulez que nous oubliions tout ce que vous avez fait ici ? C'est irréversible.",
                    "reallyDelete": "$~Êtes-vous sûr ? Votre compte et vos paramètres seront immédiatement supprimés et vos projets seront programmés pour suppression. Les collaborateurs de vos projets perdront immédiatement l'accès à ces derniers. Saisissez votre adresse e-mail ou votre nom d'utilisateur pour confirmer que c'est bien ce que vous souhaitez.",
                    "name": "$~Choisissezunemojipourvousreprésenterauprèsdesautres.",
                    "login": "$~Connectez-vous pour sauvegarder vos projets, collaborer et partager :",
                    "join": "$~Ou, <créez un compte@://join> pour commencer."
                },
                "error": {
                    "expired": "$~Ce lien a expiré.",
                    "invalid": "$~Ce lien n'est pas valide.",
                    "email": "$~Cet email n'était pas valide.",
                    "offline": "$~Nous n'avons pas pu atteindre le nuage ☁️.",
                    "failure": "$~Impossible de se connecter :(",
                    "unchanged": "$~Nous n'avons pas pu changer votre adresse e-mail, mais nous ne savons pas pourquoi.",
                    "delete": "$~Nous n'avons pas pu supprimer votre compte, mais nous ne savons pas pourquoi.",
                    "wrongPassword": "$~Nom d'utilisateur et mot de passe non valides. Soit votre mot de passe est erroné, soit quelqu'un d'autre possède ce nom d'utilisateur.",
                    "tooMany": "$~Vous avez essayé de vous connecter à plusieurs reprises sans succès. Vous devrez attendre avant de réessayer."
                },
                "feedback": {
                    "changing": "$~Envoi d'un nouvel e-mail...",
                    "deleting": "$~Ok, suppression de vos projets et paramètres...",
                    "updatedPassword": "$~Votre mot de passe est mis à jour.",
                    "match": "$~Cela doit correspondre au nom d'utilisateur de votre compte."
                },
                "field": {
                    "email": {
                        "description": "$~modifier l'e-mail de connexion",
                        "placeholder": "$~e-mail"
                    },
                    "username": {
                        "description": "$~nom d'utilisateur de connexion, n'utilisez pas d'informations personnelles identifiables",
                        "placeholder": "$~nom d'utilisateur"
                    },
                    "password": {
                        "description": "$~mot de passe de connexion, au moins 10 caractères",
                        "placeholder": "$~mot de passe"
                    },
                    "currentPassword": {
                        "description": "$~votre mot de passe de connexion actuel",
                        "placeholder": "$~mot de passe actuel"
                    },
                    "newPassword": {
                        "description": "$~votre nouveau mot de passe",
                        "placeholder": "$~nouveau mot de passe"
                    }
                },
                "button": {
                    "logout": {
                        "tip": "$~déconnectez-vous de votre compte",
                        "label": "$~déconnexion"
                    },
                    "login": "$~connectez-vous avec cet email, en envoyant un lien de connexion",
                    "updateEmail": "$~change ton email",
                    "updatePassword": "$~soumettre un nouveau mot de passe",
                    "delete": {
                        "tip": "$~supprimer votre compte",
                        "label": "$~supprimer mes données…"
                    },
                    "reallyDelete": {
                        "tip": "$~supprimer votre compte pour toujours",
                        "label": "$~supprime le !!!"
                    }
                },
                "toggle": {
                    "reveal": {
                        "on": "$~Afficher le mot de passe",
                        "off": "$~Masquer le mot de passe"
                    }
                },
                "subtitle": "$~Enregistrez, collaborez et partagez"
            },
            "join": {
                "header": "$~Rejoindre",
                "prompt": {
                    "create": "$~Créez un compte pour enregistrer vos projets, collaborer avec d'autres et partager votre travail.",
                    "username": "$~Les noms d'utilisateur doivent comporter au moins /5 caractères/, ne peuvent pas être une adresse e-mail et ne doivent pas contenir votre nom ou d'autres informations d'identification.",
                    "password": "$~Les mots de passe doivent comporter au moins /10 caractères/. Tapez-les deux fois et notez-les dans un endroit sûr, comme un gestionnaire de mots de passe. *Il n'y a aucun moyen de récupérer votre compte* si vous le perdez, car nous ne collectons pas d'informations de contact."
                }
            },
            "rights": {
                "header": "$~Droits",
                "content": [
                    "$~Salut!",
                    "$~Établissons quelques attentes concernant vos droits et les nôtres (également à la lumière des politiques, telles que la <COPPA@https://www.ecfr.gov/current/title-16/chapter-I/subchapter-C/part-312> et la <GDPR@https://gdpr.eu/compliance-checklist-us-companies/>).",
                    "$~La première chose à savoir est que nous ne sommes pas une entité commerciale. Nous sommes un projet de recherche communautaire hébergé dans une université à but non lucratif. Notre objectif est de créer une plateforme qui vous apporte de la joie et nous aide à faire des découvertes sur un monde informatique plus équitable et plus juste. Nous n'avons aucun intérêt à gagner de l'argent sur cette plateforme ; tout l'argent que nous collectons (généralement grâce à un financement public) est utilisé pour soutenir la plateforme, et non pour enrichir quiconque y travaille (ou y contribue).",
                    "$~Comme nous ne recherchons pas de profit, cela signifie également que nous ne pouvons faire aucune promesse quant à la fiabilité, la disponibilité ou la longévité de cette plateforme. Cela dit, <Amy@https://amyjko.phd> s'engage à la maintenir à long terme et, en tant que professeur titulaire, elle bénéficie d'un emploi assez stable.",
                    "$~Cela nous amène aux *données*. Voici ce que nous collectons et stockons dans le cloud :",
                    "$~• Vos *projets*. Nous stockons tous les projets auxquels vous contribuez ainsi que les modifications que vous y apportez, à moins que ces projets ne semblent contenir des informations personnelles identifiables telles que des numéros de téléphone, des adresses e-mail, des noms d'utilisateur, des identifiants fiscaux ou des adresses.",
                    "$~• Vos *paramètres*. Cela inclut les langues que vous choisissez, vos préférences d'animation et la progression de votre didacticiel. Tout le reste est stocké uniquement sur votre appareil.",
                    "$~• *Activité* globale. Nous suivons les connexions et les pages que vous visitez, mais pas d'une manière qui permet de vous identifier, de vous suivre sur le site ou de vous suivre sur d'autres sites. Nous utilisons Google Analytics en mode « consentement refusé », qui ne collecte que des informations minimales non identifiables sur les pages consultées, sans stocker de cookies ni envoyer d'informations d'adresse IP à Google. Nous utilisons ces informations globales pour nous aider à lever des fonds en signalant l'utilisation de la plateforme.",
                    "$~Nous ne stockons rien d'autre. Notre <source@https://github.com/amyjko/wordplay/tree/main/src> est public, donc tout le monde peut le vérifier et signaler tout suivi involontaire.",
                    "$~*Vous* êtes propriétaire de vos données, pas nous. Cela signifie :",
                    "$~• Vous contrôlez qui peut accéder à vos projets. Ils sont privés par défaut, mais vous pouvez les partager avec des personnes, des groupes ou les rendre entièrement publics.",
                    "$~• Vous pouvez supprimer complètement n’importe quel projet ou votre propre compte à tout moment.",
                    "$~• Vous pouvez obtenir une exportation de n’importe quel projet ou de l’ensemble de votre compte à tout moment.",
                    "$~Voici comment nous utiliserons et n'utiliserons pas vos données :",
                    "$~• Nous ne partagerons vos données avec personne, sauf si la loi l'exige explicitement. Il est toujours possible que vos données soient récupérées sans notre autorisation (une « violation de données »). Si nous découvrons que cela s'est produit, nous vous en informerons en utilisant l'adresse e-mail que vous avez partagée avec nous.",
                    "$~• Nous ne vous contacterons pas via votre adresse e-mail, sauf si 1) vous effectuez un changement de compte qui nous oblige à le faire, 2) vous nous donnez explicitement votre consentement pour vous contacter, ou 3) dans le cas d'une violation de données ci-dessus.",
                    "$~• Nous pouvons analyser les projets sur la plateforme pour comprendre ce que chacun fait et comment il le fait. Nous pouvons partager ces informations agrégées et anonymisées dans des publications universitaires. Nous ne le ferons que sous la supervision d'un comité d'examen institutionnel, comme l'exige la loi fédérale américaine.",
                    "$~Enfin, une remarque sur la parole. Vous pouvez dire tout ce que vous voulez sur cette plateforme en *privé*. Les projets sont privés par défaut, et si vous les partagez avec des adresses e-mail spécifiques, ils sont toujours considérés comme privés. Nous ne modérerons rien dans les projets privés.",
                    "$~Mais rendre un projet *public*, ou l'inclure dans une galerie publique, est un privilège. Il s'agit d'une plateforme faite pour l'amour, l'affirmation, le respect et la dignité. Par conséquent, nous nous attendons à ce qu'aucun de vos contenus *publics* :"
                ],
                "consequences": [
                    "$~Si nous trouvons un projet ou une galerie qui enfreint ces règles, nous avertirons les créateurs avant qu'ils ne le consultent ou nous bloquerons sa consultation. Si vous enfreignez ces règles de manière répétée, vous perdrez le privilège de publier publiquement."
                ]
            },
            "donate": {
                "header": "$~Faire un don",
                "prompt": "$~Aidez-nous à payer la bande passante et à rémunérer les étudiants et les enseignants contributeurs.",
                "content": [
                    "$~Wordplay est un projet communautaire gratuit soutenu par l'<University of Washington@https://washington.edu>. Nous comptons sur les dons de personnes qui croient en notre mission de créer des langages de programmation accessibles, inclusifs et éducatifs.",
                    "$~Voici nos coûts actuels :",
                    "$~• Nous rémunérons les étudiants de l'Université de Washington, en particulier ceux qui sont handicapés ou dont la langue maternelle n'est pas l'anglais, pour faire évoluer et maintenir le projet. Cela représente environ 90 % de nos coûts.",
                    "$~• Nous accordons des bourses aux enseignants avec lesquels nous collaborons pour développer des programmes multilingues et accessibles.",
                    "$~• Nous payons Google pour la bande passante et le stockage de <Firebase@https://firebase.google.com/> et pour les services <Workspace@https://workspace.google.com/>.",
                    "$~• Nous payons <Squarespace@https://www.squarespace.com/> annuellement pour le domaine.",
                    "$~Nos coûts actuels, en supposant 5 étudiants de premier cycle à 20 USD/heure, 10 heures/semaine pendant l'année universitaire (36 semaines) et 2 étudiants de premier cycle pendant l'été (12 semaines), plus les services cloud, sont d'environ 60 000 USD par an.",
                    "$~Si 2 400 personnes donnaient 25 $ US par an, cela couvrirait nos coûts actuels, et tout excédent servirait à rémunérer davantage d’étudiants et d’enseignants.",
                    "$~Pouvez-vous faire partie de ces 2 400 personnes ? Si c'est le cas, voici notre lien vers le don à l'Université de Washington :"
                ]
            },
            "teach": {
                "header": "$~Enseigner",
                "prompt": {
                    "none": "$~Bienvenue professeur ! Créez une classe pour configurer et gérer les comptes étudiants et les galeries de projets.",
                    "some": "$~Bienvenue professeur ! Gérez vos cours ou créez-en un nouveau."
                },
                "error": {
                    "offline": "$~Nous ne sommes pas en mesure de vérifier votre statut d'enseignant.",
                    "login": "$~Vous devez être connecté pour gérer les cours.",
                    "teacher": "$~Vous devez disposer des privilèges d'enseignant pour créer et gérer des classes. Remplissez ce formulaire et faisons connaissance !"
                },
                "link": {
                    "request": "$~Demander des privilèges d'enseignant",
                    "new": "$~Créer une classe"
                }
            },
            "newclass": {
                "header": "$~Nouvelle classe",
                "subheader": {
                    "class": "$~Votre classe",
                    "students": "$~Vos étudiants",
                    "credentials": "$~Noms d'utilisateur et mots de passe",
                    "submit": "$~Soumettre"
                },
                "prompt": {
                    "start": "$~Créer une classe avec des comptes générés pour tous les élèves de votre classe et vous permettre de créer des galeries auxquelles tous vos élèves peuvent ajouter des projets. Si les élèves ont déjà des comptes, vous pouvez les ajouter ultérieurement.",
                    "review": "$~Vérifiez les noms d'utilisateur et les mots de passe que nous avons créés. Voulez-vous les *modifier* avant de continuer ? Si vous le faites, vous ne pourrez pas modifier les informations sur les étudiants ci-dessus.",
                    "ready": "$~Faites-nous savoir quand vous serez prêt à générer vos identifiants ci-dessus. Vous pourrez les modifier après l'avoir fait.",
                    "pending": "$~Génération de noms d'utilisateur et de mots de passe...",
                    "submit": "$~Prêt à soumettre votre demande ? Dès que votre demande sera acceptée, vous recevrez un téléchargement de ces informations. Les mots de passe ne sont pas récupérables, alors conservez-les dans un endroit sûr.",
                    "submitting": "$~Demande de nouveaux comptes avec les noms d'utilisateur et mots de passe ci-dessus...",
                    "download": "$~Votre cours est prêt ! Vous devriez voir un téléchargement des données de vos élèves dans votre dossier de téléchargement. *Les mots de passe ne sont pas récupérables*, alors conservez ce fichier dans un endroit sûr !"
                },
                "field": {
                    "name": {
                        "description": "$~nom de la classe",
                        "placeholder": "$~un nom court"
                    },
                    "description": {
                        "description": "$~description",
                        "placeholder": "$~une description de votre classe, pour vous et vos élèves."
                    },
                    "existing": {
                        "label": "$~étudiants avec comptes",
                        "prompt": "$~Certains de vos élèves possèdent-ils déjà un compte Wordplay ? Ajoutez-les ici."
                    },
                    "metadata": {
                        "description": "$~informations pour les étudiants",
                        "placeholder": "$~par exemple, carte d'étudiant, nom de famille, prénom",
                        "prompt": "$~Vous souhaitez créer de nouveaux comptes pour les élèves ? Fournissez *toutes les informations* sur les élèves, une par ligne, séparées par des virgules. Il peut s'agir de noms de famille, de prénoms, de numéros d'élèves ou d'autres détails distinctifs. Nous les utiliserons pour générer des noms d'utilisateur que vous pourrez modifier ci-dessous, ce qui vous aidera à associer les noms d'utilisateur aux apprenants."
                    },
                    "words": {
                        "description": "$~mots à utiliser dans les mots de passe",
                        "placeholder": "$~par exemple, chat, point, rat...",
                        "prompt": "$~Fournissez au moins *25 mots* et générez au hasard des mots de passe de 2 à 3 mots faciles à retenir. Choisissez des mots que vos élèves connaissent ou demandez-leur de réfléchir à des mots. Plus c'est aléatoire, plus c'est sûr !"
                    },
                    "generate": {
                        "label": "$~générer",
                        "tip": "$~Créez des noms d’utilisateur et des mots de passe en fonction des informations ci-dessus."
                    },
                    "edit": {
                        "label": "$~modifier",
                        "tip": "$~modifier les informations sur les étudiants générées"
                    },
                    "submit": {
                        "label": "$~créer une classe",
                        "tip": "$~Créez une nouvelle classe avec ces informations."
                    }
                },
                "error": {
                    "duplicates": "$~Il y a des entrées en double dans les informations sur les étudiants.",
                    "columns": "$~Assurez-vous que chaque élève dispose du même nombre de colonnes.",
                    "generate": "$~Impossible de créer des noms d'utilisateur uniques.",
                    "taken": "$~Un ou plusieurs noms d'utilisateur ci-dessus sont déjà pris",
                    "limit": "$~Vous ne pouvez pas créer une classe de plus de 35 étudiants à la fois.",
                    "words": "$~Fournissez au moins 25 mots.",
                    "account": "$~Impossible de créer certains comptes.",
                    "generic": "$~Nous n'avons pas pu créer la classe. Voici quelques informations pour aider les développeurs à comprendre ce qui s'est passé."
                }
            },
            "class": {
                "header": "$~Classe",
                "subheader": {
                    "teachers": "$~Enseignants",
                    "students": "$~Étudiants",
                    "galleries": "$~Galeries"
                },
                "prompt": {
                    "gallery": "$~Créez une galerie pour votre classe afin d'organiser un devoir ou un projet. Tous les enseignants du projet seront les conservateurs de la galerie et tous les élèves les créateurs de la galerie.",
                    "delete": "$~La suppression de cette classe supprimera définitivement les informations sur la classe, mais ses projets, ses galeries ou ses comptes étudiants."
                },
                "field": {
                    "name": {
                        "description": "$~nom de la classe",
                        "placeholder": "$~nom"
                    },
                    "description": {
                        "description": "$~description de la classe",
                        "placeholder": "$~description"
                    },
                    "newteacher": {
                        "placeholder": "$~email ou nom d'utilisateur",
                        "description": "$~e-mail ou nom d'utilisateur du créateur à qui vous souhaitez donner accès à cette classe en tant qu'enseignant"
                    },
                    "addteacher": "$~Ajouter un enseignant à cette classe",
                    "delete": {
                        "tip": "$~Supprimez cette classe pour toujours.",
                        "label": "$~Supprimer cette classe"
                    }
                },
                "error": {
                    "notfound": "$~Nous n'avons pas pu trouver ce cours ou vous n'avez pas la permission de le consulter."
                }
            }
        },
        "edit": {
            "node": "$~$1$2[, tapez $2|]",
            "before": "$~avant $1[$1|fin]",
            "inside": "$~en $1, entre $2[$2|début] et $3[$3|fin]",
            "between": "$~entre 1$ et 2$",
            "line": "$~ligne vide entre $1[$1|start] et $2[$2|end]",
            "conflicts": "$~$1 conflits",
            "assign": "$~/$2[Hâte de rejoindre|Envisage de partir]…/",
            "append": "$~/Hâte d'insérer…/",
            "remove": "$~/Envisage de partir…/",
            "replace": "$~/Veut intervenir…/",
            "wrap": "$~mettre entre parenthèses",
            "unwrap": "$~déballer",
            "bind": "$~nomme cette expression"
        },
        "template": {
            "unwritten": "$~À déterminer",
            "unparsable": "$~Modèle non analysable : $1"
        },
        "collaborate": {
            "label": "$~collaborer",
            "role": {
                "owner": "$~propriétaire",
                "collaborators": "$~collaborateurs",
                "curators": "$~conservateurs"
            },
            "field": {
                "message": {
                    "description": "$~Le message de discussion à soumettre",
                    "placeholder": "$~Tapez un message"
                }
            },
            "button": {
                "submit": {
                    "label": "$~Envoyer",
                    "tip": "$~Envoyez un message à vos collaborateurs"
                },
                "start": {
                    "label": "$~Démarrer une discussion",
                    "tip": "$~Commencez une discussion avec vous-même ou avec d’autres."
                },
                "delete": "$~supprimer ce message"
            },
            "error": {
                "unowned": "$~Ce projet n'a pas de propriétaire, il ne peut donc pas avoir de chat.",
                "offline": "$~Impossible de charger ce chat.",
                "empty": "$~Aucun message.",
                "deleted": "$~Ce message a été supprimé."
            },
            "prompt": {
                "solo": "$~Discutez avec vous-même ou ajoutez un collaborateur, qui peut éditer et discuter.",
                "owner": "$~Les collaborateurs peuvent éditer ce projet et en discuter.",
                "collaborator": "$~Vous êtes un collaborateur. Vous pouvez éditer ce projet et en discuter.",
                "curator": "$~Vous êtes curateur de la galerie de ce projet. Vous pouvez éditer ce projet et en discuter."
            }
        },
        "checkpoints": {
            "label": {
                "now": "$~maintenant",
                "history": "$~restaurer",
                "restore": "$~Ceci est une version précédente de ce projet.",
                "ago": "$~1 $ il y a 2 $"
            },
            "button": {
                "clear": "$~supprimer l'historique",
                "select": "$~voir cette version",
                "checkpoint": "$~enregistrer cette version du projet",
                "back": "$~revenir à la version précédente",
                "forward": "$~revenir à la version suivante",
                "restore": "$~restaurer cette version",
                "now": "$~revenir à la version actuelle"
            }
        }
    },
    "moderation": {
        "warning": {
            "header": "$~Avertissement",
            "explanation": "$~Un modérateur a jugé que ce contenu pouvait :"
        },
        "blocked": {
            "header": "$~Bloqué",
            "explanation": "$~Un modérateur a jugé que ce contenu pouvait :"
        },
        "unmoderated": {
            "header": "$~Note",
            "explanation": "$~Ce contenu n'a pas encore été modéré. Il peut :"
        },
        "moderate": {
            "header": "$~Modéré",
            "explanation": "$~Examinez ce projet et déterminez si son contenu correspond à l'une des situations suivantes. Si tel est le cas, le contenu sera signalé ou bloqué. Vous pouvez ignorer cette étape si vous n'êtes pas sûr."
        },
        "flags": {
            "violence": "$~Inciter, encourager ou célébrer la violence, le mal ou l’automutilation envers quiconque.",
            "dehumanization": "$~Déshumaniser des individus ou des groupes en fonction de leur race, de leur origine ethnique, de leur origine nationale, de leur caste, de leur orientation sexuelle, de leur sexe, de leur religion, de leur âge, de leurs capacités ou de leur apparence.",
            "disclosure": "$~Révéler des informations privées sur d'autres personnes telles que des noms, des coordonnées ou des adresses physiques",
            "misinformation": "$~Contenir des informations fausses, trompeuses, mensongères ou manipulatrices"
        },
        "progress": "$~*$1* modéré, *$2* restant",
        "button": {
            "submit": {
                "tip": "$~Enregistrez ces paramètres de modération",
                "label": "$~sauvegarder"
            },
            "skip": {
                "tip": "$~Ignorer ce projet",
                "label": "$~sauter"
            }
        }
    },
    "gallery": {
        "games": {
            "name": "$~Jeux",
            "description": "$~Jeux interactifs avec des mots et des symboles."
        },
        "visualizations": {
            "name": "$~Visualisations",
            "description": "$~Visualisations de et via le texte."
        },
        "motion": {
            "name": "$~Mouvement",
            "description": "$~Exemples de mouvements et de collisions."
        },
        "av": {
            "name": "$~Audio/Vidéo",
            "description": "$~Utilisation du volume, de la hauteur et de la vidéo comme entrée."
        },
        "tools": {
            "name": "$~Outils",
            "description": "$~Utilitaires et applications simples."
        }
    }
}
