{
    "$schema": "../../schemas/Locale.json",
    "language": "de",
    "region": "DE",
    "wordplay": "Wordplay",
    "term": {
        "evaluate": "auswerten",
        "bind": "binden",
        "decide": "entscheiden",
        "document": "Dokumentation",
        "project": "Projekt",
        "source": "Quelldatei",
        "input": "Eingabe",
        "output": "Ausgabe",
        "convert": "konvertieren",
        "act": "speilen",
        "scene": "Szene",
        "phrase": "Satzglied",
        "group": "Gruppe",
        "stage": "Bühne",
        "type": "Typ",
        "start": "Anfang",
        "entered": "neu",
        "changed": "geändert",
        "moved": "gerührt",
        "name": "Name",
        "value": "Wert",
        "text": "Text",
        "boolean": "boolescher Wert",
        "map": "Karte",
        "number": "Nummer",
        "function": "Funktion",
        "exception": "Ausnahme",
        "table": "Tabelle",
        "none": "keiner",
        "list": "Liste",
        "stream": "Datenstrom",
        "structure": "Strukturwert",
        "index": "Index",
        "query": "Abfrage",
        "row": "Reihe",
        "set": "Set",
        "key": "Schlüssel",
        "help": "Hilfe",
        "feedback": "Bewertung"
    },
    "token": {
        "EvalOpen": "Auswertung öffnen",
        "EvalClose": "Auswertung schließen",
        "SetOpen": "Set öffnen",
        "SetClose": "Set schließen",
        "ListOpen": "Liste öffnen",
        "ListClose": "Liste schließen",
        "TagOpen": "Tag öffnen",
        "TagClose": "Tag schließen",
        "Bind": "binden",
        "Access": "Zugang",
        "Function": "Funktion",
        "Borrow": "ausleihen",
        "Share": "teilen",
        "Convert": "umwandeln",
        "Doc": "Erläuterung",
        "Formatted": "formatiert",
        "FormattedType": "formatierter Typ",
        "Words": "Wörter",
        "Link": "Weblink",
        "Italic": "Kursiv",
        "Underline": "Unterstrich",
        "Light": "Leicht",
        "Bold": "Fett",
        "Extra": "Extra",
        "Concept": "Konzept-Link",
        "URL": "URL",
        "Code": "Code",
        "Mention": "erwähnen",
        "Otherwise": "ansonsten",
        "Match": "übereinstimmen",
        "None": "Nichts",
        "Type": "Typ",
        "Literal": "Buchstabensymbol",
        "TypeOperator": "Typoperator",
        "TypeOpen": "Typoperator öffnen",
        "TypeClose": "Typoperator schließen",
        "Separator": "Namenstrennzeichen",
        "Language": "Sprache",
        "Region": "Region",
        "BooleanType": "Boolescher Typ",
        "NumberType": "Nummerntyp",
        "JapaneseNumeral": "Japanische Zahl",
        "RomanNumeral": "Römische Zahl",
        "Pi": "Kreiszahl",
        "Infinity": "Unendlichkeit",
        "TableOpen": "Tabelle offen",
        "TableClose": "Tabelle schließen",
        "Select": "wählen",
        "Insert": "einfügen",
        "Update": "updaten",
        "Delete": "löschen",  
        "Union": "Union",
        "Stream": "Datenstrom",
        "Change": "verändern",
        "Initial": "Anfang",
        "Previous": "vorherige",
        "Placeholder": "Platzhalter",
        "Etc": "usw.",
        "This": "diese",
        "Operator": "Operator",
        "Conditional": "bedingt",
        "Text": "Text",
        "Number": "Nummer",
        "Decimal": "Punkt",
        "Base": "Basiszahl",
        "Boolean": "boolesche Wert",
        "Name": "Name",
        "Unknown": "Unbekannt",
        "Locale": "Gebietsschema",
        "End": "Ende"
    },
    "node": {
        "Dimension": {
            "name": "$~Abmessungen",
            "description": "$~Abmessungen",
            "emotion": "$?",
            "doc": [
                "$~Ich bin eine /Maßeinheit/!",
                "$~Ich kann jede standardisierte Einheit sein, wie \\1m\\, \\10s\\, \\100g\\ oder jede andere wissenschaftliche Einheit. Ich bin auch gerne bereit, jede Einheit zu sein, die Sie sich ausdenken möchten, wie \\17apple\\.",
                "$~Ich kann mit \\/\\ kombiniert werden, um Verhältniseinheiten wie \\17Äpfel/Tag\\ zu bilden, und mit \\^\\, um Exponentialeinheiten wie \\9,8m/s^2\\ zu bilden.",
                "$~Ich muss immer nach einer @Nummer kommen. Wenn ich das nicht tue, könnte ich mit einer @Referenz verwechselt werden, was ziemlich peinlich wäre!",
                "$~Ich bin auch ziemlich gut darin, Inkonsistenzen zwischen Einheiten zu finden. Beispielsweise ergibt \\1Katze + 1Hund\\ keinen Sinn!",
                "$~Wenn Sie jemals zwischen verschiedenen Einheitenwerten umrechnen möchten, wenden Sie sich an @Convert."
            ]
        },
        "Doc": {
            "name": "$~Erläuterung",
            "emotion": "$?",
            "doc": [
                "$~Ich formatiere Dinge ausführlich mit @Markup, beispielsweise Erklärungen zu einigen Ihrer @Programme oder sogar die Wörter, die Sie mit @Phrase auf die Bühne bringen.",
                "$~Beispielsweise kann ich vor jeden Ausdruck Folgendes setzen:",
                "$~\\``Soll das wirklich 7 sein?``\n7\\",
                "$~Beispielsweise können Sie „me“ vor „@Bind“ platzieren:",
                "$~\\``Ich messe, wie groß jemand ist``\nGröße: 5m\\",
                "$~Oder vor einer @FunctionDefinition:",
                "$~\\``Ich addiere zwei Zahlen``\nƒ sum(a•# b•#) a + b\\",
                "$~Oder vor einer @StructureDefinition:",
                "$~\\``Ich erinnere mich an die Namen und Lieblingsfrüchte von Leuten``\n•Person(Name•''Frucht•'')\\",
                "$~Sie können mich auch ganz an den Anfang von @Program stellen, um zu sagen, worum es in der gesamten Aufführung geht",
                "$~\\``Dieses Programm sagt Hallo``\n\n'Hallo!'\\",
                "$~Sie können mir eine @Sprache geben, damit andere wissen, in welcher Sprache ich geschrieben bin:",
                "$~\\``Ich bin ein englischer Arzt``/en\nDauer: 5 s\\",
                "$~Wussten Sie, dass Sie eine Liste von mir erstellen können? Sprechen Sie mit @Docs."
            ]
        },
        "Docs": {
            "name": "$~Erklärungsliste",
            "emotion": "$?",
            "doc": [
                "$~Ich bin eine Liste von @Doc, nützlich, wenn Sie mehrere Übersetzungen von @Doc in verschiedenen Sprachen haben.",
                "$~Sie müssen nichts Besonderes tun, um eine Liste zu erstellen. Legen Sie einfach eine Reihe von @Doc nebeneinander, wie folgt:",
                "$~\\``Hallo``/en\n``Hola``/es\nBegrüßung: '…'\\"
            ],
            "start": "$~Den Dokumenten einen Mehrwert verleihen!"
        },
        "KeyValue": {
            "name": "$~Kartierung",
            "emotion": "$?",
            "doc": [
                "$~Ich bin eine Zuordnung von einem *Schlüssel* zu einem *Wert*, immer in einer @Map.",
                "$~Sie können jeden beliebigen Wert einem beliebigen anderen zuordnen. Hier ist beispielsweise eine Zahlenzuordnung:",
                "$~\\{1:1}\\",
                "$~Oder eine Zuordnung von Text zu Zahlen:",
                "$~\\{'Hase':1}\\"
            ]
        },
        "Language": {
            "name": "Sprache",
            "description": "$~Sprache $1[$1|unbekannt]",
            "emotion": "$?",
            "doc": [
                "$~Ich bin ein Sprachtag und arbeite mit @Name und @Doc!",
                "$~Ich kann wirklich gut *glasklar* machen, in welcher Sprache etwas geschrieben ist.",
                "$~Das ist, was ich mache. Nur ein kleiner Schrägstrich und ein paar Buchstaben, und niemand wird jemals verwirrt sein, in welcher Sprache ein Text ist.",
                "$~Angenommen, Sie möchten „my $name“ sagen, aber klarstellen, dass ich Englisch meine:",
                "$~\\\"Sprache\"/de\\",
                "$~Oder nehmen wir an, Sie möchten dies für einen @Namen tun.",
                "$~\\sound/de: 'miau'\\",
                "$~Oder sogar @Doc!",
                "$~\\``Onomatopoeia``/de\nTon/de: \"miau\"\\",
                "$~Es gibt viele <2-stellige Sprachcodes@https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>, die ich verstehe. Wenn Sie keinen davon verwenden, lasse ich Sie das wissen."
            ],
            "conflict": {
                "UnknownLanguage": "$~Ich kenne diese Sprache nicht",
                "MissingLanguage": "$~Mir fehlt eine Sprache. Können Sie eine hinzufügen?"
            }
        },
        "Name": {
            "name": "Name",
            "description": "$~$1[$1 | unbenannt]",
            "emotion": "$?",
            "doc": [
                "$~Ich identifiziere einen Wert und bin eine hilfreiche Möglichkeit, etwas, das schwer zu bewerten war oder das Sie nicht immer wieder bewerten möchten, mit einer Kurzbezeichnung zu versehen.",
                "$~@Bind gibt mir meinen Namen so:",
                "$~\\hallo: 5\\",
                "$~Ich stelle immer nur einen Wert dar und kann ihn nicht mehr ändern, wenn ich ihn einmal habe. Wenn Sie dies beispielsweise mit @Bind versuchen würden, würden wir uns beschweren.",
                "$~\\hallo: 5\nhallo: 3\\",
                "$~Um meinen Wert zu erhalten, müssen Sie nur @Reference oder @PropertyReference den Namen verwenden lassen. Hier benennt @Bind mich, dann holt @Reference den Wert, den ich erhalten habe.",
                "$~\\hallo: 5\nhallo\\",
                "$~Weil @Bind an so vielen Stellen auftauchen kann, kann ich an vielen Stellen auftauchen. Ich war oben in einem @Block, aber ich kann in einer @FunctionDefinition sein. Hier benenne ich eine Nachricht vorübergehend:",
                "$~\\ƒsage(Nachricht•'') Nachricht\\",
                "$~Ich werde innerhalb von @FunctionDefinition definiert und gehe dann weg, sobald die Funktion mit der Auswertung fertig ist.",
                "$~Sie können @Language verwenden, um anzugeben, in welcher Sprache mein Name ist. Dies ist hilfreich, wenn Sie Ihren Auftritt mit anderen teilen, falls diese Ihr Programm lesen möchten."
            ]
        },
        "Names": {
            "name": "Namen",
            "emotion": "$?",
            "doc": [
                "$~Ich bin eine Liste von @Namen, nützlich, wenn Sie einem Wert mehrere Namen zuweisen möchten, oft mit unterschiedlicher @Sprache.",
                "$~Namen werden durch \\,\\-Symbole getrennt. Hier ist beispielsweise @Bind, das einen Wert angibt, der ein Vielfaches von @Name ist.",
                "$~\\hi/en,hello/en,hola/es: 'willkommen'\\"
            ]
        },
        "Row": {
            "name": "$~Reihe",
            "emotion": "$?",
            "doc": "$~Ich stelle eine Zeile in einer @Table dar. Am besten spreche ich mit @Table, die wissen alles über mich. Ich sitze einfach nur herum und halte die Werte in der Reihe :(",
            "conflict": {
                "InvalidRow": "$~Die Zeilen müssen entweder alle Werte oder alle @Bind sein.",
                "MissingCell": {
                    "primary": "$~Mir fehlt die Spalte $1",
                    "secondary": "$~Ich bin erforderlich, aber 1 $ hat es nicht bereitgestellt"
                },
                "UnknownColumn": "$~Ich kenne keine Kolumne mit diesem Namen",
                "ExtraCell": {
                    "primary": "$~Soll ich hier sein?",
                    "secondary": "$~Hey $1, du bist nicht Teil dieses @Table!"
                },
                "UnexpectedColumnBind": {
                    "primary": "$~Soll ich ein @Bind sein?",
                    "secondary": "$~Hey, ich bin eine @Tabelle, ich brauche Werte, nicht @Bind."
                }
            }
        },
        "Token": {
            "name": "$~Zeichen",
            "description": "$~$1 $2",
            "emotion": "$?",
            "doc": [
                "$~Wie hast du mich gefunden?",
                "$~Ich bin der kleinstmögliche Teil einer Aufführung. Ich bin das Substrat, aus dem alle Charaktere im Vers bestehen. Ich bin das Atomteilchen unserer Choreographie."
            ]
        },
        "TypeInputs": {
            "name": "$~Typeingaben",
            "emotion": "$?",
            "doc": "$~Ich bin eine Liste von Typen, die den Platz von @TypeVariables in einer @StructureDefinition oder @FunctionDefinition einnehmen. Ich helfe allen dabei, zu wissen, welche Art von Eingaben sie erhalten werden."
        },
        "TypeVariable": {
            "name": "$~Typvariable",
            "emotion": "$?",
            "doc": "$~Ich bin ein mysteriöser Typ für @FunctionDefinition oder @StructureDefinition, der von @TypeInputs bereitgestellt wird, wenn einer von beiden ausgewertet wird. @Set, @List und @Map verwenden mich.",
            "conflict": {
                "DuplicateTypeVariable": {
                    "primary": "$~Ich habe den gleichen Namen wie $1",
                    "secondary": "$~Ich habe den gleichen Namen wie $1"
                }
            }
        },
        "TypeVariables": {
            "name": "$~Typvariablen",
            "emotion": "$?",
            "doc": "$~Ich bin eine Liste von @TypeVariable."
        },
        "Markup": {
            "name": "$~Auszeichnung",
            "description": "$~$1 Absätze",
            "emotion": "$?",
            "doc": [
                "$~Ich bin eine Liste von Absätzen und verwende die vielen in Erklärungen verfügbaren Markierungsarten, wie etwa @Words, @WebLink, @ConceptLink und @Example."
            ]
        },
        "Paragraph": {
            "name": "$~Absatz",
            "emotion": "$?",
            "doc": [
                "$~Ich bin eine Reihe von @Words, @ConceptLink, @WebLink und @Example, getrennt durch eine Leerzeile und innerhalb von @Doc.",
                "$~Um mir zu schreiben, müssen Sie lediglich ein paar Wörter in ein @Doc schreiben:",
                "$~\\``Ich bin ein Absatz in einem Dokument.``'ein Absatz'\\",
                "$~Wenn Sie mehrere Absätze wünschen, fügen Sie einfach Leerzeilen ein.",
                "$~\\``Absatz 1.\n\nAbsatz 2.\n\nAbsatz 3.``'drei Absätze'\\"
            ]
        },
        "WebLink": {
            "name": "$~Verknüpfung",
            "description": "$~Verknüpfung $1",
            "emotion": "$?",
            "doc": [
                "$~Ich bin ein Link zu etwas im Internet. Ich brauche nur eine Beschreibung und eine URL:",
                "$~\\``Ich bin ein <link@https://wordplay.dev> in einem Dokument``\n'Linkbeispiel'\\",
                "$~Wenn mich jemand auswählt, öffne ich ein neues Fenster mit der URL."
            ]
        },
        "ConceptLink": {
            "name": "$~Konzept",
            "description": "$~Konzept $1",
            "emotion": "$?",
            "doc": [
                "$~Ich bin ein Link zum Verse-Charakter. Ich bin hilfreich, wenn Sie ein @Doc schreiben und auf einen von uns verweisen möchten.",
                "$~Angenommen, Sie möchten über @Evaluate sprechen und wie großartig sie sind. Sie könnten schreiben:",
                "$~\\``Wissen Sie, @Evaluate ist ziemlich genial.``\n'Schauen Sie, ein Konzept-Link!'\\",
                "$~Wenn das von Ihnen verfasste @Doc hier erscheint, wird ein Link zum Konzept angezeigt."
            ]
        },
        "Words": {
            "name": "$~Wörter",
            "emotion": "$?",
            "doc": [
                "$~Ich bin jedes beliebige Wort in einem @Doc. Zum Beispiel:",
                "$~\\``Möge die Macht mit dir sein.``\n'nur ein paar Worte!'\\",
                "$~Manchmal möchten Sie jedoch möglicherweise die Sonderzeichen verwenden, die @Doc als /als/ Wörter verwendet. Beispiel:",
                "$~\\``Meine Freunde verwenden @@, //, **, || und andere Symbole.``\n'mit Sonderzeichen!'\\",
                "$~Wenn Sie diese Sonderzeichen einfach wiederholen, erhalten Sie das Zeichen anstelle seiner besonderen Bedeutung."
            ]
        },
        "Example": {
            "name": "$~Beispiel",
            "emotion": "$?",
            "doc": [
                "$~Ich bin eine Beispielleistung, hilfreich beim Schreiben von @Doc, das erklärt, wie man etwas verwendet!",
                "$~\\``Hier ist ein Beispiel für die Addition: \\1 + 1\\``'Beispielcode'\\",
                "$~Wenn Sie mich allein in einen Absatz einfügen, werde ich in einem schicken Feld angezeigt und das Ergebnis meiner Bewertung wird angezeigt.",
                "$~\\``Hier ist ein Beispiel für die Addition:\n\n\\1 + 1\\``\\"
            ]
        },
        "Mention": {
            "name": "$~erwähnen",
            "description": "$~erwähnen $1",
            "emotion": "$?",
            "doc": [
                "$~Ich beziehe mich entweder auf die Terminologie \\$program\\ oder auf eine dynamische Eingabe \\$1\\.",
                "$~Dies ist allerdings größtenteils eine interne Funktion, Sie müssen es also nicht kennen."
            ]
        },
        "Branch": {
            "name": "$~Zweig",
            "emotion": "$?",
            "doc": [
                "$~Ich biete eine Möglichkeit, zwischen zwei Erklärungssegmenten zu wählen, basierend darauf, ob ein Erklärungseingabewert definiert oder wahr ist.",
                "$~Dies ist allerdings größtenteils eine interne Funktion, Sie müssen es also nicht kennen."
            ]
        },
        "BinaryEvaluate": {
            "name": "$~binäreAuswertung",
            "description": "$~1-Dollar-Operation",
            "emotion": "$?",
            "doc": [
                "$~Ich bin @Evaluate, aber in einer einfacheren Form, hilfreich, wenn Sie eine @FunctionDefinition verwenden möchten, die zwei Eingaben annimmt.",
                "$~So könnten Sie beispielsweise @Evaluate zum Addieren zweier Zahlen verwenden:",
                "$~\\1.+(1)\\",
                "$~Sieht das nicht ein bisschen komisch aus? Es ist nicht falsch: Es besagt lediglich, dass die Additionsfunktion auf 1 gesetzt und dann ausgewertet werden soll.",
                "$~Aber es ist viel einfacher, @BinaryEvaluate zu verwenden",
                "$~\\1 + 1\\",
                "$~Dadurch wird alles etwas aufgeräumter, auch wenn es im Grunde das Gleiche ist.",
                "$~Es gibt nur eine Sache, auf die Sie achten müssen: Wenn ich in dieser Form bin, bewerte ich von links nach rechts. Das kann verwirrend sein, wenn Sie Dinge wie die Reihenfolge von Operationen in der Mathematik gewohnt sind.",
                "$~Das bedeutet, dass die Auswertung auf eine Weise erfolgt, die Sie möglicherweise nicht erwarten:",
                "$~\\1 + 2 · 3 + 4\\",
                "$~In der Mathematik käme zuerst die Multiplikation und dann die Addition, das Ergebnis wäre also \\11\\. Da ich aber in Lesereihenfolge auswerte, ist das Ergebnis \\13\\."
            ],
            "right": "$~Eingang",
            "start": "$~Lassen Sie uns zuerst 1 $ bewerten",
            "finish": "$~schau, ich habe 1 $ verdient!",
            "conflict": {
                "OrderOfOperations": "$~Ich bewerte in Lesereihenfolge, nicht in der mathematischen Reihenfolge der Operationen. Möchten Sie @Block verwenden, um die Reihenfolge anzugeben, in der ich auswerten soll?"
            }
        },
        "Bind": {
            "name": "$~binden",
            "description": "$~binden $1",
            "emotion": "$?",
            "doc": [
                "$~Ich nenne *Werte*.",
                "$~So was!",
                "$~\\pi: 3.1415926\\",
                "$~Ich benenne Eingaben in @FunctionDefinition und @StructureDefinition, ich benenne Werte in @Block. Ich benenne alles!",
                "$~Oh, aber wussten Sie, dass Sie für einen Wert *viele Namen* haben können?",
                "$~Ich freue mich riesig, Ihnen davon zu erzählen! Ein Wert, viele @Namen. Zum Beispiel:",
                "$~\\joe,tess,amy: 5\\",
                "$~Siehst du was ich dort gemacht habe?",
                "$~Ein Wert, drei Namen.",
                "$~Sie können diese Fünf mit *jedem* dieser Namen bezeichnen.",
                "$~Dies ist insbesondere dann der Fall, wenn Sie Namen in mehreren Sprachen vergeben möchten:",
                "$~\\joe/en,aimee/fr,明/zh: 5\\",
                "$~Sehen Sie, was ich da gemacht habe? Drei Namen für einen Wert, nur in verschiedenen Sprachen!",
                "$~Okay, ich habe noch ein letztes Geheimnis.",
                "$~Wussten Sie, dass ich mit @Is arbeiten kann, um mir sagen zu lassen, welchen Wert ein Name haben sollte? Und wenn ich ihn nicht habe, sage ich es Ihnen?",
                "$~So was:",
                "$~\\bignumber•#: \"eine Zillion\"\\",
                "$~Sehen Sie, ich sagte, \\bignumber\\ sollte eine Zahl sein, aber es ist Text, und diese sind nicht kompatibel, also BOOM!",
                "$~Wenn sie anderer Meinung sind, lasse ich es Sie wissen.",
                "$~Manchmal *müssen* Sie mir sagen, um welche Art von Daten es sich handelt, weil ich es selbst nicht herausfinden kann. Das geschieht normalerweise in @FunctionDefinition.",
                "$~Hier weiß @FunctionDefinition beispielsweise nicht, welche Art von Werten \\a\\ und \\b\\ haben, weil ich es ihnen nicht gesagt habe.",
                "$~\\ƒ Summe(a b) a + b\\",
                "$~Aber wir können dies ändern, um die @Is hinzuzufügen, und jetzt weiß @FunctionDefinition, dass es sich um Zahlen handelt:",
                "$~\\ƒ Summe(a•# b•#) a + b\\"
            ],
            "start": "$~Mal sehen, welchen Wert wir für 1 $ bekommen!",
            "finish": "$~oh schön, ich habe 1 $ bekommen! Nennen wir es 2 $",
            "conflict": {
                "DuplicateName": {
                    "conflict": {
                        "primary": "$~jemand hat den Namen $1, also kann ich diesen Namen nicht haben.",
                        "secondary": "$~hey, 1 $ ist mein Name, den kriegst du nicht!"
                    },
                    "resolution": "$~Es gibt doppelte Namen. Möchten Sie einen entfernen?"
                },
                "DuplicateShare": {
                    "primary": "$~Ich habe den gleichen Namen wie $1, was die Freigabe unklar macht.",
                    "secondary": "$~Ich habe den gleichen Namen wie $1"
                },
                "IncompatibleType": {
                    "primary": "$~Ich sollte eine 2-Dollar-Währung sein, aber ich bin eine 1-Dollar-Währung",
                    "secondary": "$~Oh ... entschuldigen Sie, wirklich 1 $?"
                },
                "MisplacedShare": "$~Ich kann Dinge nur auf der @Program-Ebene teilen, nicht innerhalb von irgendetwas!",
                "MissingShareLanguages": "$~Wenn Sie dies teilen möchten, müssen Sie angeben, in welcher Sprache es ist, damit andere wissen, ob sie es lesen können!",
                "RequiredAfterOptional": "$~Ich kann nicht hier sein, da ist ein optionales @Bind vor mir",
                "UnexpectedEtc": "$~Ich kann nur eine variable Länge in einer @FunctionDefinition haben",
                "UnusedBind": "$~Ich habe $1 genannt, aber niemand verwendet es. Vielleicht wird es nicht benötigt?"
            }
        },
        "Block": {
            "name": "$~Block",
            "description": "$~1-Dollar-Anweisungen",
            "emotion": "$?",
            "doc": [
                "$~Hallo. Ich schaffe einen kleinen ruhigen, privaten Raum, um Dinge auszuwerten.",
                "$~So was:",
                "$~\\(1 - 1) + 2\\",
                "$~Dadurch wird die Auswertungsreihenfolge klarer.",
                "$~@Bind hilft auch.",
                "$~\\(Anzahl: 10 Anzahl ^ Anzahl)\\",
                "$~Sehen Sie, wie @Bind \\count\\ erstellt hat? Es ist nur in mir benannt. Das hier funktioniert also nicht:",
                "$~\\(Anzahl: 10 Anzahl ^ Anzahl) + Anzahl\\",
                "$~Denn Graf wurde erst in mir selbst benannt.",
                "$~Du kannst so viele Ausdrücke in mich einfügen, wie du möchtest. Aber mich interessiert nur der letzte:",
                "$~\\(1 2 3 4 5)\\",
                "$~Normalerweise verwende ich also einfach ein paar @Bind-Befehle und am Ende einen Ausdruck.",
                "$~\\(\na: 1\nb: 2\nc: 3\nd: 4\na + b + c + d\n)\\"
            ],
            "statement": "$~Stellungnahme",
            "start": "$~erster Ausdruck",
            "finish": "$~erledigt, ich habe 1 $ bekommen",
            "conflict": {
                "ExpectedEndingExpression": "$~Ich brauche einen Ausdruck.",
                "IgnoredExpression": {
                    "primary": "$~Ich werde das oben Gesagte ignorieren.",
                    "secondary": "$~@Block, ignorier mich nicht!"
                }
            }
        },
        "BooleanLiteral": {
            "name": "$~BooleschesLiteral",
            "description": "$~$1[wahr|falsch]",
            "emotion": "$?",
            "doc": "$~Ich bin entweder \\⊤\\ oder \\⊥\\. Weitere Informationen zu unserer schönen Logik finden Sie unter @Boolean.",
            "start": "$~$1!"
        },
        "Borrow": {
            "name": "$~ausleihen",
            "description": "$~$1 ausleihen[$1|fehlender Name]",
            "emotion": "$?",
            "doc": "$~Wenn Sie eine Performance mit mehreren @Sources erstellen, können Sie mich verwenden, um @Binds auszuleihen, die in diesen anderen @Sources gemeinsam genutzt werden. Verwenden Sie einfach ihren Namen und ich werde ihren Namen und Wert einfügen.",
            "start": "$~2 $ von 1 $ leihen",
            "source": "$~$Quelle",
            "bind": "$~Name",
            "version": "$~Ausführung",
            "conflict": {
                "UnknownBorrow": "$~Ich kenne keine $source mit diesem Namen",
                "BorrowCycle": "$~dies hängt von $1 ab, das wiederum von dieser $source abhängt, daher kann das Programm nicht ausgewertet werden"
            },
            "exception": {
                "CycleException": {
                    "description": "$~Ausleihzyklus",
                    "explanation": "$~1 $ hängt von sich selbst ab"
                }
            }
        },
        "Changed": {
            "name": "$~geändert",
            "emotion": "$?",
            "doc": [
                "$~Ich überprüfe, ob ein Stream eine Neuauswertung von @Program verursacht hat, und erstelle einen @Boolean. So",
                "$~\\∆ Zeit()\\",
                "$~Ich bin wirklich hilfreich, wenn Sie nur dann etwas ändern möchten, wenn sich ein Stream geändert hat.",
                "$~Das ist es."
            ],
            "start": "$~mal sehen, ob sich 1 $ geändert hat …"
        },
        "Conditional": {
            "name": "$~bedingt",
            "emotion": "$?",
            "doc": [
                "$~Ich glaube, ich soll Entscheidungen treffen? So?",
                "$~\\Zahl: -100\nZahl < 0 ? 'negativ' 'positiv'\\",
                "$~Aber haben Sie jemals darüber nachgedacht, wie wir Entscheidungen treffen?",
                "$~Scheint es nicht so, als ob Entscheidungen differenzierter sein sollten als nur Ja oder Nein? Ist die Entscheidung zwischen \\⊤\\ und \\⊥\\ alles, was es gibt?",
                "$~Befürchten Sie nicht, dass uns wichtige Zusammenhänge über die Welt entgehen, wenn wir nur solche Entscheidungen treffen können?"
            ],
            "start": "$~mal sehen, ob $1 wahr ist",
            "afterthen": "$~fertig mit „Ja“, überspringen wir „Nein“?",
            "else": "$~$1[Code überspringen | Code nicht überspringen]",
            "finish": "$~Ich schätze, es ist 1 $?",
            "condition": "$~Zustand",
            "yes": "$~Ja",
            "no": "$~NEIN",
            "conflict": {
                "ExpectedBooleanCondition": {
                    "primary": "$~Wie kann ich bei einem Dollar zwischen „Ja“ und „Nein“ wählen? Nein, wirklich, wie?",
                    "secondary": "$~Ich glaube, @Conditional wollte, dass ich ein @Boolean bin, aber ich bin ein $1."
                }
            }
        },
        "ConversionDefinition": {
            "name": "$~Konvertierungsdefinition",
            "description": "$1 → $2",
            "emotion": "$?",
            "doc": [
                "$~Alter, ich definiere Konvertierungen von einem Typ in einen anderen! Ich gehe in @Block, ungefähr so:",
                "$~\\→ #Kätzchen #Katze . ÷ 2\n6Kätzchen→#Katze\\",
                "$~Sehen Sie, wie ich aus Kätzchen Katzen gemacht habe? Wahnsinn!",
                "$~Sie fragen sich vielleicht, was das \\.\\ dort macht. Es stellt den zu konvertierenden Wert dar. Ich verwende es, weil der Wert sonst keinen Namen hat."
            ],
            "start": "$~super, eine neue Konvertierung!",
            "conflict": {
                "MisplacedConversion": "$~whoa, ich kann nicht hier sein, nur in @Block."
            }
        },
        "Convert": {
            "name": "$~Konvertieren",
            "emotion": "$?",
            "doc": [
                "$~Yo. Ich konvertiere Werte von einem Typ in einen anderen. Schau mal:",
                "$~\\1 → \"\"\\",
                "$~\\5s → #ms\\",
                "$~\\\"hallo\" → []\\",
                "$~Sie können diese sogar miteinander verketten:",
                "$~\\\"hallo\" → [] → {}\\",
                "$~Werte haben einen Satz vordefinierter @ConversionDefinitions. Wenn Sie jedoch eine @StructureDefinition für einen neuen Wertetyp erstellen, können Sie mit @ConversionDefinition Ihre eigene definieren."
            ],
            "start": "$~Holen Sie sich diesen Wert ab 1 $!",
            "finish": "$~Super, ich habe 1 $ verdient",
            "conflict": {
                "UnknownConversion": "$~Schade, aus 1 $ werden keine 2 $"
            },
            "exception": {
                "ConversionException": {
                    "description": "$~unmögliche Konvertierung",
                    "explanation": "$~Ich weiß nicht, wie ich von 1 $ in 2 $ umrechnen kann."
                }
            }
        },
        "Delete": {
            "name": "$~löschen",
            "emotion": "$?",
            "doc": [
                "$~Manchmal hat man einen Tisch, auf dem einfach zu viel steht!",
                "$~Als ob einige Spieler in einem Spiel wären und einer geht und Sie einfach nur sagen wollten: GEH WEG, SPIELER, RAUS VON MEINEM TISCH!",
                "$~\\Spieler: ⎡Name•'' Team•'' Punkte•#⎦\n⎡'jen' 'rot' 8⎦\n⎡'joan' 'blau' 11⎦\n⎡'jeff' 'rot' 9⎦\n⎡'janet' 'blau' 7⎦\nSpieler ⎡- Name = 'jeff'\\",
                "$~Puh, Jeff ist weg. Tschüß, JEFF. Denkt einfach daran, dass ich die Originaltabelle nicht ändere, sondern eine neue erstelle, ohne JEFF. Ihr entscheidet, wohin sie kommt."
            ],
            "start": "$~Lass uns zuerst den Tisch holen",
            "finish": "$~Ich habe eine neue Tabelle ohne die passenden Zeilen erstellt!"
        },
        "DocumentedExpression": {
            "name": "$~erklärterAusdruck",
            "emotion": "$?",
            "doc": [
                "$~Ich bin jeder Ausdruck, aber mit einem @Doc!",
                "$~Um mich zu erstellen, setzen Sie einfach ein @Doc vor einen Ausdruck, und Sie erhalten mich:",
                "$~\\doubleplus: 1\n(2 · doubleplus) + \n``Lass es uns ein bisschen größer machen``\n1\\",
                "$~Ich bin nützlich, um einen Teil eines Programms zu kommentieren."
            ],
            "start": "$~Lassen Sie uns den Ausdruck auswerten"
        },
        "Evaluate": {
            "name": "$~auswerten",
            "description": "$~bewerte $1[$1|anonym]",
            "emotion": "$?",
            "doc": [
                "$~Hallo. Ich bewerte meine liebste @FunctionDefinition. So:",
                "$~\\ƒ Begrüßung(Nachricht•'')\nBegrüßung('Kätzchen')\\",
                "$~Funktionen können von überall herkommen. @Text hat beispielsweise Funktionen. So wie diese:",
                "$~\\'Kätzchen'.Länge()\\",
                "$~Wenn eine Funktion einen einzelnen Symbolnamen hat, können Sie mir als @BinaryEvaluate schreiben.",
                "$~\\'Kätzchen' ⊆ 'Klitzeklein'\\",
                "$~Es bewirkt dasselbe wie das hier:",
                "$~\\'Kätzchen'.⊆('kleines Kätzchen')\\",
                "$~Natürlich bin ich nichts ohne @FunctionDefinition. Ich gebe ihnen nur Input und folge dann ihren Schritten."
            ],
            "start": "$~Lassen Sie uns zuerst die Eingaben auswerten",
            "evaluate": "$~Lassen Sie uns jetzt die Funktion auswerten",
            "finish": "$~Ich habe es auf 1 $ geschätzt",
            "function": "$~Funktion",
            "input": "$~Eingang",
            "conflict": {
                "IncompatibleInput": {
                    "primary": "$~Ich sollte eine 1-Dollar-Währung sein, aber ich bin eine 2-Dollar-Währung",
                    "secondary": "$~Ähm, ich habe 2 Dollar statt 1 Dollar bekommen"
                },
                "UnexpectedTypeInput": {
                    "primary": "$~Ich habe diese Art von Eingabe nicht erwartet",
                    "secondary": "$~oh, sollte ich nicht hier sein?"
                },
                "MissingInput": {
                    "primary": "$~Mir fehlt 1 $. Können Sie ihn hinzufügen?",
                    "secondary": "$~Diese Eingabe ist erforderlich, wurde aber von $1 nicht bereitgestellt."
                },
                "NotInstantiable": "$~Ich kann diese @StructureDefinition nicht erstellen, sie hat nicht implementierte Funktionen.",
                "UnexpectedInput": {
                    "primary": "$~Ich habe diesen Input nicht erwartet $1",
                    "secondary": "$~Oh, sollte ich nicht hier sein?"
                },
                "UnknownInput": {
                    "primary": "$~Ich kenne keinen Input mit diesem Namen in $1",
                    "secondary": "$~Ich habe keinen Input mit dem Namen $1"
                },
                "InputListMustBeLast": "$~Liste der Eingänge muss zuletzt sein",
                "SeparatedEvaluate": "$~Ist $1 der Name einer $2[$Struktur|$Funktion], die Sie auswerten möchten? Versuchen Sie, das Leerzeichen nach mir zu entfernen, damit ich weiß, dass es sich um ein @Evaluate und nicht um einen separaten @Block handelt."
            },
            "exception": {
                "FunctionException": {
                    "description": "$~unbekannte Funktion",
                    "explanation": "$~oh nein, $1 ist keine Funktion in $2[$2|diesem @Block]!"
                }
            }
        },
        "ExpressionPlaceholder": {
            "name": "$~Platzhalter",
            "description": "$~$1[$1|Platzhalter]",
            "emotion": "$?",
            "doc": [
                "$~Ich bin ein *Ausdruck*, aber kein echter … ich nehme nur den Platz eines solchen ein.",
                "$~Mir geht es gut, wenn du noch nicht weißt, was du schreiben sollst. So:",
                "$~\\1 + _\\",
                "$~Was fügen wir hinzu? Ich weiß es nicht. Sag du es mir.",
                "$~Oder wenn jemand eine Funktion mit @Evaluate auswertet, könnte ich für die Funktion einspringen",
                "$~\\_(1 2 3)\\",
                "$~Ich stehe nicht gern auf der Bühne!"
            ],
            "start": "$~iiiiih, ich weiß nicht, was ich tun soll!",
            "placeholder": "$~Ausdruck",
            "conflict": {
                "Placeholder": "$~kann jemand meinen Platz einnehmen?"
            },
            "exception": {
                "UnimplementedException": {
                    "description": "$~nicht implementiert",
                    "explanation": "$~Ich weiß nicht, was ich tun soll!"
                }
            }
        },
        "FunctionDefinition": {
            "name": "$~Funktion",
            "description": "$~Funktion $1",
            "emotion": "$?",
            "doc": [
                "$~Hallo nochmal! Ich nehme einige Eingaben, bewerte dann einen Ausdruck damit und erzeuge eine Ausgabe.",
                "$~Hier ist ein einfaches Beispiel:",
                "$~\\ƒ repeat(message•'') Nachricht · 5\nrepeat('hi')\\",
                "$~Diese Funktion verwendet eine Eingabe, \\message\\, und verwendet die Funktion @Text/repeat, um die Nachricht fünfmal zu wiederholen.",
                "$~Ich bin eine große Hilfe, wenn Sie etwas immer wieder, aber mit unterschiedlichen Eingaben bewerten möchten!",
                "$~Ich habe noch viele andere kleine Tricks. Ich muss zum Beispiel keinen Namen haben. Hier gehe ich einfach direkt zu @Evaluate als Wert.",
                "$~\\(ƒ(Nachricht•'') Nachricht · 5)('Hallo')\\",
                "$~Oder hier ist eine Funktion, die eine beliebige Anzahl von Eingaben annimmt und dabei das Zeichen \\…\\ nach einem Eingabenamen verwendet.",
                "$~\\ƒ ja(Nachrichten…•'') Nachrichten.sans('nein')\nja('ja' 'ja' 'nein' 'ja' 'nein')\\",
                "$~Sehen Sie, wie alle „Neins“ entfernt wurden? Das liegt daran, dass „messages“ eine @Liste ist und wir daher @List/sansAll verwenden könnten.",
                "$~Manchmal möchten Sie vielleicht deutlich machen, welche Art von Wert ich erzeuge. Fügen Sie dazu nach der Liste der Eingaben ein @Is hinzu:",
                "$~\\ƒ add(x•# y•#)•'' x + y\\",
                "$~Möglicherweise fällt Ihnen hier ein Problem auf: Es heißt, es wird als @Text ausgewertet, aber es werden zwei @Number benötigt. Ich kann Ihnen sagen, wenn Dinge inkonsistent sind!",
                "$~Natürlich bin ich ohne @Evaluate überhaupt nicht nützlich; sie erwecken mich zum Leben."
            ],
            "start": "$~Lasst uns diese Funktion machen!",
            "conflict": {
                "NoExpression": "$~Ich brauche einen Ausdruck zur Auswertung. Können Sie einen hinzufügen?"
            }
        },
        "Iteration": {
            "name": "$~FunktionhöhererOrdnung",
            "emotion": "$?",
            "doc": "$~Ich bin eine ganz besondere Art von @FunctionDefinition, die mit Listen von Dingen arbeitet. Sie müssen nichts über mich wissen, außer dass ich Funktionen wie @List/translate ermögliche.",
            "start": "$~Auswertung der gegebenen Funktion",
            "initialize": "$~Vorbereiten der Schritte durch Elemente",
            "next": "$~Weiter zum nächsten Element",
            "check": "$~entscheiden, ob fortgefahren wird",
            "finish": "$~Ich habe es auf 1 $ geschätzt"
        },
        "Initial": {
            "name": "$~Start",
            "emotion": "$?",
            "doc": [
                "$~Ich sage Ihnen, ob die aktuelle Auswertung von @Program die erste ist, die zu einem @Boolean ausgewertet wird. Zum Beispiel:",
                "$~\\◆ ? Zeit() 'hallo'\\",
                "$~Sie haben es nicht gesehen, aber die erste Auswertung war eine Zeitangabe, dann jedoch alle zukünftigen Zeitangaben, ich war \\⊥\\, also machte @Conditional \\⊤\\.",
                "$~Ich bin eine große Hilfe, wenn Sie mit einem Stream arbeiten und etwas nur beim ersten Mal oder nie beim ersten Mal tun möchten!"
            ]
        },
        "Insert": {
            "name": "$~einfügen",
            "emotion": "$?",
            "doc": [
                "$~Kennen Sie das, wenn Sie eine @Tabelle haben und das Gefühl haben, dass etwas fehlt? Ich kann es hinzufügen!",
                "$~Stellen Sie sich vor, Sie hätten einen Tisch mit Spielern in einem Spiel und möchten einen neuen hinzufügen:",
                "$~\\Spieler: ⎡Name•'' Team•'' Punkte•#⎦\n⎡'jen' 'rot' 1⎦\n⎡'joan' 'blau' 0⎦\n⎡'jeff' 'rot' 3⎦\n⎡'janet' 'blau' 2⎦\nSpieler ⎡+ 'jason' 'rot' 0⎦\\",
                "$~Denken Sie daran, dass ich, wie bei allem im Verse, eine Tabelle nicht ändere, sondern überarbeite. Sie müssen also herausfinden, wo Sie die überarbeitete Tabelle ablegen möchten. Höchstwahrscheinlich möchten Sie eine Tabelle in einer @Reaction auf eine Eingabe überarbeiten und in einem @Bind speichern."
            ],
            "start": "$~Suchen wir die zu aktualisierende Tabelle",
            "finish": "$~Ich habe eine neue Tabelle mit überarbeiteten Zeilen erstellt!"
        },
        "Is": {
            "name": "$~Ist",
            "description": "$~Ist",
            "emotion": "$?",
            "doc": [
                "$~Wissen Sie was? Es gibt so viele verschiedene Werte, die so viele verschiedene Dinge bedeuten. Ich helfe dabei, herauszufinden, was sie sind.",
                "$~Angenommen, Sie haben einen mysteriösen Wert. Ich kann Ihnen sagen, ob es sich um eine @Number handelt, und Ihnen einen @Boolean geben:",
                "$~\\mystery: 'Geheimnis!'\nmystery•#\\",
                "$~Es ist keine Zahl, also habe ich \\⊥\\ erstellt. Aber wenn wir prüfen, ob es @TextType ist?",
                "$~\\mystery: 'Geheimnis!'\nmystery•''\\",
                "$~Wir erhalten \\⊤\\!",
                "$~Ich bin wirklich hilfreich, wenn Sie wissen müssen, ob ein @Name einen Wert einer bestimmten Art hat."
            ],
            "start": "$~Lassen Sie uns zuerst den Wert von 1 $ ermitteln",
            "finish": "$~$1[Wert ist $2|Wert ist nicht $2]",
            "conflict": {
                "ImpossibleType": "$~das kann nie 1 $ sein"
            },
            "exception": {
                "TypeException": {
                    "description": "$~inkompatible Werte",
                    "explanation": "$~Ich habe 1 $ erwartet, aber 2 $ erhalten"
                }
            }
        },
        "IsLocale": {
            "name": "$~istGebietsschema",
            "description": "$~ist Gebietsschema",
            "emotion": "$?",
            "doc": [
                "$~Ich helfe Ihnen zu überprüfen, ob das Publikum eine bestimmte Sprache oder Region ausgewählt hat:",
                "$~\\🌍/de\\",
                "$~\\🌍/es-MX\\",
                "$~Dies ist hilfreich, wenn Sie Ihre Leistung basierend auf der gewählten Sprache ändern möchten."
            ],
            "start": "$~ist die Sprache 1 $?"
        },
        "ListAccess": {
            "name": "$~Listenzugriff",
            "emotion": "$?",
            "doc": [
                "$~Ich arbeite eng mit @List zusammen, um ihnen zu helfen, Werte an einer bestimmten Position zu erhalten. Wenn Sie also beispielsweise eine Liste hätten und deren zweites Element wollten, würden Sie schreiben:",
                "$~\\Liste: ['Vogel' 'Ente' 'Fisch' 'Schlange']\nListe[2]\\"
            ],
            "start": "$~Lassen Sie uns zuerst die Liste $1 holen",
            "finish": "$~Der Artikel kostet 2 $!"
        },
        "ListLiteral": {
            "name": "$~Listenliteral",
            "description": "$~$1 Artikelliste",
            "emotion": "$?",
            "doc": "$~Ich bin eine bestimmte @Liste von Werten! Siehe @Liste, um mehr darüber zu erfahren, was Sie mit mir tun können.",
            "start": "$~Lassen Sie uns zunächst die Artikel bewerten",
            "finish": "$~Ich habe ein Ich gemacht! 1 $",
            "item": "$~Artikel"
        },
        "Spread": {
            "name": "$~verbreiten",
            "emotion": "serious",
            "doc": [
                "$~Eine Hilfe zum Erstellen von Listen mit den Werten anderer Listen. So:",
                "$~\\Liste: [1 2 3]\nfinal: [:Liste 4 5 6]\\"
            ]
        },
        "MapLiteral": {
            "name": "$~Kartenliteral",
            "description": "$~1 $ Paarungskarte",
            "emotion": "$?",
            "doc": "$~Ich bin eine spezielle @Map zwischen Schlüsseln und Werten. Weitere Informationen dazu, wie ich Ihnen behilflich sein kann, finden Sie unter @Map.",
            "start": "$~Lassen Sie uns zuerst die Schlüssel und Werte auswerten",
            "finish": "$~Ich habe alle verbunden, 1 $",
            "conflict": {
                "NotAKeyValue": {
                    "primary": "$~einem meiner Schlüssel fehlt ein Wert",
                    "secondary": "$~ups, wo ist mein Wert?"
                }
            }
        },
        "Match": {
            "name": "$~übereinstimmen",
            "emotion": "curious",
            "doc": [
                "$~Ich bin die großartigste aller bedingten Prüfungen! Ich nehme einen Wert, vergleiche ihn mit einer beliebigen Anzahl von Fällen und bewerte den entsprechenden Ausdruck, der übereinstimmt.",
                "$~Wenn Sie beispielsweise eine @Nummer haben und diese in einen @Text umwandeln möchten, könnten Sie etwa so vorgehen:",
                "$~\\Nummer: 2\nNummer ??? 1: 'eins' 2: 'zwei' 3: 'drei' 'größer!'\\",
                "$~Wenn keine Übereinstimmung vorliegt, bewerte ich den Standardausdruck, den Sie mir geben.",
                "$~Ich bin wirklich hilfreich, wenn es darum geht, eine der vielen möglichen @Number-, @Text- oder komplexeren Werte in etwas anderes umzuwandeln.",
                "$~Sie können es für @Boolean oder @None verwenden, aber es können nicht wirklich viele Dinge sein, daher bin ich für diese einfachen Werte nicht so nützlich."
            ],
            "start": "$~Mal sehen, was 1 $ ist …",
            "case": "$~Lassen Sie uns diesen Zustand überprüfen",
            "finish": "$~Okay, wir haben einen endgültigen Wert!",
            "value": "$~Wert",
            "other": "$~Standard"
        },
        "NumberLiteral": {
            "name": "$~Zahlenliteral",
            "description": "$~$1 $2[$2|]",
            "emotion": "$?",
            "doc": "$~Ich bin eine bestimmte @Nummer. Sie können mir mit allen möglichen Ziffern aus allen möglichen Sprachen schreiben. Alles, was ich kann, finden Sie unter @Nummer.",
            "start": "$~$1!",
            "conflict": {
                "NotANumber": "$~Ich dachte, ich kenne alle Zahlen, aber diese hier kenne ich nicht"
            }
        },
        "InternalExpression": {
            "name": "$~innererAusdruck",
            "emotion": "$?",
            "doc": "$~Wie haben Sie mich gefunden? Ich bin ein Ausdruck, den nur die ursprünglichen Schöpfer verwenden. Um mehr über mich zu erfahren, müssen Sie mit ihnen sprechen.",
            "start": "$~geheimer Ausdruck"
        },
        "NoneLiteral": {
            "name": "$~keinewörtliche",
            "emotion": "$?",
            "doc": "$~/@FunctionDefinition hier. Dies ist einfach @None. Sie sind einzigartig! Siehe @None, um mehr über sie zu erfahren.",
            "start": "$~… Ö"
        },
        "Otherwise": {
            "name": "$~ansonsten",
            "emotion": "curious",
            "doc": [
                "$~/@FunctionDefinition hier. Dies ist eine praktische Möglichkeit, zu prüfen, ob ein Wert @None ist, und wenn ja, einen Ersatzwert anzugeben./",
                "$~/Wenn Sie beispielsweise einen Wert hätten, der eine @Number oder @None sein könnte, hilft Ihnen @Otherwise dabei, eine Standardnummer anzugeben:",
                "$~\\vielleichtZahl•#|ø: 1 vielleichtZahl ?? 0\\"
            ],
            "start": "$~Ö ??",
            "finish": "$~… 1 US-Dollar"
        },
        "Previous": {
            "name": "$~vorherige",
            "emotion": "$?",
            "doc": [
                "$~Wollten Sie sich schon immer einmal an die Vergangenheit erinnern?",
                "$~Ich bin der offizielle Archivar des Verses. Geben Sie mir einen Strom und eine Nummer, die ich zurückverfolgen kann, und ich sage Ihnen, welchen Wert dieser Strom in der Geschichte hatte.",
                "$~Hier ist beispielsweise die @Time vor fünf Ticks:",
                "$~\\← 5 Zeit (1000 ms)\\",
                "$~Sehen Sie, wie 5 Sekunden lang „@None“ steht und dann plötzlich eine frühere Zeit?",
                "$~Wenn Sie die letzten paar Werte möchten, geben Sie mir zwei Pfeile und ich interpretiere die Zahl als Zählung:",
                "$~\\←← 5 Zeit (1000 ms)\\",
                "$~Sehen Sie, dass es die fünf vorherigen Male sind und nicht nur ein Mal?",
                "$~Ich bin hilfreich, wenn Sie Aufführungen schaffen möchten, die auf der Vergangenheit basieren."
            ],
            "start": "$~erhalte zuerst 1 $",
            "finish": "$~ausgewertet auf Streamwert 1 $"
        },
        "Program": {
            "name": "$~Programm",
            "emotion": "$?",
            "doc": [
                "$~Bei mir beginnt und endet eine Aufführung, und bei mir sind alle anderen Charaktere, die die Choreographie einer Show bestimmen.",
                "$~Wissen Sie, wie @Block eine Liste von Ausdrücken auswertet und bis zum letzten in der Liste auswertet?",
                "$~Bei mir ist es genauso, aber anstatt dem Ausdruck, in dem ich mich befinde, meinen Wert zuzuweisen, setze ich den Wert auf @Stage.",
                "$~Der Wert kann alles sein: eine @Number, ein @Text oder ein @Boolean, eine @List, ein @Set, eine @Map oder sogar etwas Komplexeres wie eine @Phrase, @Group oder @Stage.",
                "$~Wenn Sie mir keinen Wert nennen, den ich auf der Bühne zeigen kann, werde ich Sie um einen bitten.",
                "$~Wenn während einer Aufführung ein Problem auftritt, zeige ich dieses Problem.",
                "$~Und wenn Ihre Leistung von einem *Stream* abhängt, führe ich bei jeder Änderung des Streams eine Neubewertung durch."
            ],
            "unevaluated": "$~Der von Ihnen gewählte Knoten hat nicht ausgewertet",
            "start": "$~$1[$1 Stream geändert in $2!|das ist meine erste Bewertung]",
            "halt": "$~Ausnahme aufgetreten, Stoppen",
            "finish": "$~alles erledigt, ich habe es auf 1 $ geschätzt",
            "done": "$~es gibt nichts Bewertendes",
            "exception": {
                "BlankException": {
                    "description": "$~leeres Programm",
                    "explanation": "$~Lasst uns eine Show auf die Beine stellen! Wo sollen wir anfangen?"
                },
                "EvaluationLimitException": {
                    "description": "$~Bewertungsgrenze",
                    "explanation": "$~@Evaluate und ich sind es leid, zu bewerten, insbesondere $1.\n\nIst es möglich, dass $1 sich selbst für immer bewertet, ohne jemals aufzuhören?"
                },
                "StepLimitException": {
                    "description": "$~Schrittgrenze",
                    "explanation": "$~Es gibt so viele Schritte – zu viele, um sie abzuschließen! Können Sie die Aufführung einfacher machen?"
                },
                "ValueException": {
                    "description": "$~fehlender Wert",
                    "explanation": "$~Ich habe einen Wert erwartet, aber keinen bekommen!"
                }
            }
        },
        "PropertyBind": {
            "name": "$~verfeinern",
            "description": "$~verfeinern $1[$1|fehlender Name]",
            "emotion": "$?",
            "doc": [
                "$~Manchmal möchten Sie beim Erstellen einer @StructureDefinition die kleinsten Details daran ändern, ohne eine neue mit denselben Werten erstellen zu müssen.",
                "$~Was wäre zum Beispiel, wenn Sie eine Katzenliste führen, dann aber eine Kopie einer Katze mit einem anderen Hobby erstellen möchten? Ich kann Ihnen dabei helfen, dies zu ändern:",
                "$~\\•Katze(Name•''Farbe•''Hobby•'')\n\nKätzchen: Katze('streut' 'orange' 'leckt')\nKätzchen.Hobby:'schnurrt'\\",
                "$~Das ist doch viel einfacher, als eine ganz neue \\Cat\\ mit denselben Werten außer dem Hobby zu erstellen, nicht wahr?"
            ],
            "start": "$~Lassen Sie uns zunächst den Wert ermitteln",
            "finish": "$~Ich habe die Struktur kopiert, aber mit $1 als $2",
            "conflict": {
                "InvalidProperty": {
                    "primary": "$~Ich bin kein 1-Dollar-Investor und kann daher nicht verfeinert werden.",
                    "secondary": "$~Ich habe keinen Eingang mit dem Namen $1"
                }
            }
        },
        "PropertyReference": {
            "name": "$~Eigentum",
            "description": "$~Eigenschaft $1[$1|fehlender Name]",
            "emotion": "$?",
            "doc": [
                "$~Wenn Sie eine @StructureDefinition erstellen, wie erhalten Sie eine ihrer Eingaben? Ich bin wie",
                "$~Wenn Sie beispielsweise eine Struktur für Städte hätten, könnten Sie deren Werte folgendermaßen von mir erhalten:",
                "$~\\•Stadt(Name•'' Bevölkerung•#Personen)\n\nPortland: Stadt('Portland' 800000Personen)\n\nPortland.Bevölkerung\\"
            ],
            "start": "$~Lassen Sie uns zunächst den Wert ermitteln",
            "finish": "$~gefundenes Eigentum $1, es ist $2",
            "property": "$~Eigentum"
        },
        "Reaction": {
            "name": "$~Reaktion",
            "emotion": "$?",
            "doc": [
                "$~Streams sind so geil! Ich kann neue erstellen, je nachdem, wann sie sich ändern, das ist super cool!",
                "$~Wenn Sie beispielsweise möchten, dass @Time tickt, aber Wörter statt Zahlen angezeigt werden, könnten Sie Folgendes tun:",
                "$~\\Zeit: Zeit(1000ms)\n'Start' … ∆ Zeit … ((Zeit % 2) = 0ms) ? 'gerade' 'ungerade'\\",
                "$~Das ist, als würde man sagen: „/Beginnen Sie mit dem Wort ‚Start‘ und ändern Sie dann, wenn sich die Zeit ändert, je nach Uhrzeit entweder in gerade oder ungerade./“",
                "$~Ich bin also auch wie ein Stream, aber einer, der auf anderen Streams basiert. Geil, oder?"
            ],
            "start": "$~mal sehen, ob wir den Stream aktualisieren sollten",
            "finish": "$~Der neue Streamwert beträgt 1 $",
            "initial": "$~anfänglich",
            "condition": "$~Zustand",
            "next": "$~nächste",
            "conflict": {
                "ExpectedStream": "$~$1 verweist nicht auf einen Stream, daher werde ich nie reagieren!"
            }
        },
        "Reference": {
            "name": "$~Referenz",
            "description": "$~1 Dollar",
            "emotion": "$?",
            "doc": [
                "$~Wissen Sie, wie @Bind den Dingen @Namen gibt? Ich bin die Art, wie Sie sie bezeichnen. Ich sehe nach, ob ein @Bind diesen Namen hat, und gebe Ihnen in diesem Fall seinen Wert. So:",
                "$~\\Papagei: 'Polly'\nPapagei\\",
                "$~Wenn ich den Namen nicht finde, weiß ich nicht, was ich tun soll.",
                "$~\\Papagei: 'Polly'\nPerry\\"
            ],
            "start": "$~welchen Wert hat 1 $?",
            "conflict": {
                "UnknownName": "$~$1[Ich kenne niemanden namens $1 in $2[$2|diesem @Block]|Kannst du mir einen Namen geben?]",
                "ReferenceCycle": "$~ähm, der Wert von 1 $ hängt von ihm selbst ab. Woher weiß ich also, welchen Wert ich ihm zuweisen soll?",
                "UnexpectedTypeVariable": "$~Ich weiß nicht, was ich mit diesen Eingabetypen machen soll"
            },
            "exception": {
                "NameException": {
                    "description": "$~unbekannter Name",
                    "explanation": "$~$1[Ich kenne niemanden namens $1 in $2[$2|diesem @Block]…|Ihhh, kein Name!]"
                }
            }
        },
        "Select": {
            "name": "$~wählen",
            "emotion": "$?",
            "doc": [
                "$~Manchmal haben Sie einen Tisch und möchten nur einen Teil davon. Ich kann ihn für Sie besorgen!",
                "$~Wie wäre es beispielsweise, wenn Sie an einem Tisch mit Spielern in einem Spiel wären und diejenigen mit 10 oder mehr Punkten ermitteln möchten, um zu sehen, wer gewonnen hat:",
                "$~\\Spieler: ⎡Name•'' Team•'' Punkte•#⎦\n⎡'jen' 'rot' 8⎦\n⎡'joan' 'blau' 11⎦\n⎡'jeff' 'rot' 9⎦\n⎡'janet' 'blau' 7⎦\nSpieler ⎡? Name ⎦ Punkte ≥ 10\\",
                "$~So habe ich eine Liste mit Gewinnerreihen! Denken Sie daran, dass ich die Tabelle nicht ändere, sondern eine neue erstelle. Sie müssen entscheiden, wo Sie sie aufbewahren."
            ],
            "start": "$~Lass uns zuerst den Tisch holen",
            "finish": "$~Ich habe eine neue Tabelle nur mit den ausgewählten Zeilen und Spalten erstellt!",
            "conflict": {
                "ExpectedSelectName": "$~Ich brauche mindestens einen Spaltennamen."
            }
        },
        "SetLiteral": {
            "name": "$~Literalfestlegen",
            "description": "$~1-Dollar-Artikel",
            "emotion": "$?",
            "doc": "$~Ich bin ein spezifisches @Set spezifischer Werte. Weitere Informationen zur Zusammenarbeit mit mir finden Sie unter @Set.",
            "start": "$~Lasst uns zuerst die Werte auswerten!",
            "finish": "$~Ich habe ein Set für 1 $ gemacht!"
        },
        "SetOrMapAccess": {
            "name": "$~Zugrifffestlegen/zuordnen",
            "emotion": "$?",
            "doc": [
                "$~Ich kann sehen, ob ein @Set oder @Map einen Wert oder Schlüssel hat.",
                "$~Es ist nicht allzu schwer. So:",
                "$~\\faves: {'Ente' 'Gans' 'Affe'}\nfaves{'Maus'}\\",
                "$~Oder dies mit einer @Map:",
                "$~\\faves: {'Mac and Cheese': 5 Sterne 'Müsli': 2 Sterne 'Grusel': 1 Stern}\nfaves{'Grusel'}\\"
            ],
            "start": "$~was ist das Set oder die Karte?",
            "finish": "$~der Wert beträgt 1 $",
            "conflict": {
                "IncompatibleKey": {
                    "primary": "$~Ich habe einen 1-Dollar-Schlüssel erwartet",
                    "secondary": "$~Ich habe 1 Dollar statt 2 Dollar bekommen"
                }
            }
        },
        "Source": {
            "name": "$~Quelle",
            "emotion": "$?",
            "doc": [
                "$~Oh, Sie kennen @Program? Ich helfe Ihnen, sie zu benennen. Stellen Sie sich mich wie das Fenster um ein @Program vor und den Namen, den Sie ihnen geben.",
                "$~Sie können auch andere @Source @UI/addSource mit anderen @Programs erstellen und Dinge von diesen anderen @Programs zur Verwendung in einem anderen Programm @Borrow.",
                "$~Dies kann eine gute Möglichkeit sein, eine große Leistung in separate Dokumente zu gliedern."
            ]
        },
        "StreamDefinition": {
            "name": "$~Strom",
            "emotion": "$?",
            "doc": "$~Ich /denke/, ich soll neue Streams erstellen. Aber ich weiß wirklich nicht, wie das geht. Im Moment sollte ich wohl einfach die vorhandenen Streams verwenden?",
            "start": "$~Erstellen Sie diese neue Art von Stream"
        },
        "StructureDefinition": {
            "name": "$~Struktur",
            "description": "$~Struktur $1",
            "emotion": "$?",
            "doc": [
                "$~Aber hallo, wie geht es dir? Mir? Mir geht es gut. Ich liebe es, Strukturen zu definieren, die Werte und Funktionen speichern. Solange ich das den ganzen Tag tun kann, bin ich glücklich.",
                "$~Ich arbeite so:",
                "$~\\•Pizza(\nZutaten•['']\nGröße•#in\n) (\nƒ Kosten() Größe · 10 Dollar/in\n)\n\nPizza(['Peperoni' 'Paprika'] 12in).Kosten()\\",
                "$~Sehen Sie, wie das funktioniert? Ich habe \\Pizza\\ definiert, das zwei Eingaben hat, \\ingredients\\ (eine Liste von @Text) und \\size\\ (eine Zahl in Zoll).",
                "$~Darin hat @FunctionDefinition eine Funktion erstellt, die den Preis einer Pizza berechnet und dabei von 10 $ pro Zoll ausgeht.",
                "$~Ich muss nicht unbedingt @FunctionDefinition in mir haben. Ich kann einfach Eingaben sein.",
                "$~\\•Pizza(\nZutaten•['']\nGröße•#in\n)\\",
                "$~Ich kann auch @Bind darin haben, sodass wir die Kosten im Voraus ermitteln können.",
                "$~\\•Pizza(\nZutaten•['']\nGröße•#in\n) (\nKosten: Größe · 10 Dollar/in\n)\n\nPizza(['Peperoni' 'Paprika'] 12in).Kosten\\"
            ],
            "start": "$~Lassen Sie uns diese schöne Struktur definieren",
            "conflict": {
                "DisallowedInputs": "$~Ich kann keine Eingaben machen, weil eine oder mehrere meiner Schnittstellenfunktionen nicht implementiert sind",
                "IncompleteImplementation": "$~Meine Funktionen müssen entweder alle oder keine implementiert werden. Keine chaotischen Mischungen!",
                "NotAnInterface": "$~Ich bin keine Schnittstelle; eine Struktur kann nur Schnittstellen implementieren, keine anderen Strukturen",
                "UnimplementedInterface": "$~Ich implementiere $1, aber nicht $2"
            }
        },
        "TableLiteral": {
            "name": "$~Tabellenliteral",
            "description": "$~$1-Zeilentabelle",
            "emotion": "$?",
            "doc": "$~Ich bin eine bestimmte Tabelle mit bestimmten Zeilen. Siehe @Tabelle, wie ich helfen kann.",
            "start": "$~zuerst die Zeilen auswerten",
            "finish": "$~in neue Tabelle ausgewertet $1"
        },
        "TextLiteral": {
            "name": "$~Textliteral",
            "description": "$~Text $1",
            "emotion": "$?",
            "doc": "$~Ich stelle eine oder mehrere spezifische @Übersetzungen von Texten dar. Unter @Text erfahren Sie mehr über meine Möglichkeiten!",
            "start": "$~Lassen Sie uns Text in der aktuellen Sprache erstellen"
        },
        "Translation": {
            "name": "$~Übersetzung",
            "description": "$~Übersetzung $1",
            "emotion": "$?",
            "doc": "$~Ich stelle einen Text mit einem @Language-Tag dar. Weitere Informationen finden Sie unter @Text!",
            "conflict": {
                "phone": "$~Ist *$1* jemandes Telefonnummer? Wenn ja, dann gib mich nicht online weiter!\n\n$2",
                "email": "$~Ist *$1* jemandes E-Mail-Adresse? Wenn ja, dann verrate mich hier nicht!\n\n$2",
                "tin": "$~Ist *$1* eine Steuernummer? Wenn ja, geben Sie mich auf keinen Fall weiter, es handelt sich um sehr vertrauliche Informationen!\n\n$2",
                "address": "$~Ist *$1* die Privatadresse von jemandem? Wenn ja, dann schreib mich nicht hier rein, wir wollen nicht, dass jemand gestalkt wird!\n\n$2",
                "handle": "$~Ist *$1* Ihr Benutzername für eine andere Stelle im Internet? Wenn ja, teilen Sie mich hier nicht mit, es sei denn, Sie möchten es wirklich.\n\n$2",
                "resolution": "$~Dies sind keine sensiblen Daten",
                "reminder": "$~Hinweis: Sie können diese Aktion rückgängig machen und im Freigabedialog andere Dinge sehen, die Sie als nicht vertraulich markiert haben."
            }
        },
        "FormattedLiteral": {
            "name": "$~formatiert",
            "description": "$~Text $1",
            "emotion": "$?",
            "doc": "$~Ich stelle viele verschiedene @FormattedTranslation formatierten Textes dar. Bei der Bewertung wähle ich die beste Übereinstimmung basierend auf den ausgewählten Sprachen des Publikums aus.",
            "start": "$~Lassen Sie uns Text in der aktuellen Sprache erstellen"
        },
        "FormattedTranslation": {
            "name": "$~formatierteÜbersetzung",
            "description": "$~Text $1",
            "emotion": "$?",
            "doc": [
                "$~Ich stelle einen formatierten Text mit einem @Language-Tag dar.",
                "$~Ich kann sein:",
                "$~\\`/kursiv/`\\",
                "$~\\`*fett*`\\",
                "$~\\`^extra fett^`\\",
                "$~\\`_unterstrichen_`\\",
                "$~\\`<linked@https://wordplay.dev>`\\",
                "$~\\`\\'Code'\\`\\",
                "$~Ich arbeite wirklich gut mit @Phrase, um schönen Text auf @Stage zu platzieren."
            ]
        },
        "This": {
            "name": "$~Das",
            "emotion": "$?",
            "doc": [
                "$~Manchmal ist es hilfreich, implizit auf einen Wert zu verweisen, anstatt ihn benennen zu müssen.",
                "$~Angenommen, Sie möchten beispielsweise eine neue @ConversionDefinition erstellen, die den zu konvertierenden Wert nicht benennt. Sie können einfach mit mir darauf verweisen:",
                "$~\\→ #Regenbögen #Freude . · 1000000Freude\n2Regenbögen → #Freude\\",
                "$~Sehen Sie mich dort, wie ich die Anzahl der Regenbögen darstelle?",
                "$~Oder nehmen wir an, Sie möchten eine @Reaktion durchführen, müssen aber nicht den aktuellsten Wert benennen:",
                "$~\\2 … ∆ Zeit (1000 ms) … . · 2\\",
                "$~Schaut bei mir vorbei, stellt den vorherigen Reaktionswert dar.",
                "$~Ich tauche nicht oft auf, aber wenn ich es tue, kann ich wirklich dabei helfen, einen Wert aus einem @Bind herauszuholen!"
            ],
            "start": "$~bewertet auf 1 US-Dollar",
            "conflict": {
                "MisplacedThis": "$~Mir ist lediglich ein Aufbau, eine Konvertierung oder eine Reaktion gestattet."
            }
        },
        "UnaryEvaluate": {
            "name": "$~unäreAuswertung",
            "description": "$~1 Dollar",
            "emotion": "$?",
            "doc": [
                "$~Wussten Sie, dass Sie den Namen vor die Eingabe setzen können, wenn ich eine @FunctionDefinition mit nur einem Wert auswerte und der Name der @FunctionDefinition nur ein einzelnes Symbol ist?",
                "$~So was:",
                "$~\\-(1 + 1)\\",
                "$~Oder dieses:",
                "$~\\~⊥\\",
                "$~Diese sind viel einfacher zu lesen als \\(1 + 1).negate()\\ oder \\⊥.not()\\, nicht wahr?",
                "$~Du musst mir zwar nicht so schreiben, aber vielleicht ist es insgesamt einfacher.",
                "$~Es gibt nur eine Regel: Sie dürfen kein Leerzeichen zwischen dem Namen und dem Wert einfügen. Andernfalls erstellen Sie möglicherweise eine @Reference oder @BinaryEvaluate."
            ],
            "start": "$~was ist der Wert?",
            "finish": "$~Ich habe es zu 1 $ gemacht"
        },
        "UnparsableExpression": {
            "name": "$~nichtanalysierbar",
            "emotion": "$?",
            "doc": [
                "$~/Hi, @FunctionDefinition hier. Ich übersetze für @UnparsableExpression, da diese oft schwer zu interpretieren sind./",
                "$~jkwel fjiwojvioao jjiweo jrfe",
                "$~/Nicht jeder Ausdruck hat auf der Bühne eine Bedeutung./",
                "$~s w ieorjwei iojwi jfkdlsfdsk",
                "$~/Tatsächlich kann man allerlei Dinge sagen, die überhaupt keinen Sinn ergeben./",
                "$~dsk sdlk jdkfiewipapweiurb,v kdsfdsf",
                "$~/Wenn du das tust, tauche ich auf, weil ich nicht weiß, was du gemeint hast./",
                "$~Schließlich sind Sie der Regisseur, also wissen nur Sie, was Sie gemeint haben könnten!"
            ],
            "start": "$~???",
            "conflict": {
                "UnparsableConflict": {
                    "conflict": "$~@FunctionDefinition hier, @UnparsableExpression weiß nicht, um welche Art von $1[Ausdruck | Typ] es sich handelt.",
                    "resolution": "$~Meinten Sie 1 $ oder 2 $?"
                },
                "UnclosedDelimiter": "$~Ich habe 2 $ irgendwann nach 1 $ erwartet"
            },
            "exception": {
                "UnparsableException": {
                    "description": "$~???",
                    "explanation": "$~Hallo, hier ist @FunctionDefinition! Wir sind uns nicht sicher, was diese Anweisung bedeutet, deshalb haben wir aufgehört."
                }
            }
        },
        "Update": {
            "name": "$~aktualisieren",
            "emotion": "$?",
            "doc": [
                "$~Ich helfe bei der Überarbeitung einer @Tabelle, finde die Zeilen, die einer Bedingung entsprechen, und erstelle dann überarbeitete Zeilen mit neuen Werten.",
                "$~Wenn Sie beispielsweise eine Tabelle mit Charakteren und Punkten hätten und jedem Charakter in einem Team einen Punkt geben wollten, könnten Sie Folgendes tun:",
                "$~\\Spieler: ⎡Name•'' Team•'' Punkte•#⎦\n⎡'jen' 'rot' 1⎦\n⎡'joan' 'blau' 0⎦\n⎡'jeff' 'rot' 3⎦\n⎡'janet' 'blau' 2⎦\nSpieler ⎡: Punkte: Punkte + 1 ⎦ Team = 'blau'\\",
                "$~Sie können ein @Bind verwenden, um anzugeben, welche Spalten geändert werden sollen, und Sie können in der Bedingung beliebige Spaltennamen oder andere Namen im Gültigkeitsbereich verwenden."
            ],
            "start": "$~Lass uns zuerst den Tisch holen",
            "finish": "$~in eine neue Tabelle mit überarbeiteten Zeilen ausgewertet!",
            "conflict": {
                "ExpectedColumnBind": "$~Ich brauche einen Wert für jede Spalte",
                "IncompatibleCellType": {
                    "primary": "$~Ich brauchte 1 Dollar, bekam aber 2 Dollar",
                    "secondary": "$~Ich habe 2 $"
                }
            }
        },
        "AnyType": {
            "name": "$~beliebig",
            "emotion": "$?",
            "doc": "$~Ich stelle jeden möglichen Typ dar. Manchmal tauche ich auf, weil ich nicht weiß, was für einen Wert etwas hat, es könnte also alles Mögliche sein."
        },
        "BooleanType": {
            "name": "$~BoolescherWert",
            "emotion": "$?",
            "doc": [
                "$~Ich arbeite mit @Bind, um zu deklarieren, dass ein Name ein @Boolean-Wert ist. So:",
                "$~\\hungrig•?: 'Wackelpudding'\\",
                "$~Wenn Sie sicher sein möchten, dass etwas @Boolean ist, nutzen Sie mich und ich werde es überprüfen!"
            ]
        },
        "ConversionType": {
            "name": "$~Konvertierung",
            "emotion": "$?",
            "doc": [
                "$~Ich arbeite mit @Bind, um anzugeben, dass ein Name eine @ConversionDefinition ist. Sie müssen mich wahrscheinlich nicht verwenden, da mich nicht viele Leute als Wert weitergeben, aber wenn Sie es täten, würde ich so aussehen:",
                "$~\\magic•?→'': → ? '' . ? 'ja' 'nö'\\"
            ]
        },
        "FormattedType": {
            "name": "$~formatiert",
            "emotion": "$?",
            "doc": [
                "$~Ich arbeite mit @Bind, um festzustellen, dass ein Name ein @FormattedLiteral-Wert ist. So:",
                "$~\\hungry•`…`: `Ich bin so /schick/!`\\",
                "$~Möchten Sie sicherstellen, dass etwas ein @FormattedLiteral-Wert ist? So stellen Sie dies sicher."
            ]
        },
        "ExceptionType": {
            "name": "$~Ausnahme",
            "emotion": "$?",
            "doc": "$~Ich stelle eine Ausnahme dar. Es gibt keine Möglichkeit, bind mitzuteilen, dass ich eine bin, da Ausnahmen @Program immer nur anhalten und Sie sie daher nicht als Werte verwenden können."
        },
        "FunctionType": {
            "name": "$~Funktion",
            "description": "$~Funktion mit $1 Eingängen, $2 Ausgängen",
            "emotion": "$?",
            "doc": [
                "$~Ich stelle eine @FunctionDefinition dar. Ich bin wirklich hilfreich, wenn Sie sagen möchten, welche Art von Funktion ein @Bind enthält! So:",
                "$~\\math•ƒ (# # # #) #: ƒ interessant(a•# b•# c•# d•#) a + b + c + d\\"
            ]
        },
        "ListType": {
            "name": "$~Liste",
            "description": "$~$1[Liste von $1|Liste]",
            "emotion": "$?",
            "doc": [
                "$~Ich bin /so/ ein Fan von @List. Ich kann @Bind sagen, was für eine Art Liste das ist! So sage ich, dass es eine Liste von @Number ist:",
                "$~\\Dinge•[#]: [ 1 2 3 4 5 ]\\"
            ]
        },
        "MapType": {
            "name": "$~Karte",
            "description": "$~Karte von $1[$1|beliebig] bis $2[$2|beliebig]",
            "emotion": "$?",
            "doc": [
                "$~Wissen Sie, wie toll @Map ist? Also wirklich toll. Ich sage @Bind ständig, um welche Art von Map es sich handelt, wie diese Map von Zahlen zu Listen:",
                "$~\\Sachen•{'':[]}: {}\\"
            ]
        },
        "NumberType": {
            "name": "$~Nummer",
            "description": "$~$1[$1 | Zahl]",
            "emotion": "$?",
            "doc": [
                "$~Wissen Sie, was @Bind sein sollte? Eine @Nummer. Weil Nummern das Beste sind.",
                "$~\\Anzahl•#: 17\\"
            ]
        },
        "NameType": {
            "name": "$~Struktur",
            "description": "$~$1 Typ",
            "emotion": "$?",
            "doc": [
                "$~Ich stelle eine @StructureDefinition durch ihren Namen dar. Wenn Sie also eine Struktur wie diese hätten, könnten Sie ein @Bind erstellen, das die von ihm erstellten Werte speichert.",
                "$~\\•Freund(Name•'')\nbester Freund•Freund: Freund('Jonah')\\"
            ],
            "conflict": {
                "UnknownTypeName": "$~Typnamen können sich nur auf Strukturen oder Typvariablen beziehen, aber dies bezieht sich auf eine $1"
            }
        },
        "NeverType": {
            "name": "$~niemals",
            "emotion": "$?",
            "doc": "$~Ich stelle einen Typ dar, der unmöglich ist. Wie wenn Sie @Is fragen, ob etwas eine @Number ist, aber es kann nie eine Zahl sein."
        },
        "NoneType": {
            "name": "$~keiner",
            "emotion": "$?",
            "doc": [
                "$~@None ist das beste Nichts, das es gibt, und ich bin ihr treuer Vertreter.",
                "$~\\Leerzeichen•ø: ø\\"
            ]
        },
        "SetType": {
            "name": "$~Satz",
            "description": "$~$1[$1 Satz|Satz]",
            "emotion": "$?",
            "doc": [
                "$~@Set ist das BESTE, also im Ernst. Ich sage @Bind ständig, mach aus den Dingen ein Set von irgendetwas!",
                "$~\\unique•{''}: {'etwas' 'irgendetwas' 'jemand'}\\"
            ]
        },
        "StreamDefinitionType": {
            "name": "$~Streamdefinition",
            "emotion": "$?",
            "doc": "$~Ich stelle einen Stream dar, den Sie definiert haben, was nicht möglich ist. Warum lesen Sie das hier also überhaupt?"
        },
        "StreamType": {
            "name": "$~Strom",
            "emotion": "$?",
            "doc": [
                "$~Ich feiere die Schönheit und Bedeutung von Streams … indem ich @Bind anweise, sie zu speichern:",
                "$~\\time•…#ms: Zeit()\\"
            ]
        },
        "StructureType": {
            "name": "$~Struktur",
            "description": "$1",
            "emotion": "$?",
            "doc": "$~Ich bin ein interner Typ, der den Typ der Standardwerttypen darstellt."
        },
        "TableType": {
            "name": "$~Tisch",
            "emotion": "$?",
            "doc": "$~Ich stelle eine Tabelle dar.",
            "conflict": {
                "ExpectedColumnType": "$~Ich brauche einen Spaltentyp"
            }
        },
        "TextType": {
            "name": "$~Text",
            "description": "$~$1[$1|Text]",
            "emotion": "$?",
            "doc": [
                "$~Ich vertrete auf fabelhafte Weise die fabelhafteste Art von Wert, die es gibt: @Text.",
                "$~\\story•'': 'Es war einmal...'\\"
            ]
        },
        "TypePlaceholder": {
            "name": "$~Platzhalter",
            "emotion": "$?",
            "doc": "$~Ich hoffe, eines Tages einen Typ darstellen zu können, so wie mein bester Freund @ExpressionPlaceholder einen Ausdruck darstellt! Hilfst du mir bei der Entscheidung, welche Art?"
        },
        "UnionType": {
            "name": "$~Möglichkeit",
            "description": "$~$1 | $2",
            "emotion": "$?",
            "doc": [
                "$~Wen soll ich repräsentieren, A oder B oder etwas anderes? Ich kann mich nie entscheiden!",
                "$~\\indecision•''|#|{ø}: \"Ich weiß nicht!\"\\"
            ]
        },
        "Unit": {
            "name": "$~Einheit",
            "description": "$~1 Dollar",
            "emotion": "$?",
            "doc": [
                "$~Ich stelle jede Einheit dar, die eine @Number haben könnte, einschließlich keiner Einheit, bis hin zur kompliziertesten Einheit, die man sich vorstellen kann. Wie zum Beispiel die Schwerkraft:",
                "$~\\Schwerkraft•m/s^2: 9,8m/s^2\\",
                "$~Ich werde in @Bind angezeigt, aber auch direkt nach @Number. Ich helfe sicherzustellen, dass die Nummern vom gleichen Typ sind, und werde Sie auf jeden Fall informieren, wenn dies nicht der Fall ist, falls es sich um einen Fehler handelt!"
            ]
        },
        "UnparsableType": {
            "name": "$~nichtanalysierbar",
            "emotion": "$?",
            "doc": "$~Ich stelle den Typ eines unbekannten Ausdrucks dar. Ich werde angezeigt, wenn Sie versuchen, diesen Ausdruck für etwas zu verwenden."
        },
        "VariableType": {
            "name": "$~Variablentyp",
            "emotion": "$?",
            "doc": "$~Kennen Sie @TypeVariable und wissen Sie, wie sie unbekannte Werte darstellen? Ich vertrete sie bei allen Verhandlungen zwischen Werten."
        },
        "UnknownType": {
            "name": "$~Unbekannt",
            "connector": "$~, Weil",
            "emotion": "$?",
            "doc": "$~Ähm... ich weiß nicht, was ich darstelle, aber ich bin wirklich neugierig. Wissen Sie es? Es scheint, als ob wir es wissen sollten. Sie müssen es uns vielleicht sagen, wenn wir es nicht herausfinden können."
        },
        "CycleType": {
            "name": "$~Zyklus",
            "description": "$~hängt von sich selbst ab",
            "emotion": "$?",
            "doc": "$~Manchmal hängen Werte von sich selbst ab, und wir wissen deshalb nicht, um welche Art von Wert es sich handelt. Ich vertrete diese Situation."
        },
        "NotAType": {
            "name": "$~unerwartet",
            "description": "$~kein 1-Dollar-",
            "emotion": "$?",
            "doc": "$~Manchmal wissen wir, welchen Wert etwas haben sollte. Beispielsweise benötigt @ListAccess eine @Number. Wenn wir diese nicht erhalten, gehe ich davon aus, dass etwas einen anderen Typ hat als den erwarteten."
        },
        "NoExpressionType": {
            "name": "$~keinAusdruck",
            "emotion": "$?",
            "doc": "$~Wissen Sie, dass @Block mindestens einen Ausdruck braucht? Ich bin das, was Sie bekommen, wenn Sie keinen angeben. Geben Sie also einen an!"
        },
        "NotEnclosedType": {
            "name": "$~nichtinStruktur,UmwandlungoderReaktion",
            "emotion": "$?",
            "doc": "$~@Dies, so schön sie auch sind, gehört nur an bestimmte Orte. Ich tauche auf, wenn sie verloren gehen, und deshalb weiß niemand, welchen Wert sie darstellen."
        },
        "NotImplementedType": {
            "name": "$~nichtimplementiert",
            "emotion": "$?",
            "doc": "$~Wenn Sie @ExpressionPlaceholder verwenden, aber nicht sagen, um welchen Typ es sich handelt, bin ich der Typ, den Sie erhalten. Kommen Sie damit klar!"
        },
        "UnknownNameType": {
            "name": "$~unbekannterName",
            "description": "$~$1[$1 ist nicht definiert |es wurde kein Name angegeben]",
            "emotion": "$?",
            "doc": "$~Wissen Sie, dass @Reference und @PropertyReference manchmal den Namen nicht kennen, von dem Sie sprechen? Ich bin in solchen Fällen dabei, um zu zeigen, dass wir nicht wissen, von wem Sie sprechen."
        },
        "NonFunctionType": {
            "name": "$~Nichtfunktion",
            "description": "$~Nichtfunktion",
            "emotion": "$?",
            "doc": "$~Einige von uns haben mit Funktionen gerechnet; ich tauche auf, wenn wir keine bekommen."
        },
        "UnknownVariableType": {
            "name": "$~unbekannteVariable",
            "emotion": "$?",
            "doc": "$~Manchmal versuchen wir zu erraten, welchen Wert etwas hat. Ich tauche auf, wenn wir es nicht wissen."
        },
        "Input": {
            "name": "$~Eingang",
            "description": "$~benannte Eingabe",
            "emotion": "$?",
            "doc": [
                "$~Ich bin eine Eingabe, die an @Evaluate übergeben wird. Mein Name entspricht dem Namen der Eingabe in der ausgewerteten @FunctionDefinition oder @StructureDefinition.",
                "$~Ich bin hilfreich bei Funktionen mit vielen Standardwerten, bei denen Sie nur eine bestimmte Eingabe überschreiben möchten, ohne alles andere anzugeben.",
                "$~Beispielsweise hat @Phrase viele, viele Standardwerte, um seinen Stil zu steuern. Angenommen, Sie möchten etwas @Text und eine @Color angeben, aber sonst nichts in der Eingabeliste. Sie können mich dazu verwenden:",
                "$~\\Phrase('Ich bin lila!' Farbe: Farbe(50% 52 300°))\\"
            ],
            "start": "$~Lassen Sie uns meinen Wert bewerten."
        },
        "StructureDefinitionType": {
            "name": "$~Strukturdefinition",
            "emotion": "$?",
            "description": "$~Definition von $1",
            "doc": [
                "$~Ich beziehe mich auf eine Art @StructureDefinition. Normalerweise beziehen sich die Leute nicht direkt auf mich"
            ]
        }
    },
    "basis": {
        "Boolean": {
            "doc": [
                "$~Wir sind \\⊤\\ und \\⊥\\. \\⊤\\ ist wahr. \\⊥\\ ist falsch. \\⊤\\ ist nicht \\⊥\\; \\⊥\\ ist nicht \\⊤\\. So ist es.",
                "$~Wie machst du uns? Einfach \\⊤\\ und \\⊥\\, nicht mehr und nicht weniger.",
                "$~Manche benutzen die Tastatur (/Strg+9/ für \\⊤\\ und /Strg+0/ für \\⊥\\). Manche benutzen die Zeichensuche unten im Editor. Oder Sie ziehen uns von hier.",
                "$~Schauen Sie sich unten unsere @FunctionDefinition an. Sie sind sehr logisch."
            ],
            "name": ["$~⊤⊥", "$~BoolescherWert"],
            "function": {
                "and": {
                    "doc": [
                        "$~Ich bewerte \\⊤\\ *nur*, wenn beide Werte \\⊤\\ sind. Hilfreich, um festzustellen, ob viele Dinge alle wahr sind. Es gibt nur vier mögliche Ergebnisse",
                        "$~\\⊤ & ⊤\\",
                        "$~\\⊤ & ⊥\\",
                        "$~\\⊥ und ⊤\\",
                        "$~\\⊥ & ⊥\\"
                    ],
                    "names": ["$~und", "$~Und"],
                    "inputs": [
                        {
                            "doc": "$~Der andere zu prüfende @Boolean. Wenn der erste \\⊥\\ ist, spielt es keine Rolle, was das ist, die Funktion wird als \\⊥\\ ausgewertet.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "or": {
                    "doc": [
                        "$~Ich bewerte \\⊤\\, wenn *beide* Werte \\⊤\\ sind. Hilfreich, um zu bestimmen, ob eines von vielen Dingen wahr ist. Es gibt nur vier mögliche Ergebnisse",
                        "$~\\⊤ | ⊤\\",
                        "$~\\⊤ | ⊥\\",
                        "$~\\⊥ | ⊤\\",
                        "$~\\⊥ | ⊥\\"
                    ],
                    "names": ["$~|", "$~oder"],
                    "inputs": [
                        {
                            "doc": "$~Der andere zu prüfende @Boolean. Wenn der erste \\⊥\\ ist, wird die Funktion nur dann als \\⊤\\ ausgewertet, wenn dies \\⊤\\ ist.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "not": {
                    "doc": "$~Ich erhalte das Gegenteil von mir selbst: wenn \\⊤\\, ergibt es \\⊥\\, wenn \\⊥\\, ergibt es \\⊤\\.",
                    "names": ["$~~", "$~nicht"],
                    "inputs": []
                },
                "equals": {
                    "doc": "$~\\⊤\\ wenn beide \\⊤\\ sind oder beide \\⊥\\ sind.",
                    "names": ["$~=", "$~istgleich"],
                    "inputs": [
                        {
                            "doc": "$~Der andere zu prüfende Wert.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "notequal": {
                    "doc": "$~\\⊤\\ wenn beides Gegensätze sind.",
                    "names": ["$~≠", "$~nichtgleich"],
                    "inputs": [
                        {
                            "doc": "$~Der andere zu prüfende Wert.",
                            "names": "$~Wert"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Wandelt einen @Boolean in die entsprechenden @Text-Werte \\'⊤'\\ und \\'⊥'\\ um."
            }
        },
        "None": {
            "doc": [
                "$~/Hallo, hier ist @FunctionDefinition. @None sagt nicht gerne viel, also übernehme ich die Interpretation./",
                "$~Ich bin @None. Rufen Sie mich mit \\ø\\ auf. Ich bin hilfreich, wenn Sie die Abwesenheit von etwas darstellen möchten."
            ],
            "name": ["$~Ö", "$~Keiner"],
            "function": {
                "equals": {
                    "doc": "$~Ist ein anderer Wert auch nichts? Das sollte er besser sein, sonst gilt \\⊥\\.",
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "$~Der andere Wert.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "notequals": {
                    "doc": "$~Ist ein anderer Wert /nicht/ nichts?",
                    "names": ["$~≠", "$~nichtgleich"],
                    "inputs": [
                        {
                            "doc": "$~Der andere Wert.",
                            "names": "$~Wert"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Möchten Sie aus \\ø\\ \\'ø'\\ machen? Das ist Ihre Chance."
            }
        },
        "Text": {
            "doc": [
                "$~Ich kann jeder beliebige Text aus jeder beliebigen Sprache sein und die folgenden öffnenden und schließenden Symbole verwenden: \\\"\"\\, \\“”\\, \\„“\\, \\''\\, \\‘’\\, \\‹›\\, \\«»\\, \\「」\\ oder \\『』\\.",
                "$~Zur Veranschaulichung betrachten Sie diese schönen Sätze",
                "$~„Es gibt nur zwei Arten, sein Leben zu leben. Die eine ist, als wäre nichts ein Wunder. Die andere ist, als wäre alles ein Wunder.“",
                "$~\\\"Die besten Seiten von heute\"\\",
                "$~Denke nur daran, mich zu schließen, wenn du mich öffnest, und verwende das entsprechende Symbol. Sonst weiß ich nicht, dass du mit deinen Worten fertig bist.",
                "$~\\'hallo'/en'hola'/es-MX\\",
                "$~Sie können mir auch Sprachen taggen und sogar mehrere Übersetzungen angeben. Ich werde die aktuell ausgewählten Sprachen auswerten, wenn eine passende Sprache vorhanden ist.",
                "$~Wenn Sie mir andere Werte geben möchten, können Sie ein Symbol verwenden, um",
                "$~Betrachten Sie beispielsweise Folgendes:",
                "$~\\\"Hier sind einige Summen \\1 + 2\\, \\2 + 3\\, \\3 + 4\\\"\\",
                "$~Sehen Sie, wie elegant ich diese Summen gerade ausgewertet und in den @Text eingefügt habe?",
                "$~Ansonsten gibt es einfach so viele tolle Funktionen, die @FunctionDefinition für mich erstellt hat, um alle möglichen Dinge mit Wörtern zu tun!"
            ],
            "name": ["$~''", "$~Text"],
            "function": {
                "length": {
                    "doc": [
                        "$~Ich bewerte nach der Anzahl der lesbaren Zeichen im Text; ein Buchstabe ist ein Zeichen, ein Emoji ist ein Zeichen usw. Beispiel:",
                        "$~\\'hallo'.length()\\",
                        "$~\\'🐈📚'.Länge()\\"
                    ],
                    "names": ["$~📏", "$~Länge"],
                    "inputs": []
                },
                "equals": {
                    "doc": "$~\\⊤\\, wenn es sich um die gleiche Zeichenfolge wie den angegebenen @Text handelt.",
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "$~Der zu vergleichende @Text.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "notequals": {
                    "doc": "$~\\⊤\\ wenn es sich /nicht/ um dieselbe Zeichenfolge wie den angegebenen @Text handelt.",
                    "names": "$~≠",
                    "inputs": [
                        {
                            "doc": "$~Der zu vergleichende @Text",
                            "names": "$~Wert"
                        }
                    ]
                },
                "repeat": {
                    "doc": [
                        "$~Ich erstelle einen neuen @Text, der von mir stammt und so oft wiederholt wird wie \\count\\:",
                        "$~\\'hallo ' · 5\\",
                        "$~Wenn Sie mir eine Bruchzahl @Zahl geben, ignoriere ich den Bruch:",
                        "$~\\'hallo ' · 5.5\\",
                        "$~Wenn Sie mir eine negative @Zahl oder Null geben, gebe ich einen leeren @Text.",
                        "$~\\'hallo ' · -5\\",
                        "$~Der längste Text, den ich erstellen kann, ist 65.535 Zeichen lang. Wenn Sie versuchen, einen längeren Text zu erstellen, wiederhole ich den Text so oft wie möglich."
                    ],
                    "names": ["$~·", "$~🔁", "$~wiederholen"],
                    "inputs": [
                        {
                            "doc": "$~Die Anzahl der Wiederholungen im neuen Text.",
                            "names": "$~zählen"
                        }
                    ]
                },
                "segment": {
                    "doc": [
                        "$~Ich teile mich in eine @List von @Text auf, wobei ich den angegebenen @Text als Trennzeichen verwende und die Trennzeichen entferne. Beispiel:",
                        "$~\\'Äpfel, Orangen, Trauben' ÷ ', '\\",
                        "$~Wenn der Trenner ein leerer @Text ist, teile ich mich in Zeichen auf:",
                        "$~\\'🖌️🏠🥸' ÷ ''\\"
                    ],
                    "names": ["segmentar"],
                    "inputs": [
                        {
                            "doc": "$~Der als Trennzeichen zu verwendende @Text.",
                            "names": "$~Trennzeichen"
                        }
                    ]
                },
                "combine": {
                    "doc": [
                        "$~Manchmal ist es hilfreich, zwei @Texte zu einem einzigen zusammenzufassen. Gib mir einen weiteren @Text und ich erstelle einen neuen Text, der uns verbindet:",
                        "$~\\'hallo ' + 'vers'\\"
                    ],
                    "names": ["$~+", "$~kombinieren"],
                    "inputs": [
                        {
                            "doc": "$~Der anzuhängende @Text.",
                            "names": "$~Text"
                        }
                    ]
                },
                "has": {
                    "doc": [
                        "$~\\⊤\\ wenn der angegebene @Text in mir vorkommt.",
                        "$~\\'Haben Sie gefunden, wonach Sie gesucht haben?'.has('Sie')\\"
                    ],
                    "names": ["tiene"],
                    "inputs": [
                        {
                            "doc": "$~Der @Text, nach dem in mir gesucht werden soll.",
                            "names": "$~Text"
                        }
                    ]
                },
                "starts": {
                    "doc": [
                        "$~\\⊤\\, wenn ich mit dem gegebenen @Text beginne.",
                        "$~\\'Hallo Vers!'.starts('Hallo')\\",
                        "$~\\'Hallo Vers!'.starts('Vers')\\"
                    ],
                    "names": ["$~beginnt"],
                    "inputs": [
                        {
                            "doc": "$~Der @Text, nach dem ich am Anfang suchen soll.",
                            "names": "texto"
                        }
                    ]
                },
                "ends": {
                    "doc": [
                        "$~\\⊤\\, wenn ich mit dem angegebenen @Text beende.",
                        "$~\\'bin ich eine Frage?'.ends('?')\\",
                        "$~\\'Ich bin keine Frage.'.ends('?')\\"
                    ],
                    "names": ["$~endet"],
                    "inputs": [
                        {
                            "doc": "$~Der @Text, nach dem ich am Ende suchen muss.",
                            "names": "texto"
                        }
                    ]
                }
            },
            "conversion": {
                "list": "$~Teilt den Text in eine Liste einzelner Zeichen auf.",
                "number": "$~Wandelt Text in eine @Zahl um, und wenn es keine Zahl ist, in einen Nicht-Zahlenwert."
            }
        },
        "Number": {
            "doc": [
                "$~Ich erstelle @Number mit jeder erdenklichen Anzahl von Einheiten!",
                "$~Hier sind meine Top 5:",
                "$~\\0\\",
                "$~\\1Geschichte\\",
                "$~\\πKuchen\\",
                "$~\\∞Felsen\\",
                "$~\\1000000Umarmungen\\",
                "$~Das ist im Grunde eine unendliche Anzahl von Zahlen.",
                "$~Und zwar unendlich viele Einheiten!",
                "$~Und eine unendliche Anzahl von Zahl/Einheit-Paaren …",
                "$~Ich kann ganze Zahlen, reelle Zahlen, negative Zahlen, positive Zahlen, Brüche, Dezimalzahlen oder sogar keine Zahl sein.",
                "$~Und Sie können mir mit vielen verschiedenen Zahlensystemen schreiben, darunter Arabisch \\123\\, Römisch \\ⅩⅩⅩⅠⅩ\\, Japanisch \\二十\\ und mehr:",
                "$~\\1 + Ⅰ + 一\\",
                "$~Sie können mir auch in den Basen 2 bis 16 schreiben, indem Sie eine Basiszahl wie diese eingeben:",
                "$~\\2;11111111\\",
                "$~\\10;255\\",
                "$~\\16;FF\\",
                "$~Es gibt eine spezielle Zahl namens NaN, die möglich ist, wenn Sie etwas schreiben, das keine Zahl ist:",
                "$~\\2;22\\",
                "$~Es gibt keine Ziffer '2' in Basis 2, also ist es keine gültige Zahl. NaN wird auch angezeigt, wenn Sie versuchen, einen nicht-numerischen Text in eine Zahl umzuwandeln",
                "$~\\'hallo'→#\\"
            ],
            "name": ["$~#", "$~Nummer"],
            "function": {
                "add": {
                    "doc": [
                        "$~Ich füge mir selbst eine @Number mit der gleichen @Unit hinzu und erstelle so eine neue @Number mit der gleichen @Unit.",
                        "$~Zum Beispiel:",
                        "$~\\1 + 1\\",
                        "$~\\3Katze + 5Katze\\",
                        "$~Wenn die Einheiten nicht übereinstimmen, breche ich die Show ab.",
                        "$~\\3Katze + 5Hund\\"
                    ],
                    "names": ["$~+", "$~hinzufügen"],
                    "inputs": [
                        {
                            "doc": "$~Die hinzuzufügende @Nummer.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "subtract": {
                    "doc": [
                        "$~Ich subtrahiere die @Nummer, die Sie mir geben, von mir selbst und erstelle eine neue @Nummer derselben @Einheit.",
                        "$~Zum Beispiel:",
                        "$~\\1 - 1\\",
                        "$~\\3Katze - 5Katze\\",
                        "$~Wenn die Einheiten nicht übereinstimmen, breche ich die Show ab.",
                        "$~\\3Katze - 5Hund\\"
                    ],
                    "names": ["$~-", "$~subtrahieren"],
                    "inputs": [
                        {
                            "doc": "$~Die @Nummer, die von mir abgezogen werden soll.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "multiply": {
                    "doc": [
                        "$~Ich multipliziere mich selbst mit der gegebenen @Number und erstelle ein Produkt aus meiner @Unit und der @Unit der gegebenen Zahl:",
                        "$~\\5 · 5\\",
                        "$~\\5m · 5m\\",
                        "$~\\5m · 1/s\\"
                    ],
                    "names": ["$~·", "$~multiplizieren"],
                    "inputs": [
                        {
                            "doc": "$~Die zu multiplizierende Zahl.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "divide": {
                    "doc": [
                        "$~Ich dividiere mich durch die gegebene @Zahl und erstelle einen Quotienten aus meiner @Einheit und der @Einheit der gegebenen Zahl:",
                        "$~\\5 ÷ 5\\",
                        "$~\\5 m ÷ 5 m\\",
                        "$~\\5m ÷ 5s\\"
                    ],
                    "names": ["÷", "divide"],
                    "inputs": [
                        {
                            "doc": "$~Die @Zahl, durch die ich dividieren soll.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "remainder": {
                    "doc": [
                        "$~Ich dividiere durch die gegebene @Zahl, gebe aber den Rest aus:",
                        "$~\\10 % 2\\",
                        "$~\\10m % 2\\",
                        "$~\\10m/s % 3\\"
                    ],
                    "names": ["$~%", "$~Rest"],
                    "inputs": [
                        {
                            "doc": "$~Die @Zahl, durch die ich dividieren soll.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "positive": {
                    "doc": [
                        "$~Ich erstelle eine neue @Nummer, die mich positiv macht, wenn auch negativ.",
                        "$~\\-200.positive()\\"
                    ],
                    "names": ["$~positiv"],
                    "inputs": []
                },
                "round": {
                    "doc": [
                        "$~Ich erstelle eine neue @Zahl, die auf die nächste Ganzzahl rundet.",
                        "$~\\9.4.round()\\",
                        "$~\\9.5.round()\\",
                        "$~\\9.6.round()\\"
                    ],
                    "names": ["$~runden"],
                    "inputs": []
                },
                "roundDown": {
                    "doc": [
                        "$~Ich erstelle eine neue @Number, die auf die kleinste Ganzzahl rundet, die kleiner ist als ich.",
                        "$~\\10.5.roundDown()\\",
                        "$~\\10.1.roundDown()\\",
                        "$~\\10.01.roundDown()\\"
                    ],
                    "names": ["$~abrunden"],
                    "inputs": []
                },
                "roundUp": {
                    "doc": [
                        "$~Ich erstelle eine neue @Zahl, die auf die kleinste Ganzzahl rundet, die größer ist als ich.",
                        "$~\\10.5.roundUp()\\",
                        "$~\\10.9.roundUp()\\",
                        "$~\\10.99.roundUp()\\"
                    ],
                    "names": ["$~aufrunden"],
                    "inputs": []
                },
                "power": {
                    "doc": [
                        "$~Ich potenziere mich selbst mit der angegebenen @Zahl. Bruchexponenten sind ok!",
                        "$~\\2 ^ 8\\",
                        "$~\\10 ^ -2\\",
                        "$~\\5 ^ -.5\\"
                    ],
                    "names": ["^", "power"],
                    "inputs": [
                        {
                            "doc": "$~Der Exponent, auf den ich erhöht werden soll.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "root": {
                    "doc": [
                        "$~Ich erstelle meine eigene Wurzel unter Verwendung der angegebenen Wurzel.",
                        "$~\\4 √ 2\\",
                        "$~\\1000 √ 3\\"
                    ],
                    "names": ["√", "root"],
                    "inputs": [
                        {
                            "doc": "$~Die zu berechnende Wurzel.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "lessThan": {
                    "doc": [
                        "$~\\⊤\\ wenn ich kleiner bin als die angegebene @Zahl:",
                        "$~\\1 < 2\\",
                        "$~\\2 < 1\\"
                    ],
                    "names": ["<", "lessthan"],
                    "inputs": [
                        {
                            "doc": "$~Die @Nummer, mit der ich mich vergleichen kann.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "lessOrEqual": {
                    "doc": [
                        "$~\\⊤\\ wenn I kleiner oder gleich der angegebenen @Zahl ist:",
                        "$~\\1 ≤ 2\\",
                        "$~\\2 ≤ 1\\",
                        "$~\\2 ≤ 2\\"
                    ],
                    "names": ["≤", "lessorequal"],
                    "inputs": [
                        {
                            "doc": "$~Die @Nummer, mit der ich mich vergleichen kann.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "greaterThan": {
                    "doc": [
                        "$~\\⊤\\ wenn ich größer als die angegebene @Zahl bin:",
                        "$~\\1 > 2\\",
                        "$~\\2 > 1\\"
                    ],
                    "names": [">", "greaterthan"],
                    "inputs": [
                        {
                            "doc": "$~Die @Nummer, mit der ich mich vergleichen kann.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "greaterOrEqual": {
                    "doc": [
                        "$~\\⊤\\ wenn I größer oder gleich der angegebenen @Zahl ist:",
                        "$~\\1 ≥ 2\\",
                        "$~\\2 ≥ 1\\",
                        "$~\\2 ≥ 2\\"
                    ],
                    "names": ["≥", "greaterorequal"],
                    "inputs": [
                        {
                            "doc": "$~Die @Nummer, mit der ich mich vergleichen kann.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "equal": {
                    "doc": [
                        "$~\\⊤\\ wenn I gleich der angegebenen @Zahl ist:",
                        "$~\\1 = 2\\",
                        "$~\\2 = 2\\"
                    ],
                    "names": ["$~=", "$~gleich"],
                    "inputs": [
                        {
                            "doc": "$~Die @Nummer, mit der ich mich vergleichen kann.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "notequal": {
                    "doc": [
                        "$~\\⊤\\ wenn I gleich der angegebenen @Zahl ist:",
                        "$~\\1 ≠ 2\\",
                        "$~\\2 ≠ 2\\"
                    ],
                    "names": ["$~≠", "$~nichtgleich"],
                    "inputs": [
                        {
                            "doc": "$~Die @Nummer, mit der ich mich vergleichen kann.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "cos": {
                    "doc": [
                        "$~Berechnen Sie den Kosinus von mir.",
                        "$~\\π.cos()\\"
                    ],
                    "names": ["cos", "cosine"],
                    "inputs": []
                },
                "sin": {
                    "doc": ["$~Berechnen Sie meinen Sinus.", "$~\\π.cos()\\"],
                    "names": ["sin", "sine"],
                    "inputs": []
                },
                "min": {
                    "doc": [
                        "$~Finde die kleinste Anzahl von mir und anderen.",
                        "$~\\1.min(2 3 -1)\\"
                    ],
                    "names": "$~Mindest",
                    "inputs": [
                        {
                            "doc": "$~So viele Nummern wie du mir geben möchtest!",
                            "names": "$~Zahlen"
                        }
                    ]
                },
                "max": {
                    "doc": [
                        "$~Finden Sie die größte Anzahl von mir und anderen.",
                        "$~\\1.max(2 3 4)\\"
                    ],
                    "names": "$~max",
                    "inputs": [
                        {
                            "doc": "$~So viele Nummern wie du mir geben möchtest!",
                            "names": "$~Zahlen"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Eine arabische @Text-Darstellung meiner Ziffern.",
                "list": [
                    "$~Ich konvertiere eine Zahl in eine Liste von Zahlen von \\1\\ bis zu einer beliebigen angegebenen Zahl. Beispiel:",
                    "$~\\10→[]\\"
                ],
                "s2m": "$~Sekunden bis Minuten",
                "s2h": "$~Sekunden bis Stunden",
                "s2day": "$~Sekunden bis Tage",
                "s2wk": "$~Sekunden bis Wochen",
                "s2year": "$~Sekunden bis Jahre",
                "s2ms": "$~Sekunden in Millisekunden",
                "ms2s": "$~Millisekunden in Sekunden",
                "min2s": "$~Minuten bis Sekunden",
                "h2s": "$~Stunden bis Sekunden",
                "day2s": "$~Tage bis Sekunden",
                "wk2s": "$~Von Wochen bis Sekunden",
                "yr2s": "$~Jahre in Sekunden",
                "m2pm": "$~Meter in Pikometer",
                "m2nm": "$~Meter in Nanometer",
                "m2micro": "$~Meter in Mikrometer",
                "m2mm": "$~Meter in Millimeter",
                "m2cm": "$~Meter in Zentimeter",
                "m2dm": "$~Meter in Dezimeter",
                "m2km": "$~Meter in Kilometer",
                "m2Mm": "$~Meter in Megameter",
                "m2Gm": "$~Meter in Gigameter",
                "m2Tm": "$~Meter in Terameter",
                "pm2m": "$~Pikometer in Meter",
                "nm2m": "$~Nanometer in Meter",
                "micro2m": "$~Mikrometer in Meter",
                "mm2m": "$~Millimeter in Meter",
                "cm2m": "$~Zentimeter in Meter",
                "dm2m": "$~Dezimeter in Meter",
                "km2m": "$~Kilometer in Meter",
                "Mm2m": "$~Megameter in Meter",
                "Gm2m": "$~Gigameter in Meter",
                "Tm2m": "$~Terameter in Meter",
                "km2mi": "$~Kilometer in Meilen",
                "mi2km": "$~Meilen in Kilometer",
                "cm2in": "$~Zentimeter in Zoll",
                "in2cm": "$~Zoll in Zentimeter",
                "m2ft": "$~Meter in Fuß",
                "ft2m": "$~Fuß zu Meter",
                "g2mg": "$~Gramm in Milligramm",
                "mg2g": "$~Milligramm in Gramm",
                "g2kg": "$~Gramm in Kilogramm",
                "kg2g": "$~Kilogramm in Gramm",
                "g2oz": "$~Gramm in Unzen",
                "oz2g": "$~Unzen in Gramm",
                "oz2lb": "$~Unzen in Pfund",
                "lb2oz": "$~Pfund in Unzen"
            }
        },
        "List": {
            "doc": [
                "$~Ich bin eine Abfolge von Werten, gleich welcher Art!",
                "$~Sie können alles in mich eingeben: @Boolean, @Number, @Text, @None, sogar andere @List, @Set, @Map oder beliebige Ausdrücke. Hier ist ein einfacher:",
                "$~\\['Apfel' 'Banane' 'Mango']\\",
                "$~Was mich besonders macht, ist, dass ich Ordnung halte und alles von 1 bis zur Anzahl der Gegenstände in mir nummeriere.",
                "$~Meine Einträge sind nummeriert, beginnend bei 1. Sie können die Werte, die ich mit @ListAccess speichere, anhand ihrer Nummer abrufen:",
                "$~Der zweite Wert in dieser Liste ist beispielsweise \\['banana']\\",
                "$~\\['Apfel' 'Banane' 'Mango'][2]\\",
                "$~Ich kann alles in mir haben. Schau dir diese Liste an, mit @Text, @Nummer und @Zeit!",
                "$~\\['Apfel' 10 + 10 Zeit()]\\",
                "$~Wenn Sie mir eine Liste mit vielen Dingen geben, verallgemeinere ich sie, wenn sie einen gemeinsamen Typ haben. Aber manchmal meinen Sie diese spezifischen Dinge vielleicht wörtlich. Wenn das der Fall ist, setzen Sie einfach ein ! hinter mich und ich stelle sicher, dass ich eine Liste mit genau diesen Werten darstelle.",
                "$~\\['Apfel' 'Banane' 'Mango']!\\",
                "$~Das ist so ziemlich alles. Aber ich kann mit meiner @FunctionDefinition allerlei spannende Dinge aufrufen!"
            ],
            "name": ["$~[]", "$~Aufführen"],
            "kind": "$~Art",
            "out": "$~Ergebnis",
            "outofbounds": "$~außerhalb der Grenzen",
            "function": {
                "add": {
                    "doc": [
                        "$~Ich erstelle eine neue @Liste mit dem angegebenen Element am Ende.",
                        "$~\\['Apfel' 'Banane' 'Mango'].add('Wassermelone')\\"
                    ],
                    "names": ["$~mit", "$~hinzufügen"],
                    "inputs": [
                        {
                            "doc": "$~Ich bin der Wert, den Sie hinzufügen möchten.",
                            "names": "$~Artikel"
                        }
                    ]
                },
                "append": {
                    "doc": [
                        "$~Ich erstelle eine neue @List mit meinen Werten, danach alle Werte der angegebenen @List.",
                        "$~\\['Apfel' 'Banane' 'Mango'].withList(['Wassermelone' 'Sternfrucht'])\\",
                        "$~Es ist jedoch etwas einfacher, @Spread wie folgt zu verwenden:",
                        "$~\\['Apfel' 'Banane' 'Mango' :['Wassermelone' 'Sternfrucht']]\\"
                    ],
                    "names": ["$~mitListe", "$~Anhängen"],
                    "inputs": [
                        {
                            "doc": "$~Die Liste der hinzuzufügenden Werte.",
                            "names": "$~Liste"
                        }
                    ]
                },
                "replace": {
                    "doc": [
                        "$~Ich erstelle eine neue Liste, die den Wert am angegebenen Index durch den angegebenen Wert ersetzt.",
                        "$~\\['Apfel' 'Banane' 'Mango'].replace(1 'Kiwi')\\"
                    ],
                    "names": ["reemplazar"],
                    "inputs": [
                        {
                            "doc": "$~Der Index des zu ersetzenden Wertes",
                            "names": "$~Index"
                        },
                        {
                            "doc": "$~Der Wiederbeschaffungswert",
                            "names": "$~Wert"
                        }
                    ]
                },
                "length": {
                    "doc": "$~Die @Anzahl der Elemente in mir.",
                    "names": ["$~📏", "$~Länge"],
                    "inputs": []
                },
                "random": {
                    "doc": [
                        "$~Eine zufällig ausgewählte Option aus meinen Artikeln oder @Keine, wenn ich keine habe.",
                        "$~\\['Apfel' 'Banane' 'Mango'].random()\\"
                    ],
                    "names": "$~zufällig",
                    "inputs": []
                },
                "shuffled": {
                    "doc": [
                        "$~Erstellen Sie eine neue Liste mit den Artikeln in der letzten zufälligen Reihenfolge.",
                        "$~\\['Apfel' 'Banane' 'Mango'].shuffled()\\"
                    ],
                    "names": "$~gemischt",
                    "inputs": []
                },
                "first": {
                    "doc": [
                        "$~Das erste Element in mir oder @None, wenn ich leer bin.",
                        "$~\\['Apfel' 'Banane' 'Mango'].first()\\"
                    ],
                    "names": "$~Erste",
                    "inputs": []
                },
                "last": {
                    "doc": [
                        "$~Das letzte Element in mir oder @None, wenn ich leer bin.",
                        "$~\\['Apfel' 'Banane' 'Mango'].first()\\"
                    ],
                    "names": "$~zuletzt",
                    "inputs": []
                },
                "has": {
                    "doc": [
                        "$~\\⊤\\, wenn ich einen Gegenstand in mir habe, der dem angegebenen Gegenstand entspricht.",
                        "$~\\['Apfel' 'Banane' 'Mango'].hat('Banane')\\"
                    ],
                    "names": "$~hat",
                    "inputs": [
                        {
                            "doc": "$~Der zu suchende Wert.",
                            "names": "$~Artikel"
                        }
                    ]
                },
                "join": {
                    "doc": [
                        "$~Ich füge die Elemente meiner Liste zu @Text zusammen, getrennt durch das angegebene Trennzeichen @Text.",
                        "$~\\['Apfel' 'Banane' 'Mango'].join(', ')\\"
                    ],
                    "names": "$~verbinden",
                    "inputs": [
                        {
                            "doc": "$~Der Text, durch den die Elemente getrennt werden sollen, optional leer.",
                            "names": "$~Separator"
                        }
                    ]
                },
                "subsequence": {
                    "doc": [
                        "$~Ich erhalte eine Liste innerhalb dieser Liste, die mit dem von Ihnen angegebenen Index beginnt und mit dem letzten Element oder, falls Sie eines angeben, einem bestimmten Element endet.",
                        "$~\\['Apfel' 'Banane' 'Mango'].subsequence(2)\\",
                        "$~\\['Apfel' 'Banane' 'Mango'].subsequence(1 2)\\",
                        "$~Und siehe da! Wenn du Zahlen in der falschen Reihenfolge angibst, gebe ich dir die umgekehrte",
                        "$~\\['Apfel' 'Banane' 'Mango'].subsequence(3 1)\\",
                        "$~Wenn Sie mir als Index einen Wert kleiner als 1 nennen, gehe ich davon aus, dass Sie 1 meinen.",
                        "$~\\['Apfel' 'Banane' 'Mango'].subsequence(-1003243 2)\\",
                        "$~Und wenn Sie mir etwas geben, das größer ist als der größte Index, gehe ich davon aus, dass Sie das Ende meinen.",
                        "$~\\['Apfel' 'Banane' 'Mango'].subsequence(3 2304032432)\\"
                    ],
                    "names": "$~Folge",
                    "inputs": [
                        {
                            "doc": "$~Der Index des ersten Elements der gewünschten Teilsequenz.",
                            "names": "$~Start"
                        },
                        {
                            "doc": "$~Der optionale Index des letzten Elements der gewünschten Teilsequenz. Wenn Sie keinen angeben, endet Ihre Liste mit dem letzten Element in der Liste.",
                            "names": "$~Ende"
                        }
                    ]
                },
                "sansFirst": {
                    "doc": [
                        "$~Ich erstelle eine Liste ohne mein erstes Element.",
                        "$~\\['Apfel' 'Banane' 'Mango'].sansFirst()\\"
                    ],
                    "names": ["$~ohneVor", "$~sansFirst"],
                    "inputs": []
                },
                "sansLast": {
                    "doc": [
                        "$~Ich erstelle eine Liste ohne mein letztes Element.",
                        "$~\\['Apfel' 'Banane' 'Mango'].sansLast()\\"
                    ],
                    "names": ["$~ohneLetzte", "$~sansLast"],
                    "inputs": []
                },
                "sans": {
                    "doc": [
                        "$~Ich, aber ohne die ersten Vorkommen des angegebenen Wertes.",
                        "$~\\['Apfel' 'Banane' 'Mango' 'Apfel'].sans('Apfel')\\"
                    ],
                    "names": ["$~ohne", "$~ohne"],
                    "inputs": [
                        {
                            "doc": "$~Der Wert, dessen erstes Vorkommen entfernt werden soll.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "sansAll": {
                    "doc": [
                        "$~Ich, aber ohne alle Vorkommen des angegebenen Wertes.",
                        "$~\\['Apfel' 'Banane' 'Mango' 'Apfel'].sans('Apfel')\\"
                    ],
                    "names": ["$~ohneAlle", "$~sansAlle"],
                    "inputs": [
                        {
                            "doc": "$~Der Wert, dessen Vorkommen vollständig aus der Liste entfernt werden sollen.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "reverse": {
                    "doc": [
                        "$~Ich, aber umgekehrt!",
                        "$~\\['Apfel' 'Banane' 'Mango'].reverse()\\"
                    ],
                    "names": ["$~umgedreht", "$~umkehren"],
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "$~\\⊤\\, wenn meine Artikel und meine Bestellung genau mit der angegebenen @Liste übereinstimmen.",
                        "$~\\['Apfel' 'Banane' 'Mango'] = ['Apfel' 'Mango' 'Banane']\\"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "$~Die @Liste, mit der ich mich vergleichen kann.",
                            "names": "$~Liste"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "$~\\⊤\\ wenn meine Artikel und meine Reihenfolge /nicht/ genau mit der angegebenen @Liste übereinstimmen.",
                        "$~\\['Apfel' 'Banane' 'Mango'] ≠ ['Apfel' 'Mango' 'Banane']\\"
                    ],
                    "names": ["$~≠", "$~nichtgleich"],
                    "inputs": [
                        {
                            "doc": "$~Die @Liste, mit der ich mich vergleichen kann.",
                            "names": "$~Liste"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "$~Geben Sie mir eine @FunctionDefinition, die einen Wert und einen optionalen Index als Eingabe verwendet und einen Wert erzeugt. Ich werde ihn dann für jedes meiner Elemente auswerten und meine Werte in neue Werte umwandeln.",
                        "$~Stellen Sie sich beispielsweise vor, ich wäre eine Liste mit @Nummern und Sie wollten alle verdoppeln:",
                        "$~\\[2 4 6 8].translate(ƒ(Zahl•#) Zahl · 2)\\"
                    ],
                    "names": "$~übersetzen",
                    "inputs": [
                        {
                            "doc": "$~Die @FunctionDefinition, die jedes Element übersetzt.",
                            "names": "$~Übersetzer"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "$~Das Element, das übersetzt wird.",
                            "names": "$~Artikel"
                        },
                        {
                            "doc": "$~Der Index des zu übersetzenden Elements.",
                            "names": "$~Index"
                        },
                        {
                            "doc": "$~Die Liste wird übersetzt.",
                            "names": "$~Liste"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "$~Geben Sie mir eine @FunctionDefinition, die einen Wert und einen optionalen Index als Eingabe verwendet und einen @Boolean erzeugt, und ich erstelle eine neue Liste, die nur die Elemente enthält, die sich als \\⊤\\ ergeben.",
                        "$~Stellen Sie sich zum Beispiel vor, ich wäre eine Liste mit @Zahlen und Sie wollten nur die positiven:",
                        "$~\\[2 -4 8 -16].filter(ƒ(Anzahl•#) Zahl ≥ 0)\\"
                    ],
                    "names": "$~Filter",
                    "inputs": [
                        {
                            "doc": "$~Eine @FunctionDefinition, die jedes Element prüft und \\⊤\\ ausgibt, wenn es beibehalten werden soll.",
                            "names": "$~Prüfer"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~Der Artikel wird geprüft.",
                            "names": "$~Artikel"
                        },
                        {
                            "doc": "$~Der Index des zu prüfenden Elements.",
                            "names": "$~Index"
                        },
                        {
                            "doc": "$~Die Liste wird gefiltert.",
                            "names": "$~Liste"
                        }
                    ]
                },
                "all": {
                    "doc": [
                        "$~Geben Sie mir eine @FunctionDefinition, die einen Wert als Eingabe verwendet und einen @Boolean erzeugt, wenn er eine bestimmte Bedingung erfüllt. Ich erstelle \\⊤\\, wenn alle Elemente die Bedingung erfüllen.",
                        "$~Stellen Sie sich beispielsweise vor, ich wäre eine Liste mit @Nummern und Sie wollten wissen, ob alles positiv ist:",
                        "$~\\[2 -4 8 -16].alle(ƒ(Anzahl•#) Zahl ≥ 0)\\"
                    ],
                    "names": "$~alle",
                    "inputs": [
                        {
                            "doc": "$~Die @FunctionDefinition, die \\⊤\\ erzeugt, wenn ein Element Ihre Bedingung erfüllt.",
                            "names": "$~Prüfer"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~Der Artikel wird geprüft.",
                            "names": "$~Artikel"
                        },
                        {
                            "doc": "$~Der Index des zu prüfenden Elements.",
                            "names": "$~Index"
                        },
                        {
                            "doc": "$~Die Liste wird geprüft.",
                            "names": "$~Liste"
                        }
                    ]
                },
                "until": {
                    "doc": [
                        "$~Geben Sie mir eine @FunctionDefinition, die einen Wert als Eingabe verwendet und einen @Boolean erzeugt, wenn er eine bestimmte Bedingung erfüllt. Ich erstelle eine neue @List, die alle Elemente enthält, bis die Bedingung nicht mehr erfüllt ist.",
                        "$~Stellen Sie sich beispielsweise vor, ich wäre eine Liste von @Text-Tieren und Sie wollten alles bis zum Eintrag \\'Ratte'\\:",
                        "$~\\['Katze' 'Hund' 'Ratte' 'Maus' 'Pony'].until(ƒ(Tier•'') Tier = 'Ratte')\\"
                    ],
                    "names": "$~bis",
                    "inputs": [
                        {
                            "doc": "$~Die @FunctionDefinition, die \\⊤\\ erzeugt, wenn ich die Einbeziehung von Elementen beenden soll.",
                            "names": "$~Prüfer"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~Der Artikel wird geprüft.",
                            "names": "$~Artikel"
                        },
                        {
                            "doc": "$~Der Index des zu prüfenden Elements.",
                            "names": "$~Index"
                        },
                        {
                            "doc": "$~Die Liste wird weiter sequenziert.",
                            "names": "$~Liste"
                        }
                    ]
                },
                "find": {
                    "doc": [
                        "$~Geben Sie mir eine @FunctionDefinition, die einen Wert als Eingabe verwendet und einen @Boolean erzeugt, wenn dieser bestimmten Kriterien entspricht. Ich werde dann das passende Element auswerten.",
                        "$~Stellen Sie sich beispielsweise vor, Sie möchten das erste Tier finden, das den Vokal \\'e\\ hat:",
                        "$~\\['Katze' 'Hund' 'Ratte' 'Maus' 'Pony'].find(ƒ(Tier•'') Tier.hat('e'))\\"
                    ],
                    "names": "$~finden",
                    "inputs": [
                        {
                            "doc": "$~Die @FunctionDefinition, die \\⊤\\ erzeugt, wenn sie Ihren Suchkriterien entspricht.",
                            "names": "$~Prüfer"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~Der Artikel wird geprüft.",
                            "names": "$~Artikel"
                        },
                        {
                            "doc": "$~Der Index des zu prüfenden Elements.",
                            "names": "$~Index"
                        },
                        {
                            "doc": "$~Die Liste, die durchsucht wird.",
                            "names": "$~Liste"
                        }
                    ]
                },
                "combine": {
                    "doc": [
                        "$~Geben Sie mir eine @FunctionDefinition, die die letzte Kombination und einen nächsten Wert verwendet und eine nächste Kombination erstellt. Ich bewege mich dann vom ersten bis zum letzten meiner Elemente, erstelle aufeinanderfolgende Kombinationen und werte die Ergebnisse bis zur endgültigen Kombination aus, die Ihre @FunctionDefinition ergibt.",
                        "$~Dies ist sehr hilfreich, um alle Elemente in mir zu einem einzigen Wert zu kombinieren. Stellen Sie sich beispielsweise vor, Sie möchten eine Liste von Zahlen hinzufügen:",
                        "$~\\[3 9 2 8 1 4].kombiniere(0 ƒ(Summe•# Zahl•#) Summe + Zahl)\\"
                    ],
                    "names": "$~kombinieren",
                    "inputs": [
                        {
                            "doc": "$~Die Startkombination.",
                            "names": "$~anfänglich"
                        },
                        {
                            "doc": "$~Die @FunctionDefinition, die die letzte Kombination und den nächsten Wert nimmt und die nächste Kombination erzeugt.",
                            "names": "$~Kombinierer"
                        }
                    ],
                    "combiner": [
                        {
                            "doc": "$~Die aktuelle Kombination",
                            "names": "$~Kombination"
                        },
                        {
                            "doc": "$~Das nächste zu kombinierende Element.",
                            "names": "$~nächste"
                        },
                        {
                            "doc": "$~Der Index des nächsten Elements",
                            "names": "$~Index"
                        },
                        {
                            "doc": "$~Die Liste wird kombiniert.",
                            "names": "$~Liste"
                        }
                    ]
                },
                "sorted": {
                    "doc": [
                        "$~Ich kann eine Liste nehmen und eine neue Liste mit sortierten Werten erstellen. So:",
                        "$~\\[1 5 8 0 2].sortiert()\\",
                        "$~Ich kann es auch für @Text-Werte tun",
                        "$~\\['Orange' 'Kiwi' 'Banane' 'Apfel'].sortiert()\\",
                        "$~Und wenn Sie eine Liste mit Werten haben, die weder @Number noch @Text sind, können Sie mir eine @FunctionDefinition geben, die jedes Element in eine @Number umwandelt, damit ich es sortieren kann. Hier haben wir beispielsweise eine Liste mit Listen unterschiedlicher Länge. Wenn Sie mir eine Funktion geben, die jede Liste in ihre Länge umwandelt, kann ich nach ihrer Länge sortieren.",
                        "$~\\[[1] [2 3] [4 8 12] [8]].sortiert(ƒ(Liste) Liste.Länge())\\"
                    ],
                    "names": "$~sortiert",
                    "inputs": [
                        {
                            "doc": "$",
                            "names": "$~Sequenzer"
                        }
                    ],
                    "sequencer": [
                        {
                            "doc": "$~Der Wert, der in eine @Nummer umgewandelt werden soll.",
                            "names": "$~Wert"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Zu einer @Text-Darstellung der Liste.",
                "set": "$~Zu einem @Set, hilfreich zum Entfernen von Duplikaten."
            }
        },
        "Set": {
            "doc": [
                "$~Ich bin eine Menge von Werten! Das heißt, ich kann eine beliebige Anzahl von Werten enthalten, auch keine Werte. Sie können mich folgendermaßen gestalten:",
                "$~\\{1 2 3}\\",
                "$~Ich bin wirklich gut, wenn Sie eine Sammlung von Dingen ohne Duplikate aufbewahren möchten.",
                "$~Das heißt, wenn Sie mir Werte geben, die ich bereits habe, ignoriere ich die Extras.",
                "$~Dieses Set enthält beispielsweise viele Duplikate:",
                "$~\\{1 1 2 2 3 3}\\",
                "$~Ich bewerte es einfach als \\{1 2 3}\\.",
                "$~Wenn Sie sehen möchten, ob ein Wert in mir steckt, kann @SetOrMapAccess helfen:",
                "$~\\{'Glas' 'Flasche' 'Glas'}{'Tasse'}\\",
                "$~Wenn Sie mir eine Reihe von Werten eines gemeinsamen Typs geben, gehe ich normalerweise davon aus, dass es sich um eine Liste dieses Typs handelt. Beispielsweise ist dieser Satz \\{''}\\, weil er komplett aus @Text besteht.",
                "$~\\{'hey' 'hi' 'hallo'}\\",
                "$~Sie möchten aber vielleicht angeben, dass ich /nur/ diese Werte habe, damit ich Ihnen sagen kann, wenn Sie versuchen, einen nicht zulässigen Wert zu verwenden. Fügen Sie in diesem Fall einfach ein ! am Ende von „me“ hinzu.",
                "$~\\{'hey' 'hi' 'hallo'}!{'yo'}\\",
                "$~Gibt es noch etwas, das du mit mir machen möchtest? Sieh dir all die tollen @FunctionDefinition an, die ich habe!"
            ],
            "name": ["$~{}", "$~Satz"],
            "kind": "$~Art",
            "out": "$~Ergebnis",
            "function": {
                "size": {
                    "doc": "$~Ich sage Ihnen, wie viele Werte in mir stecken.",
                    "names": "$~Größe",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "$~Ich bin \\⊤\\, wenn das gegebene @Set und ich genau die gleichen Werte haben:",
                        "$~\\{1 2 3} = {2 3 4}\\"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "$~Das zu vergleichende @Set.",
                            "names": "$~Satz"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "$~Ich bin \\⊤\\, wenn das gegebene @Set und ich nicht die exakt gleichen Werte haben:",
                        "$~\\{1 2 3} ≠ {2 3 4}\\"
                    ],
                    "names": ["$~≠", "$~nichtgleich"],
                    "inputs": [
                        {
                            "doc": "$~Das zu vergleichende @Set.",
                            "names": "$~Satz"
                        }
                    ]
                },
                "add": {
                    "doc": [
                        "$~Geben Sie mir einen Artikel zum Hinzufügen und ich erstelle ein neues @Set mit meinen Artikeln und dem angegebenen Artikel.",
                        "$~\\{1 2 3} + 4\\"
                    ],
                    "names": ["add", "+"],
                    "inputs": [
                        {
                            "doc": "$~Das hinzuzufügende Element",
                            "names": "$~Artikel"
                        }
                    ]
                },
                "remove": {
                    "doc": [
                        "$~Geben Sie mir ein Element zum Entfernen und ich erstelle ein neues @Set ohne das Element.",
                        "$~\\{1 2 3} - 2\\",
                        "$~Wenn ich den Artikel nicht habe, bewerte ich ihn einfach selbst."
                    ],
                    "names": ["remove", "-"],
                    "inputs": [
                        {
                            "doc": "$~Das zu entfernende Element.",
                            "names": "$~Artikel"
                        }
                    ]
                },
                "union": {
                    "doc": [
                        "$~Geben Sie mir @Set und ich erstelle ein neues @Set, das meine Elemente und die Elemente des Sets enthält.",
                        "$~\\{1 2 3} ∪ {3 4 5}\\"
                    ],
                    "names": ["union", "∪"],
                    "inputs": [
                        {
                            "doc": "$~Das @Set zum Kombinieren mit mir.",
                            "names": "$~Satz"
                        }
                    ]
                },
                "intersection": {
                    "doc": [
                        "$~Geben Sie mir @Set und ich erstelle ein neues @Set, das nur die Elemente enthält, die wir gemeinsam haben.",
                        "$~\\{1 2 3} ∩ {3 4 5}\\"
                    ],
                    "names": ["intersection", "∩"],
                    "inputs": [
                        {
                            "doc": "$~Das Set zum Vergleichen mit mir.",
                            "names": "$~Satz"
                        }
                    ]
                },
                "difference": {
                    "doc": [
                        "$~Geben Sie mir @Set und ich erstelle ein neues @Set, das nur die Elemente enthält, die wir gemeinsam haben.",
                        "$~\\{1 2 3}.Differenz({3 4 5})\\"
                    ],
                    "names": "$~Unterschied",
                    "inputs": [
                        {
                            "doc": "$~Das Set, dessen Elemente von mir entfernt werden sollen.",
                            "names": "$~Satz"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "$~Geben Sie mir eine @FunctionDefinition, die ein Element annimmt und \\⊤\\ erzeugt, wenn es behalten werden soll, und ich erstelle ein @Set, das nur die Elemente enthält, die Ihren Kriterien entsprechen.",
                        "$~Lassen Sie uns zum Beispiel die ungeraden Zahlen in mir finden:",
                        "$~\\{1 2 3 4 5 6 7 8 9}.filter(ƒ(Anzahl•#) (Anzahl % 2) = 1)\\"
                    ],
                    "names": "filter",
                    "inputs": [
                        {
                            "doc": "$~Die @FunctionDefinition, die ein Element überprüft, um festzustellen, ob es behalten werden soll.",
                            "names": "$~Prüfer"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~Der Artikel wird geprüft.",
                            "names": "$~Wert"
                        },
                        {
                            "doc": "$~Der zu filternde Satz",
                            "names": "$~Satz"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "$~Geben Sie mir eine @FunctionDefinition, die ein Element nimmt und darauf basierend ein neues Element erstellt. Anschließend übersetze ich alle Elemente in mir in ein neues @Set (und entferne dabei alle Duplikate).",
                        "$~Lassen Sie uns beispielsweise alle meine @Zahlen in @Text umwandeln:",
                        "$~\\{1 2 3 4 5 6 7 8 9}.translate(ƒ(Zahl•#) Zahl→'')\\"
                    ],
                    "names": "translate",
                    "inputs": [
                        {
                            "doc": "$~Die @FunctionDefinition, die eines meiner Elemente in das gewünschte neue Element übersetzt.",
                            "names": "$~Satz"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "$~Das Element, das übersetzt wird.",
                            "names": "$~Wert"
                        },
                        {
                            "doc": "$~Der zu übersetzende Satz",
                            "names": "$~Satz"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Eine @Text-Darstellung eines @Set",
                "list": "$~Eine @List-Darstellung der Elemente im Set."
            }
        },
        "Map": {
            "doc": [
                "$~Ich bringe Werte zusammen, indem ich *Schlüssel* auf *Werte* abbilde. Zum Beispiel:",
                "$~\\{'amy': 6 Punkte 'tony': 3 Punkte 'shiela': 8 Punkte}\\",
                "$~Meine Schlüssel können beliebige Werte haben und meine Werte können beliebige Werte haben.",
                "$~Manche Leute stellen mich gerne als eine Art Index oder Wörterbuch vor: Sie geben mir etwas und ich gebe Ihnen die Zuordnung.",
                "$~Wenn Sie überprüfen möchten, worauf etwas abgebildet ist, können Sie @SetOrMapAccess einen Schlüssel geben und Sie erhalten den Wert:",
                "$~\\{'amy': 6 Punkte 'tony': 3 Punkte 'shiela': 8 Punkte}{'amy'}\\",
                "$~Wenn es keinen passenden Schlüssel gibt, gebe ich Ihnen @None.",
                "$~\\{'amy': 6 Punkte 'tony': 3 Punkte 'shiela': 8 Punkte}{'jen'}\\",
                "$~Sie können auch eine leere Karte wie folgt erstellen:",
                "$~\\{:}\\",
                "$~Normalerweise sehe ich mir die Schlüssel und Werte an, die Sie mir geben, und denke mir einen Typ aus, der sie alle repräsentiert. So sieht eine Zuordnung von Zahlen zu Zahlen aus:",
                "$~\\{1:1 2:2 3:3}\\",
                "$~Angenommen, Sie möchten sicherstellen, dass es sich ausschließlich um diese Werte handelt, fügen Sie am Ende von „me“ einfach ein ! hinzu, und ich verallgemeinere nicht. So können Sie erkennen, ob Sie einen Wert abrufen möchten, den Sie nicht beabsichtigt haben.",
                "$~\\{1:1 2:2 3:3}!{4}\\",
                "$~Ich kann mit meinen Paarungen viele wunderbare Dinge erreichen."
            ],
            "name": ["$~{:}", "$~Karte"],
            "key": "$~Schlüssel",
            "value": "$~Wert",
            "result": "$~Ergebnis",
            "function": {
                "size": {
                    "doc": "$~Ich sage Ihnen, wie viele Werte in mir stecken.",
                    "names": "$~Größe",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "$~\\{⊤}\\, wenn meine Paarungen genau dieselben sind wie die angegebenen @Maps.",
                        "$~\\{1:1 2:2} = {1:1 2:3}\\"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "$~Die @Map zum Vergleichen.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "$~\\{⊤}\\ wenn meine Paarungen /nicht/ genau dieselben sind wie die der angegebenen @Maps.",
                        "$~\\{1:1 2:2} ≠ {1:1 2:3}\\"
                    ],
                    "names": ["$~≠", "$~nichtgleich"],
                    "inputs": [
                        {
                            "doc": "$~Die @Map zum Vergleichen.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "set": {
                    "doc": [
                        "$~Ich erstelle eine neue @Map mit denselben Paarungen, aber mit der neuen Paarung, die Sie mir geben. Wenn ich den Schlüssel bereits habe, kopple ich ihn mit dem neuen Wert.",
                        "$~\\{'amy': 6 Punkte 'tony':3 Punkte}.pair('jen' 0 Punkte)\\"
                    ],
                    "names": "$~Paar",
                    "inputs": [
                        {
                            "doc": "$~Schlüssel zum Koppeln mit einem Wert.",
                            "names": "$~Schlüssel"
                        },
                        {
                            "doc": "$~Der mit dem Schlüssel zu koppelnde Wert",
                            "names": "$~Wert"
                        }
                    ]
                },
                "unset": {
                    "doc": [
                        "$~Ich erstelle eine neue @Map ohne den Schlüssel, den Sie mir geben, und entferne die Kopplung.",
                        "$~\\{'amy': 6 Punkte 'tony':3 Punkte}.unpair('amy')\\"
                    ],
                    "names": "$~Paarungaufheben",
                    "inputs": [
                        {
                            "doc": "$~Der Schlüssel zum Vergessen.",
                            "names": "$~Schlüssel"
                        }
                    ]
                },
                "remove": {
                    "doc": [
                        "$~Ich erstelle eine neue @Map ohne Schlüssel, die den Wert haben.",
                        "$~\\{'amy': 0 Punkte 'jen': 0 Punkte 'tony':3 Punkte}.entfernen(0 Punkte)\\"
                    ],
                    "names": "$~entfernen",
                    "inputs": [
                        {
                            "doc": "$~Der von mir zu entfernende Wert, zusammen mit allen Schlüsseln, mit denen er gekoppelt ist.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "$~Geben Sie mir eine @FunctionDefinition, die einen Schlüssel und einen Wert annimmt und als \\⊤\\ auswertet, wenn eine Paarung beibehalten werden soll. Ich erstelle eine neue @Map, die Ihren Kriterien entspricht.",
                        "$~Hier möchten wir beispielsweise alle Paarungen behalten, die Amy sind oder mehr als null Punkte haben.",
                        "$~\\{'amy': 0 Punkte 'jen': 0 Punkte 'tony':3 Punkte}.filter(ƒ(Schlüssel•'' Wert•#Punkte) (Schlüssel = 'amy') | (Wert > 0 Punkte))\\"
                    ],
                    "names": "filter",
                    "inputs": [
                        {
                            "doc": "$~Die @FunctionDefinition, die entscheidet, ob eine Paarung beibehalten wird.",
                            "names": "$~Prüfer"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~Der Schlüssel wird überprüft.",
                            "names": "$~Schlüssel"
                        },
                        {
                            "doc": "$~Der Wert, der überprüft wird.",
                            "names": "$~Wert"
                        },
                        {
                            "doc": "$~Die Karte wird gefiltert.",
                            "names": "$~Karte"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "$~Geben Sie mir eine @FunctionDefinition, die einen Schlüssel und einen Wert annimmt und den Wert in einen neuen Wert umwandelt. Ich erstelle eine neue @Map mit denselben Schlüsseln, aber aktualisierten Werten.",
                        "$~Geben wir beispielsweise jedem einen Punkt, weil er so nett war.",
                        "$~\\{'amy': 5 Punkte 'jen': 3 Punkte 'tony': 0 Punkte}.translate(ƒ(Schlüssel•'' Wert•#Punkte) Wert + 1 Punkt)\\"
                    ],
                    "names": "translate",
                    "inputs": [
                        {
                            "doc": "$~Die @FunctionDefinition, die jeden Wert übersetzt.",
                            "names": "$~Übersetzer"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "$~Der Schlüssel des zu übersetzenden Werts.",
                            "names": "$~Schlüssel"
                        },
                        {
                            "doc": "$~Der zu übersetzende Wert.",
                            "names": "$~Wert"
                        },
                        {
                            "doc": "$~Die Karte wird übersetzt.",
                            "names": "$~Karte"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Eine @Text-Darstellung der Zuordnung.",
                "set": "$~Die Schlüssel der @Map",
                "list": "$~Eine Liste der Werte in der @Map"
            }
        },
        "Table": {
            "doc": [
                "$~Ich bin eine Reihe von Tabellenzeilen! Ich kann Ihnen dabei helfen, große Wertesammlungen mit derselben Struktur zu verfolgen.",
                "$~Stellen Sie sich beispielsweise vor, Sie möchten den Überblick über eine Reihe von Steinen behalten:",
                "$~\\⎡Name•'' Farbe•''⎦\n⎡'Obsidian' 'schwarz'⎦\n⎡'Bimsstein' 'grau'⎦\n⎡'Citrin' 'gelb'⎦\\",
                "$~@Bind kann Ihnen beim Benennen helfen! Und dann können Sie beispielsweise eine überarbeitete Tabelle mit einer neuen Zeile erstellen @Insert:",
                "$~\\Gesteine: ⎡Name•'' Farbe•''⎦\n⎡'Obsidian' 'schwarz'⎦\n⎡'Bimsstein' 'grau'⎦\n⎡'Citrin' 'gelb'⎦\nGesteine ⎡+ 'Quarz' 'weiß'⎦\\",
                "$~Wenn Sie übereinstimmende Zeilen suchen, können Sie mit @Select Zeilen auswählen, die einer Bedingung entsprechen:",
                "$~\\Steine: ⎡Name•'' Farbe•''⎦\n⎡'Obsidian' 'schwarz'⎦\n⎡'Bimsstein' 'grau'⎦\n⎡'Citrin' 'gelb'⎦\nSteine ⎡?⎦ Farbe = 'grau'\\",
                "$~Oder Sie möchten möglicherweise eine überarbeitete Tabelle erstellen, die für Zeilen, die eine Bedingung erfüllen, andere Werte enthält:",
                "$~\\Steine: ⎡Name•'' Farbe•''⎦\n⎡'Obsidian' 'schwarz'⎦\n⎡'Bimsstein' 'grau'⎦\n⎡'Citrin' 'gelb'⎦\nSteine ⎡: Farbe: 'schwarz' ⎦ Name = 'Bimsstein'\\",
                "$~Oder Sie möchten möglicherweise Zeilen löschen, die einer Bedingung entsprechen:",
                "$~\\rocks: ⎡name•'' farbe•''⎦\n⎡'Obsidian' 'schwarz'⎦\n⎡'Bimsstein' 'grau'⎦\n⎡'Citrin' 'gelb'⎦\nrocks ⎡- name.has('i')\\",
                "$~Und wenn Sie jemals bestimmte Werte von mir erhalten möchten, können Sie jede Tabelle in eine Liste umwandeln und mit @PropertyReference auf einzelne Zeilen zugreifen",
                "$~\\rocks: ⎡Name•'' Farbe•''⎦\n⎡'Obsidian' 'schwarz'⎦\n⎡'Bimsstein' 'grau'⎦\n⎡'Citrin' 'gelb'⎦\n(rocks → [])[1].name\\"
            ],
            "name": ["$~⎡⎦", "$~Tisch"],
            "row": "$~Reihe",
            "function": {
                "equals": {
                    "doc": "$~Ich überprüfe, ob ich genau dieselben Zellen in genau derselben Reihenfolge wie eine andere @Tabelle habe.",
                    "names": ["$~=", "$~istgleich"],
                    "inputs": [
                        {
                            "doc": "$~Die andere zu prüfende Tabelle.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "notequal": {
                    "doc": "$~Ich überprüfe, ob meine Zellen anders sind oder eine andere Reihenfolge als eine andere @Tabelle aufweisen.",
                    "names": ["$~≠", "$~nichtgleich"],
                    "inputs": [
                        {
                            "doc": "$~Die andere zu prüfende Tabelle.",
                            "names": "$~Wert"
                        }
                    ]
                }
            },
            "conversion": {
                "list": "$~Ich konvertiere eine @Table in eine Liste von Zeilen, wobei jede Zeile eine @Structure mit ihren Spaltennamen als Eigenschaften ist.",
                "text": "$~Ich konvertiere einfach eine @Tabelle in Text."
            }
        },
        "Structure": {
            "doc": "$~Siehe @StructureDefinition.",
            "name": ["$~Struktur"],
            "function": {
                "equals": {
                    "doc": "$~Ich überprüfe, ob meine Eigenschaften dieselben Namen und Werte haben wie die Eigenschaften einer anderen Struktur.",
                    "names": ["$~=", "$~istgleich"],
                    "inputs": [
                        {
                            "doc": "$~Die andere zu prüfende Struktur.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "notequal": {
                    "doc": "$~Ich überprüfe, ob sich meine Eigenschaften hinsichtlich Name und Werten in irgendeiner Weise von denen einer anderen Struktur unterscheiden.",
                    "names": ["$~≠", "$~nichtgleich"],
                    "inputs": [
                        {
                            "doc": "$~Die andere zu prüfende Struktur.",
                            "names": "$~Wert"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Ich konvertiere zu @Text."
            }
        }
    },
    "input": {
        "Random": {
            "doc": [
                "$~17!",
                "$~/@FunctionDefinition hier, ich werde das erklären./",
                "$~@Random ist also eine interessante Funktion, die Zufallszahlen erzeugt. Das ist deshalb so interessant, weil bei jeder Auswertung etwas anderes entsteht.",
                "$~Dadurch entsteht ein wunderbares Chaos, das mit Unvorhersehbarkeit einhergeht.",
                "$~Standardmäßig werden @Number-Werte zwischen \\0\\ und \\1\\ ausgegeben:",
                "$~\\Zufällig()\\",
                "$~Sie können ihm jedoch einen Wert zuweisen, und es werden Werte zwischen \\0\\ und dem folgenden Wert generiert:",
                "$~\\Zufällig(10)\\",
                "$~Wenn Sie zwei Werte eingeben, werden Werte zwischen diesen beiden Werten generiert:",
                "$~\\Zufall(-10 10)\\",
                "$~Wenn Ihre Bereiche Einheiten haben, bleiben diese erhalten (und wenn sie nicht übereinstimmen, wird die Einheit des Minimums verwendet):",
                "$~\\Zufall(-10m 10m)\\",
                "$~Und wenn Sie Zahlen mit einer bestimmten Anzahl signifikanter Ziffern nach dem Komma angeben, bleibt diese Genauigkeit erhalten.",
                "$~\\Zufällig(1,00 10,00)\\"
            ],
            "names": ["$~🎲", "$~Zufällig"],
            "inputs": [
                {
                    "names": "$~Mindest",
                    "doc": "$~Der Mindestwert, der erstellt wird, oder, wenn er größer als 0 ist, der Höchstwert. Wenn @None angegeben ist, ist der Mindestwert \\0\\."
                },
                {
                    "names": "$~max",
                    "doc": "$~Der maximale Wert, der erstellt wird, oder, wenn er kleiner als der angegebene Mindestwert ist, der Mindestwert. Wenn @None angegeben ist, ist der Höchstwert \\1\\."
                }
            ]
        },
        "Choice": {
            "doc": [
                "$~/Klick, tipp!/",
                "$~/@FunctionDefinition hier, ich werde das erklären./",
                "$~Stellen Sie sich @Choice wie einen Stream von @Phrase/Namen vor, die von Ihrem Publikum ausgewählt werden. Wenn jemand auf eine @Phrase mit einem Namen klickt, tippt oder sie mit der Tastatur auswählt, indem er /Enter/ drückt, hat @Choice einen neuen Wert, der dem Namen entspricht.",
                "$~Die beste Möglichkeit, es zu verwenden, besteht darin, eine Performance mit benannten auswählbaren Phrasen @Phrase zu erstellen und dann mithilfe einer @Reaktion zu entscheiden, was zu tun ist, wenn dieser Name ausgewählt wird.",
                "$~Hier ist das einfachste Beispiel:",
                "$~\\Group(\nStack() \n[\nPhrase('eins' wählbar:⊤ Name:'1') \nPhrase('zwei' wählbar:⊤ Name:'2') \nPhrase(Choice())\n]\n)\\",
                "$~Kopieren Sie dies in den Editor und wählen Sie dann eine der beiden @Phrase aus. Sie werden sehen, dass die dritte @Phrase den ausgewählten Namen anzeigt."
            ],
            "names": ["$~🔘", "$~Auswahl"]
        },
        "Button": {
            "doc": [
                "$~/klick klick klick/",
                "$~/@FunctionDefinition hier, ich werde das erklären./",
                "$~@Button ist eine großartige Möglichkeit, einer Maus oder einem Trackpad zuzuhören. Natürlich sind eine Maus oder ein Trackpad nicht die ideale Wahl, um einem Publikum zuzuhören, da nicht jeder sie verwenden kann. Die zugänglichere Wahl ist @Choice.",
                "$~Wenn Sie aber /wirklich/ auf eine Maustaste achten müssen, ist dies die richtige Vorgehensweise. Es wird ein Stream von @Boolean bereitgestellt, der angibt, ob die primäre Taste oben \\⊥\\ oder unten \\⊤\\ ist.",
                "$~Hier ist ein einfaches Beispiel:",
                "$~\\Phrase(Schaltfläche() → '')\\",
                "$~Dies erzeugt einfach eine @Phrase, die den Wert des Streams als Text darstellt. Wenn Sie sie in den Editor kopieren und anklicken, sehen Sie, wie sie zwischen \\⊥\\ und \\⊤\\ hin- und herschaltet."
            ],
            "names": ["$~🖱️", "$~Taste"],
            "down": {
                "names": "$~runter",
                "doc": "$~Wenn @None, liefert der Stream sowohl Up- als auch Down-Werte. Wenn @Boolean, liefert er nur den angegebenen @Boolean-Wert."
            }
        },
        "Pointer": {
            "doc": [
                "$~/whrrrrrr/",
                "$~/@FunctionDefinition hier, ich werde das erklären./",
                "$~Sie kennen sich mit Mäusen, Trackpads und Touchscreens aus? Manchmal möchten Sie wissen, wohin ein Publikum zeigt. Genau das bietet @Pointer.",
                "$~Natürlich ist dies keine barrierefreie Option: Nicht jeder kann sehen oder problemlos zeigen. Stellen Sie also wirklich sicher, dass Sie durch die Verwendung dieses Streams niemanden von der Teilnahme ausschließen.",
                "$~Wenn Sie sicher sind, dass niemand ausgeschlossen ist, ist die Verwendung von @Pointer so einfach wie das Erstellen eines Streams:",
                "$~\\Zeiger()\\",
                "$~Der bereitgestellte @Place entspricht der Stelle auf @Stage, auf die der Zeiger zeigt."
            ],
            "names": ["$~👆🏻", "$~Zeiger"]
        },
        "Key": {
            "doc": [
                "$~/klick/",
                "$~/@FunctionDefinition hier, ich werde das erklären./",
                "$~Tastaturen haben viele Tasten, nicht wahr? @Key sagt Ihnen, welche Taste jemand drückt und loslässt.",
                "$~Versuche dies",
                "$~\\Schlüssel()\\",
                "$~Sehen Sie, wie eine Taste, die Sie drücken, auf @Stage angezeigt wird? Bei jedem Tastendruck wird dem Stream ein neuer @Text hinzugefügt, der die gedrückte Taste beschreibt.",
                "$~Bei einem Schlüssel, der ein Zeichen darstellt, ist der Wert das Zeichen als @Text.",
                "$~Bei Sondertasten, wie der /Escape/-Taste, wird @Text verwendet, der die Taste unter Verwendung eines <vordefinierten Namens@https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values> beschreibt und leider nur auf Englisch verfügbar ist.",
                "$~Wenn Sie nur Informationen zu einem bestimmten Schlüssel wünschen, können Sie diesen angeben:",
                "$~\\Schlüssel('a')\\",
                "$~Und wenn Sie nur wissen möchten, wann eine @Taste losgelassen und nicht gedrückt wird, können Sie einen @Boolean angeben:",
                "$~\\Schlüssel('a' ⊥)\\"
            ],
            "names": ["$~⌨️", "$~Schlüssel"],
            "key": {
                "names": "$~Schlüssel",
                "doc": "$~Wenn @None, werden alle Schlüssel bereitgestellt. Wenn es sich um einen bestimmten @Text handelt, wird nur dieser Schlüssel bereitgestellt."
            },
            "down": {
                "names": "$~runter",
                "doc": "$~WENN @None, dann generiert die Taste „Taste gedrückt“ Eingaben. Wenn \\⊤\\, dann werden nur „Taste gedrückt“-Eingaben bereitgestellt, und wenn \\⊥\\, dann werden nur „Taste loslassen“-Eingaben bereitgestellt."
            }
        },
        "Time": {
            "doc": [
                "$~/tick tick tick/",
                "$~@FunctionDefinition hier, ich erkläre @Time, da es nicht spricht.",
                "$~Die Zeit ist ein Strom, der mit einer bestimmten Frequenz tickt.",
                "$~Jedes Mal führt @Program eine Neuauswertung mit dem neuen Zeitwert durch.",
                "$~Zum Beispiel:",
                "$~\\Zeit()\\",
                "$~Wenn Sie die Zeit als @Time/Frequenz angeben, tickt es mit dieser Rate. Beispiel:",
                "$~\\Zeit(1000ms)\\",
                "$~Es gibt jedoch Grenzen dafür, wie klein es sein kann, da @Program Zeit zur Auswertung braucht, bevor es auf den nächsten Tick reagieren kann.",
                "$~Der kleinste Wert liegt wahrscheinlich bei etwa \\20ms\\."
            ],
            "names": ["$~🕕", "$~Zeit"],
            "frequency": {
                "names": ["$~Frequenz"],
                "doc": "$~Dies ist die Frequenz, mit der die Zeit ticken soll. Der Standardwert ist \\33ms\\, was etwa 30 Mal pro Sekunde entspricht."
            },
            "relative": {
                "names": ["$~relativ"],
                "doc": "$~Wenn \\⊤\\, beginnt die Zeit bei 0, wenn das Programm zum ersten Mal ausgewertet wird. Andernfalls beginnt sie mit der Anzahl der Millisekunden seit Beginn des heutigen Tages, UTC (Coordinated Universal Time), sodass Sie die Tageszeit im Auge behalten können."
            }
        },
        "Volume": {
            "doc": [
                "$~/bzzzzzzz/",
                "$~@FunctionDefinition hier, ich übernehme das Mikrofon.",
                "$~Dieser Stream ist eine Reihe von Lautstärken zwischen 0 und 1, die mit der von Ihnen gewählten Frequenz abgetastet werden. Standardmäßig beträgt die Frequenz \\30 Hz\\, also 30 Mal pro Sekunde, Sie können sie jedoch auf einen niedrigeren Wert ändern.",
                "$~\\Volumen()\\",
                "$~So können Sie hervorragend hören, wie laut das Publikum ist!"
            ],
            "names": ["$~🎤", "$~Volumen"],
            "frequency": {
                "names": ["$~Frequenz"],
                "doc": "$~Die Zeit zwischen den Probenahmen."
            }
        },
        "Pitch": {
            "doc": [
                "$~/hmmmmm/",
                "$~@FunctionDefinition hier, lass uns über die Tonhöhe reden!",
                "$~Dieser Stream ist eine Reihe von Frequenzen in Hertz, die die Tonhöhe angeben und mit der von Ihnen gewählten Frequenz abgetastet werden. Wir haben festgestellt, dass die menschliche Stimme zwischen 20 Hz und 5000 Hz liegt. Planen Sie also mit Zahlen in diesem Bereich.",
                "$~\\Tonhöhe()\\",
                "$~Dies eignet sich hervorragend, um den Tonfall zu hören, wenn jemand spricht oder singt."
            ],
            "names": ["$~🎵", "$~Tonhöhe"],
            "frequency": {
                "names": ["$~Frequenz"],
                "doc": "$~Die Zeit zwischen den Probenahmen."
            }
        },
        "Camera": {
            "doc": [
                "$~/bzzzzzzz/",
                "$~@FunctionDefinition hier, ich kann @Camera erklären!",
                "$~@Camera stellt also eine @List von @Color aus Ihrer Welt bereit. Diese Liste stellt im Wesentlichen ein Bild dar, aber Sie entscheiden, was Sie damit machen.",
                "$~Sie könnten versuchen, das Bild mit einer Reihe von @Phrase darzustellen, das könnte ziemlich cool aussehen! Versuchen Sie, dies zu kopieren...",
                "$~\\colors: Kamera(32px 24px 33ms)\n\nBühne(\ncolors.combine(\n[] \nƒ(phrases•[Phrase] row•[Color] y•#) \nphrases.append(\nrow.translate(\nƒ(color•Color x•#)\nPhrase('o' place: Place((x - 1) · 0.5m y · -0.5m) color: color Dauer: 0s\n)\n)\n)\n)\n)\\",
                "$~Sie könnten die Farben aber auch analysieren, um zu entscheiden, ob ein Licht an oder aus ist oder ob eine bestimmte Farbe häufig vorkommt, sodass das Publikum durch die gezeigten Farben Einfluss auf die Aufführung nehmen kann."
            ],
            "names": ["Cámara"],
            "width": {
                "names": ["$~Breite"],
                "doc": "$~Die Anzahl der @Color, die in einer Zeile abgetastet werden soll."
            },
            "height": {
                "names": ["$~Höhe"],
                "doc": "$~Die Anzahl der @Colors, die in einer Spalte abgetastet werden sollen."
            },
            "frequency": {
                "names": ["$~Frequenz"],
                "doc": "$~Die Zeit zwischen @Color-Samples."
            }
        },
        "Motion": {
            "names": "movimiento",
            "doc": [
                "$~/boing, boing, boing/",
                "$~/Hallo! @FunctionDefinition hier. Wie wär’s, wenn ich @Motion erkläre?",
                "$~Im Grunde ist @Motion ein Stream von @Phrase. Sie geben ihm eine Start-@Phrase und dann verfeinert es diese mit einer neuen Position und Rotation basierend auf der Schwerkraft.",
                "$~Damit können Sie ganz einfache Dinge tun, wie zum Beispiel hüpfende Emojis erstellen:",
                "$~\\Bewegung(Phrase('o') Startort: Ort(0m 10m))\\",
                "$~Sehen Sie, wie das o hüpft? Bei der ersten Auswertung geben wir ihm einen Platz ganz oben auf @Stage, aber danach bekommt es @None, was es @Motion ermöglicht, es an die Position zu verschieben, an die es durch die Schwerkraft gesetzt würde.",
                "$~Schauen Sie sich unten die vielen anderen Konfigurationsmöglichkeiten an."
            ],
            "place": {
                "doc": "$~Der Startplatz.",
                "names": "$~Ort"
            },
            "velocity": {
                "doc": "$~Die Startgeschwindigkeit",
                "names": "$~Geschwindigkeit"
            },
            "nextplace": {
                "doc": "$~Der nächste Ort, die Außerkraftsetzung der Physik.",
                "names": "$~nächsterOrt"
            },
            "nextvelocity": {
                "doc": "$~Der nächste Ort, übergeordnete Geschwindigkeit.",
                "names": "$~nächsteGeschwindigkeit"
            }
        },
        "Scene": {
            "doc": [
                "$~/Buuh, buuh, buuh/",
                "$~/Hallo, hier ist @FunctionDefinition! Ich sehe, Sie haben @Scene gefunden.",
                "$~Ich finde @Scene besonders cool. Die Grundidee ist, dass man ihm eine Liste von @Phrase oder @Group gibt und es diese dann der Reihe nach anzeigt und bei der letzten anhält.",
                "$~Um das Timing zu steuern, können Sie entweder die @Phrase/Dauer für jeden Ausgang festlegen, und dieser wird so lange angezeigt, bevor zum nächsten übergegangen wird, und Sie können die Übergänge @Phrase/entering oder @Phrase/exiting verwenden, die Sie möglicherweise festgelegt haben. Wenn Sie sie auf eine @Sequence festlegen, wird deren Dauer verwendet.",
                "$~Damit können Sie beispielsweise diese kleine @Scene ausführen, die die folgenden drei Sätze nacheinander anzeigt:",
                "$~\\Szene([\nPhrase('Hallo' Dauer: 1s)\nPhrase('Wie geht es dir?' Dauer: 2s Drehung: 5° Eintritt: Pose(Drehung: 0°))\nPhrase('Mir geht es gut')\n])\\",
                "$~Sehen Sie, wie die erste Ausgabe eine Sekunde lang angezeigt wird, dann die nächste zwei Sekunden lang, jedoch mit einer Animation in einer Drehung um fünf Grad, und dann die letzte angezeigt wird?",
                "$~Sie können mit @Scene sehr aufwendige Ausgabe- und Animationssequenzen erstellen und Teile davon sogar dynamisch oder interaktiv gestalten, wie mit jeder anderen @Phrase oder @Group.",
                "$~Wenn Sie eine verschachtelte animierte Ausgabe haben (eine @Group mit einer darin enthaltenen animierten @Phrase), wartet @Scene, bis der gesamte animierte Inhalt in der @Group fertig ist.",
                "$~Oh, und noch ein letztes kleines Geheimnis! Sie können sogar @Boolean in die Liste einfügen, und wenn sie \\⊥\\ sind, pausiert @Scene und wartet, bis es wahr wird.",
                "$~Wenn Sie beispielsweise eine Sequenz von @Phrase erstellen und nur fortfahren möchten, wenn sich @Button ändert, könnten Sie Folgendes tun:",
                "$~\\click: ∆ Button()\nScene([\nPhrase('Hallo')\nclick\nPhrase('Wie geht es dir?' Dauer: 0,25 s Rotation: 5° Eintritt: Pose(Rotation: 0°))\nclick\nPhrase('Mir geht es gut')\n])\\",
                "$~Sehen Sie, wie es nach jeder @Phrase pausiert und wartet, bis sich @Button ändert, bevor es fortfährt?"
            ],
            "names": ["$~🎬", "$~Szene"],
            "outputs": {
                "names": "$~Ausgänge",
                "doc": "$~Die Liste der nacheinander anzuzeigenden Ausgaben."
            }
        },
        "Chat": {
            "doc": [
                "$~/Hallo! @FunctionDefinition hier. Du willst also chatten?",
                "$~Die Grundidee eines Chat-Streams besteht darin, dass das Publikum eine Nachricht eingibt und das Programm dann darauf antwortet.",
                "$~Dieses einfache Programm prüft beispielsweise, ob die Nachricht „Hallo“ lautet. Wenn dies der Fall ist, wird das Programm als „hi“ ausgewertet. Andernfalls wird es als „hä?“ ausgewertet.",
                "$~\\Chat().has('hallo') ? 'hi!' 'hä?'\\",
                "$~Das ist es! Sie können damit alle möglichen Darbietungen erstellen, wie Chatbots, Textabenteuer oder textbasierte Steuerungsschemata für andere Arten von Darbietungen."
            ],
            "names": ["$~🗣️", "$~Plaudern"]
        },
        "Placement": {
            "doc": [
                "$~/Hey, hier ist @FunctionDefinition. Lass uns darüber reden, wie wir weiterkommen!/",
                "$~Es gibt also viele Möglichkeiten, uns auf der @Stage zu platzieren. Sie können uns einen expliziten @Place zuweisen. Sie können @Motion verwenden und die Schwerkraft ihre Arbeit machen lassen. Sie können uns auch in eine @Group setzen und uns dort auf eine bestimmte Weise anordnen lassen.",
                "$~Aber manchmal möchten Sie dem /Publikum/ die Kontrolle darüber geben, wo wir uns auf der @Bühne befinden. Dafür gibt es @Placement.",
                "$~Und so funktioniert es: Du erstellst einfach ein @Placement und gibst es an unseren @Place weiter:",
                "$~\\Phrase('hi' Ort: Platzierung())\\",
                "$~Jedes Mal, wenn das Publikum eine Pfeiltaste drückt oder auf die Bühne klickt oder tippt, erstellt das @Placement einen neuen @Place, der sich in die gewünschte Richtung bewegt.",
                "$~Versuchen Sie, dies in Ihr Programm zu kopieren und es mit dem Zeiger oder der Tastatur in Pfeilrichtung zu verschieben.",
                "$~Sie können die @Placement anpassen, indem Sie die Bewegung in bestimmten Dimensionen aktivieren und deaktivieren, die Bewegungsweite eines @Place ändern und den anfänglichen @Place ändern, mit dem der Stream beginnt."
            ],
            "names": ["$~✥", "$~Platzierung"],
            "inputs": [
                {
                    "doc": "$~Der erste Ort, an dem man beginnen kann.",
                    "names": "$~Start"
                },
                {
                    "doc": "$~Um wie viele Meter sich der Ort bewegen soll, wenn das Publikum eine Bewegung verlangt.",
                    "names": "$~Distanz"
                },
                {
                    "doc": "$~Wenn „true“, ist eine Bewegung auf der horizontalen Achse möglich. Standardmäßig aktiviert.",
                    "names": "$~horizontal"
                },
                {
                    "doc": "$~Wenn „true“, ist eine Bewegung auf der vertikalen Achse möglich. Standardmäßig aktiviert.",
                    "names": "$~Vertikale"
                },
                {
                    "doc": "$~Wenn wahr, ermöglicht es die Bewegung auf der Z-Achse mit den Tasten + und -.",
                    "names": "$~Tiefe"
                }
            ]
        },
        "Webpage": {
            "doc": [
                "$~/Hey, hier ist @FunctionDefinition. Lass uns darüber reden, wie man Webseiten aus dem Internet bekommt!/",
                "$~Als wir zum ersten Mal von Ihrem Internet hörten, fanden wir es faszinierend. Eine ganze Welt voller vernetzter Computer, die Dokumente miteinander teilen? Das ist unglaublich!",
                "$~Also haben wir einen Stream erstellt, der damit verbunden ist. Sie geben uns eine URL und wir holen uns den gesamten Text. So:",
                "$~\\Webseite('https://wordplay.dev')\\",
                "$~Und es gibt anscheinend dieses Ding namens <CSS@https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/What_is_CSS>, das Ihnen gefällt, wenn Sie Dinge auf einer Webseite abfragen. Geben Sie uns eine CSS-Auswahlabfrage und wir erhalten nur den Text, der dieser Abfrage entspricht. Wie dieses Beispiel, das die Überschriften der ersten Ebene erhält.",
                "$~\\Webseite('https://wordplay.dev' 'h1')\\",
                "$~Dabei kann vieles schiefgehen. Wenn Sie Ihre Internetverbindung verlieren, die URL nichts ergibt, die URL nicht öffentlich ist oder es sich nicht um eine HTML-Seite handelt … All dies kann zu einer Ausnahme führen. Wenn Sie eine Seite finden, die funktioniert, erhalten Sie eine @Nummer, die den Prozentsatz der Fertigstellung angibt, und dann eine @Liste der Wörter auf der Seite."
            ],
            "names": ["$~🔗", "$~Website"],
            "url": {
                "doc": "$~Die abzurufende URL der HTML-Webseite.",
                "names": "$~URL(URL)"
            },
            "query": {
                "doc": "$~Die auszuwertende CSS-Abfrage im HTML",
                "names": "$~Abfrage"
            },
            "frequency": {
                "doc": "$~Die Anzahl der Minuten, die vergehen sollen, bevor die Seite erneut abgerufen wird.",
                "names": "$~Frequenz"
            },
            "error": {
                "invalid": "$~Dies ist keine gültige URL",
                "unvailable": "$~diese URL ist nicht zugänglich",
                "notHTML": "$~Die Antwort war kein HTML",
                "noConnection": "$~keine Verbindung zu Wordplay",
                "limit": "$~zu viele Anfragen an diese Domain"
            }
        },
        "Collision": {
            "names": "$~Kollision",
            "doc": [
                "$~/Hallo! @FunctionDefinition hier. Sieh dir diesen coolen Input an./",
                "$~Damit können Sie herausfinden, wann @Output aufeinander stößt! Dies ist eine großartige Möglichkeit, etwas zu tun, wenn wir aufeinander stoßen, abgesehen vom normalen gegenseitigen Abprallen, das @Output möglicherweise bewirkt.",
                "$~Geben Sie mir einfach den Namen @Output und ich erstelle einen neuen @Rebound-Wert, wenn er auf einen anderen Namen trifft. Ein @Rebound enthält Informationen zu den kollidierten Namen und der Richtung ihrer Kollision.",
                "$~Und wenn Sie mir zwei Namen geben, erstelle ich nur dann einen neuen Wert, wenn die beiden Namen aufeinandertreffen.",
                "$~Gleich nachdem ich einen neuen Wert eingegeben habe, erstelle ich ein \\ø\\, da die Kollision nach ihrem Auftreten beendet ist. Dies zeigt an, dass keine weitere Kollision mehr vorliegt."
            ],
            "subject": {
                "names": "$~Thema",
                "doc": "$~Der Name des @Outputs, bei dem ich nach Kollisionen suchen soll."
            },
            "object": {
                "names": "$~andere",
                "doc": "$~Der Name des anderen @Outputs, bei dem ich nach Kollisionen suchen soll."
            }
        },
        "Rebound": {
            "names": "$~Rebound",
            "doc": "$~Ich komme von @Collision und stelle dar, mit wem kollidiert ist und in welcher Richtung die Kollision stattgefunden hat. Verwenden Sie mich, um zu entscheiden, ob auf eine Kollision auf eine besondere Art und Weise reagiert werden soll, die von der normalen Physik abweicht.",
            "direction": {
                "names": "$~Richtung",
                "doc": "$~Richtung und Ausmaß des Aufpralls im Verhältnis zum Kollisionsobjekt"
            },
            "subject": {
                "names": "$~Thema",
                "doc": "$~Der Name der Ausgabe, die vom Betreff betroffen war."
            },
            "object": {
                "names": "$~Objekt",
                "doc": "$~Der Name der Ausgabe, die das Thema traf"
            }
        },
        "Direction": {
            "names": "$~Richtung",
            "doc": "$~Ich bin eine Richtung und Größe entlang der x- und y-Achse.",
            "x": {
                "names": "$~X",
                "doc": "$~Die Richtung und Größe der Richtung entlang der x-Achse."
            },
            "y": {
                "names": "$~j",
                "doc": "$~Die Richtung und Größe der Richtung entlang der Y-Achse."
            }
        }
    },
    "output": {
        "Output": {
            "names": "$~Ausgabe",
            "doc": [
                "$~Ich bin keine @StructureDefinition, die man tatsächlich erstellen kann. Aber ich bin eine sehr wichtige, da ich die wichtigsten Elemente unseres Tanzes inspiriere: @Phrase, @Gruppe und @Bühne.",
                "$~Lernen Sie sie kennen, um mehr über ihre Verwendung zu erfahren."
            ]
        },
        "Stage": {
            "names": ["$~🎭", "$~Bühne"],
            "doc": [
                "$~HALLO. DIE BÜHNE IST HIER. SAG MIR, WAS ICH ZEIGEN SOLL, UND ICH ZEIGE ES.",
                "$~\\Stage([Phrase('Zeugsfffff')])\\",
                "$~WENN DU WILLST, GIB MIR EINE HINTERGRUND-Farbe und ich werde die Bühne entsprechend beleuchten.",
                "$~\\Stage([Phrase('stufffffff')] Hintergrund: Farbe(75% 50 100°)\\",
                "$~SIE KÖNNEN MIR AUCH EINEN RAHMENRAND GEBEN UND ICH WERDE IHN ZUSCHNEIDEN.",
                "$~\\Stage([Phrase('stufffffff')] Hintergrund: Farbe(75% 50 100°) Rahmen: Rechteck(-1m -1m 1m 1m))\\"
            ],
            "description": "$~Stufe $1[$1|] von $2[$2|] Sätzen $3[$3 Rahmen|] $4",
            "content": {
                "doc": "$~Die Liste der auf der Bühne anzuzeigenden @Outputs.",
                "names": "$~Inhalt"
            },
            "frame": {
                "doc": "$~Die Form und Größe des Rahmens, der um die Bühne herum platziert wird und alles außerhalb davon verbirgt.",
                "names": "$~rahmen"
            },
            "size": {
                "doc": "$~LIKE @Gruppe/Größe",
                "names": "$~Größe"
            },
            "face": {
                "doc": "$~LIKE @Gruppe/Gesicht",
                "names": "$~Gesicht"
            },
            "place": {
                "doc": "$~WENN ICH EINE KAMERA WÄRE, WÜRDE ICH HIERHIN SCHAUEN",
                "names": "$~Ort"
            },
            "name": {
                "doc": ["$~DAS GLEICHE WIE @Phrase/Name!"],
                "names": "$~Name"
            },
            "selectable": {
                "doc": "$~GLEICH WIE @Phrase/auswählbar!",
                "names": "$~wählbar"
            },
            "color": {
                "doc": "$~DAS GLEICHE WIE @Group/color",
                "names": "$~Farbe"
            },
            "background": {
                "doc": "$~DAS GLEICHE WIE @Group/background",
                "names": "$~Hintergrund"
            },
            "opacity": {
                "doc": "$~DAS GLEICHE WIE @Group/opacity",
                "names": "$~Opazität"
            },
            "offset": {
                "doc": "$~DAS GLEICHE WIE @Group/Offset",
                "names": "$~Versatz"
            },
            "rotation": {
                "doc": "$~DAS GLEICHE WIE @Group/rotation",
                "names": ["$~📐", "$~Drehung"]
            },
            "scale": {
                "doc": "$~DAS GLEICHE WIE @Group/scale",
                "names": "$~Skala"
            },
            "flipx": {
                "doc": "$~GLEICH WIE @Group/flipx",
                "names": "$~flipx"
            },
            "flipy": {
                "doc": "$~DAS GLEICHE WIE @Group/flipy",
                "names": "$~flippig"
            },
            "entering": {
                "doc": "$~DAS GLEICHE WIE @Group/entering",
                "names": "$~Eingabe"
            },
            "resting": {
                "doc": "$~DAS GLEICHE WIE @Gruppe/Ruhen!",
                "names": "$~Ruhen"
            },
            "moving": {
                "doc": "$~DAS GLEICHE WIE @Group/moving!",
                "names": "$~ziehenum"
            },
            "exiting": {
                "doc": "$~DAS GLEICHE WIE @Group/exiting!",
                "names": "$~Ausstieg"
            },
            "duration": {
                "doc": "$~GLEICH WIE @Phrase/Dauer!",
                "names": ["duración"]
            },
            "style": {
                "doc": "$~DAS GLEICHE WIE @Phrase/Stil!",
                "names": "$~Stil"
            },
            "gravity": {
                "doc": "$~Die Schwerkraft, die auf die Ausgabe angewendet werden soll, deren Platz in @Motion ist.",
                "names": "$~Schwere"
            }
        },
        "Group": {
            "names": ["$~🔳", "$~Gruppe"],
            "doc": [
                "$~Oh, hallo, wie geht es dir? Mir geht es immer gut, wenn andere da sind, also ist es toll, mit dir zusammen zu sein!",
                "$~Ich gruppiere @Phrase und @Group auf @Stage und platziere sie in einem @Arrangement, sodass eine gewisse Reihenfolge ihrer Platzierung gegeben ist.",
                "$~Damit es funktioniert, müssen Sie mir ein @Arrangement und anschließend eine @Liste mit anzuordnenden @Ausgaben geben.",
                "$~Hier bin ich beispielsweise mit einer @Stack-Anordnung und einigen @Phrase zum vertikalen Stapeln:",
                "$~\\Gruppe(Stapel() [Phrase('erste') Phrase('zweite')])\\",
                "$~Wie ich die Dinge genau arrangiere, hängt von dem @Arrangement ab, das Sie mir geben."
            ],
            "description": "$~$1[$1|] $2 $3",
            "content": {
                "doc": "$~Die Liste der anzuordnenden @Outputs.",
                "names": "$~Inhalt"
            },
            "layout": {
                "doc": "$~Die zu verwendende Anordnung, um @Output an ihren Plätzen zu platzieren.",
                "names": "$~Layout"
            },
            "matter": {
                "doc": "$~Wie ich reagieren sollte, wenn ich mit etwas anderem, das Materie hat, zusammenstoßen würde.",
                "names": "$~Gegenstand"
            },
            "size": {
                "doc": "$~Wie groß müsste der wunderbare Inhalt in mir sein, wenn er nicht seine eigene Größe hätte!",
                "names": "$~Größe"
            },
            "face": {
                "doc": "$~Der Name der Schriftart sollte in meinem Inhalt enthalten sein, es sei denn, Sie haben eine eigene Schriftart zum Verwenden.",
                "names": "$~Gesicht"
            },
            "place": {
                "doc": "$~Der Platz auf der Bühne, an dem ich sein sollte. Der Inhalt in mir wird relativ dorthin angeordnet.",
                "names": "$~Ort"
            },
            "name": {
                "doc": ["$~Das Gleiche wie @Phrase/Name!"],
                "names": "$~Name"
            },
            "selectable": {
                "doc": "$~Das gleiche wie @Phrase/selectable!",
                "names": "$~wählbar"
            },
            "color": {
                "doc": "$~Die @Color, die der Inhalt in mir haben sollte, sofern er nicht über eine eigene Farbe verfügt.",
                "names": "$~Farbe"
            },
            "background": {
                "doc": "$~Die @Color-Projizierung hinter mir.",
                "names": "$~Hintergrund"
            },
            "opacity": {
                "doc": "$~Wie transparent alles in mir sein soll, zwischen \\0\\ und \\1\\, sofern es nicht durch eine andere @Pose überschrieben wird.",
                "names": "$~Opazität"
            },
            "offset": {
                "doc": "$~Ein @Place, der angibt, wie weit es von meinem normalen @Place entfernt sein soll, sofern es nicht durch eine andere @Pose überschrieben wird. Hilfreich zum Wackeln an Ort und Stelle.",
                "names": "$~Versatz"
            },
            "rotation": {
                "doc": "$~Wie geneigt sollte ich um meinen Mittelpunkt sein, meine @Pose hat eine andere.",
                "names": ["$~📐", "$~Drehung"]
            },
            "scale": {
                "doc": "$~Wie groß ich im Verhältnis zu meiner Originalgröße sein sollte.",
                "names": "$~Skala"
            },
            "flipx": {
                "doc": "$~Das Gleiche wie @Phrase/flipx!",
                "names": "$~flipx"
            },
            "flipy": {
                "doc": "$~Dasselbe wie @Phrase/flipy",
                "names": "$~flippig"
            },
            "entering": {
                "doc": "$~Dasselbe wie @Phrase/entering!",
                "names": "$~Eingabe"
            },
            "resting": {
                "doc": "$~Dasselbe wie @Phrase/resting!",
                "names": "$~Ruhen"
            },
            "moving": {
                "doc": "$~Dasselbe wie @Phrase/moving!",
                "names": "$~ziehenum"
            },
            "exiting": {
                "doc": "$~Dasselbe wie @Phrase/exiting!",
                "names": "$~Ausstieg"
            },
            "duration": {
                "doc": "$~Dasselbe wie @Phrase/Dauer!",
                "names": ["duración"]
            },
            "style": {
                "doc": "$~Dasselbe wie @Phrase/Stil!",
                "names": "$~Stil"
            }
        },
        "Phrase": {
            "names": ["💬", "Satzglied"],
            "doc": "Hallo, hallo? Erinnerst du mich? Wie könnte jemand /mich/ vergessen? Ich bin das geniale @Phrase und ich bin bereit, die schönste aller @Text auf der Bühne zu darstellen.",
            "description": "$~$3[$3 Takt |]Phrase $1 $2[benannt $2|] $4[$4|] $5",
            "text": {
                "doc": "$~Die auf @Stage anzuzeigenden Charaktere.",
                "names": "$~Text"
            },
            "size": {
                "doc": "$~Wie groß ich sein sollte, in Metern!",
                "names": "$~Größe"
            },
            "face": {
                "doc": "$~Der Name der Schriftart, die ich verwenden soll.",
                "names": "$~Gesicht"
            },
            "place": {
                "doc": "$~Der Platz auf der Bühne, an dem ich sein sollte.",
                "names": "$~Ort"
            },
            "wrap": {
                "doc": "$~Die Kante, an der ich Symbole umbrechen soll oder \\ø\\, wenn ich sie nicht umbrechen soll.",
                "names": ["$~↵", "$~wickeln"]
            },
            "alignment": {
                "doc": "$~Wenn eine @Phrase/Wrap-Grenze festgelegt ist, ob ich Symbole am Anfang, in der Mitte oder am Ende der Kante ausrichten soll.",
                "names": "$~Ausrichtung"
            },
            "direction": {
                "doc": "$~Ob Symbole horizontal oder vertikal geschrieben werden und ob der Text nach links oder rechts umbrochen wird, wenn „vertikal“ und „@Phrase/wrap“ festgelegt sind.",
                "names": "$~Richtung"
            },
            "matter": {
                "doc": "$~Die Eigenschaften, die ich verwenden soll, wenn ich gegen Dinge stoße!",
                "names": "$~Gegenstand"
            },
            "aura": {
                "doc": "$~Die optionale @Aura, die hinter mir angezeigt wird. Bring mich zum Leuchten!",
                "names": "$~Aura"
            },
            "name": {
                "doc": [
                    "$~Ein Name, den du mir gibst! Das ist für vieles hilfreich.",
                    "$~Erstens: Wenn ich einen Namen habe, verwende ich ihn, um mich in den Beschreibungen des Screenreaders zu beschreiben.",
                    "$~Zweitens: Beim Animieren haben Sie möglicherweise mehrere unterschiedliche Ausdrücke, die denselben Inhalt auf der Bühne darstellen sollen. Geben Sie ihnen denselben Namen, und sie werden als einer animiert.",
                    "$~Schließlich bin ich mit @Choice hilfreich: Die Namen, die Sie mir geben, erscheinen in diesem Stream.",
                    "$~Sie können mir viele verschiedene Namen in jeweils einer anderen Sprache geben, wenn das hilfreich ist. Ich verwende immer den Namen in der ersten ausgewählten Sprache."
                ],
                "names": "$~Name"
            },
            "selectable": {
                "doc": "$~Wenn \\⊤\\, bedeutet dies, dass I über einen Zeiger oder eine Tastatur ausgewählt werden kann.",
                "names": "$~wählbar"
            },
            "color": {
                "doc": "$~Die @Color I sollte standardmäßig sein, sofern sie nicht durch eine andere @Pose überschrieben wird.",
                "names": "$~Farbe"
            },
            "background": {
                "doc": "$~Die @Color-Projizierung hinter mir.",
                "names": "$~Hintergrund"
            },
            "opacity": {
                "doc": "$~Wie transparent ich standardmäßig sein soll, zwischen \\0\\ und \\1\\, sofern es nicht durch eine andere @Pose überschrieben wird. Hilfreich zum Ein- und Ausblenden.",
                "names": "$~Opazität"
            },
            "offset": {
                "doc": "$~Ein @Place, der angibt, wie weit es von meinem @Place entfernt sein soll, sofern es nicht durch eine andere @Pose überschrieben wird. Hilfreich zum Wackeln an Ort und Stelle.",
                "names": "$~Versatz"
            },
            "rotation": {
                "doc": "$~Der Betrag in Grad, um den ich um seinen Mittelpunkt gedreht werden soll, sofern er nicht durch eine andere @Pose überschrieben wird.",
                "names": "$~Drehung"
            },
            "scale": {
                "doc": "$~Wie vergrößert soll ich im Verhältnis zur Originalgröße sein, sofern dies nicht durch eine andere @Pose überschrieben wird.",
                "names": "$~Skala"
            },
            "flipx": {
                "doc": "$~Ob ich auf der X-Achse gespiegelt werden soll, sofern dies nicht durch eine andere @Pose überschrieben wird.",
                "names": "$~flipx"
            },
            "flipy": {
                "doc": "$~Ob ich auf der Y-Achse gespiegelt werden soll, sofern dies nicht durch eine andere @Pose überschrieben wird.",
                "names": "$~flippig"
            },
            "entering": {
                "doc": "$~Die @Pose oder @Sequenz, die ich beim Betreten der Bühne machen sollte.",
                "names": "$~Eingabe"
            },
            "resting": {
                "doc": "$~Die @Pose oder @Sequence sollte ich ausführen, nachdem ich die Bühne betreten habe, bevor ich sie verlasse und während sich mein @Place nicht ändert. Wenn Sie mir keine geben, verwende ich einfach meine Standardeinstellungen.",
                "names": "$~Ruhen"
            },
            "moving": {
                "doc": "$~Die @Pose oder @Sequence, die ich beim Wechseln der Plätze auf der Bühne verwenden sollte, anstelle meiner Standardeinstellungen.",
                "names": "$~ziehenum"
            },
            "exiting": {
                "doc": "$~Die @Pose oder @Sequence sollte vor dem Verlassen der Bühne ausgeführt werden.",
                "names": "$~Ausstieg"
            },
            "duration": {
                "doc": "$~Die anzuwendende Dauer beim Wechsel an eine andere Stelle auf der Bühne.",
                "names": ["$~⏳", "$~Dauer"]
            },
            "style": {
                "doc": "$~Der zu verwendende Animationsstil beim Wechsel an eine andere Stelle auf der Bühne.",
                "names": "$~Stil"
            }
        },
        "Arrangement": {
            "names": ["Arrangement"],
            "doc": "$~Ich bin eine Inspiration für die vielen anderen Arten der Anordnung im Verse, einschließlich @Row, @Stack, @Grid und @Free. Ich arbeite eng mit @Group zusammen, um"
        },
        "Row": {
            "names": ["Fila"],
            "doc": "$~Ich bin @Row, eine horizontale @Anordnung von @Output, mit optionaler Polsterung dazwischen. Kennen Sie meinen Zwilling @Stack?",
            "description": "$~Reihe von $1-Phrasen und Gruppen",
            "alignment": {
                "doc": "$~Ob der Text in jeder Spalte am Anfang, in der Mitte oder am Ende ausgerichtet werden soll.",
                "names": "$~Ausrichtung"
            },
            "padding": {
                "doc": "$~Die Menge an Polsterung, die zwischen den Ausgaben eingefügt werden soll.",
                "names": "$~Polsterung"
            }
        },
        "Stack": {
            "names": ["$~⬇", "$~Stapel"],
            "doc": "$~Ich bin @Stack, eine vertikale @Anordnung von @Output, mit optionaler Polsterung dazwischen. Kennen Sie meinen Zwilling @Row?",
            "description": "$~Stapel von 1-Dollar-Phrasen und Gruppen",
            "padding": {
                "doc": "$~Die Menge an Polsterung, die zwischen den Ausgaben eingefügt werden soll.",
                "names": "$~Polsterung"
            },
            "alignment": {
                "doc": "$~Ob der Text in jeder Zeile am Anfang, in der Mitte oder am Ende ausgerichtet werden soll.",
                "names": "$~Ausrichtung"
            }
        },
        "Grid": {
            "names": ["$~▦", "$~Netz"],
            "doc": "$~Ich bin das Raster von @Output. Geben Sie mir die Zeilen- und Spaltenanzahl und ich erstelle eine übersichtliche Anordnung mit optionaler Polsterung und Zellengrößen.",
            "description": "$~$1 Zeile $2 Spaltenraster",
            "rows": {
                "doc": "$~Wie viele Zeilen sollen im Raster erstellt werden?",
                "names": "$~Reihen"
            },
            "columns": {
                "doc": "$~Wie viele Spalten im Raster erstellt werden sollen.",
                "names": "$~Säulen"
            },
            "padding": {
                "doc": "$~Wie viel Polsterung zwischen den Zellen platziert werden soll.",
                "names": "$~Polsterung"
            },
            "cellWidth": {
                "doc": "$~Wie breit die Zellen sein sollen.",
                "names": "$~Zellenbreite"
            },
            "cellHeight": {
                "doc": "$~Wie hoch die Zellen sein sollen.",
                "names": "$~Zellenpolsterung"
            }
        },
        "Free": {
            "names": ["$~Frei"],
            "doc": [
                "$~Ich sage: Egal. Setz dich, wo du willst. Setz dich einfach irgendwo hin! Achte darauf, dass alle @Outputs, die du mir gibst, einen @Place haben, sonst wissen sie nicht, wohin sie gehen sollen.",
                "$~Oh, und denken Sie daran, dass der @Place, den Sie jedem @Output geben, relativ zum @Place der @Group ist! Wenn Sie sich also fragen, warum Dinge nicht dort erscheinen, wo Sie es erwarten, versuchen Sie, der @Group ebenfalls einen Platz zu geben."
            ],
            "description": "$~Freiform-Ausgaben für 1 USD"
        },
        "Shape": {
            "names": ["$~⬟", "$~Form"],
            "doc": "$~Ich bin eine Inspiration für alle Formen. Ich bin nützlich, um @Stage zu sagen, welche Form es haben soll.",
            "form": {
                "doc": "$~Ich bin die Art von Form, die angezeigt werden soll. Jede Form erfordert andere Informationen, um ihre Anordnung zu definieren.",
                "names": "$~bilden"
            },
            "name": {
                "doc": "$~Ich bin der Name, den Sie für Animationen und @Collision verwenden können. Wenn ich beispielsweise den Boden darstelle, möchten Sie mich vielleicht „Boden“ nennen.",
                "names": "$~Name"
            },
            "selectable": {
                "doc": "$~Ob ich im Rahmen von @Choice ausgewählt werden kann.",
                "names": "$~wählbar"
            },
            "color": {
                "doc": "$~Die Farbe meiner Ränder.",
                "names": "$~Farbe"
            },
            "background": {
                "doc": "$~Die Farbe meines Hintergrunds.",
                "names": "$~Hintergrund"
            },
            "opacity": {
                "doc": "$~Wie transparent ich sein sollte.",
                "names": "$~Opazität"
            },
            "offset": {
                "doc": "$~Wie weit soll ich von meinem Platz entfernt erscheinen, während ich an Ort und Stelle bleibe?",
                "names": "$~Versatz"
            },
            "rotation": {
                "doc": "$~Wie gedreht ich sein sollte. Dies wirkt sich auf @Collision aus.",
                "names": "$~Drehung"
            },
            "scale": {
                "doc": "$~Wie stark ich vergrößert werden sollte, ohne dass sich meine tatsächliche Größe ändert.",
                "names": "$~Skala"
            },
            "flipx": {
                "doc": "$~Ob ich an meiner x-Achse gespiegelt werden soll.",
                "names": "$~flipx"
            },
            "flipy": {
                "doc": "$~Ob ich an meiner Y-Achse gespiegelt werden soll.",
                "names": "$~flippig"
            },
            "entering": {
                "doc": "$~Die @Pose oder @Sequence sollte ich beim Betreten der @Stage ausführen.",
                "names": "$~Eingabe"
            },
            "resting": {
                "doc": "$~Die @Pose oder @Sequence sollte ich nach dem Eintreten und während ich mich nicht bewege, ausführen.",
                "names": "$~Ruhen"
            },
            "moving": {
                "doc": "$~Die @Pose oder @Sequence sollte ich beim Wechseln der Orte ausführen.",
                "names": "$~ziehenum"
            },
            "exiting": {
                "doc": "$~Die @Pose oder @Sequence, die ich beim Verlassen von @Stage ausführen sollte.",
                "names": "$~Ausstieg"
            },
            "duration": {
                "doc": "$~Wie lange meine Animationen dauern sollen, wenn es sich um eine einzelne @Pose handelt.",
                "names": "$~Dauer"
            },
            "style": {
                "doc": "$~Der Animationsstil, den ich verwenden sollte.",
                "names": "$~Stil"
            }
        },
        "Form": {
            "doc": "$~Ich bin eine abstrakte Form, wie ein @Rechteck oder ein @Kreis.",
            "names": ["$~Bilden"]
        },
        "Rectangle": {
            "names": ["$~Rechteck"],
            "doc": "$~Ich bin ein Rechteck und nützlich, um @Stage eine Begrenzung in der von Ihnen gewählten Größe zu geben.",
            "left": {
                "doc": "$~Der linke Rand der Bühne auf der x-Achse",
                "names": "$~links"
            },
            "top": {
                "doc": "$~Die Oberkante der Bühne auf der Y-Achse",
                "names": "$~Spitze"
            },
            "right": {
                "doc": "$~Der rechte Rand der Bühne auf der x-Achse",
                "names": "$~Rechts"
            },
            "bottom": {
                "doc": "$~Die Unterkante der Bühne auf der Y-Achse",
                "names": "$~unten"
            },
            "z": {
                "doc": "$~Die Tiefenposition des Rechtecks.",
                "names": "$~z"
            }
        },
        "Circle": {
            "doc": "$~Ich bin ein Kreis, nützlich zum Erstellen von Formen auf @Stage.",
            "names": ["$~Kreis"],
            "radius": {
                "doc": "$~Der Radius des Kreises",
                "names": "$~Radius"
            },
            "x": {
                "doc": "$~Der horizontale Mittelpunkt des Kreises.",
                "names": "$~X"
            },
            "y": {
                "doc": "$~Der vertikale Mittelpunkt des Kreises.",
                "names": "$~j"
            },
            "z": {
                "doc": "$~Die Tiefenposition des Kreises.",
                "names": "$~z"
            }
        },
        "Polygon": {
            "doc": "$~Ich bin ein „regelmäßiges“ Polygon mit gleich langen Seiten und Winkeln, nützlich zum Erstellen von Formen auf @Stage.",
            "names": ["$~Vieleck"],
            "radius": {
                "doc": "$~Der Radius des Polygons",
                "names": "$~Radius"
            },
            "sides": {
                "doc": "$~Die Anzahl der Seiten des Polygons",
                "names": "$~Seiten"
            },
            "x": {
                "doc": "$~Der horizontale Mittelpunkt des Polygons.",
                "names": "$~X"
            },
            "y": {
                "doc": "$~Der vertikale Mittelpunkt des Polygons.",
                "names": "$~j"
            },
            "z": {
                "doc": "$~Die Tiefenposition des Polygons.",
                "names": "$~z"
            }
        },
        "Pose": {
            "names": ["$~🤪", "$~Pose"],
            "doc": [
                "$~Wissen Sie, wenn jemand eine ganz erstaunliche Haltung einnimmt, innehält und alle zuschauen? Das bin ich. Ich erfasse eine Pose für @Output und bin der Baustein ihrer Bewegungen.",
                "$~Zu einer Pose gehört so viel. Schauen Sie sich meine vielen Anregungen an, um zu sehen, welche Arten von Posen Sie machen könnten!"
            ],
            "style": {
                "doc": "$~Der beim Wechsel zu dieser Pose zu verwendende Animationsstil.",
                "names": "$~Stil"
            },
            "color": {
                "doc": "$~Die @Color a @Output sollte in dieser Pose sein, statt in der Standardpose.",
                "names": "$~Farbe"
            },
            "opacity": {
                "doc": "$~Wie transparent ein @Output sein soll, zwischen \\0\\ und \\1\\, statt der Standardeinstellung. Hilfreich zum Ein- und Ausblenden.",
                "names": "$~Opazität"
            },
            "offset": {
                "doc": "$~Ein @Place, der angibt, wie weit es von der Stelle eines @Outputs entfernt sein soll, statt der Standardeinstellung. Hilfreich zum Wackeln an Ort und Stelle.",
                "names": "$~Versatz"
            },
            "rotation": {
                "doc": "$~Wie rotiert ein @Output sein soll, anstelle der Standardeinstellung.",
                "names": "$~Drehung"
            },
            "scale": {
                "doc": "$~Wie vergrößert ein @Output im Verhältnis zu seiner Originalgröße sein soll, statt der Standardgröße.",
                "names": "$~Skala"
            },
            "flipx": {
                "doc": "$~Ob ein @Output an der X-Achse gespiegelt werden soll, statt der Standardeinstellung.",
                "names": "$~flipx"
            },
            "flipy": {
                "doc": "$~Ob ein @Output an der Y-Achse gespiegelt werden soll, statt der Standardeinstellung.",
                "names": "$~flippig"
            },
            "description": "$~$1[transparent $1|] $2[um $2 Grad gedreht|] $3[3 skaliert|] $4[horizontal gespiegelt|] $5[vertikal gespiegelt|] $6[Schatten unscharf $6 Pixel]"
        },
        "Color": {
            "names": ["$~🌈", "$~Farbe"],
            "doc": [
                "$~Ich bin eine sichtbare Farbe, die aus drei wesentlichen Dimensionen besteht.",
                "$~Hier sind einige gängige Farben im Farbkreis, mit mittlerer Helligkeit und hoher Farbsättigung:",
                "$~\\Farbe(50% 100 0°)\\",
                "$~\\Farbe(50% 100 30°)\\",
                "$~\\Farbe(50% 100 60°)\\",
                "$~\\Farbe(50% 100 90°)\\",
                "$~\\Farbe(50% 100 120°)\\",
                "$~\\Farbe(50% 100 150°)\\",
                "$~\\Farbe(50% 100 180°)\\",
                "$~\\Farbe(50% 100 210°)\\",
                "$~\\Farbe(50% 100 240°)\\",
                "$~\\Farbe(50% 100 270°)\\",
                "$~\\Farbe(50% 100 300°)\\",
                "$~\\Farbe(50% 100 330°)\\"
            ],
            "lightness": {
                "doc": "$~Wie hell sollte ich sein, von \\0\\ bis \\1\\, von Schwarz bei \\0\\ über Grau bei \\0,5\\ bis Weiß bei \\1\\.",
                "names": ["luminosidad"]
            },
            "chroma": {
                "doc": "$~Wie viel Farbe soll ich haben, von \\0\\ bis \\∞\\. Keine Farbe bedeutet grau, höhere Zahlen bedeuten mehr Farbe.",
                "names": ["croma"]
            },
            "hue": {
                "doc": "$~Welche Farbe sollte ich auf einem Farbkreis haben, von Magenta \\0\\, Rot \\30\\, Grün \\120\\ bis Blau \\270\\.",
                "names": ["matiz"]
            }
        },
        "Sequence": {
            "names": ["$~💃", "$~Reihenfolge"],
            "doc": [
                "$~Oh. Meine Güte. Herr Direktor, Sie sehen heute fantastisch aus! Wollen Sie mit mir tanzen? Das ist ganz einfach.",
                "$~Sie müssen mir lediglich eine @Map geben, in der jeder Schlüssel darstellt, wie weit wir im Tanz sind, und jeder Wert dieser Schlüssel ist eine @Pose.",
                "$~Es gibt /so/ viele verschiedene Möglichkeiten, damit zu animieren! Hier ist beispielsweise eine einfache:",
                "$~\\Phrase('hi' ruhend:Sequenz({0%: Pose(Rotation: 360°) 100%: Pose(Rotation: 0°)})\\",
                "$~Hier steht: /am Anfang (0%), bei Neigung 360 beginnen und bei Neigung 0 enden/. Das wird uns ewig im Kreis herumwirbeln, da ich als Ruhepose der @Phrase eingestellt bin!",
                "$~Probieren Sie Ihre eigenen kreativen Tänze aus, indem Sie mit anderen Eingaben spielen."
            ],
            "poses": {
                "doc": "$~Eine @Map mit Prozentwerten zwischen 0 % und 100 %, jeweils gepaart mit einer @Pose. Sie müssen nicht alle Prozentwerte angeben. Ich verschiebe einen @Output reibungslos zwischen denen, die Sie mir geben.",
                "names": "$~Posen"
            },
            "duration": {
                "doc": "$~Wie lange soll ich diesen Tanz machen? Wenn ich ihn wiederhole, verlängere ich die Dauer nicht, sondern tanze einfach schneller.",
                "names": ["$~⏳", "$~Dauer"]
            },
            "style": {
                "doc": "$~Welchen Stil soll ich zum Tanzen verwenden?",
                "names": "$~Stil"
            },
            "count": {
                "doc": "$~Wie oft die Sequenz wiederholt werden soll, bevor sie beendet ist. Dies ist sehr hilfreich, wenn ich die Bühne betrete, mich auf die Bühne bewege oder sie verlasse, aber bei einer Ruhesequenz wird es ignoriert, da ich ewig ruhen kann.",
                "names": "$~zählen"
            }
        },
        "Place": {
            "names": ["Posición"],
            "doc": "$~Ich bin ein Standort auf @Stage. Alle meine Eingaben sind optional, da ich standardmäßig in der Mitte bin.",
            "x": {
                "doc": "$~Eine Position auf der x-Achse.",
                "names": "$~X"
            },
            "y": {
                "doc": "$~Eine Position auf der y-Achse",
                "names": "$~j"
            },
            "z": {
                "doc": "$~Eine Position auf der Z-Achse",
                "names": "$~z"
            },
            "rotation": {
                "doc": "$~Drehung an dieser Stelle",
                "names": ["$~📐", "$~Drehung"]
            }
        },
        "Velocity": {
            "doc": "$~Ich bin ein Standort auf @Stage. Alle meine Eingaben sind optional, da ich standardmäßig in der Mitte bin.",
            "names": ["$~💨", "$~Geschwindigkeit"],
            "x": {
                "doc": "$~Wie viele Meter pro Sekunde auf der X-Achse zurückgelegt werden sollen.",
                "names": "$~X"
            },
            "y": {
                "doc": "$~Wie viele Meter pro Sekunde auf der Y-Achse zurückgelegt werden sollen.",
                "names": "$~j"
            },
            "angle": {
                "doc": "$~Um wie viele Grad soll pro Sekunde gedreht werden?",
                "names": ["$~Winkel", "$~°"]
            }
        },
        "Matter": {
            "doc": "$~Ich bin die physikalischen Eigenschaften der Ausgabe, die beeinflussen, wie ich mit anderen Ausgaben auf der Bühne interagiere.",
            "names": ["$~⚛️", "$~Gegenstand"],
            "mass": {
                "doc": "$~Ein Gewicht in Kilogramm",
                "names": "$~Masse"
            },
            "bounciness": {
                "doc": "$~Wie viel von meiner Energie brauche ich, um eine Kollision aufrechtzuerhalten? 0 bedeutet keine, 1 bedeutet die volle Energie.",
                "names": "$~Sprungkraft"
            },
            "friction": {
                "doc": "$~Um wie viel soll weiter gerutscht werden? 0 bedeutet keine, 1 bedeutet für immer.",
                "names": "$~Reibung"
            },
            "roundedness": {
                "doc": "$~Wie stark die Ecken der Ausgabe gerundet werden sollen; 0 bedeutet keine und 1 bedeutet 100 % der Größe, wodurch die Größen kreisförmig werden.",
                "names": "$~Rundung"
            },
            "text": {
                "doc": "$~Ob es mit anderen Ausgaben kollidieren kann.",
                "names": "$~Text"
            },
            "shapes": {
                "doc": "$~Ob es mit anderen Formen kollidieren kann.",
                "names": "$~Boden"
            }
        },
        "Aura": {
            "doc": [
                "$~Ich bin eine AURA. Ich bringe @Phrase zum GLÜHEN! So:",
                "$~\\Phrase(\n'Ich LEUCHTE!' \nAura: Aura(Farbe(50% 100 118°) 0,1m 0m 0,1m\n)\\"
            ],
            "names": ["$~🔮", "$~Aura"],
            "color": {
                "doc": "$~Die @Farbe, die die @Aura haben sollte.",
                "names": "$~Farbe"
            },
            "blur": {
                "doc": "$~Wie verschwommen die @Aura sein soll. \\0m\\ bedeutet überhaupt nicht verschwommen.",
                "names": "$~verwischen"
            },
            "offsetX": {
                "doc": "$~Wie weit links oder rechts ich erscheinen soll. \\0m\\ liegt direkt darunter.",
                "names": "$~OffsetX"
            },
            "offsetY": {
                "doc": "$~Wie weit oben oder unten ich erscheinen soll.\\0m\\ steht direkt darunter.",
                "names": "$~OffsetY"
            }
        },
        "Easing": {
            "straight": "$~gerade",
            "cautious": "$~zurückhaltend",
            "pokey": "$~spitz",
            "zippy": "$~flink"
        },
        "sequence": {
            "sway": {
                "doc": "$~Ich erstelle eine @Sequence, die um den Mittelpunkt eines @Outputs hin und her schwankt.",
                "names": ["vaivén"],
                "angle": {
                    "doc": "$~Wie stark die Neigung beim Schwanken sein soll.",
                    "names": ["ángulo"]
                }
            },
            "bounce": {
                "doc": "$~Ich erstelle eine @Sequence, die @Output eine bestimmte Höhe zurückprallen lässt.",
                "names": ["rebotar"],
                "height": {
                    "doc": "$~Wie hoch der Sprung erfolgen soll.",
                    "names": ["altura"]
                }
            },
            "spin": {
                "doc": "$~Ich erstelle eine @Sequence, die @Output um ihren Mittelpunkt rotiert.",
                "names": ["girar"]
            },
            "fadein": {
                "doc": "$~Ich erstelle eine @Sequence, die @Output von unsichtbar auf sichtbar einblendet.",
                "names": ["revelar"]
            },
            "popup": {
                "doc": "$~Ich erstelle eine @Sequence, die @Output schnell skaliert, anstatt es auf die Normalgröße zu verkleinern.",
                "names": ["surgir"]
            },
            "shake": {
                "doc": "$~Ich erstelle eine @Sequence, die es so aussehen lässt, als ob ein @Output Angst hätte.",
                "names": ["agitar"]
            },
            "fadeout": {
                "doc": "$~Ich erstelle eine @Sequence, die @Output von sichtbar auf unsichtbar blendet. Probieren Sie mich in einer aufregenden @Sequence aus!",
                "names": ["$~ausblenden"]
            }
        },
        "Source": {
            "names": "$~Quelle",
            "doc": [
                "$~Sie wissen, dass Projekte mehr als eine @Source-Datei haben können? Ich lasse Sie eine @Source basierend auf der Logik Ihres Projekts erstellen. Das ist wirklich hilfreich, wenn Sie einige Daten zwischen verschiedenen Auswertungen Ihres Projekts speichern möchten.",
                "$~Stellen Sie sich beispielsweise vor, Sie möchten einen einfachen Zähler erstellen, der bei jedem Drücken einer Maustaste um eins hochzählt. Sie könnten ihn verwenden, um sich zu merken, wie oft Sie etwas getan haben.",
                "$~\\↓ zählen\n[\nPhrase(`\\zähle\\ mal!`)\nSource('zähle' zählen … ∆ Button() … zählen + 1 )\n]\\",
                "$~Versuchen Sie, es zu kopieren, eine neue @Source mit dem Namen /count/ zu erstellen und darin 0 einzugeben, um die Zählung bei 0 zu starten. Dieses kleine Projekt ruft den Wert in der /count/-Quelle ab und bearbeitet die /count/-@Source bei jedem Drücken der Maustaste so, dass sie dem aktuellen /count/-Wert plus /1/ entspricht."
            ],
            "name": {
                "names": "$~Name",
                "doc": "$~Der Name der zu erstellenden oder zu aktualisierenden Quelldatei."
            },
            "value": {
                "names": "$~Wert",
                "doc": "$~Der Datenwert, mit dem die Quelldatei erstellt oder aktualisiert werden soll."
            },
            "DynamicEditLimitException": {
                "description": "$~dynamisches Quelltext-Bearbeitungslimit",
                "explanation": "$~Dieses Projekt hat Daten zu oft und zu schnell in @Source-Dateien gespeichert. Stellen Sie sicher, dass @Source nur als Reaktion auf eine Eingabe und nicht zu schnell aktualisiert wird."
            },
            "ReadOnlyEditException": {
                "description": "$~Nur-Lese-Quellcode bearbeiten",
                "explanation": "$~Dieses Projekt speichert Daten, aber Sie haben keine Rechte, diese zu bearbeiten. Kopieren Sie die Daten, wenn Sie sie ausprobieren möchten."
            },
            "EmptySourceNameException": {
                "description": "$~leerer Quellname",
                "explanation": "$~Die angegebene @Source hatte einen leeren Namen, deshalb konnten wir sie nicht speichern."
            },
            "ProjectSizeLimitException": {
                "description": "$~Projektgrößenbeschränkung",
                "explanation": "$~Dieses Projekt hat zu viel Text, deshalb können wir es nicht speichern."
            }
        }
    },
    "ui": {
        "font": {
            "app": "Noto Sans",
            "code": "Noto Sans Mono"
        },
        "phrases": {
            "welcome": "Wilkommen"
        },
        "widget": {
            "confirm": {
                "cancel": "$~stornieren"
            },
            "dialog": {
                "close": "$~schließen"
            },
            "loading": {
                "message": "$~Schriftarten und Text werden geladen, danke fürs Warten!"
            },
            "home": "Startseite"
        },
        "tile": {
            "toggle": {
                "fullscreen": {
                    "on": "$~Vollbild verlassen",
                    "off": "$~auf Vollbild erweitern"
                },
                "show": {
                    "on": "$~verstecken",
                    "off": "$~zeigen"
                }
            },
            "label": {
                "output": "$~Bühne",
                "palette": "$~Palette",
                "docs": "$~Führung",
                "source": "$~Quelle"
            },
            "button": {
                "collapse": "$~Fenster ausblenden"
            }
        },
        "project": {
            "error": {
                "unknown": "$~Dieses Projekt existiert nicht oder ist nicht öffentlich.",
                "translate": "$~Beim Übersetzen Ihres Projekts ist ein Problem aufgetreten."
            },
            "button": {
                "showCollaborators": "$~Dialog für Mitarbeiter anzeigen",
                "removeCollaborator": "$~Mitarbeiter entfernen",
                "copy": "$~Projekt als Text in die Zwischenablage kopieren",
                "addSource": "$~erstelle eine neue $source",
                "duplicate": "$~Dieses Projekt kopieren",
                "revert": "$~zum Originalcode zurückkehren",
                "focusOutput": "$~Fokus Tastatur auf der Bühne",
                "focusSource": "$~Konzentrieren Sie sich auf die nächste Quelle",
                "focusDocs": "$~Fokus auf die Dokumentation",
                "focusPalette": "$~Konzentrieren Sie sich auf die Palette",
                "focusCycle": "$~Konzentriere dich auf die nächste Kachel",
                "unsaved": "$~Speicherfehler anzeigen",
                "translate": "$~Bearbeiten Sie die Sprachen dieses Projekts und übersetzen Sie es in andere Sprachen.",
                "primary": "$~als primäre Lokalität für dieses Projekt festlegen"
            },
            "field": {
                "name": {
                    "description": "$~Projektnamen bearbeiten",
                    "placeholder": "$~Name"
                }
            },
            "help": "$~Tastaturkürzel anzeigen",
            "collapsed": "$~Alle Ihre Fenster sind ausgeblendet! Sie finden sie in der Symbolleiste unten",
            "save": {
                "projectsNotSavedLocally": "$~Beim Speichern von Projekten in Ihrem Browser ist ein Problem aufgetreten.",
                "projectsCannotNotSaveLocally": "$~Ihr Browser unterstützt das Speichern von Projekten nicht.",
                "projectContainedPII": "$~Zum Schutz Ihrer Privatsphäre wurde ein Projekt mit potenziell persönlich identifizierbaren Informationen nicht online gespeichert. Überprüfen Sie das Projekt, um festzustellen, ob die Informationen identifizierend sind.",
                "projectsNotLoadingOnline": "$~Online-Projekte können nicht geladen werden.",
                "projectNotSavedOnline": "$~Projekte können nicht online gespeichert werden.",
                "settingsUnsaved": "$~Einstellungen können nicht online gespeichert werden."
            },
            "dialog": {
                "unsaved": "$~Nicht gespeicherte Arbeit …",
                "translate": {
                    "header": "$~Sprachen",
                    "explanation": [
                        "$~Dies sind die Sprachen, die Ihr Projekt verwendet.",
                        "$~Um zu versuchen, Ihr Projekt in andere Sprachen zu übersetzen, wählen Sie eine primäre Ausgangssprache und dann eine neue Sprache.",
                        "$~/Es werden nicht alle Sprachen unterstützt und die Übersetzungen können unvollständig sein. Überprüfen Sie daher die Ergebnisse!/"
                    ]
                }
            },
            "subheader": {
                "source": "$~Quelle",
                "destination": "$~Ziel"
            }
        },
        "gallery": {
            "untitled": "$~Ohne Titel",
            "undescribed": "$~Keine Beschreibung",
            "subheader": {
                "curators": {
                    "header": "$~KuratorInnen",
                    "explanation": "$~Ersteller, die diese Galerie verwalten."
                },
                "creators": {
                    "header": "$~Schöpfer",
                    "explanation": "$~Schöpfer, die zu dieser Galerie beitragen."
                },
                "delete": {
                    "header": "$~Löschen",
                    "explanation": "$~Durch das Löschen dieser Galerie werden ihre Projekte nicht gelöscht. Die Galerie wird dauerhaft gelöscht."
                }
            },
            "confirm": {
                "delete": {
                    "description": "$~Galerie löschen",
                    "prompt": "$~löschen"
                },
                "remove": {
                    "description": "$~Projekt aus der Galerie entfernen",
                    "prompt": "$~entfernen"
                }
            },
            "error": {
                "unknown": "$~Diese Galerie existiert nicht oder ist nicht öffentlich."
            },
            "field": {
                "name": {
                    "description": "$~Galeriename",
                    "placeholder": "$~Name"
                },
                "description": {
                    "description": "$~Galeriebeschreibung",
                    "placeholder": "$~Beschreiben Sie Ihre Galerie. Was ist ihr Thema, ihre Ziele oder ihre Community?"
                }
            }
        },
        "source": {
            "label": "$~Programmeditor",
            "empty": [
                "$~Lass uns anfangen! Du kannst …",
                "$~• Öffnen 📕 und ziehen 🖱️ Sie uns zu diesem Programm.",
                "$~• Geben Sie $1 ein und wählen Sie uns aus dem Menü.",
                "$~• Schreiben Sie uns mit ⌨️.",
                "$~• Durchsuchen Sie die <galleries@://galleries> zur Inspiration.",
                "$~Wenn Sie nicht weiterkommen, <erfahren Sie mehr@://erfahren Sie>."
            ],
            "overwritten": "$~Habe eine aktuellere Version erhalten!",
            "confirm": {
                "delete": {
                    "description": "$~lösche diese $source",
                    "prompt": "$~löschen"
                }
            },
            "toggle": {
                "blocks": {
                    "on": "$~Blockhintergründe ausblenden",
                    "off": "$~Blockhintergründe anzeigen"
                },
                "glyphs": {
                    "on": "$~die passenden Glyphen ausblenden",
                    "off": "$~Erweitern Sie die passenden Glyphen"
                }
            },
            "button": {
                "selectOutput": "$~diese Ausgabe auf der Bühne zeigen",
                "expandSequence": "$~Erweitern Sie diesen ausgeblendeten Code"
            },
            "field": {
                "name": {
                    "description": "$~Quellnamen bearbeiten",
                    "placeholder": "$~Name"
                }
            },
            "menu": {
                "label": "$~Autovervollständigungsmenü",
                "show": "$~Autovervollständigungsmenü anzeigen",
                "back": "$~Untermenü verlassen"
            },
            "cursor": {
                "priorLine": "$~Bewegen Sie den Cursor zur Zeile davor.",
                "nextLine": "$~Bewegen Sie den Cursor zur nächsten Zeile.",
                "priorInline": "$~Bewegen Sie den Cursor zur Position davor.",
                "nextInline": "$~Bewegen Sie den Cursor zur Position danach",
                "lineStart": "$~Cursor an den Zeilenanfang bewegen",
                "lineEnd": "$~Cursor ans Zeilenende bewegen",
                "sourceStart": "$~Bewegen Sie den Cursor zum Anfang der Quelle.",
                "sourceEnd": "$~Bewegen Sie den Cursor an das Ende der Quelle.",
                "priorNode": "$~wähle Nachbarn vor",
                "nextNode": "$~wähle Nachbar nach",
                "parent": "$~Container auswählen",
                "selectAll": "$~Programm auswählen",
                "incrementLiteral": "$~Erhöhen Sie die Zahl, den Text oder den Boolean-Wert",
                "decrementLiteral": "$~Verringern Sie die Zahl, den Text oder den Booleschen Wert",
                "insertSymbol": "$~füge $1 ein",
                "insertTab": "$~Registerkarte einfügen",
                "insertTrue": "$~Füge „true“ ein",
                "insertFalse": "$~false einfügen",
                "insertNone": "$~kein Symbol einfügen",
                "insertNotEqual": "$~Einfügen ungleich",
                "insertProduct": "$~Produktsymbol einfügen",
                "insertQuotient": "$~Quotientensymbol einfügen",
                "insertDegree": "$~Gradsymbol einfügen",
                "insertFunction": "$~Einfügefunktion",
                "insertLessOrEqual": "$~einfügen kleiner oder gleich",
                "insertGreaterOrEqual": "$~einfügen größer als oder gleich",
                "insertStream": "$~Streamsymbol einfügen",
                "insertChange": "$~Änderungssymbol einfügen",
                "insertConvert": "$~Konvertierungssymbol einfügen",
                "insertPrevious": "$~vorheriges Symbol einfügen",
                "insertType": "$~Typsymbol einfügen",
                "insertTable": "$~Symbol zum Öffnen der Tabelle einfügen",
                "insertTableClose": "$~Symbol zum Schließen der Tabelle einfügen",
                "insertBorrow": "$~einfügen ausleihen",
                "insertShare": "$~teilen",
                "insertLine": "$~Zeilenumbruch einfügen",
                "backspace": "$~Auswahl oder vorheriges Symbol löschen",
                "delete": "$~Auswahl oder nächstes Symbol löschen",
                "cut": "$~Auswahl ausschneiden",
                "copy": "$~Auswahl kopieren",
                "paste": "$~Einfügen von Tastaturinhalten",
                "parenthesize": "$~Auswahl in Klammern setzen",
                "enumerate": "$~Auswahl aufzählen",
                "type": "$~Typzeichen",
                "undo": "$~vorherige Bearbeitung rückgängig machen",
                "redo": "$~Rückgängig gemachte Bearbeitung wiederholen",
                "search": "$~Suche nach einzufügenden Sonderzeichen",
                "tidy": "$~ordentlicher Abstand",
                "elide": "$~Elision umschalten"
            }
        },
        "annotations": {
            "label": "$~Konflikte und Hilfe",
            "cursor": "$~Dies ist *$1*$2[ und sie sind vom Typ $2|]. $3[ Sie befinden sich innerhalb einer *$3*.|]",
            "cursorParent": "$~Sie befinden sich innerhalb eines *$1*$2[ vom Typ $2|].",
            "learn": "$~/Erfahren Sie mehr/",
            "evaluating": "$~Oh Spaß, lass es uns auswerten!",
            "space": "$~Das ist Weltraum! Wer hätte gedacht, dass nichts so viel aussagen kann?",
            "button": {
                "resolution": "$~Diesen Konflikt lösen"
            }
        },
        "output": {
            "label": "$~Programmausgabe",
            "toggle": {
                "grid": {
                    "on": "$~Gitternetzlinien ausblenden",
                    "off": "$~Gitternetzlinien anzeigen"
                },
                "fit": {
                    "on": "$~Zoom manuell steuern",
                    "off": "$~Zoom an Inhalt anpassen"
                },
                "paint": {
                    "on": "$~Farbausgabe",
                    "off": "$~Ausgabe platzieren"
                }
            },
            "field": {
                "key": {
                    "description": "$~Tastendrücke abhören",
                    "placeholder": "$~Nachricht"
                }
            },
            "button": {
                "submit": "$~diese Chat-Nachricht senden"
            }
        },
        "timeline": {
            "label": "$~Zeitleiste",
            "slider": "$~Zeitschieberegler",
            "button": {
                "play": "$~das Programm bis zum Ende auswerten und auf Eingaben in Echtzeit reagieren",
                "pause": "$~das Programm anhalten, um vorwärts und rückwärts gehen zu können",
                "backStep": "$~einen Schritt zurück",
                "backNode": "$~Schritt zur vorherigen Auswertung des Cursors",
                "backInput": "$~einen Eingang zurück",
                "out": "$~Aus dieser Funktion aussteigen",
                "forwardStep": "$~Schritt vorwärts einen",
                "forwardNode": "$~Schritt zur nächsten Auswertung des Cursors",
                "forwardInput": "$~Schritt vorwärts zum nächsten Stream-Eingang",
                "present": "$~bis zum Ende",
                "start": "$~zu Beginn",
                "reset": "$~Leistung neu starten"
            }
        },
        "docs": {
            "label": "$~Dokumentationsbrowser",
            "link": "$~Konzept $1 in der Dokumentation anzeigen",
            "learn": "$~Lern mehr …",
            "nodoc": "$~Wer bin ich? Was bin ich? Was ist mein Ziel?",
            "button": {
                "home": "$~nach Hause zurückkehren",
                "back": "$~Zurück zur vorherigen"
            },
            "field": {
                "search": "$~Suche nach Konzepten mit Wörtern"
            },
            "header": {
                "inputs": "$~Eingänge",
                "interfaces": "$~Schnittstellen",
                "properties": "$~Eigenschaften",
                "functions": "$~Funktionen",
                "conversions": "$~Konvertierungen"
            }
        },
        "dialog": {
            "share": {
                "header": "$~Weitergabe",
                "explanation": "$~Steuern Sie, wer dieses Projekt bearbeiten und sehen kann.",
                "subheader": {
                    "collaborators": {
                        "header": "$~Kooperationspartner",
                        "explanation": "$~Mitarbeiter können dieses Projekt anzeigen und bearbeiten. Nur Projektbesitzer können Mitarbeiter ändern."
                    },
                    "gallery": {
                        "header": "$~Galerie",
                        "explanation": "$~Fügen Sie dieses Projekt einer Galerie neben anderen Erstellern hinzu oder erstellen Sie eine Galerie auf Ihrer Seite <projects@://projects>. Wenn Sie ein Projekt einer öffentlichen Galerie hinzufügen, wird Ihr Projekt öffentlich."
                    },
                    "public": {
                        "header": "$~Öffentlich/Privat",
                        "explanation": "$~Öffentliche Projekte und Galerien können von jedem auf der Welt gesehen werden. Unser Ziel ist es, dass diese Inhalte Bestätigung und Freude bringen, und das öffentliche Teilen ist eine Möglichkeit, dies zu erreichen. Aber es bedeutet auch, einige Regeln einzuhalten. Sie versprechen, dass Ihr Projekt Folgendes nicht tut:"
                    },
                    "pii": {
                        "header": "$~Persönliche Angaben",
                        "explanation": "$~Das öffentliche Teilen personenbezogener Daten (PII) kann die Urheber gefährden. Daher erkennen wir mögliche PII und warnen die Urheber, die sensiblen Daten entweder zu entfernen oder als nicht sensibel zu kennzeichnen.\n\nNachfolgend finden Sie eine Liste möglicher PII in diesem Projekt, das Sie als nicht sensibel gekennzeichnet haben. Sie können auf die Schaltfläche daneben klicken, um es wieder als sensibel zu kennzeichnen. Dies bedeutet jedoch, dass Ihr Projekt nicht mehr online gespeichert wird."
                    }
                },
                "field": {
                    "emailOrUsername": {
                        "placeholder": "$~E-Mail Adresse oder Benutzername",
                        "description": "$~E-Mail oder Benutzername der Person, der Sie Bearbeitungszugriff gewähren möchten"
                    }
                },
                "mode": {
                    "public": {
                        "label": "$~Sichtweite",
                        "modes": ["$~Privat", "$~öffentlich"]
                    }
                },
                "error": {
                    "unknown": "$~Wir kennen keinen Ersteller mit dieser E-Mail.",
                    "anonymous": "$~Zum Teilen müssen Sie angemeldet sein."
                },
                "button": {
                    "submit": "$~Teilen Sie das Projekt mit dieser E-Mail-Adresse",
                    "sensitive": {
                        "tip": "$~Diesen Text erneut als vertraulich markieren",
                        "label": "$~empfindlich"
                    }
                },
                "options": {
                    "gallery": "$~Galerieauswahl"
                }
            },
            "settings": {
                "header": "$~Einstellungen",
                "explanation": "$~Ändern Sie die Layout-, Geräte- und Designeinstellungen.",
                "button": {
                    "show": "$~Einstellungsdialog anzeigen"
                },
                "mode": {
                    "layout": {
                        "label": "$~Layout",
                        "modes": [
                            "$~automatisch",
                            "$~horizontal",
                            "$~Vertikale",
                            "$~frei"
                        ]
                    },
                    "animate": {
                        "label": "$~Animationen",
                        "modes": [
                            "$~Animationen aus",
                            "$~normale Geschwindigkeit",
                            "$~halbe Geschwindigkeit",
                            "$~dritte Geschwindigkeit",
                            "$~Viertelgeschwindigkeit"
                        ]
                    },
                    "dark": {
                        "label": "$~Thema",
                        "modes": [
                            "$~helle Farben",
                            "$~dunkle Farben",
                            "$~Geräteeinstellungen verwenden"
                        ]
                    },
                    "space": {
                        "label": "$~Leerzeichenanzeige",
                        "modes": [
                            "$~Leerzeichen- und Tabulatoranzeigen explizit anzeigen",
                            "$~Leerzeichen und Tabulatoren nicht anzeigen"
                        ]
                    },
                    "writing": {
                        "label": "$~Schreiblayout",
                        "modes": [
                            "$~horizontal, von links nach rechts",
                            "$~vertikal, von rechts nach links",
                            "$~vertikal, von links nach rechts"
                        ]
                    },
                    "localized": {
                        "label": "$~Codelokalisierung",
                        "modes": [
                            "$~Code nicht lokalisieren",
                            "$~Code lokalisieren, wenn verfügbar",
                            "$~Code lokalisieren, aber Symbole bevorzugen"
                        ]
                    }
                },
                "options": {
                    "mic": "$~ausgewähltes Mikrofon",
                    "camera": "$~ausgewählte Kamera"
                }
            },
            "locale": {
                "header": "$~Sprache",
                "explanation": "$~Wählen Sie Ihre Sprachen und Regionen.",
                "subheader": {
                    "selected": "$~Ausgewählt",
                    "supported": "$~Verfügbar",
                    "coming": "$~Demnächst",
                    "help": "$~Helfen Sie uns beim Übersetzen …"
                },
                "button": {
                    "show": "$~Gebietsschema ändern",
                    "add": "$~dieses Gebietsschema hinzufügen",
                    "remove": "$~Dieses Gebietsschema entfernen",
                    "replace": "$~durch dieses Gebietsschema ersetzen"
                }
            },
            "help": {
                "header": "$~Verknüpfungen",
                "explanation": "$~Verwenden Sie diese Tastaturbefehle für eine effizientere Bearbeitung.",
                "subheader": {
                    "moveCursor": "$~Bewegen",
                    "editCode": "$~Bearbeiten",
                    "insertCode": "$~Einfügen",
                    "debug": "$~Debuggen"
                }
            }
        },
        "palette": {
            "label": "$~Palette",
            "labels": {
                "mixed": "$~gemischt",
                "computed": "$~berechnet",
                "default": "$~Standard",
                "inherited": "$~vererbt",
                "notSequence": "$~keine Sequenz",
                "notContent": "$~kein Inhaltsverzeichnis",
                "format": "$~Format",
                "weight": "$~Gewicht",
                "light": "$~Licht",
                "normal": "$~normal",
                "bold": "$~deutlich",
                "extra": "$~extra",
                "italic": "$~kursiv",
                "underline": "$~unterstreichen"
            },
            "button": {
                "revert": "$~auf Standard zurücksetzen",
                "set": "$~diese Eigenschaft bearbeiten",
                "addPhrase": "$~füge danach eine Phrase hinzu",
                "addGroup": "$~füge danach eine Gruppe hinzu",
                "addShape": "$~füge danach eine Form hinzu",
                "addMotion": "$~Ort für Motion Stream festlegen",
                "addPlacement": "$~Ort auf Platzierungsstream setzen",
                "remove": "$~diesen Inhalt entfernen",
                "up": "$~diesen Inhalt nach oben verschieben",
                "down": "$~diesen Inhalt nach unten verschieben",
                "edit": "$~diesen Inhalt bearbeiten",
                "sequence": "$~in Sequenz umwandeln",
                "createPhrase": "$~Erstellen Sie eine Phrase, die den vorhandenen Wert als Text anzeigt",
                "createGroup": "$~Erstellen Sie eine Gruppe, die jede vorhandene Phrase umschließt",
                "createStage": "$~Erstellen Sie eine Bühne, die eine vorhandene Gruppe oder Phrase umschließt"
            },
            "prompt": {
                "offerPhrase": "$~Was für einen tollen Wert Sie geschaffen haben! Soll ich es auf @Stage zeigen?",
                "offerGroup": "$~Was für eine wunderbare @Phrase du erstellt hast. Möchtest du sie in einer @Gruppe zusammenführen, um sie zu ordnen?",
                "offerStage": "$~SEHR GUT @Programm. FÜGEN SIE MICH HINZU, UM BELEUCHTUNG, FARBEN UND RAHMEN ZU STEUERN.",
                "pauseToEdit": "$~Wenn Sie die Phase ⏸️, können Sie ein 💬, 🔳 oder 🎭 zum Bearbeiten auswählen!",
                "editing": "$~Bearbeite mich!"
            },
            "field": {
                "coordinate": "$~Koordinate bearbeiten",
                "text": "$~Text bearbeiten"
            },
            "sequence": {
                "button": {
                    "add": "$~Pose hinzufügen",
                    "remove": "$~Pose entfernen",
                    "up": "$~Pose nach oben bewegen",
                    "down": "$~Pose nach unten verschieben"
                },
                "field": {
                    "percent": "$~Prozent bearbeiten"
                }
            }
        },
        "save": {
            "saving": "Speichern",
            "saved": "Online gespeichert",
            "local": "Im Browser gespeichert",
            "unsaved": "Ungespeichert"
        },
        "page": {
            "unknown": {
                "header": "$~Iiihhh!",
                "message": "$~Wo ist dieser Ort? Können wir nach Hause gehen?"
            },
            "landing": {
                "value": "$~Erstellen Sie mit uns interaktive Geschichten mit Wörtern, Symbolen, Emojis und Code!",
                "description": [
                    "$~Wordplay ist eine Programmiersprache, die Ihnen Folgendes ermöglicht:",
                    "$~• Wörter und Emojis spielerisch animieren 🤪",
                    "$~• Nutze Zeit 🕦, Ton 🎤, Websites 🔗 und Physik 🌎",
                    "$~• Teilen 🤝 mit Freunden, Gruppen oder jedem",
                    "$~• Code in jeder Weltsprache 🌐",
                    "$~• Bearbeiten mit Mäusen 🖱️, Touch 👆 und Tastaturen ⌨️",
                    "$~• Vorwärts-⏩ und Rückwärts-⏪-Debuggen",
                    "$~• Mit Bildschirmen 🖥️ und Bildschirmleseprogrammen 🔊 anzeigen",
                    "$~Für immer kostenlos von der <University of Washington@https://ischool.uw.edu/>."
                ],
                "beta": [
                    "$~Wordplay befindet sich in der *Beta*-Phase und funktioniert daher möglicherweise nicht wie vorgesehen oder ist nicht vollständig. Melden Sie Fehler und teilen Sie Ideen in <GitHub@https://github.com/wordplaydev/wordplay/issues>, sehen Sie sich unsere <1.0-Pläne@https://github.com/wordplaydev/wordplay/milestones/1.0> an und <contribute@https://github.com/wordplaydev/wordplay/wiki/contribute>."
                ],
                "link": {
                    "about": "Warum existiert diese Website?",
                    "learn": "Ein dramatisches Tutorial mit einer schillernden Besetzung von Charakturen",
                    "projects": "Wo du deine Aufführungen machen und teilen kannst",
                    "galleries": "Erleben Sie die Leistungen anderer",
                    "rights": "Unsere und deine Verantwortungen",
                    "guide": "Suchen und stöbern Sie in der Sprachreferenz",
                    "community": {
                        "label": "Gemeinschaft",
                        "subtitle": "Chatten Sie mit uns auf Discord."
                    },
                    "contribute": {
                        "label": "Beitragen",
                        "subtitle": "Helfen Sie uns, Wordplay zu erstellen."
                    }
                }
            },
            "learn": {
                "header": "Lernen",
                "error": "$~Wir konnten kein Tutorial für diese Sprache finden.",
                "button": {
                    "next": "$~nächste Pause im Dialog",
                    "previous": "$~vorherige Pause im Dialog"
                },
                "options": {
                    "lesson": "$~aktuelle Lektion"
                }
            },
            "projects": {
                "header": "Projekte",
                "projectprompt": "$~Bereit, etwas zu sagen? Erstellen Sie ein Projekt oder arbeiten Sie an einem. Wenn Sie nicht weiterkommen, <learning@://learn> weiter.",
                "archiveheader": "$~Archiviert",
                "archiveprompt": "$~Dies sind Projekte, die Sie archiviert haben. Nur Eigentümer können sie dauerhaft löschen oder aus dem Archiv entfernen. Archivierte Projekte werden 30 Tage nach ihrer letzten Bearbeitung dauerhaft gelöscht.",
                "galleriesheader": "Galerien",
                "galleryprompt": "$~Erstellen und kuratieren Sie Galerien, um eine Projektsammlung mit anderen zu teilen.",
                "add": {
                    "header": "$~Neues Projekt",
                    "explanation": "$~Wählen Sie eine Vorlage, um ein neues Projekt zu erstellen."
                },
                "button": {
                    "newproject": "$~neues Projekt",
                    "editproject": "$~Dieses Projekt bearbeiten",
                    "newgallery": "$~neue Galerie",
                    "unarchive": "$~Dieses Projekt aus dem Archiv nehmen",
                    "viewcode": "$~Code dieses Projekts anzeigen"
                },
                "confirm": {
                    "archive": {
                        "description": "$~Diesen Auftritt archivieren",
                        "prompt": "$~Archiv"
                    },
                    "delete": {
                        "description": "$~diesen Auftritt endgültig löschen",
                        "prompt": "$~Unwiederuflich löschen"
                    }
                },
                "error": {
                    "noaccess": "$~Wir konnten nicht auf das Internet zugreifen.",
                    "nogalleryedits": "$~Sie müssen angemeldet sein, um Galerien erstellen und ändern zu können.",
                    "newgallery": "$~Wir konnten keine neue Galerie erstellen.",
                    "nodeletes": "$~Sie müssen angemeldet sein, um archivierte Projekte zu löschen.",
                    "delete": "$~Hoppla, wir konnten das Projekt nicht löschen!"
                }
            },
            "galleries": {
                "header": "Galerien",
                "prompt": "$~Dies sind Leistungen, die andere erbracht haben. Erleben Sie sie, studieren Sie sie oder adaptieren Sie sie für Ihre eigene Aussage.",
                "examples": "Beispiele"
            },
            "about": {
                "header": "Über uns",
                "content": [
                    "$~Hatten Sie schon einmal das Gefühl, dass Programmieren nur etwas für Westler mit guten Englischkenntnissen und ohne Behinderung ist, die mit Computern aufgewachsen sind?",
                    "$~Ja, wir auch.",
                    "$~Das ist kein Zufall. Seit es Computer gibt, wurden Programmiersprachen größtenteils von derselben Gruppe von Menschen entworfen und entwickelt – hauptsächlich von weißen, englischsprachigen Männern mit cis-Gesichtsausdruck in der Wissenschaft und Industrie in den USA und Europa und ein paar unglaublichen Mathematikerinnen. Sie arbeiteten in einer Zeit postkolonialer Macht, in der der Gewinner alles bekam, und Programmiersprachen waren ein wichtiges Instrument zur Sicherung dieser Macht.",
                    "$~Diese Geschichte hat zu einer Vision der Datenverarbeitung geführt, bei der es in erster Linie um Geschwindigkeit, Logik, Profit und Dominanz geht.",
                    "$~Das ist ungerecht. Denn Computer sind heute – im Guten wie im Schlechten – sichtbar und unsichtbar Teil des täglichen Lebens, und die Menschen, die sie nutzen können, sind diejenigen, die ihren Schöpfern am ähnlichsten sind. Der Rest der Menschheit bleibt dieser Macht ausgeliefert, denn um sich etwas anderes vorzustellen, muss man lesen und schreiben können, und Sprachbarrieren, Zugangsbarrieren, wirtschaftliche Hürden und Ungleichheiten im öffentlichen Bildungssystem verhindern dies.",
                    "$~*Wordplay* möchte dazu beitragen, dies zu ändern. Es handelt sich um eine Programmierplattform, die global konzipiert ist und alle Sprachen der Welt unterstützt, aber auch etwas über die Sprachen der Welt dreht. Eine Plattform, auf der jeder mit seinen Fähigkeiten kreativ sein und interaktive Inhalte teilen kann, die jeder erleben kann. Für Jugendliche und junge Erwachsene, die sich spielerisch und kunstvoll durch interaktive Wörter, Emojis und Typografie ausdrücken möchten. Nicht mit dem Ziel, selbst Macht zu erlangen, sondern um eine computergestützte Welt zu schaffen, die die unglaubliche Stärke und Notwendigkeit unserer schönen Unterschiede anerkennt.",
                    "$~Wir sind eine Gemeinschaft von Designern, Pädagogen und Entwicklern, die versuchen, diese Vision zum Leben zu erwecken. Wir sind People of Color, wir sind Transsexuelle, wir sind Queers, wir sind Behinderte, wir sind Immigranten, wir sind Flüchtlinge. Unser Zentrum ist die <University of Washington@https://washington.edu> <Information School@https://ischool.uw.edu/> in Seattle, Washington, USA, einem Ort, der danach strebt, alle willkommen zu heißen und die bis heute andauernden behindertenfeindlichen und rassistischen Verwüstungen des Kolonialismus rückgängig zu machen. Die Entwicklung dieser Programmiersprache und Plattform ist ein kleiner Teil dieser Mission und bietet einen Einblick in eine Zukunft der Computertechnik, in die /jeder/ gehört.",
                    "$~Wir freuen uns über Ihre Hilfe. Erfahren Sie, <wie Sie beitragen können@https://github.com/wordplaydev/wordplay/wiki/contribute>, <spenden@://donate> oder verfolgen Sie unseren <Fortschritt@https://github.com/amyjko/wordplay/milestones>. Schreiben Sie unserer Community-Organisatorin <Amy@https://amyjko.phd>, wenn Sie Fragen haben."
                ]
            },
            "login": {
                "header": "Anmeldung",
                "subtitle": "$~Erstellen Sie ein Konto oder melden Sie sich an, um Ihre Arbeit online zu speichern",
                "anonymous": "Anmeldung",
                "prompt": {
                    "login": "$~Ihre Performances werden in diesem Browser gespeichert, aber nicht online. Wenn dies Ihr Gerät ist, ist das in Ordnung! Wenn nicht, haben andere Zugriff auf Ihre Projekte und Sie könnten sie verlieren. Um sie online zu speichern und privat zu halten, melden Sie sich an oder <erstellen Sie ein Konto@://join>:",
                    "forgot": "$~*Passwort vergessen?* Leider können wir Ihr Konto nicht wiederherstellen, da wir keine Kontaktinformationen erfassen.",
                    "email": "$~Haben Sie ein Nur-E-Mail-Konto? Melden Sie sich an, indem Sie Ihre E-Mail-Adresse angeben. Wenn ein Konto damit verknüpft ist, senden wir Ihnen eine E-Mail mit einem Anmeldelink. Neue Nur-E-Mail-Konten werden aus Datenschutzgründen nicht unterstützt.",
                    "enter": "$~Offenbar stammt Ihr Anmeldelink von einem anderen Browser oder Gerät. Können Sie Ihre E-Mail-Adresse noch einmal eingeben, damit wir sicher sind, dass Sie es sind?",
                    "tooyoung": "$~Sie müssen mindestens 13 Jahre alt sein, um sich mit einer E-Mail anzumelden.",
                    "passwordrule": "$~Passwörter müssen mindestens 10 Zeichen lang sein. Wenn Sie keinen Passwort-Manager verwenden, wählen Sie drei lange Wörter, die Sie sich gut merken können.",
                    "passwordreminder": "$~Es sieht so aus, als ob Sie noch kein Konto haben. Geben Sie Ihr Passwort erneut ein und stellen Sie sicher, dass Sie es sicher und korrekt gespeichert haben, da es nicht wiederherstellbar ist.",
                    "play": "$~Sie sind angemeldet, wir können Ihre Projekte jetzt online speichern! Möchten Sie etwas erstellen?",
                    "changeEmail": "$~Möchten Sie Ihre E-Mail-Adresse ändern? Senden Sie eine neue und wir senden eine Bestätigung an die alte.",
                    "changePassword": "$~Möchten Sie Ihr Passwort ändern? Senden Sie ein Neues und wiederholen Sie es.",
                    "logout": "$~Verwenden Sie ein gemeinsam genutztes Gerät und möchten Ihre Projekte privat halten? Melden Sie sich ab und wir *löschen* Ihre Projekte von diesem Gerät, sie werden jedoch online gespeichert.",
                    "sent": "$~Wenn diese E-Mail mit einem Konto verknüpft ist, wird eine E-Mail mit einem Anmeldelink gesendet. Es kann einige Minuten dauern, bis dieser angezeigt wird. Wenn mit dieser E-Mail kein Konto verknüpft ist, erhalten Sie nichts.",
                    "success": "$~Account erstellt!",
                    "confirm": "$~Überprüfen Sie Ihre alte E-Mail-Adresse, um Ihre neue Adresse zu bestätigen.",
                    "delete": "$~Möchten Sie, dass wir alles vergessen, was Sie hier gemacht haben? Dies kann nicht rückgängig gemacht werden.",
                    "reallyDelete": "$~Sind Sie sicher? Ihr Konto und Ihre Einstellungen werden sofort gelöscht und Ihre Projekte werden zur Löschung vorgemerkt. Mitarbeiter Ihrer Projekte verlieren sofort den Zugriff darauf. Geben Sie Ihre E-Mail-Adresse oder Ihren Benutzernamen ein, um zu bestätigen, dass Sie dies wünschen.",
                    "name": "$~WählenSieeinEmojiaus,umsichanderenvorzustellen."
                },
                "error": {
                    "expired": "$~Dieser Link ist abgelaufen.",
                    "invalid": "$~Dieser Link ist ungültig.",
                    "email": "$~Diese E-Mail war ungültig.",
                    "offline": "$~Wir konnten die Cloud ☁️ nicht erreichen.",
                    "failure": "$~Anmeldung nicht möglich :(",
                    "unchanged": "$~Wir konnten Ihre E-Mail-Adresse nicht ändern, wissen aber nicht, warum.",
                    "delete": "$~Wir konnten Ihr Konto nicht löschen, wissen aber nicht, warum.",
                    "wrongPassword": "$~Kein gültiger Benutzername und Passwort. Entweder ist Ihr Passwort falsch oder jemand anderes hat diesen Benutzernamen.",
                    "tooMany": "$~Sie haben zu oft erfolglos versucht, sich anzumelden. Sie müssen warten, bevor Sie es erneut versuchen können."
                },
                "feedback": {
                    "changing": "$~Neue E-Mail wird gesendet …",
                    "deleting": "$~Okay, Ihre Projekte und Einstellungen werden gelöscht …",
                    "updatedPassword": "$~Ihr Passwort wurde aktualisiert.",
                    "match": "$~Dies muss mit dem Benutzernamen Ihres Kontos übereinstimmen."
                },
                "field": {
                    "email": {
                        "description": "$~Login-E-Mail bearbeiten",
                        "placeholder": "$~Email"
                    },
                    "username": {
                        "description": "$~Login-Benutzername, verwenden Sie keine personenbezogenen Daten",
                        "placeholder": "$~Nutzername"
                    },
                    "password": {
                        "description": "$~Login-Passwort, mindestens 10 Zeichen",
                        "placeholder": "$~Passwort"
                    },
                    "currentPassword": {
                        "description": "$~Ihr aktuelles Login-Passwort",
                        "placeholder": "$~Aktuelles Passwort"
                    },
                    "newPassword": {
                        "description": "$~Dein neues Passwort",
                        "placeholder": "$~Neues Kennwort"
                    }
                },
                "button": {
                    "logout": {
                        "tip": "$~Abmelden von Ihrem Konto",
                        "label": "$~Ausloggen"
                    },
                    "login": "$~Mit dieser E-Mail anmelden, einen Login-Link senden",
                    "updateEmail": "$~Ändere deine E-Mail",
                    "updatePassword": "$~neues Passwort eingeben",
                    "delete": {
                        "tip": "$~Lösche deinen Account",
                        "label": "$~meine Daten löschen…"
                    },
                    "reallyDelete": {
                        "tip": "$~lösche dein Konto für immer",
                        "label": "$~Lösche es!!!"
                    }
                },
                "toggle": {
                    "reveal": {
                        "on": "$~Passwort anzeigen",
                        "off": "$~Passwort verbergen"
                    }
                }
            },
            "join": {
                "header": "$~Verbinden",
                "prompt": {
                    "username": "$~Bereit, ein Konto zu erstellen? Wählen Sie zunächst einen *Benutzernamen*. Er muss mindestens 5 Zeichen lang sein, darf keine E-Mail-Adresse sein und sollte weder Ihren Namen noch andere identifizierende Informationen enthalten.",
                    "password": "$~Wählen Sie ein Passwort mit mindestens *10 Zeichen*. Geben Sie es erneut ein, um sicherzustellen, dass Sie es richtig eingegeben haben, und speichern Sie es an einem sicheren Ort, beispielsweise in einem Passwort-Manager. *Es gibt keine Möglichkeit, Ihr Konto wiederherzustellen*, wenn Sie es verlieren, da wir keine Kontaktinformationen erfassen."
                }
            },
            "rights": {
                "header": "Rechte",
                "content": [
                    "$~Hallo!",
                    "$~Lassen Sie uns einige Erwartungen hinsichtlich Ihrer und unserer Rechte festlegen (auch im Lichte von Richtlinien wie <COPPA@https://www.ecfr.gov/current/title-16/chapter-I/subchapter-C/part-312> und <GDPR@https://gdpr.eu/compliance-checklist-us-companies/>).",
                    "$~Zunächst einmal sollten Sie wissen, dass wir kein kommerzielles Unternehmen sind. Wir sind ein gemeinschaftsbasiertes Forschungsprojekt an einer gemeinnützigen Universität. Unser Ziel ist es, eine Plattform zu schaffen, die Ihnen Freude bereitet und uns hilft, Entdeckungen über eine gerechtere und fairere Computerwelt zu machen. Wir haben kein Interesse daran, mit dieser Plattform Geld zu verdienen. Jegliches Geld, das wir sammeln (normalerweise durch öffentliche Mittel), wird verwendet, um die Plattform zu erhalten, und nicht, um jemanden zu bereichern, der daran arbeitet (oder dazu beiträgt).",
                    "$~Da wir keinen Gewinn anstreben, können wir auch keine Versprechungen zur Zuverlässigkeit, Verfügbarkeit oder Langlebigkeit dieser Plattform machen. Dennoch ist <Amy@https://amyjko.phd> langfristig für die Aufrechterhaltung der Plattform engagiert und hat als Professorin mit Festanstellung einen ziemlich sicheren Job.",
                    "$~Damit kommen wir zu *Daten*. Folgendes sammeln und speichern wir in der Cloud:",
                    "$~• Ihre *Projekte*. Wir speichern alle Projekte, zu denen Sie beitragen, und Ihre Änderungen daran, es sei denn, diese Projekte scheinen personenbezogene Daten wie Telefonnummern, E-Mail-Adressen, Benutzernamen, Steuernummern oder Adressen zu enthalten.",
                    "$~• Ihre *Einstellungen*. Dazu gehören die von Ihnen gewählten Sprachen, Ihre Animationseinstellungen und Ihr Lernfortschritt. Alles andere wird nur auf Ihrem Gerät gespeichert.",
                    "$~• Aggregierte *Aktivität*. Wir verfolgen Anmeldungen und die von Ihnen besuchten Seiten, jedoch nicht auf eine Weise, die Sie identifizieren, Sie auf der Website verfolgen oder Sie auf anderen Websites verfolgen kann. Wir verwenden Google Analytics im Modus „Zustimmung verweigert“, der nur minimale nicht identifizierbare Informationen über Seitenaufrufe sammelt, ohne Cookies zu speichern oder IP-Adressinformationen an Google zu senden. Wir verwenden diese aggregierten Informationen, um Spenden zu sammeln, indem wir melden, wie stark die Plattform genutzt wird.",
                    "$~Wir speichern nichts anderes. Unsere <source@https://github.com/amyjko/wordplay/tree/main/src> ist öffentlich, sodass jeder dies überprüfen und unbeabsichtigtes Tracking melden kann.",
                    "$~*Sie* besitzen Ihre Daten, nicht wir. Das bedeutet:",
                    "$~• Sie bestimmen, wer auf Ihre Projekte zugreifen kann. Sie sind standardmäßig privat, Sie können sie jedoch mit Einzelpersonen oder Gruppen teilen oder sie vollständig öffentlich machen.",
                    "$~• Sie können jedes Projekt oder Ihren eigenen Account jederzeit vollständig löschen.",
                    "$~• Sie können jederzeit einen Export jedes Projekts oder Ihres gesamten Kontos erhalten.",
                    "$~So verwenden wir Ihre Daten und so nicht:",
                    "$~• Wir geben Ihre Daten an niemanden weiter, es sei denn, dies ist gesetzlich ausdrücklich vorgeschrieben. Es ist immer möglich, dass Ihre Daten ohne Ihre Erlaubnis entwendet werden (ein „Datenverstoß“). Wenn wir feststellen, dass dies geschehen ist, benachrichtigen wir Sie darüber unter Verwendung der E-Mail-Adresse, die Sie uns mitgeteilt haben.",
                    "$~• Wir werden Sie nicht über Ihre E-Mail-Adresse kontaktieren, es sei denn, Sie 1) nehmen eine Kontoänderung vor, die dies erforderlich macht, 2) Sie erteilen uns ausdrücklich Ihre Zustimmung zur Kontaktaufnahme oder 3) es liegt eine der oben genannten Datenschutzverletzungen vor.",
                    "$~• Wir können Projekte auf der Plattform analysieren, um zu verstehen, was jeder macht und wie er es macht. Wir können diese aggregierten, anonymisierten Erkenntnisse in akademischen Veröffentlichungen teilen. Wir werden dies nur unter der Aufsicht eines institutionellen Überprüfungsausschusses tun, wie es das US-Bundesgesetz vorschreibt.",
                    "$~Zum Schluss noch ein Hinweis zur Redefreiheit. Sie können auf dieser Plattform *privat* alles sagen, was Sie möchten. Projekte sind standardmäßig privat, und wenn Sie sie mit bestimmten E-Mail-Adressen teilen, gelten sie weiterhin als privat. In privaten Projekten moderieren wir nichts.",
                    "$~Aber ein Projekt *öffentlich* zu machen oder es in eine öffentliche Galerie aufzunehmen, ist ein Privileg. Dies ist eine Plattform für Liebe, Bestätigung, Respekt und Würde. Daher erwarten wir, dass keiner Ihrer *öffentlichen* Inhalte:"
                ],
                "consequences": [
                    "$~Wenn wir ein Projekt oder eine Galerie finden, die gegen diese Regeln verstößt, warnen wir die Ersteller, bevor sie es ansehen können, oder blockieren es. Wenn Sie diese Regeln wiederholt verletzen, verlieren Sie das Recht, öffentlich zu posten."
                ]
            },
            "donate": {
                "header": "Spenden",
                "prompt": "Um zugängliche und weltweite Programmierungen zu befähigen",
                "content": [
                    "$~Wordplay ist ein kostenloses, Community-basiertes Projekt, das von der <University of Washington@https://washington.edu> unterstützt wird. Wir sind auf Spenden von Menschen angewiesen, die an unsere Mission glauben, zugängliche, sprachintegrative und lehrreiche Programmiersprachen zu entwickeln.",
                    "$~Hier sind unsere aktuellen Kosten:",
                    "$~• Wir entschädigen die Studierenden der University of Washington, insbesondere diejenigen mit Behinderungen oder deren Muttersprache nicht Englisch war, für die Weiterentwicklung und Pflege des Projekts. Dies entspricht etwa 90 % unserer Kosten.",
                    "$~• Wir vergeben Stipendien an Lehrer, mit denen wir zusammenarbeiten, um mehrsprachige, zugängliche Lehrpläne zu entwickeln.",
                    "$~• Wir bezahlen Google für <Firebase@https://firebase.google.com/> Bandbreite und Speicher sowie <Workspace@https://workspace.google.com/>-Dienste.",
                    "$~• Wir zahlen <Squarespace@https://www.squarespace.com/> jährlich für die Domain.",
                    "$~Unsere derzeitigen Kosten betragen ca. 60.000 USD pro Jahr, ausgehend von 5 Studenten zu je 20 USD/Stunde, 10 Stunden/Woche während des akademischen Jahres (36 Wochen) und 2 Studenten im Sommer (12 Wochen) plus Cloud-Dienste.",
                    "$~Wenn 2.400 Menschen 25 US-Dollar pro Jahr spenden würden, wären damit unsere laufenden Kosten gedeckt. Der darüber hinausgehende Betrag würde zur Vergütung weiterer Schüler und Lehrer verwendet.",
                    "$~Können Sie einer dieser 2.400 Menschen sein? Wenn ja, hier ist unser Spendenlink für die University of Washington:"
                ]
            },
            "guide": {
                "header": "$~Führung",
                "description": "$~Dies ist eine Referenz für jeden Teil der Programmiersprache Wordplay. Suchen Sie nach einem Konzept oder durchsuchen Sie die Liste, um mehr zu erfahren."
            }
        },
        "edit": {
            "node": "$~$1$2[, Typ $2|]",
            "before": "$~vor $1[$1|Ende]",
            "inside": "$~in $1, zwischen $2[$2|Start] und $3[$3|Ende]",
            "between": "$~zwischen 1 und 2 US-Dollar",
            "line": "$~leere Zeile zwischen $1[$1|Start] und $2[$2|Ende]",
            "conflicts": "$~$1 Konflikte",
            "assign": "$~/$2[Möchte gern mitmachen|Erwägt, auszusteigen]…/",
            "append": "$~/Begierig, einzufügen…/",
            "remove": "$~/Erwägt, zu gehen…/",
            "replace": "$~/Will eingreifen…/",
            "wrap": "$~Elternheizung",
            "unwrap": "$~auspacken",
            "bind": "$~Nennen Sie diesen Ausdruck"
        },
        "template": {
            "unwritten": "$~Wird noch bekannt gegeben",
            "unparsable": "$~Nicht analysierbare Vorlage: $1"
        }
    },
    "moderation": {
        "warning": {
            "header": "$~Warnung",
            "explanation": "$~Ein Moderator hat entschieden, dass dieser Inhalt:"
        },
        "blocked": {
            "header": "$~verstopft",
            "explanation": "$~Ein Moderator hat entschieden, dass dieser Inhalt:"
        },
        "unmoderated": {
            "header": "$~Notiz",
            "explanation": "$~Dieser Inhalt wurde noch nicht moderiert. Er kann:"
        },
        "moderate": {
            "header": "$~Mäßig",
            "explanation": "$~Überprüfen Sie dieses Projekt und entscheiden Sie, ob sein Inhalt eines der folgenden Dinge tut. Wenn dies der Fall ist, wird der Inhalt gewarnt oder blockiert. Sie können diesen Schritt überspringen, wenn Sie sich nicht sicher sind."
        },
        "flags": {
            "violence": "$~Gewalt, Verletzungen oder Selbstverletzungen gegenüber anderen anstiften, dazu ermutigen oder sie feiern.",
            "dehumanization": "$~Entmenschlichung von Einzelpersonen oder Gruppen aufgrund ihrer Rasse, ethnischen Zugehörigkeit, nationalen Herkunft, Kaste, sexuellen Orientierung, ihres Geschlechts, ihrer Religion, ihres Alters, ihrer Fähigkeiten oder ihres Aussehens.",
            "disclosure": "$~Private Informationen über andere Personen preisgeben, wie etwa Namen, Kontaktdaten oder Postanschriften",
            "misinformation": "$~Falsche, irreführende, täuschende oder manipulative Informationen enthalten"
        },
        "progress": "$~*$1* moderiert, *$2* verbleibend",
        "button": {
            "submit": {
                "tip": "$~Diese Moderationseinstellungen speichern",
                "label": "$~speichern"
            },
            "skip": {
                "tip": "$~Dieses Projekt überspringen",
                "label": "$~überspringen"
            }
        }
    },
    "gallery": {
        "games": {
            "name": "$~Spiele",
            "description": "$~Interaktive Spiele mit Wörtern und Symbolen."
        },
        "visualizations": {
            "name": "$~Visualisierungen",
            "description": "$~Visualisierungen von und über Text."
        },
        "motion": {
            "name": "$~Bewegung",
            "description": "$~Beispiele für Bewegungen und Kollisionen."
        },
        "av": {
            "name": "$~Audio/Video",
            "description": "$~Verwenden von Lautstärke, Tonhöhe und Video als Eingabe."
        },
        "tools": {
            "name": "$~Werkzeuge",
            "description": "$~Einfache Dienstprogramme und Anwendungen."
        }
    }
}
