{
    "$schema": "../../schemas/LocaleText.json",
    "language": "de",
    "region": "DE",
    "wordplay": "Wordplay",
    "term": {
        "evaluate": "auswerten",
        "bind": "binden",
        "decide": "entscheiden",
        "document": "Dokumentation",
        "project": "Projekt",
        "source": "Quelldatei",
        "input": "Eingabe",
        "output": "Ausgabe",
        "convert": "konvertieren",
        "act": "speilen",
        "scene": "Szene",
        "phrase": "Satzglied",
        "group": "Gruppe",
        "stage": "B√ºhne",
        "type": "Typ",
        "start": "Anfang",
        "entered": "neu",
        "changed": "ge√§ndert",
        "moved": "ger√ºhrt",
        "name": "Name",
        "value": "Wert",
        "text": "Text",
        "boolean": "boolescher Wert",
        "map": "Karte",
        "number": "Nummer",
        "function": "Funktion",
        "exception": "Ausnahme",
        "table": "Tabelle",
        "none": "keiner",
        "list": "Liste",
        "stream": "Datenstrom",
        "structure": "Strukturwert",
        "index": "Index",
        "query": "Abfrage",
        "row": "Reihe",
        "set": "Set",
        "key": "Schl√ºssel",
        "help": "Hilfe",
        "feedback": "Bewertung"
    },
    "token": {
        "EvalOpen": "Auswertung √∂ffnen",
        "EvalClose": "Auswertung schlie√üen",
        "SetOpen": "Set √∂ffnen",
        "SetClose": "Set schlie√üen",
        "ListOpen": "Liste √∂ffnen",
        "ListClose": "Liste schlie√üen",
        "TagOpen": "Tag √∂ffnen",
        "TagClose": "Tag schlie√üen",
        "Bind": "binden",
        "Access": "Zugang",
        "Function": "Funktion",
        "Borrow": "ausleihen",
        "Share": "teilen",
        "Convert": "umwandeln",
        "Doc": "Erl√§uterung",
        "Formatted": "formatiert",
        "FormattedType": "formatierter Typ",
        "Words": "W√∂rter",
        "Link": "Weblink",
        "Italic": "Kursiv",
        "Underline": "Unterstrich",
        "Light": "Leicht",
        "Bold": "Fett",
        "Extra": "Extra",
        "Concept": "Konzept-Link",
        "URL": "URL",
        "Code": "Code",
        "Mention": "erw√§hnen",
        "Otherwise": "ansonsten",
        "Match": "√ºbereinstimmen",
        "None": "Nichts",
        "Type": "Typ",
        "Literal": "Buchstabensymbol",
        "TypeOperator": "Typoperator",
        "TypeOpen": "Typoperator √∂ffnen",
        "TypeClose": "Typoperator schlie√üen",
        "Separator": "Namenstrennzeichen",
        "Language": "Sprache",
        "Region": "Region",
        "BooleanType": "Boolescher Typ",
        "NumberType": "Nummerntyp",
        "JapaneseNumeral": "Japanische Zahl",
        "RomanNumeral": "R√∂mische Zahl",
        "Pi": "Kreiszahl",
        "Infinity": "Unendlichkeit",
        "TableOpen": "Tabelle offen",
        "TableClose": "Tabelle schlie√üen",
        "Select": "w√§hlen",
        "Insert": "einf√ºgen",
        "Update": "updaten",
        "Delete": "l√∂schen",
        "Union": "Union",
        "Stream": "Datenstrom",
        "Change": "ver√§ndern",
        "Initial": "Anfang",
        "Previous": "vorherige",
        "Placeholder": "Platzhalter",
        "Etc": "usw.",
        "This": "diese",
        "Operator": "Operator",
        "Conditional": "bedingt",
        "Text": "Text",
        "Number": "Nummer",
        "Decimal": "Punkt",
        "Base": "Basiszahl",
        "Boolean": "boolesche Wert",
        "Name": "Name",
        "Unknown": "Unbekannt",
        "Locale": "Gebietsschema",
        "End": "Ende"
    },
    "node": {
        "Dimension": {
            "name": "$~Abmessungen",
            "description": "$~Abmessungen",
            "emotion": "$?",
            "doc": [
                "$~Ich bin eine /Ma√üeinheit/!",
                "$~Ich kann jede standardisierte Einheit sein, wie \\1m\\, \\10s\\, \\100g\\ oder jede andere wissenschaftliche Einheit. Ich bin auch gerne bereit, jede Einheit zu sein, die Sie sich ausdenken m√∂chten, wie \\17apple\\.",
                "$~Ich kann mit \\/\\ kombiniert werden, um Verh√§ltniseinheiten wie \\17√Ñpfel/Tag\\ zu bilden, und mit \\^\\, um Exponentialeinheiten wie \\9,8m/s^2\\ zu bilden.",
                "$~Ich muss immer nach einer @Nummer kommen. Wenn ich das nicht tue, k√∂nnte ich mit einer @Referenz verwechselt werden, was ziemlich peinlich w√§re!",
                "$~Ich bin auch ziemlich gut darin, Inkonsistenzen zwischen Einheiten zu finden. Beispielsweise ergibt \\1Katze + 1Hund\\ keinen Sinn!",
                "$~Wenn Sie jemals zwischen verschiedenen Einheitenwerten umrechnen m√∂chten, wenden Sie sich an @Convert."
            ]
        },
        "Doc": {
            "name": "$~Erl√§uterung",
            "emotion": "$?",
            "doc": [
                "$~Ich formatiere Dinge ausf√ºhrlich mit @Markup, beispielsweise Erkl√§rungen zu einigen Ihrer @Programme oder sogar die W√∂rter, die Sie mit @Phrase auf die B√ºhne bringen.",
                "$~Beispielsweise kann ich vor jeden Ausdruck Folgendes setzen:",
                "$~\\``Soll das wirklich 7 sein?``\n7\\",
                "$~Beispielsweise k√∂nnen Sie ‚Äûme‚Äú vor ‚Äû@Bind‚Äú platzieren:",
                "$~\\``Ich messe, wie gro√ü jemand ist``\nGr√∂√üe: 5m\\",
                "$~Oder vor einer @FunctionDefinition:",
                "$~\\``Ich addiere zwei Zahlen``\n∆í sum(a‚Ä¢# b‚Ä¢#) a + b\\",
                "$~Oder vor einer @StructureDefinition:",
                "$~\\``Ich erinnere mich an die Namen und Lieblingsfr√ºchte von Leuten``\n‚Ä¢Person(Name‚Ä¢''Frucht‚Ä¢'')\\",
                "$~Sie k√∂nnen mich auch ganz an den Anfang von @Program stellen, um zu sagen, worum es in der gesamten Auff√ºhrung geht",
                "$~\\``Dieses Programm sagt Hallo``\n\n'Hallo!'\\",
                "$~Sie k√∂nnen mir eine @Sprache geben, damit andere wissen, in welcher Sprache ich geschrieben bin:",
                "$~\\``Ich bin ein englischer Arzt``/en\nDauer: 5¬†s\\",
                "$~Wussten Sie, dass Sie eine Liste von mir erstellen k√∂nnen? Sprechen Sie mit @Docs."
            ]
        },
        "Docs": {
            "name": "$~Erkl√§rungsliste",
            "emotion": "$?",
            "doc": [
                "$~Ich bin eine Liste von @Doc, n√ºtzlich, wenn Sie mehrere √úbersetzungen von @Doc in verschiedenen Sprachen haben.",
                "$~Sie m√ºssen nichts Besonderes tun, um eine Liste zu erstellen. Legen Sie einfach eine Reihe von @Doc nebeneinander, wie folgt:",
                "$~\\``Hallo``/en\n``Hola``/es\nBegr√º√üung: '‚Ä¶'\\"
            ],
            "start": "$~Den Dokumenten einen Mehrwert verleihen!"
        },
        "KeyValue": {
            "name": "$~Kartierung",
            "emotion": "$?",
            "doc": [
                "$~Ich bin eine Zuordnung von einem *Schl√ºssel* zu einem *Wert*, immer in einer @Map.",
                "$~Sie k√∂nnen jeden beliebigen Wert einem beliebigen anderen zuordnen. Hier ist beispielsweise eine Zahlenzuordnung:",
                "$~\\{1:1}\\",
                "$~Oder eine Zuordnung von Text zu Zahlen:",
                "$~\\{'Hase':1}\\"
            ]
        },
        "Language": {
            "name": "Sprache",
            "description": "$~Sprache $1[$1|unbekannt]",
            "emotion": "$?",
            "doc": [
                "$~Ich bin ein Sprachtag und arbeite mit @Name und @Doc!",
                "$~Ich kann wirklich gut *glasklar* machen, in welcher Sprache etwas geschrieben ist.",
                "$~Das ist, was ich mache. Nur ein kleiner Schr√§gstrich und ein paar Buchstaben, und niemand wird jemals verwirrt sein, in welcher Sprache ein Text ist.",
                "$~Angenommen, Sie m√∂chten ‚Äûmy $name‚Äú sagen, aber klarstellen, dass ich Englisch meine:",
                "$~\\\"Sprache\"/de\\",
                "$~Oder nehmen wir an, Sie m√∂chten dies f√ºr einen @Namen tun.",
                "$~\\sound/de: 'miau'\\",
                "$~Oder sogar @Doc!",
                "$~\\``Onomatopoeia``/de\nTon/de: \"miau\"\\",
                "$~Es gibt viele <2-stellige Sprachcodes@https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>, die ich verstehe. Wenn Sie keinen davon verwenden, lasse ich Sie das wissen."
            ],
            "conflict": {
                "UnknownLanguage": "$~Ich kenne diese Sprache nicht",
                "MissingLanguage": "$~Mir fehlt eine Sprache. K√∂nnen Sie eine hinzuf√ºgen?"
            }
        },
        "Name": {
            "name": "Name",
            "description": "$~$1[$1 | unbenannt]",
            "emotion": "$?",
            "doc": [
                "$~Ich identifiziere einen Wert und bin eine hilfreiche M√∂glichkeit, etwas, das schwer zu bewerten war oder das Sie nicht immer wieder bewerten m√∂chten, mit einer Kurzbezeichnung zu versehen.",
                "$~@Bind gibt mir meinen Namen so:",
                "$~\\hallo: 5\\",
                "$~Ich stelle immer nur einen Wert dar und kann ihn nicht mehr √§ndern, wenn ich ihn einmal habe. Wenn Sie dies beispielsweise mit @Bind versuchen w√ºrden, w√ºrden wir uns beschweren.",
                "$~\\hallo: 5\nhallo: 3\\",
                "$~Um meinen Wert zu erhalten, m√ºssen Sie nur @Reference oder @PropertyReference den Namen verwenden lassen. Hier benennt @Bind mich, dann holt @Reference den Wert, den ich erhalten habe.",
                "$~\\hallo: 5\nhallo\\",
                "$~Weil @Bind an so vielen Stellen auftauchen kann, kann ich an vielen Stellen auftauchen. Ich war oben in einem @Block, aber ich kann in einer @FunctionDefinition sein. Hier benenne ich eine Nachricht vor√ºbergehend:",
                "$~\\∆ísage(Nachricht‚Ä¢'') Nachricht\\",
                "$~Ich werde innerhalb von @FunctionDefinition definiert und gehe dann weg, sobald die Funktion mit der Auswertung fertig ist.",
                "$~Sie k√∂nnen @Language verwenden, um anzugeben, in welcher Sprache mein Name ist. Dies ist hilfreich, wenn Sie Ihren Auftritt mit anderen teilen, falls diese Ihr Programm lesen m√∂chten."
            ]
        },
        "Names": {
            "name": "Namen",
            "emotion": "$?",
            "doc": [
                "$~Ich bin eine Liste von @Namen, n√ºtzlich, wenn Sie einem Wert mehrere Namen zuweisen m√∂chten, oft mit unterschiedlicher @Sprache.",
                "$~Namen werden durch \\,\\-Symbole getrennt. Hier ist beispielsweise @Bind, das einen Wert angibt, der ein Vielfaches von @Name ist.",
                "$~\\hi/en,hello/en,hola/es: 'willkommen'\\"
            ]
        },
        "Row": {
            "name": "$~Reihe",
            "emotion": "$?",
            "doc": "$~Ich stelle eine Zeile in einer @Table dar. Am besten spreche ich mit @Table, die wissen alles √ºber mich. Ich sitze einfach nur herum und halte die Werte in der Reihe :(",
            "conflict": {
                "InvalidRow": "$~Die Zeilen m√ºssen entweder alle Werte oder alle @Bind sein.",
                "MissingCell": {
                    "primary": "$~Mir fehlt die Spalte $1",
                    "secondary": "$~Ich bin erforderlich, aber 1 $ hat es nicht bereitgestellt"
                },
                "UnknownColumn": "$~Ich kenne keine Kolumne mit diesem Namen",
                "ExtraCell": {
                    "primary": "$~Soll ich hier sein?",
                    "secondary": "$~Hey $1, du bist nicht Teil dieses @Table!"
                },
                "UnexpectedColumnBind": {
                    "primary": "$~Soll ich ein @Bind sein?",
                    "secondary": "$~Hey, ich bin eine @Tabelle, ich brauche Werte, nicht @Bind."
                }
            }
        },
        "Token": {
            "name": "$~Zeichen",
            "description": "$~$1 $2",
            "emotion": "$?",
            "doc": [
                "$~Wie hast du mich gefunden?",
                "$~Ich bin der kleinstm√∂gliche Teil einer Auff√ºhrung. Ich bin das Substrat, aus dem alle Charaktere im Vers bestehen. Ich bin das Atomteilchen unserer Choreographie."
            ]
        },
        "TypeInputs": {
            "name": "$~Typeingaben",
            "emotion": "$?",
            "doc": "$~Ich bin eine Liste von Typen, die den Platz von @TypeVariables in einer @StructureDefinition oder @FunctionDefinition einnehmen. Ich helfe allen dabei, zu wissen, welche Art von Eingaben sie erhalten werden."
        },
        "TypeVariable": {
            "name": "$~Typvariable",
            "emotion": "$?",
            "doc": "$~Ich bin ein mysteri√∂ser Typ f√ºr @FunctionDefinition oder @StructureDefinition, der von @TypeInputs bereitgestellt wird, wenn einer von beiden ausgewertet wird. @Set, @List und @Map verwenden mich.",
            "conflict": {
                "DuplicateTypeVariable": {
                    "primary": "$~Ich habe den gleichen Namen wie $1",
                    "secondary": "$~Ich habe den gleichen Namen wie $1"
                }
            }
        },
        "TypeVariables": {
            "name": "$~Typvariablen",
            "emotion": "$?",
            "doc": "$~Ich bin eine Liste von @TypeVariable."
        },
        "Markup": {
            "name": "$~Auszeichnung",
            "description": "$~$1 Abs√§tze",
            "emotion": "$?",
            "doc": [
                "$~Ich bin eine Liste von Abs√§tzen und verwende die vielen in Erkl√§rungen verf√ºgbaren Markierungsarten, wie etwa @Words, @WebLink, @ConceptLink und @Example."
            ]
        },
        "Paragraph": {
            "name": "$~Absatz",
            "emotion": "$?",
            "doc": [
                "$~Ich bin eine Reihe von @Words, @ConceptLink, @WebLink und @Example, getrennt durch eine Leerzeile und innerhalb von @Doc.",
                "$~Um mir zu schreiben, m√ºssen Sie lediglich ein paar W√∂rter in ein @Doc schreiben:",
                "$~\\``Ich bin ein Absatz in einem Dokument.``'ein Absatz'\\",
                "$~Wenn Sie mehrere Abs√§tze w√ºnschen, f√ºgen Sie einfach Leerzeilen ein.",
                "$~\\``Absatz 1.\n\nAbsatz 2.\n\nAbsatz 3.``'drei Abs√§tze'\\"
            ]
        },
        "WebLink": {
            "name": "$~Verkn√ºpfung",
            "description": "$~Verkn√ºpfung $1",
            "emotion": "$?",
            "doc": [
                "$~Ich bin ein Link zu etwas im Internet. Ich brauche nur eine Beschreibung und eine URL:",
                "$~\\``Ich bin ein <link@https://wordplay.dev> in einem Dokument``\n'Linkbeispiel'\\",
                "$~Wenn mich jemand ausw√§hlt, √∂ffne ich ein neues Fenster mit der URL."
            ]
        },
        "ConceptLink": {
            "name": "$~Konzept",
            "description": "$~Konzept $1",
            "emotion": "$?",
            "doc": [
                "$~Ich bin ein Link zum Verse-Charakter. Ich bin hilfreich, wenn Sie ein @Doc schreiben und auf einen von uns verweisen m√∂chten.",
                "$~Angenommen, Sie m√∂chten √ºber @Evaluate sprechen und wie gro√üartig sie sind. Sie k√∂nnten schreiben:",
                "$~\\``Wissen Sie, @Evaluate ist ziemlich genial.``\n'Schauen Sie, ein Konzept-Link!'\\",
                "$~Wenn das von Ihnen verfasste @Doc hier erscheint, wird ein Link zum Konzept angezeigt."
            ]
        },
        "Words": {
            "name": "$~W√∂rter",
            "emotion": "$?",
            "doc": [
                "$~Ich bin jedes beliebige Wort in einem @Doc. Zum Beispiel:",
                "$~\\``M√∂ge die Macht mit dir sein.``\n'nur ein paar Worte!'\\",
                "$~Manchmal m√∂chten Sie jedoch m√∂glicherweise die Sonderzeichen verwenden, die @Doc als /als/ W√∂rter verwendet. Beispiel:",
                "$~\\``Meine Freunde verwenden @@, //, **, || und andere Symbole.``\n'mit Sonderzeichen!'\\",
                "$~Wenn Sie diese Sonderzeichen einfach wiederholen, erhalten Sie das Zeichen anstelle seiner besonderen Bedeutung."
            ]
        },
        "Example": {
            "name": "$~Beispiel",
            "emotion": "$?",
            "doc": [
                "$~Ich bin eine Beispielleistung, hilfreich beim Schreiben von @Doc, das erkl√§rt, wie man etwas verwendet!",
                "$~\\``Hier ist ein Beispiel f√ºr die Addition: \\1 + 1\\``'Beispielcode'\\",
                "$~Wenn Sie mich allein in einen Absatz einf√ºgen, werde ich in einem schicken Feld angezeigt und das Ergebnis meiner Bewertung wird angezeigt.",
                "$~\\``Hier ist ein Beispiel f√ºr die Addition:\n\n\\1 + 1\\``\\"
            ]
        },
        "Mention": {
            "name": "$~erw√§hnen",
            "description": "$~erw√§hnen $1",
            "emotion": "$?",
            "doc": [
                "$~Ich beziehe mich entweder auf die Terminologie \\$program\\ oder auf eine dynamische Eingabe \\$1\\.",
                "$~Dies ist allerdings gr√∂√ütenteils eine interne Funktion, Sie m√ºssen es also nicht kennen."
            ]
        },
        "Branch": {
            "name": "$~Zweig",
            "emotion": "$?",
            "doc": [
                "$~Ich biete eine M√∂glichkeit, zwischen zwei Erkl√§rungssegmenten zu w√§hlen, basierend darauf, ob ein Erkl√§rungseingabewert definiert oder wahr ist.",
                "$~Dies ist allerdings gr√∂√ütenteils eine interne Funktion, Sie m√ºssen es also nicht kennen."
            ]
        },
        "BinaryEvaluate": {
            "name": "$~bin√§reAuswertung",
            "description": "$~1-Dollar-Operation",
            "emotion": "$?",
            "doc": [
                "$~Ich bin @Evaluate, aber in einer einfacheren Form, hilfreich, wenn Sie eine @FunctionDefinition verwenden m√∂chten, die zwei Eingaben annimmt.",
                "$~So k√∂nnten Sie beispielsweise @Evaluate zum Addieren zweier Zahlen verwenden:",
                "$~\\1.+(1)\\",
                "$~Sieht das nicht ein bisschen komisch aus? Es ist nicht falsch: Es besagt lediglich, dass die Additionsfunktion auf 1 gesetzt und dann ausgewertet werden soll.",
                "$~Aber es ist viel einfacher, @BinaryEvaluate zu verwenden",
                "$~\\1 + 1\\",
                "$~Dadurch wird alles etwas aufger√§umter, auch wenn es im Grunde das Gleiche ist.",
                "$~Es gibt nur eine Sache, auf die Sie achten m√ºssen: Wenn ich in dieser Form bin, bewerte ich von links nach rechts. Das kann verwirrend sein, wenn Sie Dinge wie die Reihenfolge von Operationen in der Mathematik gewohnt sind.",
                "$~Das bedeutet, dass die Auswertung auf eine Weise erfolgt, die Sie m√∂glicherweise nicht erwarten:",
                "$~\\1 + 2 ¬∑ 3 + 4\\",
                "$~In der Mathematik k√§me zuerst die Multiplikation und dann die Addition, das Ergebnis w√§re also \\11\\. Da ich aber in Lesereihenfolge auswerte, ist das Ergebnis \\13\\."
            ],
            "right": "$~Eingang",
            "start": "$~Lassen Sie uns zuerst 1 $ bewerten",
            "finish": "$~schau, ich habe 1 $ verdient!",
            "conflict": {
                "OrderOfOperations": "$~Ich bewerte in Lesereihenfolge, nicht in der mathematischen Reihenfolge der Operationen. M√∂chten Sie @Block verwenden, um die Reihenfolge anzugeben, in der ich auswerten soll?"
            }
        },
        "Bind": {
            "name": "$~binden",
            "description": "$~binden $1",
            "emotion": "$?",
            "doc": [
                "$~Ich nenne *Werte*.",
                "$~So was!",
                "$~\\pi: 3.1415926\\",
                "$~Ich benenne Eingaben in @FunctionDefinition und @StructureDefinition, ich benenne Werte in @Block. Ich benenne alles!",
                "$~Oh, aber wussten Sie, dass Sie f√ºr einen Wert *viele Namen* haben k√∂nnen?",
                "$~Ich freue mich riesig, Ihnen davon zu erz√§hlen! Ein Wert, viele @Namen. Zum Beispiel:",
                "$~\\joe,tess,amy: 5\\",
                "$~Siehst du was ich dort gemacht habe?",
                "$~Ein Wert, drei Namen.",
                "$~Sie k√∂nnen diese F√ºnf mit *jedem* dieser Namen bezeichnen.",
                "$~Dies ist insbesondere dann der Fall, wenn Sie Namen in mehreren Sprachen vergeben m√∂chten:",
                "$~\\joe/en,aimee/fr,Êòé/zh: 5\\",
                "$~Sehen Sie, was ich da gemacht habe? Drei Namen f√ºr einen Wert, nur in verschiedenen Sprachen!",
                "$~Okay, ich habe noch ein letztes Geheimnis.",
                "$~Wussten Sie, dass ich mit @Is arbeiten kann, um mir sagen zu lassen, welchen Wert ein Name haben sollte? Und wenn ich ihn nicht habe, sage ich es Ihnen?",
                "$~So was:",
                "$~\\bignumber‚Ä¢#: \"eine Zillion\"\\",
                "$~Sehen Sie, ich sagte, \\bignumber\\ sollte eine Zahl sein, aber es ist Text, und diese sind nicht kompatibel, also BOOM!",
                "$~Wenn sie anderer Meinung sind, lasse ich es Sie wissen.",
                "$~Manchmal *m√ºssen* Sie mir sagen, um welche Art von Daten es sich handelt, weil ich es selbst nicht herausfinden kann. Das geschieht normalerweise in @FunctionDefinition.",
                "$~Hier wei√ü @FunctionDefinition beispielsweise nicht, welche Art von Werten \\a\\ und \\b\\ haben, weil ich es ihnen nicht gesagt habe.",
                "$~\\∆í Summe(a b) a + b\\",
                "$~Aber wir k√∂nnen dies √§ndern, um die @Is hinzuzuf√ºgen, und jetzt wei√ü @FunctionDefinition, dass es sich um Zahlen handelt:",
                "$~\\∆í Summe(a‚Ä¢# b‚Ä¢#) a + b\\"
            ],
            "start": "$~Mal sehen, welchen Wert wir f√ºr 1¬†$ bekommen!",
            "finish": "$~oh sch√∂n, ich habe 1 $ bekommen! Nennen wir es 2 $",
            "conflict": {
                "DuplicateName": {
                    "conflict": {
                        "primary": "$~jemand hat den Namen $1, also kann ich diesen Namen nicht haben.",
                        "secondary": "$~hey, 1 $ ist mein Name, den kriegst du nicht!"
                    },
                    "resolution": "$~Es gibt doppelte Namen. M√∂chten Sie einen entfernen?"
                },
                "DuplicateShare": {
                    "primary": "$~Ich habe den gleichen Namen wie $1, was die Freigabe unklar macht.",
                    "secondary": "$~Ich habe den gleichen Namen wie $1"
                },
                "IncompatibleType": {
                    "primary": "$~Ich sollte eine 2-Dollar-W√§hrung sein, aber ich bin eine 1-Dollar-W√§hrung",
                    "secondary": "$~Oh ... entschuldigen Sie, wirklich 1 $?"
                },
                "MisplacedShare": "$~Ich kann Dinge nur auf der @Program-Ebene teilen, nicht innerhalb von irgendetwas!",
                "MissingShareLanguages": "$~Wenn Sie dies teilen m√∂chten, m√ºssen Sie angeben, in welcher Sprache es ist, damit andere wissen, ob sie es lesen k√∂nnen!",
                "RequiredAfterOptional": "$~Ich kann nicht hier sein, da ist ein optionales @Bind vor mir",
                "UnexpectedEtc": "$~Ich kann nur eine variable L√§nge in einer @FunctionDefinition haben",
                "UnusedBind": "$~Ich habe $1 genannt, aber niemand verwendet es. Vielleicht wird es nicht ben√∂tigt?"
            }
        },
        "Block": {
            "name": "$~Block",
            "description": "$~1-Dollar-Anweisungen",
            "emotion": "$?",
            "doc": [
                "$~Hallo. Ich schaffe einen kleinen ruhigen, privaten Raum, um Dinge auszuwerten.",
                "$~So was:",
                "$~\\(1 - 1) + 2\\",
                "$~Dadurch wird die Auswertungsreihenfolge klarer.",
                "$~@Bind hilft auch.",
                "$~\\(Anzahl: 10 Anzahl ^ Anzahl)\\",
                "$~Sehen Sie, wie @Bind \\count\\ erstellt hat? Es ist nur in mir benannt. Das hier funktioniert also nicht:",
                "$~\\(Anzahl: 10 Anzahl ^ Anzahl) + Anzahl\\",
                "$~Denn Graf wurde erst in mir selbst benannt.",
                "$~Du kannst so viele Ausdr√ºcke in mich einf√ºgen, wie du m√∂chtest. Aber mich interessiert nur der letzte:",
                "$~\\(1 2 3 4 5)\\",
                "$~Normalerweise verwende ich also einfach ein paar @Bind-Befehle und am Ende einen Ausdruck.",
                "$~\\(\na: 1\nb: 2\nc: 3\nd: 4\na + b + c + d\n)\\"
            ],
            "statement": "$~Stellungnahme",
            "start": "$~erster Ausdruck",
            "finish": "$~erledigt, ich habe 1 $ bekommen",
            "conflict": {
                "ExpectedEndingExpression": "$~Ich brauche einen Ausdruck.",
                "IgnoredExpression": {
                    "primary": "$~Ich werde das oben Gesagte ignorieren.",
                    "secondary": "$~@Block, ignorier mich nicht!",
                    "resolution": "$~Meinten Sie, dass dies ein @BinaryEvaluate statt eines @UnaryEvaluate sein sollte? Ich kann ein Leerzeichen hinzuf√ºgen, damit ich wei√ü, dass Sie das gemeint haben."
                }
            }
        },
        "BooleanLiteral": {
            "name": "$~BooleschesLiteral",
            "description": "$~$1[wahr|falsch]",
            "emotion": "$?",
            "doc": "$~Ich bin entweder \\‚ä§\\ oder \\‚ä•\\. Weitere Informationen zu unserer sch√∂nen Logik finden Sie unter @Boolean.",
            "start": "$~$1!"
        },
        "Borrow": {
            "name": "$~ausleihen",
            "description": "$~$1 ausleihen[$1|fehlender Name]",
            "emotion": "$?",
            "doc": "$~Wenn Sie eine Performance mit mehreren @Sources erstellen, k√∂nnen Sie mich verwenden, um @Binds auszuleihen, die in diesen anderen @Sources gemeinsam genutzt werden. Verwenden Sie einfach ihren Namen und ich werde ihren Namen und Wert einf√ºgen.",
            "start": "$~2 $ von 1 $ leihen",
            "source": "$~$Quelle",
            "bind": "$~Name",
            "version": "$~Ausf√ºhrung",
            "conflict": {
                "UnknownBorrow": "$~Ich kenne keine $source mit diesem Namen",
                "BorrowCycle": "$~dies h√§ngt von $1 ab, das wiederum von dieser $source abh√§ngt, daher kann das Programm nicht ausgewertet werden"
            },
            "exception": {
                "CycleException": {
                    "description": "$~Ausleihzyklus",
                    "explanation": "$~1 $ h√§ngt von sich selbst ab"
                }
            }
        },
        "Changed": {
            "name": "$~ge√§ndert",
            "emotion": "$?",
            "doc": [
                "$~Ich √ºberpr√ºfe, ob ein Stream eine Neuauswertung von @Program verursacht hat, und erstelle einen @Boolean. So",
                "$~\\‚àÜ Zeit()\\",
                "$~Ich bin wirklich hilfreich, wenn Sie nur dann etwas √§ndern m√∂chten, wenn sich ein Stream ge√§ndert hat.",
                "$~Das ist es."
            ],
            "start": "$~mal sehen, ob sich 1 $ ge√§ndert hat ‚Ä¶"
        },
        "Conditional": {
            "name": "$~bedingt",
            "emotion": "$?",
            "doc": [
                "$~Ich glaube, ich soll Entscheidungen treffen? So?",
                "$~\\Zahl: -100\nZahl < 0 ? 'negativ' 'positiv'\\",
                "$~Aber haben Sie jemals dar√ºber nachgedacht, wie wir Entscheidungen treffen?",
                "$~Scheint es nicht so, als ob Entscheidungen differenzierter sein sollten als nur Ja oder Nein? Ist die Entscheidung zwischen \\‚ä§\\ und \\‚ä•\\ alles, was es gibt?",
                "$~Bef√ºrchten Sie nicht, dass uns wichtige Zusammenh√§nge √ºber die Welt entgehen, wenn wir nur solche Entscheidungen treffen k√∂nnen?"
            ],
            "start": "$~mal sehen, ob $1 wahr ist",
            "afterthen": "$~fertig mit ‚ÄûJa‚Äú, √ºberspringen wir ‚ÄûNein‚Äú?",
            "else": "$~$1[Code √ºberspringen | Code nicht √ºberspringen]",
            "finish": "$~Ich sch√§tze, es ist 1 $?",
            "condition": "$~Zustand",
            "yes": "$~Ja",
            "no": "$~NEIN",
            "conflict": {
                "ExpectedBooleanCondition": {
                    "primary": "$~Wie kann ich bei einem Dollar zwischen ‚ÄûJa‚Äú und ‚ÄûNein‚Äú w√§hlen? Nein, wirklich, wie?",
                    "secondary": "$~Ich glaube, @Conditional wollte, dass ich ein @Boolean bin, aber ich bin ein $1."
                }
            }
        },
        "ConversionDefinition": {
            "name": "$~Konvertierungsdefinition",
            "description": "$1 ‚Üí $2",
            "emotion": "$?",
            "doc": [
                "$~Alter, ich definiere Konvertierungen von einem Typ in einen anderen! Ich gehe in @Block, ungef√§hr so:",
                "$~\\‚Üí #K√§tzchen #Katze . √∑ 2\n6K√§tzchen‚Üí#Katze\\",
                "$~Sehen Sie, wie ich aus K√§tzchen Katzen gemacht habe? Wahnsinn!",
                "$~Sie fragen sich vielleicht, was das \\.\\ dort macht. Es stellt den zu konvertierenden Wert dar. Ich verwende es, weil der Wert sonst keinen Namen hat."
            ],
            "start": "$~super, eine neue Konvertierung!",
            "conflict": {
                "MisplacedConversion": "$~whoa, ich kann nicht hier sein, nur in @Block."
            }
        },
        "Convert": {
            "name": "$~Konvertieren",
            "emotion": "$?",
            "doc": [
                "$~Yo. Ich konvertiere Werte von einem Typ in einen anderen. Schau mal:",
                "$~\\1 ‚Üí \"\"\\",
                "$~\\5s ‚Üí #ms\\",
                "$~\\\"hallo\" ‚Üí []\\",
                "$~Sie k√∂nnen diese sogar miteinander verketten:",
                "$~\\\"hallo\" ‚Üí [] ‚Üí {}\\",
                "$~Werte haben einen Satz vordefinierter @ConversionDefinitions. Wenn Sie jedoch eine @StructureDefinition f√ºr einen neuen Wertetyp erstellen, k√∂nnen Sie mit @ConversionDefinition Ihre eigene definieren."
            ],
            "start": "$~Holen Sie sich diesen Wert ab 1¬†$!",
            "finish": "$~Super, ich habe 1 $ verdient",
            "conflict": {
                "UnknownConversion": "$~Schade, aus 1 $ werden keine 2 $"
            },
            "exception": {
                "ConversionException": {
                    "description": "$~unm√∂gliche Konvertierung",
                    "explanation": "$~Ich wei√ü nicht, wie ich von 1 $ in 2 $ umrechnen kann."
                }
            }
        },
        "Delete": {
            "name": "$~l√∂schen",
            "emotion": "$?",
            "doc": [
                "$~Manchmal hat man einen Tisch, auf dem einfach zu viel steht!",
                "$~Als ob einige Spieler in einem Spiel w√§ren und einer geht und Sie einfach nur sagen wollten: GEH WEG, SPIELER, RAUS VON MEINEM TISCH!",
                "$~\\Spieler: ‚é°Name‚Ä¢'' Team‚Ä¢'' Punkte‚Ä¢#‚é¶\n‚é°'jen' 'rot' 8‚é¶\n‚é°'joan' 'blau' 11‚é¶\n‚é°'jeff' 'rot' 9‚é¶\n‚é°'janet' 'blau' 7‚é¶\nSpieler ‚é°- Name = 'jeff'\\",
                "$~Puh, Jeff ist weg. Tsch√º√ü, JEFF. Denkt einfach daran, dass ich die Originaltabelle nicht √§ndere, sondern eine neue erstelle, ohne JEFF. Ihr entscheidet, wohin sie kommt."
            ],
            "start": "$~Lass uns zuerst den Tisch holen",
            "finish": "$~Ich habe eine neue Tabelle ohne die passenden Zeilen erstellt!"
        },
        "DocumentedExpression": {
            "name": "$~erkl√§rterAusdruck",
            "emotion": "$?",
            "doc": [
                "$~Ich bin jeder Ausdruck, aber mit einem @Doc!",
                "$~Um mich zu erstellen, setzen Sie einfach ein @Doc vor einen Ausdruck, und Sie erhalten mich:",
                "$~\\doubleplus: 1\n(2 ¬∑ doubleplus) + \n``Lass es uns ein bisschen gr√∂√üer machen``\n1\\",
                "$~Ich bin n√ºtzlich, um einen Teil eines Programms zu kommentieren."
            ],
            "start": "$~Lassen Sie uns den Ausdruck auswerten"
        },
        "Evaluate": {
            "name": "$~auswerten",
            "description": "$~bewerte $1[$1|anonym]",
            "emotion": "$?",
            "doc": [
                "$~Hallo. Ich bewerte meine liebste @FunctionDefinition. So:",
                "$~\\∆í Begr√º√üung(Nachricht‚Ä¢'')\nBegr√º√üung('K√§tzchen')\\",
                "$~Funktionen k√∂nnen von √ºberall herkommen. @Text hat beispielsweise Funktionen. So wie diese:",
                "$~\\'K√§tzchen'.L√§nge()\\",
                "$~Wenn eine Funktion einen einzelnen Symbolnamen hat, k√∂nnen Sie mir als @BinaryEvaluate schreiben.",
                "$~\\'K√§tzchen' ‚äÜ 'Klitzeklein'\\",
                "$~Es bewirkt dasselbe wie das hier:",
                "$~\\'K√§tzchen'.‚äÜ('kleines K√§tzchen')\\",
                "$~Nat√ºrlich bin ich nichts ohne @FunctionDefinition. Ich gebe ihnen nur Input und folge dann ihren Schritten."
            ],
            "start": "$~Lassen Sie uns zuerst die Eingaben auswerten",
            "evaluate": "$~Lassen Sie uns jetzt die Funktion auswerten",
            "finish": "$~Ich habe es auf 1 $ gesch√§tzt",
            "function": "$~Funktion",
            "input": "$~Eingang",
            "conflict": {
                "IncompatibleInput": {
                    "primary": "$~Ich sollte eine 1-Dollar-W√§hrung sein, aber ich bin eine 2-Dollar-W√§hrung",
                    "secondary": "$~√Ñhm, ich habe 2 Dollar statt 1 Dollar bekommen"
                },
                "UnexpectedTypeInput": {
                    "primary": "$~Ich habe diese Art von Eingabe nicht erwartet",
                    "secondary": "$~oh, sollte ich nicht hier sein?"
                },
                "MissingInput": {
                    "primary": "$~Mir fehlt 1¬†$. K√∂nnen Sie ihn hinzuf√ºgen?",
                    "secondary": "$~Diese Eingabe ist erforderlich, wurde aber von $1 nicht bereitgestellt."
                },
                "NotInstantiable": "$~Ich kann diese @StructureDefinition nicht erstellen, sie hat nicht implementierte Funktionen.",
                "UnexpectedInput": {
                    "primary": "$~Ich habe diesen Input nicht erwartet $1",
                    "secondary": "$~Oh, sollte ich nicht hier sein?"
                },
                "UnknownInput": {
                    "primary": "$~Ich kenne keinen Input mit diesem Namen in $1",
                    "secondary": "$~Ich habe keinen Input mit dem Namen $1"
                },
                "InputListMustBeLast": "$~Liste der Eing√§nge muss zuletzt sein",
                "SeparatedEvaluate": "$~Ist $1 der Name einer $2[$Struktur|$Funktion], die Sie auswerten m√∂chten? Versuchen Sie, das Leerzeichen nach mir zu entfernen, damit ich wei√ü, dass es sich um ein @Evaluate und nicht um einen separaten @Block handelt."
            },
            "exception": {
                "FunctionException": {
                    "description": "$~unbekannte Funktion",
                    "explanation": "$~oh nein, $1 ist keine Funktion in $2[$2|diesem @Block]!"
                }
            }
        },
        "ExpressionPlaceholder": {
            "name": "$~Platzhalter",
            "description": "$~$1[$1|Platzhalter]",
            "emotion": "$?",
            "doc": [
                "$~Ich bin ein *Ausdruck*, aber kein echter ‚Ä¶ ich nehme nur den Platz eines solchen ein.",
                "$~Mir geht es gut, wenn du noch nicht wei√üt, was du schreiben sollst. So:",
                "$~\\1 + _\\",
                "$~Was f√ºgen wir hinzu? Ich wei√ü es nicht. Sag du es mir.",
                "$~Oder wenn jemand eine Funktion mit @Evaluate auswertet, k√∂nnte ich f√ºr die Funktion einspringen",
                "$~\\_(1 2 3)\\",
                "$~Ich stehe nicht gern auf der B√ºhne!"
            ],
            "start": "$~iiiiih, ich wei√ü nicht, was ich tun soll!",
            "placeholder": "$~Ausdruck",
            "conflict": {
                "Placeholder": "$~kann jemand meinen Platz einnehmen?"
            },
            "exception": {
                "UnimplementedException": {
                    "description": "$~nicht implementiert",
                    "explanation": "$~Ich wei√ü nicht, was ich tun soll!"
                }
            }
        },
        "FunctionDefinition": {
            "name": "$~Funktion",
            "description": "$~Funktion $1",
            "emotion": "$?",
            "doc": [
                "$~Hallo nochmal! Ich nehme einige Eingaben, bewerte dann einen Ausdruck damit und erzeuge eine Ausgabe.",
                "$~Hier ist ein einfaches Beispiel:",
                "$~\\∆í repeat(message‚Ä¢'') Nachricht ¬∑ 5\nrepeat('hi')\\",
                "$~Diese Funktion verwendet eine Eingabe, \\message\\, und verwendet die Funktion @Text/repeat, um die Nachricht f√ºnfmal zu wiederholen.",
                "$~Ich bin eine gro√üe Hilfe, wenn Sie etwas immer wieder, aber mit unterschiedlichen Eingaben bewerten m√∂chten!",
                "$~Ich habe noch viele andere kleine Tricks. Ich muss zum Beispiel keinen Namen haben. Hier gehe ich einfach direkt zu @Evaluate als Wert.",
                "$~\\(∆í(Nachricht‚Ä¢'') Nachricht ¬∑ 5)('Hallo')\\",
                "$~Oder hier ist eine Funktion, die eine beliebige Anzahl von Eingaben annimmt und dabei das Zeichen \\‚Ä¶\\ nach einem Eingabenamen verwendet.",
                "$~\\∆í ja(Nachrichten‚Ä¶‚Ä¢'') Nachrichten.sans('nein')\nja('ja' 'ja' 'nein' 'ja' 'nein')\\",
                "$~Sehen Sie, wie alle ‚ÄûNeins‚Äú entfernt wurden? Das liegt daran, dass ‚Äûmessages‚Äú eine @Liste ist und wir daher @List/sansAll verwenden k√∂nnten.",
                "$~Manchmal m√∂chten Sie vielleicht deutlich machen, welche Art von Wert ich erzeuge. F√ºgen Sie dazu nach der Liste der Eingaben ein @Is hinzu:",
                "$~\\∆í add(x‚Ä¢# y‚Ä¢#)‚Ä¢'' x + y\\",
                "$~M√∂glicherweise f√§llt Ihnen hier ein Problem auf: Es hei√üt, es wird als @Text ausgewertet, aber es werden zwei @Number ben√∂tigt. Ich kann Ihnen sagen, wenn Dinge inkonsistent sind!",
                "$~Nat√ºrlich bin ich ohne @Evaluate √ºberhaupt nicht n√ºtzlich; sie erwecken mich zum Leben."
            ],
            "start": "$~Lasst uns diese Funktion machen!",
            "conflict": {
                "NoExpression": "$~Ich brauche einen Ausdruck zur Auswertung. K√∂nnen Sie einen hinzuf√ºgen?"
            }
        },
        "Iteration": {
            "name": "$~Funktionh√∂hererOrdnung",
            "emotion": "$?",
            "doc": "$~Ich bin eine ganz besondere Art von @FunctionDefinition, die mit Listen von Dingen arbeitet. Sie m√ºssen nichts √ºber mich wissen, au√üer dass ich Funktionen wie @List/translate erm√∂gliche.",
            "start": "$~Auswertung der gegebenen Funktion",
            "initialize": "$~Vorbereiten der Schritte durch Elemente",
            "next": "$~Weiter zum n√§chsten Element",
            "check": "$~entscheiden, ob fortgefahren wird",
            "finish": "$~Ich habe es auf 1 $ gesch√§tzt"
        },
        "Initial": {
            "name": "$~Start",
            "emotion": "$?",
            "doc": [
                "$~Ich sage Ihnen, ob die aktuelle Auswertung von @Program die erste ist, die zu einem @Boolean ausgewertet wird. Zum Beispiel:",
                "$~\\‚óÜ ? Zeit() 'hallo'\\",
                "$~Sie haben es nicht gesehen, aber die erste Auswertung war eine Zeitangabe, dann jedoch alle zuk√ºnftigen Zeitangaben, ich war \\‚ä•\\, also machte @Conditional \\‚ä§\\.",
                "$~Ich bin eine gro√üe Hilfe, wenn Sie mit einem Stream arbeiten und etwas nur beim ersten Mal oder nie beim ersten Mal tun m√∂chten!"
            ]
        },
        "Insert": {
            "name": "$~einf√ºgen",
            "emotion": "$?",
            "doc": [
                "$~Kennen Sie das, wenn Sie eine @Tabelle haben und das Gef√ºhl haben, dass etwas fehlt? Ich kann es hinzuf√ºgen!",
                "$~Stellen Sie sich vor, Sie h√§tten einen Tisch mit Spielern in einem Spiel und m√∂chten einen neuen hinzuf√ºgen:",
                "$~\\Spieler: ‚é°Name‚Ä¢'' Team‚Ä¢'' Punkte‚Ä¢#‚é¶\n‚é°'jen' 'rot' 1‚é¶\n‚é°'joan' 'blau' 0‚é¶\n‚é°'jeff' 'rot' 3‚é¶\n‚é°'janet' 'blau' 2‚é¶\nSpieler ‚é°+ 'jason' 'rot' 0‚é¶\\",
                "$~Denken Sie daran, dass ich, wie bei allem im Verse, eine Tabelle nicht √§ndere, sondern √ºberarbeite. Sie m√ºssen also herausfinden, wo Sie die √ºberarbeitete Tabelle ablegen m√∂chten. H√∂chstwahrscheinlich m√∂chten Sie eine Tabelle in einer @Reaction auf eine Eingabe √ºberarbeiten und in einem @Bind speichern."
            ],
            "start": "$~Suchen wir die zu aktualisierende Tabelle",
            "finish": "$~Ich habe eine neue Tabelle mit √ºberarbeiteten Zeilen erstellt!"
        },
        "Is": {
            "name": "$~Ist",
            "description": "$~Ist",
            "emotion": "$?",
            "doc": [
                "$~Wissen Sie was? Es gibt so viele verschiedene Werte, die so viele verschiedene Dinge bedeuten. Ich helfe dabei, herauszufinden, was sie sind.",
                "$~Angenommen, Sie haben einen mysteri√∂sen Wert. Ich kann Ihnen sagen, ob es sich um eine @Number handelt, und Ihnen einen @Boolean geben:",
                "$~\\mystery: 'Geheimnis!'\nmystery‚Ä¢#\\",
                "$~Es ist keine Zahl, also habe ich \\‚ä•\\ erstellt. Aber wenn wir pr√ºfen, ob es @TextType ist?",
                "$~\\mystery: 'Geheimnis!'\nmystery‚Ä¢''\\",
                "$~Wir erhalten \\‚ä§\\!",
                "$~Ich bin wirklich hilfreich, wenn Sie wissen m√ºssen, ob ein @Name einen Wert einer bestimmten Art hat."
            ],
            "start": "$~Lassen Sie uns zuerst den Wert von 1 $ ermitteln",
            "finish": "$~$1[Wert ist $2|Wert ist nicht $2]",
            "conflict": {
                "ImpossibleType": "$~das kann nie 1 $ sein"
            },
            "exception": {
                "TypeException": {
                    "description": "$~inkompatible Werte",
                    "explanation": "$~Ich habe 1 $ erwartet, aber 2 $ erhalten"
                }
            }
        },
        "IsLocale": {
            "name": "$~istGebietsschema",
            "description": "$~ist Gebietsschema",
            "emotion": "$?",
            "doc": [
                "$~Ich helfe Ihnen zu √ºberpr√ºfen, ob das Publikum eine bestimmte Sprache oder Region ausgew√§hlt hat:",
                "$~\\üåç/de\\",
                "$~\\üåç/es-MX\\",
                "$~Dies ist hilfreich, wenn Sie Ihre Leistung basierend auf der gew√§hlten Sprache √§ndern m√∂chten."
            ],
            "start": "$~ist die Sprache 1 $?"
        },
        "ListAccess": {
            "name": "$~Listenzugriff",
            "emotion": "$?",
            "doc": [
                "$~Ich arbeite eng mit @List zusammen, um ihnen zu helfen, Werte an einer bestimmten Position zu erhalten. Wenn Sie also beispielsweise eine Liste h√§tten und deren zweites Element wollten, w√ºrden Sie schreiben:",
                "$~\\Liste: ['Vogel' 'Ente' 'Fisch' 'Schlange']\nListe[2]\\"
            ],
            "start": "$~Lassen Sie uns zuerst die Liste $1 holen",
            "finish": "$~Der Artikel kostet 2 $!"
        },
        "ListLiteral": {
            "name": "$~Listenliteral",
            "description": "$~$1 Artikelliste",
            "emotion": "$?",
            "doc": "$~Ich bin eine bestimmte @Liste von Werten! Siehe @Liste, um mehr dar√ºber zu erfahren, was Sie mit mir tun k√∂nnen.",
            "start": "$~Lassen Sie uns zun√§chst die Artikel bewerten",
            "finish": "$~Ich habe ein Ich gemacht! 1 $",
            "item": "$~Artikel"
        },
        "Spread": {
            "name": "$~verbreiten",
            "emotion": "serious",
            "doc": [
                "$~Eine Hilfe zum Erstellen von Listen mit den Werten anderer Listen. So:",
                "$~\\Liste: [1 2 3]\nfinal: [:Liste 4 5 6]\\"
            ]
        },
        "MapLiteral": {
            "name": "$~Kartenliteral",
            "description": "$~1 $ Paarungskarte",
            "emotion": "$?",
            "doc": "$~Ich bin eine spezielle @Map zwischen Schl√ºsseln und Werten. Weitere Informationen dazu, wie ich Ihnen behilflich sein kann, finden Sie unter @Map.",
            "start": "$~Lassen Sie uns zuerst die Schl√ºssel und Werte auswerten",
            "finish": "$~Ich habe alle verbunden, 1 $",
            "conflict": {
                "NotAKeyValue": {
                    "primary": "$~einem meiner Schl√ºssel fehlt ein Wert",
                    "secondary": "$~ups, wo ist mein Wert?"
                }
            }
        },
        "Match": {
            "name": "$~√ºbereinstimmen",
            "emotion": "curious",
            "doc": [
                "$~Ich bin die gro√üartigste aller bedingten Pr√ºfungen! Ich nehme einen Wert, vergleiche ihn mit einer beliebigen Anzahl von F√§llen und bewerte den entsprechenden Ausdruck, der √ºbereinstimmt.",
                "$~Wenn Sie beispielsweise eine @Nummer haben und diese in einen @Text umwandeln m√∂chten, k√∂nnten Sie etwa so vorgehen:",
                "$~\\Nummer: 2\nNummer ??? 1: 'eins' 2: 'zwei' 3: 'drei' 'gr√∂√üer!'\\",
                "$~Wenn keine √úbereinstimmung vorliegt, bewerte ich den Standardausdruck, den Sie mir geben.",
                "$~Ich bin wirklich hilfreich, wenn es darum geht, eine der vielen m√∂glichen @Number-, @Text- oder komplexeren Werte in etwas anderes umzuwandeln.",
                "$~Sie k√∂nnen es f√ºr @Boolean oder @None verwenden, aber es k√∂nnen nicht wirklich viele Dinge sein, daher bin ich f√ºr diese einfachen Werte nicht so n√ºtzlich."
            ],
            "start": "$~Mal sehen, was 1¬†$ ist ‚Ä¶",
            "case": "$~Lassen Sie uns diesen Zustand √ºberpr√ºfen",
            "finish": "$~Okay, wir haben einen endg√ºltigen Wert!",
            "value": "$~Wert",
            "other": "$~Standard"
        },
        "NumberLiteral": {
            "name": "$~Zahlenliteral",
            "description": "$~$1 $2[$2|]",
            "emotion": "$?",
            "doc": "$~Ich bin eine bestimmte @Nummer. Sie k√∂nnen mir mit allen m√∂glichen Ziffern aus allen m√∂glichen Sprachen schreiben. Alles, was ich kann, finden Sie unter @Nummer.",
            "start": "$~$1!",
            "conflict": {
                "NotANumber": "$~Ich dachte, ich kenne alle Zahlen, aber diese hier kenne ich nicht"
            }
        },
        "InternalExpression": {
            "name": "$~innererAusdruck",
            "emotion": "$?",
            "doc": "$~Wie haben Sie mich gefunden? Ich bin ein Ausdruck, den nur die urspr√ºnglichen Sch√∂pfer verwenden. Um mehr √ºber mich zu erfahren, m√ºssen Sie mit ihnen sprechen.",
            "start": "$~geheimer Ausdruck"
        },
        "NoneLiteral": {
            "name": "$~keinew√∂rtliche",
            "emotion": "$?",
            "doc": "$~/@FunctionDefinition hier. Dies ist einfach @None. Sie sind einzigartig! Siehe @None, um mehr √ºber sie zu erfahren.",
            "start": "$~‚Ä¶ √ñ"
        },
        "Otherwise": {
            "name": "$~ansonsten",
            "emotion": "curious",
            "doc": [
                "$~/@FunctionDefinition hier. Dies ist eine praktische M√∂glichkeit, zu pr√ºfen, ob ein Wert @None ist, und wenn ja, einen Ersatzwert anzugeben./",
                "$~/Wenn Sie beispielsweise einen Wert h√§tten, der eine @Number oder @None sein k√∂nnte, hilft Ihnen @Otherwise dabei, eine Standardnummer anzugeben:",
                "$~\\vielleichtZahl‚Ä¢#|√∏: 1 vielleichtZahl ?? 0\\"
            ],
            "start": "$~√ñ ??",
            "finish": "$~‚Ä¶ 1 US-Dollar"
        },
        "Previous": {
            "name": "$~vorherige",
            "emotion": "$?",
            "doc": [
                "$~Wollten Sie sich schon immer einmal an die Vergangenheit erinnern?",
                "$~Ich bin der offizielle Archivar des Verses. Geben Sie mir einen Strom und eine Nummer, die ich zur√ºckverfolgen kann, und ich sage Ihnen, welchen Wert dieser Strom in der Geschichte hatte.",
                "$~Hier ist beispielsweise die @Time vor f√ºnf Ticks:",
                "$~\\‚Üê 5 Zeit (1000 ms)\\",
                "$~Sehen Sie, wie 5 Sekunden lang ‚Äû@None‚Äú steht und dann pl√∂tzlich eine fr√ºhere Zeit?",
                "$~Wenn Sie die letzten paar Werte m√∂chten, geben Sie mir zwei Pfeile und ich interpretiere die Zahl als Z√§hlung:",
                "$~\\‚Üê‚Üê 5 Zeit (1000 ms)\\",
                "$~Sehen Sie, dass es die f√ºnf vorherigen Male sind und nicht nur ein Mal?",
                "$~Ich bin hilfreich, wenn Sie Auff√ºhrungen schaffen m√∂chten, die auf der Vergangenheit basieren."
            ],
            "start": "$~erhalte zuerst 1 $",
            "finish": "$~ausgewertet auf Streamwert 1 $"
        },
        "Program": {
            "name": "$~Programm",
            "emotion": "$?",
            "doc": [
                "$~Bei mir beginnt und endet eine Auff√ºhrung, und bei mir sind alle anderen Charaktere, die die Choreographie einer Show bestimmen.",
                "$~Wissen Sie, wie @Block eine Liste von Ausdr√ºcken auswertet und bis zum letzten in der Liste auswertet?",
                "$~Bei mir ist es genauso, aber anstatt dem Ausdruck, in dem ich mich befinde, meinen Wert zuzuweisen, setze ich den Wert auf @Stage.",
                "$~Der Wert kann alles sein: eine @Number, ein @Text oder ein @Boolean, eine @List, ein @Set, eine @Map oder sogar etwas Komplexeres wie eine @Phrase, @Group oder @Stage.",
                "$~Wenn Sie mir keinen Wert nennen, den ich auf der B√ºhne zeigen kann, werde ich Sie um einen bitten.",
                "$~Wenn w√§hrend einer Auff√ºhrung ein Problem auftritt, zeige ich dieses Problem.",
                "$~Und wenn Ihre Leistung von einem *Stream* abh√§ngt, f√ºhre ich bei jeder √Ñnderung des Streams eine Neubewertung durch."
            ],
            "unevaluated": "$~Der von Ihnen gew√§hlte Knoten hat nicht ausgewertet",
            "start": "$~$1[$1 Stream ge√§ndert in $2!|das ist meine erste Bewertung]",
            "halt": "$~Ausnahme aufgetreten, Stoppen",
            "finish": "$~alles erledigt, ich habe es auf 1 $ gesch√§tzt",
            "done": "$~es gibt nichts Bewertendes",
            "exception": {
                "BlankException": {
                    "description": "$~leeres Programm",
                    "explanation": "$~Lasst uns eine Show auf die Beine stellen! Wo sollen wir anfangen?"
                },
                "EvaluationLimitException": {
                    "description": "$~Bewertungsgrenze",
                    "explanation": "$~@Evaluate und ich sind es leid, zu bewerten, insbesondere $1.\n\nIst es m√∂glich, dass $1 sich selbst f√ºr immer bewertet, ohne jemals aufzuh√∂ren?"
                },
                "StepLimitException": {
                    "description": "$~Schrittgrenze",
                    "explanation": "$~Es gibt so viele Schritte ‚Äì zu viele, um sie abzuschlie√üen! K√∂nnen Sie die Auff√ºhrung einfacher machen?"
                },
                "ValueException": {
                    "description": "$~fehlender Wert",
                    "explanation": "$~Ich habe einen Wert erwartet, aber keinen bekommen!"
                }
            }
        },
        "PropertyBind": {
            "name": "$~verfeinern",
            "description": "$~verfeinern $1[$1|fehlender Name]",
            "emotion": "$?",
            "doc": [
                "$~Manchmal m√∂chten Sie beim Erstellen einer @StructureDefinition die kleinsten Details daran √§ndern, ohne eine neue mit denselben Werten erstellen zu m√ºssen.",
                "$~Was w√§re zum Beispiel, wenn Sie eine Katzenliste f√ºhren, dann aber eine Kopie einer Katze mit einem anderen Hobby erstellen m√∂chten? Ich kann Ihnen dabei helfen, dies zu √§ndern:",
                "$~\\‚Ä¢Katze(Name‚Ä¢''Farbe‚Ä¢''Hobby‚Ä¢'')\n\nK√§tzchen: Katze('streut' 'orange' 'leckt')\nK√§tzchen.Hobby:'schnurrt'\\",
                "$~Das ist doch viel einfacher, als eine ganz neue \\Cat\\ mit denselben Werten au√üer dem Hobby zu erstellen, nicht wahr?"
            ],
            "start": "$~Lassen Sie uns zun√§chst den Wert ermitteln",
            "finish": "$~Ich habe die Struktur kopiert, aber mit $1 als $2",
            "conflict": {
                "InvalidProperty": {
                    "primary": "$~Ich bin kein 1-Dollar-Investor und kann daher nicht verfeinert werden.",
                    "secondary": "$~Ich habe keinen Eingang mit dem Namen $1"
                }
            }
        },
        "PropertyReference": {
            "name": "$~Eigentum",
            "description": "$~Eigenschaft $1[$1|fehlender Name]",
            "emotion": "$?",
            "doc": [
                "$~Wenn Sie eine @StructureDefinition erstellen, wie erhalten Sie eine ihrer Eingaben? Ich bin wie",
                "$~Wenn Sie beispielsweise eine Struktur f√ºr St√§dte h√§tten, k√∂nnten Sie deren Werte folgenderma√üen von mir erhalten:",
                "$~\\‚Ä¢Stadt(Name‚Ä¢'' Bev√∂lkerung‚Ä¢#Personen)\n\nPortland: Stadt('Portland' 800000Personen)\n\nPortland.Bev√∂lkerung\\"
            ],
            "start": "$~Lassen Sie uns zun√§chst den Wert ermitteln",
            "finish": "$~gefundenes Eigentum $1, es ist $2",
            "property": "$~Eigentum"
        },
        "Reaction": {
            "name": "$~Reaktion",
            "emotion": "$?",
            "doc": [
                "$~Streams sind so geil! Ich kann neue erstellen, je nachdem, wann sie sich √§ndern, das ist super cool!",
                "$~Wenn Sie beispielsweise m√∂chten, dass @Time tickt, aber W√∂rter statt Zahlen angezeigt werden, k√∂nnten Sie Folgendes tun:",
                "$~\\Zeit: Zeit(1000ms)\n'Start' ‚Ä¶ ‚àÜ Zeit ‚Ä¶ ((Zeit % 2) = 0ms) ? 'gerade' 'ungerade'\\",
                "$~Das ist, als w√ºrde man sagen: ‚Äû/Beginnen Sie mit dem Wort ‚ÄöStart‚Äò und √§ndern Sie dann, wenn sich die Zeit √§ndert, je nach Uhrzeit entweder in gerade oder ungerade./‚Äú",
                "$~Ich bin also auch wie ein Stream, aber einer, der auf anderen Streams basiert. Geil, oder?"
            ],
            "start": "$~mal sehen, ob wir den Stream aktualisieren sollten",
            "finish": "$~Der neue Streamwert betr√§gt 1 $",
            "initial": "$~anf√§nglich",
            "condition": "$~Zustand",
            "next": "$~n√§chste",
            "conflict": {
                "ExpectedStream": "$~$1 verweist nicht auf einen Stream, daher werde ich nie reagieren!"
            }
        },
        "Reference": {
            "name": "$~Referenz",
            "description": "$~1 Dollar",
            "emotion": "$?",
            "doc": [
                "$~Wissen Sie, wie @Bind den Dingen @Namen gibt? Ich bin die Art, wie Sie sie bezeichnen. Ich sehe nach, ob ein @Bind diesen Namen hat, und gebe Ihnen in diesem Fall seinen Wert. So:",
                "$~\\Papagei: 'Polly'\nPapagei\\",
                "$~Wenn ich den Namen nicht finde, wei√ü ich nicht, was ich tun soll.",
                "$~\\Papagei: 'Polly'\nPerry\\"
            ],
            "start": "$~welchen Wert hat 1 $?",
            "conflict": {
                "UnknownName": {
                    "conflict": "$~$1[Ich kenne niemanden namens $1 in $2[$2|diesem @Block]|Kannst du mir einen Namen geben?]",
                    "resolution": "$!"
                },
                "ReferenceCycle": "$~√§hm, der Wert von 1 $ h√§ngt von ihm selbst ab. Woher wei√ü ich also, welchen Wert ich ihm zuweisen soll?",
                "UnexpectedTypeVariable": "$~Ich wei√ü nicht, was ich mit diesen Eingabetypen machen soll"
            },
            "exception": {
                "NameException": {
                    "description": "$~unbekannter Name",
                    "explanation": "$~$1[Ich kenne niemanden namens $1 in $2[$2|diesem @Block]‚Ä¶|Ihhh, kein Name!]"
                }
            }
        },
        "Select": {
            "name": "$~w√§hlen",
            "emotion": "$?",
            "doc": [
                "$~Manchmal haben Sie einen Tisch und m√∂chten nur einen Teil davon. Ich kann ihn f√ºr Sie besorgen!",
                "$~Wie w√§re es beispielsweise, wenn Sie an einem Tisch mit Spielern in einem Spiel w√§ren und diejenigen mit 10 oder mehr Punkten ermitteln m√∂chten, um zu sehen, wer gewonnen hat:",
                "$~\\Spieler: ‚é°Name‚Ä¢'' Team‚Ä¢'' Punkte‚Ä¢#‚é¶\n‚é°'jen' 'rot' 8‚é¶\n‚é°'joan' 'blau' 11‚é¶\n‚é°'jeff' 'rot' 9‚é¶\n‚é°'janet' 'blau' 7‚é¶\nSpieler ‚é°? Name ‚é¶ Punkte ‚â• 10\\",
                "$~So habe ich eine Liste mit Gewinnerreihen! Denken Sie daran, dass ich die Tabelle nicht √§ndere, sondern eine neue erstelle. Sie m√ºssen entscheiden, wo Sie sie aufbewahren."
            ],
            "start": "$~Lass uns zuerst den Tisch holen",
            "finish": "$~Ich habe eine neue Tabelle nur mit den ausgew√§hlten Zeilen und Spalten erstellt!",
            "conflict": {
                "ExpectedSelectName": "$~Ich brauche mindestens einen Spaltennamen."
            }
        },
        "SetLiteral": {
            "name": "$~Literalfestlegen",
            "description": "$~1-Dollar-Artikel",
            "emotion": "$?",
            "doc": "$~Ich bin ein spezifisches @Set spezifischer Werte. Weitere Informationen zur Zusammenarbeit mit mir finden Sie unter @Set.",
            "start": "$~Lasst uns zuerst die Werte auswerten!",
            "finish": "$~Ich habe ein Set f√ºr 1 $ gemacht!"
        },
        "SetOrMapAccess": {
            "name": "$~Zugrifffestlegen/zuordnen",
            "emotion": "$?",
            "doc": [
                "$~Ich kann sehen, ob ein @Set oder @Map einen Wert oder Schl√ºssel hat.",
                "$~Es ist nicht allzu schwer. So:",
                "$~\\faves: {'Ente' 'Gans' 'Affe'}\nfaves{'Maus'}\\",
                "$~Oder dies mit einer @Map:",
                "$~\\faves: {'Mac and Cheese': 5 Sterne 'M√ºsli': 2 Sterne 'Grusel': 1 Stern}\nfaves{'Grusel'}\\"
            ],
            "start": "$~was ist das Set oder die Karte?",
            "finish": "$~der Wert betr√§gt 1 $",
            "conflict": {
                "IncompatibleKey": {
                    "primary": "$~Ich habe einen 1-Dollar-Schl√ºssel erwartet",
                    "secondary": "$~Ich habe 1 Dollar statt 2 Dollar bekommen"
                }
            }
        },
        "Source": {
            "name": "$~Quelle",
            "emotion": "$?",
            "doc": [
                "$~Oh, Sie kennen @Program? Ich helfe Ihnen, sie zu benennen. Stellen Sie sich mich wie das Fenster um ein @Program vor und den Namen, den Sie ihnen geben.",
                "$~Sie k√∂nnen auch andere @Source @UI/addSource mit anderen @Programs erstellen und Dinge von diesen anderen @Programs zur Verwendung in einem anderen Programm @Borrow.",
                "$~Dies kann eine gute M√∂glichkeit sein, eine gro√üe Leistung in separate Dokumente zu gliedern."
            ]
        },
        "StreamDefinition": {
            "name": "$~Strom",
            "emotion": "$?",
            "doc": "$~Ich /denke/, ich soll neue Streams erstellen. Aber ich wei√ü wirklich nicht, wie das geht. Im Moment sollte ich wohl einfach die vorhandenen Streams verwenden?",
            "start": "$~Erstellen Sie diese neue Art von Stream"
        },
        "StructureDefinition": {
            "name": "$~Struktur",
            "description": "$~Struktur $1",
            "emotion": "$?",
            "doc": [
                "$~Aber hallo, wie geht es dir? Mir? Mir geht es gut. Ich liebe es, Strukturen zu definieren, die Werte und Funktionen speichern. Solange ich das den ganzen Tag tun kann, bin ich gl√ºcklich.",
                "$~Ich arbeite so:",
                "$~\\‚Ä¢Pizza(\nZutaten‚Ä¢['']\nGr√∂√üe‚Ä¢#in\n) (\n∆í Kosten() Gr√∂√üe ¬∑ 10 Dollar/in\n)\n\nPizza(['Peperoni' 'Paprika'] 12in).Kosten()\\",
                "$~Sehen Sie, wie das funktioniert? Ich habe \\Pizza\\ definiert, das zwei Eingaben hat, \\ingredients\\ (eine Liste von @Text) und \\size\\ (eine Zahl in Zoll).",
                "$~Darin hat @FunctionDefinition eine Funktion erstellt, die den Preis einer Pizza berechnet und dabei von 10 $ pro Zoll ausgeht.",
                "$~Ich muss nicht unbedingt @FunctionDefinition in mir haben. Ich kann einfach Eingaben sein.",
                "$~\\‚Ä¢Pizza(\nZutaten‚Ä¢['']\nGr√∂√üe‚Ä¢#in\n)\\",
                "$~Ich kann auch @Bind darin haben, sodass wir die Kosten im Voraus ermitteln k√∂nnen.",
                "$~\\‚Ä¢Pizza(\nZutaten‚Ä¢['']\nGr√∂√üe‚Ä¢#in\n) (\nKosten: Gr√∂√üe ¬∑ 10 Dollar/in\n)\n\nPizza(['Peperoni' 'Paprika'] 12in).Kosten\\"
            ],
            "start": "$~Lassen Sie uns diese sch√∂ne Struktur definieren",
            "conflict": {
                "DisallowedInputs": "$~Ich kann keine Eingaben machen, weil eine oder mehrere meiner Schnittstellenfunktionen nicht implementiert sind",
                "IncompleteImplementation": "$~Meine Funktionen m√ºssen entweder alle oder keine implementiert werden. Keine chaotischen Mischungen!",
                "NotAnInterface": "$~Ich bin keine Schnittstelle; eine Struktur kann nur Schnittstellen implementieren, keine anderen Strukturen",
                "UnimplementedInterface": "$~Ich implementiere $1, aber nicht $2"
            }
        },
        "TableLiteral": {
            "name": "$~Tabellenliteral",
            "description": "$~$1-Zeilentabelle",
            "emotion": "$?",
            "doc": "$~Ich bin eine bestimmte Tabelle mit bestimmten Zeilen. Siehe @Tabelle, wie ich helfen kann.",
            "start": "$~zuerst die Zeilen auswerten",
            "finish": "$~in neue Tabelle ausgewertet $1"
        },
        "TextLiteral": {
            "name": "$~Textliteral",
            "description": "$~Text $1",
            "emotion": "$?",
            "doc": "$~Ich stelle eine oder mehrere spezifische @√úbersetzungen von Texten dar. Unter @Text erfahren Sie mehr √ºber meine M√∂glichkeiten!",
            "start": "$~Lassen Sie uns Text in der aktuellen Sprache erstellen"
        },
        "Translation": {
            "name": "$~√úbersetzung",
            "description": "$~√úbersetzung $1",
            "emotion": "$?",
            "doc": "$~Ich stelle einen Text mit einem @Language-Tag dar. Weitere Informationen finden Sie unter @Text!",
            "conflict": {
                "phone": "$~Ist *$1* jemandes Telefonnummer? Wenn ja, dann gib mich nicht online weiter!\n\n$2",
                "email": "$~Ist *$1* jemandes E-Mail-Adresse? Wenn ja, dann verrate mich hier nicht!\n\n$2",
                "tin": "$~Ist *$1* eine Steuernummer? Wenn ja, geben Sie mich auf keinen Fall weiter, es handelt sich um sehr vertrauliche Informationen!\n\n$2",
                "address": "$~Ist *$1* die Privatadresse von jemandem? Wenn ja, dann schreib mich nicht hier rein, wir wollen nicht, dass jemand gestalkt wird!\n\n$2",
                "handle": "$~Ist *$1* Ihr Benutzername f√ºr eine andere Stelle im Internet? Wenn ja, teilen Sie mich hier nicht mit, es sei denn, Sie m√∂chten es wirklich.\n\n$2",
                "resolution": "$~Dies sind keine sensiblen Daten",
                "reminder": "$~Hinweis: Sie k√∂nnen diese Aktion r√ºckg√§ngig machen und im Freigabedialog andere Dinge sehen, die Sie als nicht vertraulich markiert haben."
            }
        },
        "FormattedLiteral": {
            "name": "$~formatiert",
            "description": "$~Text $1",
            "emotion": "$?",
            "doc": "$~Ich stelle viele verschiedene @FormattedTranslation formatierten Textes dar. Bei der Bewertung w√§hle ich die beste √úbereinstimmung basierend auf den ausgew√§hlten Sprachen des Publikums aus.",
            "start": "$~Lassen Sie uns Text in der aktuellen Sprache erstellen"
        },
        "FormattedTranslation": {
            "name": "$~formatierte√úbersetzung",
            "description": "$~Text $1",
            "emotion": "$?",
            "doc": [
                "$~Ich stelle einen formatierten Text mit einem @Language-Tag dar.",
                "$~Ich kann sein:",
                "$~\\`/kursiv/`\\",
                "$~\\`*fett*`\\",
                "$~\\`^extra fett^`\\",
                "$~\\`_unterstrichen_`\\",
                "$~\\`<linked@https://wordplay.dev>`\\",
                "$~\\`\\'Code'\\`\\",
                "$~Ich arbeite wirklich gut mit @Phrase, um sch√∂nen Text auf @Stage zu platzieren."
            ]
        },
        "This": {
            "name": "$~Das",
            "emotion": "$?",
            "doc": [
                "$~Manchmal ist es hilfreich, implizit auf einen Wert zu verweisen, anstatt ihn benennen zu m√ºssen.",
                "$~Angenommen, Sie m√∂chten beispielsweise eine neue @ConversionDefinition erstellen, die den zu konvertierenden Wert nicht benennt. Sie k√∂nnen einfach mit mir darauf verweisen:",
                "$~\\‚Üí #Regenb√∂gen #Freude . ¬∑ 1000000Freude\n2Regenb√∂gen ‚Üí #Freude\\",
                "$~Sehen Sie mich dort, wie ich die Anzahl der Regenb√∂gen darstelle?",
                "$~Oder nehmen wir an, Sie m√∂chten eine @Reaktion durchf√ºhren, m√ºssen aber nicht den aktuellsten Wert benennen:",
                "$~\\2 ‚Ä¶ ‚àÜ Zeit (1000 ms) ‚Ä¶ . ¬∑ 2\\",
                "$~Schaut bei mir vorbei, stellt den vorherigen Reaktionswert dar.",
                "$~Ich tauche nicht oft auf, aber wenn ich es tue, kann ich wirklich dabei helfen, einen Wert aus einem @Bind herauszuholen!"
            ],
            "start": "$~bewertet auf 1 US-Dollar",
            "conflict": {
                "MisplacedThis": "$~Mir ist lediglich ein Aufbau, eine Konvertierung oder eine Reaktion gestattet."
            }
        },
        "UnaryEvaluate": {
            "name": "$~un√§reAuswertung",
            "description": "$~1 Dollar",
            "emotion": "$?",
            "doc": [
                "$~Wussten Sie, dass Sie den Namen vor die Eingabe setzen k√∂nnen, wenn ich eine @FunctionDefinition mit nur einem Wert auswerte und der Name der @FunctionDefinition nur ein einzelnes Symbol ist?",
                "$~So was:",
                "$~\\-(1 + 1)\\",
                "$~Oder dieses:",
                "$~\\~‚ä•\\",
                "$~Diese sind viel einfacher zu lesen als \\(1 + 1).negate()\\ oder \\‚ä•.not()\\, nicht wahr?",
                "$~Du musst mir zwar nicht so schreiben, aber vielleicht ist es insgesamt einfacher.",
                "$~Es gibt nur eine Regel: Sie d√ºrfen kein Leerzeichen zwischen dem Namen und dem Wert einf√ºgen. Andernfalls erstellen Sie m√∂glicherweise eine @Reference oder @BinaryEvaluate."
            ],
            "start": "$~was ist der Wert?",
            "finish": "$~Ich habe es zu 1 $ gemacht"
        },
        "UnparsableExpression": {
            "name": "$~nichtanalysierbar",
            "emotion": "$?",
            "doc": [
                "$~/Hi, @FunctionDefinition hier. Ich √ºbersetze f√ºr @UnparsableExpression, da diese oft schwer zu interpretieren sind./",
                "$~jkwel fjiwojvioao jjiweo jrfe",
                "$~/Nicht jeder Ausdruck hat auf der B√ºhne eine Bedeutung./",
                "$~s w ieorjwei iojwi jfkdlsfdsk",
                "$~/Tats√§chlich kann man allerlei Dinge sagen, die √ºberhaupt keinen Sinn ergeben./",
                "$~dsk sdlk jdkfiewipapweiurb,v kdsfdsf",
                "$~/Wenn du das tust, tauche ich auf, weil ich nicht wei√ü, was du gemeint hast./",
                "$~Schlie√ülich sind Sie der Regisseur, also wissen nur Sie, was Sie gemeint haben k√∂nnten!"
            ],
            "start": "$~???",
            "conflict": {
                "UnparsableConflict": {
                    "conflict": "$~@FunctionDefinition hier, @UnparsableExpression wei√ü nicht, um welche Art von $1[Ausdruck | Typ] es sich handelt.",
                    "resolution": "$~Meinten Sie 1 $ oder 2 $?"
                },
                "UnclosedDelimiter": "$~Ich habe 2 $ irgendwann nach 1 $ erwartet"
            },
            "exception": {
                "UnparsableException": {
                    "description": "$~???",
                    "explanation": "$~Hallo, hier ist @FunctionDefinition! Wir sind uns nicht sicher, was diese Anweisung bedeutet, deshalb haben wir aufgeh√∂rt."
                }
            }
        },
        "Update": {
            "name": "$~aktualisieren",
            "emotion": "$?",
            "doc": [
                "$~Ich helfe bei der √úberarbeitung einer @Tabelle, finde die Zeilen, die einer Bedingung entsprechen, und erstelle dann √ºberarbeitete Zeilen mit neuen Werten.",
                "$~Wenn Sie beispielsweise eine Tabelle mit Charakteren und Punkten h√§tten und jedem Charakter in einem Team einen Punkt geben wollten, k√∂nnten Sie Folgendes tun:",
                "$~\\Spieler: ‚é°Name‚Ä¢'' Team‚Ä¢'' Punkte‚Ä¢#‚é¶\n‚é°'jen' 'rot' 1‚é¶\n‚é°'joan' 'blau' 0‚é¶\n‚é°'jeff' 'rot' 3‚é¶\n‚é°'janet' 'blau' 2‚é¶\nSpieler ‚é°: Punkte: Punkte + 1 ‚é¶ Team = 'blau'\\",
                "$~Sie k√∂nnen ein @Bind verwenden, um anzugeben, welche Spalten ge√§ndert werden sollen, und Sie k√∂nnen in der Bedingung beliebige Spaltennamen oder andere Namen im G√ºltigkeitsbereich verwenden."
            ],
            "start": "$~Lass uns zuerst den Tisch holen",
            "finish": "$~in eine neue Tabelle mit √ºberarbeiteten Zeilen ausgewertet!",
            "conflict": {
                "ExpectedColumnBind": "$~Ich brauche einen Wert f√ºr jede Spalte",
                "IncompatibleCellType": {
                    "primary": "$~Ich brauchte 1 Dollar, bekam aber 2 Dollar",
                    "secondary": "$~Ich habe 2 $"
                }
            }
        },
        "AnyType": {
            "name": "$~beliebig",
            "emotion": "$?",
            "doc": "$~Ich stelle jeden m√∂glichen Typ dar. Manchmal tauche ich auf, weil ich nicht wei√ü, was f√ºr einen Wert etwas hat, es k√∂nnte also alles M√∂gliche sein."
        },
        "BooleanType": {
            "name": "$~BoolescherWert",
            "emotion": "$?",
            "doc": [
                "$~Ich arbeite mit @Bind, um zu deklarieren, dass ein Name ein @Boolean-Wert ist. So:",
                "$~\\hungrig‚Ä¢?: 'Wackelpudding'\\",
                "$~Wenn Sie sicher sein m√∂chten, dass etwas @Boolean ist, nutzen Sie mich und ich werde es √ºberpr√ºfen!"
            ]
        },
        "ConversionType": {
            "name": "$~Konvertierung",
            "emotion": "$?",
            "doc": [
                "$~Ich arbeite mit @Bind, um anzugeben, dass ein Name eine @ConversionDefinition ist. Sie m√ºssen mich wahrscheinlich nicht verwenden, da mich nicht viele Leute als Wert weitergeben, aber wenn Sie es t√§ten, w√ºrde ich so aussehen:",
                "$~\\magic‚Ä¢?‚Üí'': ‚Üí ? '' . ? 'ja' 'n√∂'\\"
            ]
        },
        "FormattedType": {
            "name": "$~formatiert",
            "emotion": "$?",
            "doc": [
                "$~Ich arbeite mit @Bind, um festzustellen, dass ein Name ein @FormattedLiteral-Wert ist. So:",
                "$~\\hungry‚Ä¢`‚Ä¶`: `Ich bin so /schick/!`\\",
                "$~M√∂chten Sie sicherstellen, dass etwas ein @FormattedLiteral-Wert ist? So stellen Sie dies sicher."
            ]
        },
        "ExceptionType": {
            "name": "$~Ausnahme",
            "emotion": "$?",
            "doc": "$~Ich stelle eine Ausnahme dar. Es gibt keine M√∂glichkeit, bind mitzuteilen, dass ich eine bin, da Ausnahmen @Program immer nur anhalten und Sie sie daher nicht als Werte verwenden k√∂nnen."
        },
        "FunctionType": {
            "name": "$~Funktion",
            "description": "$~Funktion mit $1 Eing√§ngen, $2 Ausg√§ngen",
            "emotion": "$?",
            "doc": [
                "$~Ich stelle eine @FunctionDefinition dar. Ich bin wirklich hilfreich, wenn Sie sagen m√∂chten, welche Art von Funktion ein @Bind enth√§lt! So:",
                "$~\\math‚Ä¢∆í (# # # #) #: ∆í interessant(a‚Ä¢# b‚Ä¢# c‚Ä¢# d‚Ä¢#) a + b + c + d\\"
            ]
        },
        "ListType": {
            "name": "$~Liste",
            "description": "$~$1[Liste von $1|Liste]",
            "emotion": "$?",
            "doc": [
                "$~Ich bin /so/ ein Fan von @List. Ich kann @Bind sagen, was f√ºr eine Art Liste das ist! So sage ich, dass es eine Liste von @Number ist:",
                "$~\\Dinge‚Ä¢[#]: [ 1 2 3 4 5 ]\\"
            ]
        },
        "MapType": {
            "name": "$~Karte",
            "description": "$~Karte von $1[$1|beliebig] bis $2[$2|beliebig]",
            "emotion": "$?",
            "doc": [
                "$~Wissen Sie, wie toll @Map ist? Also wirklich toll. Ich sage @Bind st√§ndig, um welche Art von Map es sich handelt, wie diese Map von Zahlen zu Listen:",
                "$~\\Sachen‚Ä¢{'':[]}: {}\\"
            ]
        },
        "NumberType": {
            "name": "$~Nummer",
            "description": "$~$1[$1 | Zahl]",
            "emotion": "$?",
            "doc": [
                "$~Wissen Sie, was @Bind sein sollte? Eine @Nummer. Weil Nummern das Beste sind.",
                "$~\\Anzahl‚Ä¢#: 17\\"
            ]
        },
        "NameType": {
            "name": "$~Struktur",
            "description": "$~$1 Typ",
            "emotion": "$?",
            "doc": [
                "$~Ich stelle eine @StructureDefinition durch ihren Namen dar. Wenn Sie also eine Struktur wie diese h√§tten, k√∂nnten Sie ein @Bind erstellen, das die von ihm erstellten Werte speichert.",
                "$~\\‚Ä¢Freund(Name‚Ä¢'')\nbester Freund‚Ä¢Freund: Freund('Jonah')\\"
            ],
            "conflict": {
                "UnknownTypeName": "$~Typnamen k√∂nnen sich nur auf Strukturen oder Typvariablen beziehen, aber dies bezieht sich auf eine $1"
            }
        },
        "NeverType": {
            "name": "$~niemals",
            "emotion": "$?",
            "doc": "$~Ich stelle einen Typ dar, der unm√∂glich ist. Wie wenn Sie @Is fragen, ob etwas eine @Number ist, aber es kann nie eine Zahl sein."
        },
        "NoneType": {
            "name": "$~keiner",
            "emotion": "$?",
            "doc": [
                "$~@None ist das beste Nichts, das es gibt, und ich bin ihr treuer Vertreter.",
                "$~\\Leerzeichen‚Ä¢√∏: √∏\\"
            ]
        },
        "SetType": {
            "name": "$~Satz",
            "description": "$~$1[$1 Satz|Satz]",
            "emotion": "$?",
            "doc": [
                "$~@Set ist das BESTE, also im Ernst. Ich sage @Bind st√§ndig, mach aus den Dingen ein Set von irgendetwas!",
                "$~\\unique‚Ä¢{''}: {'etwas' 'irgendetwas' 'jemand'}\\"
            ]
        },
        "StreamDefinitionType": {
            "name": "$~Streamdefinition",
            "emotion": "$?",
            "doc": "$~Ich stelle einen Stream dar, den Sie definiert haben, was nicht m√∂glich ist. Warum lesen Sie das hier also √ºberhaupt?"
        },
        "StreamType": {
            "name": "$~Strom",
            "emotion": "$?",
            "doc": [
                "$~Ich feiere die Sch√∂nheit und Bedeutung von Streams ‚Ä¶ indem ich @Bind anweise, sie zu speichern:",
                "$~\\time‚Ä¢‚Ä¶#ms: Zeit()\\"
            ]
        },
        "StructureType": {
            "name": "$~Struktur",
            "description": "$1",
            "emotion": "$?",
            "doc": "$~Ich bin ein interner Typ, der den Typ der Standardwerttypen darstellt."
        },
        "TableType": {
            "name": "$~Tisch",
            "emotion": "$?",
            "doc": "$~Ich stelle eine Tabelle dar.",
            "conflict": {
                "ExpectedColumnType": "$~Ich brauche einen Spaltentyp"
            }
        },
        "TextType": {
            "name": "$~Text",
            "description": "$~$1[$1|Text]",
            "emotion": "$?",
            "doc": [
                "$~Ich vertrete auf fabelhafte Weise die fabelhafteste Art von Wert, die es gibt: @Text.",
                "$~\\story‚Ä¢'': 'Es war einmal...'\\"
            ]
        },
        "TypePlaceholder": {
            "name": "$~Platzhalter",
            "emotion": "$?",
            "doc": "$~Ich hoffe, eines Tages einen Typ darstellen zu k√∂nnen, so wie mein bester Freund @ExpressionPlaceholder einen Ausdruck darstellt! Hilfst du mir bei der Entscheidung, welche Art?"
        },
        "UnionType": {
            "name": "$~M√∂glichkeit",
            "description": "$~$1 | $2",
            "emotion": "$?",
            "doc": [
                "$~Wen soll ich repr√§sentieren, A oder B oder etwas anderes? Ich kann mich nie entscheiden!",
                "$~\\indecision‚Ä¢''|#|{√∏}: \"Ich wei√ü nicht!\"\\"
            ]
        },
        "Unit": {
            "name": "$~Einheit",
            "description": "$~1 Dollar",
            "emotion": "$?",
            "doc": [
                "$~Ich stelle jede Einheit dar, die eine @Number haben k√∂nnte, einschlie√ülich keiner Einheit, bis hin zur kompliziertesten Einheit, die man sich vorstellen kann. Wie zum Beispiel die Schwerkraft:",
                "$~\\Schwerkraft‚Ä¢m/s^2: 9,8m/s^2\\",
                "$~Ich werde in @Bind angezeigt, aber auch direkt nach @Number. Ich helfe sicherzustellen, dass die Nummern vom gleichen Typ sind, und werde Sie auf jeden Fall informieren, wenn dies nicht der Fall ist, falls es sich um einen Fehler handelt!"
            ]
        },
        "UnparsableType": {
            "name": "$~nichtanalysierbar",
            "emotion": "$?",
            "doc": "$~Ich stelle den Typ eines unbekannten Ausdrucks dar. Ich werde angezeigt, wenn Sie versuchen, diesen Ausdruck f√ºr etwas zu verwenden."
        },
        "VariableType": {
            "name": "$~Variablentyp",
            "emotion": "$?",
            "doc": "$~Kennen Sie @TypeVariable und wissen Sie, wie sie unbekannte Werte darstellen? Ich vertrete sie bei allen Verhandlungen zwischen Werten."
        },
        "UnknownType": {
            "name": "$~Unbekannt",
            "connector": "$~, Weil",
            "emotion": "$?",
            "doc": "$~√Ñhm... ich wei√ü nicht, was ich darstelle, aber ich bin wirklich neugierig. Wissen Sie es? Es scheint, als ob wir es wissen sollten. Sie m√ºssen es uns vielleicht sagen, wenn wir es nicht herausfinden k√∂nnen."
        },
        "CycleType": {
            "name": "$~Zyklus",
            "description": "$~h√§ngt von sich selbst ab",
            "emotion": "$?",
            "doc": "$~Manchmal h√§ngen Werte von sich selbst ab, und wir wissen deshalb nicht, um welche Art von Wert es sich handelt. Ich vertrete diese Situation."
        },
        "NotAType": {
            "name": "$~unerwartet",
            "description": "$~kein 1-Dollar-",
            "emotion": "$?",
            "doc": "$~Manchmal wissen wir, welchen Wert etwas haben sollte. Beispielsweise ben√∂tigt @ListAccess eine @Number. Wenn wir diese nicht erhalten, gehe ich davon aus, dass etwas einen anderen Typ hat als den erwarteten."
        },
        "NoExpressionType": {
            "name": "$~keinAusdruck",
            "emotion": "$?",
            "doc": "$~Wissen Sie, dass @Block mindestens einen Ausdruck braucht? Ich bin das, was Sie bekommen, wenn Sie keinen angeben. Geben Sie also einen an!"
        },
        "NotEnclosedType": {
            "name": "$~nichtinStruktur,UmwandlungoderReaktion",
            "emotion": "$?",
            "doc": "$~@Dies, so sch√∂n sie auch sind, geh√∂rt nur an bestimmte Orte. Ich tauche auf, wenn sie verloren gehen, und deshalb wei√ü niemand, welchen Wert sie darstellen."
        },
        "NotImplementedType": {
            "name": "$~nichtimplementiert",
            "emotion": "$?",
            "doc": "$~Wenn Sie @ExpressionPlaceholder verwenden, aber nicht sagen, um welchen Typ es sich handelt, bin ich der Typ, den Sie erhalten. Kommen Sie damit klar!"
        },
        "UnknownNameType": {
            "name": "$~unbekannterName",
            "description": "$~$1[$1 ist nicht definiert |es wurde kein Name angegeben]",
            "emotion": "$?",
            "doc": "$~Wissen Sie, dass @Reference und @PropertyReference manchmal den Namen nicht kennen, von dem Sie sprechen? Ich bin in solchen F√§llen dabei, um zu zeigen, dass wir nicht wissen, von wem Sie sprechen."
        },
        "NonFunctionType": {
            "name": "$~Nichtfunktion",
            "description": "$~Nichtfunktion",
            "emotion": "$?",
            "doc": "$~Einige von uns haben mit Funktionen gerechnet; ich tauche auf, wenn wir keine bekommen."
        },
        "UnknownVariableType": {
            "name": "$~unbekannteVariable",
            "emotion": "$?",
            "doc": "$~Manchmal versuchen wir zu erraten, welchen Wert etwas hat. Ich tauche auf, wenn wir es nicht wissen."
        },
        "Input": {
            "name": "$~Eingang",
            "description": "$~benannte Eingabe",
            "emotion": "$?",
            "doc": [
                "$~Ich bin eine Eingabe, die an @Evaluate √ºbergeben wird. Mein Name entspricht dem Namen der Eingabe in der ausgewerteten @FunctionDefinition oder @StructureDefinition.",
                "$~Ich bin hilfreich bei Funktionen mit vielen Standardwerten, bei denen Sie nur eine bestimmte Eingabe √ºberschreiben m√∂chten, ohne alles andere anzugeben.",
                "$~Beispielsweise hat @Phrase viele, viele Standardwerte, um seinen Stil zu steuern. Angenommen, Sie m√∂chten etwas @Text und eine @Color angeben, aber sonst nichts in der Eingabeliste. Sie k√∂nnen mich dazu verwenden:",
                "$~\\Phrase('Ich bin lila!' Farbe: Farbe(50% 52 300¬∞))\\"
            ],
            "start": "$~Lassen Sie uns meinen Wert bewerten."
        },
        "StructureDefinitionType": {
            "name": "$~Strukturdefinition",
            "emotion": "$?",
            "description": "$~Definition von $1",
            "doc": [
                "$~Ich beziehe mich auf eine Art @StructureDefinition. Normalerweise beziehen sich die Leute nicht direkt auf mich"
            ]
        }
    },
    "basis": {
        "Boolean": {
            "doc": [
                "$~Wir sind \\‚ä§\\ und \\‚ä•\\. \\‚ä§\\ ist wahr. \\‚ä•\\ ist falsch. \\‚ä§\\ ist nicht \\‚ä•\\; \\‚ä•\\ ist nicht \\‚ä§\\. So ist es.",
                "$~Wie machst du uns? Einfach \\‚ä§\\ und \\‚ä•\\, nicht mehr und nicht weniger.",
                "$~Manche benutzen die Tastatur (/Strg+9/ f√ºr \\‚ä§\\ und /Strg+0/ f√ºr \\‚ä•\\). Manche benutzen die Zeichensuche unten im Editor. Oder Sie ziehen uns von hier.",
                "$~Schauen Sie sich unten unsere @FunctionDefinition an. Sie sind sehr logisch."
            ],
            "name": ["$~‚ä§‚ä•", "$~BoolescherWert"],
            "function": {
                "and": {
                    "doc": [
                        "$~Ich bewerte \\‚ä§\\ *nur*, wenn beide Werte \\‚ä§\\ sind. Hilfreich, um festzustellen, ob viele Dinge alle wahr sind. Es gibt nur vier m√∂gliche Ergebnisse",
                        "$~\\‚ä§ & ‚ä§\\",
                        "$~\\‚ä§ & ‚ä•\\",
                        "$~\\‚ä• und ‚ä§\\",
                        "$~\\‚ä• & ‚ä•\\"
                    ],
                    "names": ["$~und", "$~Und"],
                    "inputs": [
                        {
                            "doc": "$~Der andere zu pr√ºfende @Boolean. Wenn der erste \\‚ä•\\ ist, spielt es keine Rolle, was das ist, die Funktion wird als \\‚ä•\\ ausgewertet.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "or": {
                    "doc": [
                        "$~Ich bewerte \\‚ä§\\, wenn *beide* Werte \\‚ä§\\ sind. Hilfreich, um zu bestimmen, ob eines von vielen Dingen wahr ist. Es gibt nur vier m√∂gliche Ergebnisse",
                        "$~\\‚ä§ | ‚ä§\\",
                        "$~\\‚ä§ | ‚ä•\\",
                        "$~\\‚ä• | ‚ä§\\",
                        "$~\\‚ä• | ‚ä•\\"
                    ],
                    "names": ["$~|", "$~oder"],
                    "inputs": [
                        {
                            "doc": "$~Der andere zu pr√ºfende @Boolean. Wenn der erste \\‚ä•\\ ist, wird die Funktion nur dann als \\‚ä§\\ ausgewertet, wenn dies \\‚ä§\\ ist.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "not": {
                    "doc": "$~Ich erhalte das Gegenteil von mir selbst: wenn \\‚ä§\\, ergibt es \\‚ä•\\, wenn \\‚ä•\\, ergibt es \\‚ä§\\.",
                    "names": ["$~~", "$~nicht"],
                    "inputs": []
                },
                "equals": {
                    "doc": "$~\\‚ä§\\ wenn beide \\‚ä§\\ sind oder beide \\‚ä•\\ sind.",
                    "names": ["$~=", "$~istgleich"],
                    "inputs": [
                        {
                            "doc": "$~Der andere zu pr√ºfende Wert.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "notequal": {
                    "doc": "$~\\‚ä§\\ wenn beides Gegens√§tze sind.",
                    "names": ["$~‚â†", "$~nichtgleich"],
                    "inputs": [
                        {
                            "doc": "$~Der andere zu pr√ºfende Wert.",
                            "names": "$~Wert"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Wandelt einen @Boolean in die entsprechenden @Text-Werte \\'‚ä§'\\ und \\'‚ä•'\\ um."
            }
        },
        "None": {
            "doc": [
                "$~/Hallo, hier ist @FunctionDefinition. @None sagt nicht gerne viel, also √ºbernehme ich die Interpretation./",
                "$~Ich bin @None. Rufen Sie mich mit \\√∏\\ auf. Ich bin hilfreich, wenn Sie die Abwesenheit von etwas darstellen m√∂chten."
            ],
            "name": ["$~√ñ", "$~Keiner"],
            "function": {
                "equals": {
                    "doc": "$~Ist ein anderer Wert auch nichts? Das sollte er besser sein, sonst gilt \\‚ä•\\.",
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "$~Der andere Wert.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "notequals": {
                    "doc": "$~Ist ein anderer Wert /nicht/ nichts?",
                    "names": ["$~‚â†", "$~nichtgleich"],
                    "inputs": [
                        {
                            "doc": "$~Der andere Wert.",
                            "names": "$~Wert"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~M√∂chten Sie aus \\√∏\\ \\'√∏'\\ machen? Das ist Ihre Chance."
            }
        },
        "Text": {
            "doc": [
                "$~Ich kann jeder beliebige Text aus jeder beliebigen Sprache sein und die folgenden √∂ffnenden und schlie√üenden Symbole verwenden: \\\"\"\\, \\‚Äú‚Äù\\, \\‚Äû‚Äú\\, \\''\\, \\‚Äò‚Äô\\, \\‚Äπ‚Ä∫\\, \\¬´¬ª\\, \\„Äå„Äç\\ oder \\„Äé„Äè\\.",
                "$~Zur Veranschaulichung betrachten Sie diese sch√∂nen S√§tze",
                "$~‚ÄûEs gibt nur zwei Arten, sein Leben zu leben. Die eine ist, als w√§re nichts ein Wunder. Die andere ist, als w√§re alles ein Wunder.‚Äú",
                "$~\\\"Die besten Seiten von heute\"\\",
                "$~Denke nur daran, mich zu schlie√üen, wenn du mich √∂ffnest, und verwende das entsprechende Symbol. Sonst wei√ü ich nicht, dass du mit deinen Worten fertig bist.",
                "$~\\'hallo'/en'hola'/es-MX\\",
                "$~Sie k√∂nnen mir auch Sprachen taggen und sogar mehrere √úbersetzungen angeben. Ich werde die aktuell ausgew√§hlten Sprachen auswerten, wenn eine passende Sprache vorhanden ist.",
                "$~Wenn Sie mir andere Werte geben m√∂chten, k√∂nnen Sie ein Symbol verwenden, um",
                "$~Betrachten Sie beispielsweise Folgendes:",
                "$~\\\"Hier sind einige Summen \\1 + 2\\, \\2 + 3\\, \\3 + 4\\\"\\",
                "$~Sehen Sie, wie elegant ich diese Summen gerade ausgewertet und in den @Text eingef√ºgt habe?",
                "$~Ansonsten gibt es einfach so viele tolle Funktionen, die @FunctionDefinition f√ºr mich erstellt hat, um alle m√∂glichen Dinge mit W√∂rtern zu tun!"
            ],
            "name": ["$~''", "$~Text"],
            "function": {
                "length": {
                    "doc": [
                        "$~Ich bewerte nach der Anzahl der lesbaren Zeichen im Text; ein Buchstabe ist ein Zeichen, ein Emoji ist ein Zeichen usw. Beispiel:",
                        "$~\\'hallo'.length()\\",
                        "$~\\'üêàüìö'.L√§nge()\\"
                    ],
                    "names": ["$~üìè", "$~L√§nge"],
                    "inputs": []
                },
                "equals": {
                    "doc": "$~\\‚ä§\\, wenn es sich um die gleiche Zeichenfolge wie den angegebenen @Text handelt.",
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "$~Der zu vergleichende @Text.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "notequals": {
                    "doc": "$~\\‚ä§\\ wenn es sich /nicht/ um dieselbe Zeichenfolge wie den angegebenen @Text handelt.",
                    "names": "$~‚â†",
                    "inputs": [
                        {
                            "doc": "$~Der zu vergleichende @Text",
                            "names": "$~Wert"
                        }
                    ]
                },
                "repeat": {
                    "doc": [
                        "$~Ich erstelle einen neuen @Text, der von mir stammt und so oft wiederholt wird wie \\count\\:",
                        "$~\\'hallo ' ¬∑ 5\\",
                        "$~Wenn Sie mir eine Bruchzahl @Zahl geben, ignoriere ich den Bruch:",
                        "$~\\'hallo ' ¬∑ 5.5\\",
                        "$~Wenn Sie mir eine negative @Zahl oder Null geben, gebe ich einen leeren @Text.",
                        "$~\\'hallo ' ¬∑ -5\\",
                        "$~Der l√§ngste Text, den ich erstellen kann, ist 65.535 Zeichen lang. Wenn Sie versuchen, einen l√§ngeren Text zu erstellen, wiederhole ich den Text so oft wie m√∂glich."
                    ],
                    "names": ["$~¬∑", "$~üîÅ", "$~wiederholen"],
                    "inputs": [
                        {
                            "doc": "$~Die Anzahl der Wiederholungen im neuen Text.",
                            "names": "$~z√§hlen"
                        }
                    ]
                },
                "segment": {
                    "doc": [
                        "$~Ich teile mich in eine @List von @Text auf, wobei ich den angegebenen @Text als Trennzeichen verwende und die Trennzeichen entferne. Beispiel:",
                        "$~\\'√Ñpfel, Orangen, Trauben' √∑ ', '\\",
                        "$~Wenn der Trenner ein leerer @Text ist, teile ich mich in Zeichen auf:",
                        "$~\\'üñåÔ∏èüè†ü•∏' √∑ ''\\"
                    ],
                    "names": ["segmentar"],
                    "inputs": [
                        {
                            "doc": "$~Der als Trennzeichen zu verwendende @Text.",
                            "names": "$~Trennzeichen"
                        }
                    ]
                },
                "combine": {
                    "doc": [
                        "$~Manchmal ist es hilfreich, zwei @Texte zu einem einzigen zusammenzufassen. Gib mir einen weiteren @Text und ich erstelle einen neuen Text, der uns verbindet:",
                        "$~\\'hallo ' + 'vers'\\"
                    ],
                    "names": ["$~+", "$~kombinieren"],
                    "inputs": [
                        {
                            "doc": "$~Der anzuh√§ngende @Text.",
                            "names": "$~Text"
                        }
                    ]
                },
                "has": {
                    "doc": [
                        "$~\\‚ä§\\ wenn der angegebene @Text in mir vorkommt.",
                        "$~\\'Haben Sie gefunden, wonach Sie gesucht haben?'.has('Sie')\\"
                    ],
                    "names": ["tiene"],
                    "inputs": [
                        {
                            "doc": "$~Der @Text, nach dem in mir gesucht werden soll.",
                            "names": "$~Text"
                        }
                    ]
                },
                "starts": {
                    "doc": [
                        "$~\\‚ä§\\, wenn ich mit dem gegebenen @Text beginne.",
                        "$~\\'Hallo Vers!'.starts('Hallo')\\",
                        "$~\\'Hallo Vers!'.starts('Vers')\\"
                    ],
                    "names": ["$~beginnt"],
                    "inputs": [
                        {
                            "doc": "$~Der @Text, nach dem ich am Anfang suchen soll.",
                            "names": "texto"
                        }
                    ]
                },
                "ends": {
                    "doc": [
                        "$~\\‚ä§\\, wenn ich mit dem angegebenen @Text beende.",
                        "$~\\'bin ich eine Frage?'.ends('?')\\",
                        "$~\\'Ich bin keine Frage.'.ends('?')\\"
                    ],
                    "names": ["$~endet"],
                    "inputs": [
                        {
                            "doc": "$~Der @Text, nach dem ich am Ende suchen muss.",
                            "names": "texto"
                        }
                    ]
                }
            },
            "conversion": {
                "list": "$~Teilt den Text in eine Liste einzelner Zeichen auf.",
                "number": "$~Wandelt Text in eine @Zahl um, und wenn es keine Zahl ist, in einen Nicht-Zahlenwert."
            }
        },
        "Number": {
            "doc": [
                "$~Ich erstelle @Number mit jeder erdenklichen Anzahl von Einheiten!",
                "$~Hier sind meine Top 5:",
                "$~\\0\\",
                "$~\\1Geschichte\\",
                "$~\\œÄKuchen\\",
                "$~\\‚àûFelsen\\",
                "$~\\1000000Umarmungen\\",
                "$~Das ist im Grunde eine unendliche Anzahl von Zahlen.",
                "$~Und zwar unendlich viele Einheiten!",
                "$~Und eine unendliche Anzahl von Zahl/Einheit-Paaren ‚Ä¶",
                "$~Ich kann ganze Zahlen, reelle Zahlen, negative Zahlen, positive Zahlen, Br√ºche, Dezimalzahlen oder sogar keine Zahl sein.",
                "$~Und Sie k√∂nnen mir mit vielen verschiedenen Zahlensystemen schreiben, darunter Arabisch \\123\\, R√∂misch \\‚Ö©‚Ö©‚Ö©‚Ö†‚Ö©\\, Japanisch \\‰∫åÂçÅ\\ und mehr:",
                "$~\\1 + ‚Ö† + ‰∏Ä\\",
                "$~Sie k√∂nnen mir auch in den Basen 2 bis 16 schreiben, indem Sie eine Basiszahl wie diese eingeben:",
                "$~\\2;11111111\\",
                "$~\\10;255\\",
                "$~\\16;FF\\",
                "$~Es gibt eine spezielle Zahl namens NaN, die m√∂glich ist, wenn Sie etwas schreiben, das keine Zahl ist:",
                "$~\\2;22\\",
                "$~Es gibt keine Ziffer '2' in Basis 2, also ist es keine g√ºltige Zahl. NaN wird auch angezeigt, wenn Sie versuchen, einen nicht-numerischen Text in eine Zahl umzuwandeln",
                "$~\\'hallo'‚Üí#\\"
            ],
            "name": ["$~#", "$~Nummer"],
            "function": {
                "add": {
                    "doc": [
                        "$~Ich f√ºge mir selbst eine @Number mit der gleichen @Unit hinzu und erstelle so eine neue @Number mit der gleichen @Unit.",
                        "$~Zum Beispiel:",
                        "$~\\1 + 1\\",
                        "$~\\3Katze + 5Katze\\",
                        "$~Wenn die Einheiten nicht √ºbereinstimmen, breche ich die Show ab.",
                        "$~\\3Katze + 5Hund\\"
                    ],
                    "names": ["$~+", "$~hinzuf√ºgen"],
                    "inputs": [
                        {
                            "doc": "$~Die hinzuzuf√ºgende @Nummer.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "subtract": {
                    "doc": [
                        "$~Ich subtrahiere die @Nummer, die Sie mir geben, von mir selbst und erstelle eine neue @Nummer derselben @Einheit.",
                        "$~Zum Beispiel:",
                        "$~\\1 - 1\\",
                        "$~\\3Katze - 5Katze\\",
                        "$~Wenn die Einheiten nicht √ºbereinstimmen, breche ich die Show ab.",
                        "$~\\3Katze - 5Hund\\"
                    ],
                    "names": ["$~-", "$~subtrahieren"],
                    "inputs": [
                        {
                            "doc": "$~Die @Nummer, die von mir abgezogen werden soll.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "multiply": {
                    "doc": [
                        "$~Ich multipliziere mich selbst mit der gegebenen @Number und erstelle ein Produkt aus meiner @Unit und der @Unit der gegebenen Zahl:",
                        "$~\\5 ¬∑ 5\\",
                        "$~\\5m ¬∑ 5m\\",
                        "$~\\5m ¬∑ 1/s\\"
                    ],
                    "names": ["$~¬∑", "$~multiplizieren"],
                    "inputs": [
                        {
                            "doc": "$~Die zu multiplizierende Zahl.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "divide": {
                    "doc": [
                        "$~Ich dividiere mich durch die gegebene @Zahl und erstelle einen Quotienten aus meiner @Einheit und der @Einheit der gegebenen Zahl:",
                        "$~\\5 √∑ 5\\",
                        "$~\\5 m √∑ 5 m\\",
                        "$~\\5m √∑ 5s\\"
                    ],
                    "names": ["√∑", "divide"],
                    "inputs": [
                        {
                            "doc": "$~Die @Zahl, durch die ich dividieren soll.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "remainder": {
                    "doc": [
                        "$~Ich dividiere durch die gegebene @Zahl, gebe aber den Rest aus:",
                        "$~\\10 % 2\\",
                        "$~\\10m % 2\\",
                        "$~\\10m/s % 3\\"
                    ],
                    "names": ["$~%", "$~Rest"],
                    "inputs": [
                        {
                            "doc": "$~Die @Zahl, durch die ich dividieren soll.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "positive": {
                    "doc": [
                        "$~Ich erstelle eine neue @Nummer, die mich positiv macht, wenn auch negativ.",
                        "$~\\-200.positive()\\"
                    ],
                    "names": ["$~positiv"],
                    "inputs": []
                },
                "round": {
                    "doc": [
                        "$~Ich erstelle eine neue @Zahl, die auf die n√§chste Ganzzahl rundet.",
                        "$~\\9.4.round()\\",
                        "$~\\9.5.round()\\",
                        "$~\\9.6.round()\\"
                    ],
                    "names": ["$~runden"],
                    "inputs": []
                },
                "roundDown": {
                    "doc": [
                        "$~Ich erstelle eine neue @Number, die auf die kleinste Ganzzahl rundet, die kleiner ist als ich.",
                        "$~\\10.5.roundDown()\\",
                        "$~\\10.1.roundDown()\\",
                        "$~\\10.01.roundDown()\\"
                    ],
                    "names": ["$~abrunden"],
                    "inputs": []
                },
                "roundUp": {
                    "doc": [
                        "$~Ich erstelle eine neue @Zahl, die auf die kleinste Ganzzahl rundet, die gr√∂√üer ist als ich.",
                        "$~\\10.5.roundUp()\\",
                        "$~\\10.9.roundUp()\\",
                        "$~\\10.99.roundUp()\\"
                    ],
                    "names": ["$~aufrunden"],
                    "inputs": []
                },
                "power": {
                    "doc": [
                        "$~Ich potenziere mich selbst mit der angegebenen @Zahl. Bruchexponenten sind ok!",
                        "$~\\2 ^ 8\\",
                        "$~\\10 ^ -2\\",
                        "$~\\5 ^ -.5\\"
                    ],
                    "names": ["^", "power"],
                    "inputs": [
                        {
                            "doc": "$~Der Exponent, auf den ich erh√∂ht werden soll.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "root": {
                    "doc": [
                        "$~Ich erstelle meine eigene Wurzel unter Verwendung der angegebenen Wurzel.",
                        "$~\\4 ‚àö 2\\",
                        "$~\\1000 ‚àö 3\\"
                    ],
                    "names": ["‚àö", "root"],
                    "inputs": [
                        {
                            "doc": "$~Die zu berechnende Wurzel.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "lessThan": {
                    "doc": [
                        "$~\\‚ä§\\ wenn ich kleiner bin als die angegebene @Zahl:",
                        "$~\\1 < 2\\",
                        "$~\\2 < 1\\"
                    ],
                    "names": ["<", "lessthan"],
                    "inputs": [
                        {
                            "doc": "$~Die @Nummer, mit der ich mich vergleichen kann.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "lessOrEqual": {
                    "doc": [
                        "$~\\‚ä§\\ wenn I kleiner oder gleich der angegebenen @Zahl ist:",
                        "$~\\1 ‚â§ 2\\",
                        "$~\\2 ‚â§ 1\\",
                        "$~\\2 ‚â§ 2\\"
                    ],
                    "names": ["‚â§", "lessorequal"],
                    "inputs": [
                        {
                            "doc": "$~Die @Nummer, mit der ich mich vergleichen kann.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "greaterThan": {
                    "doc": [
                        "$~\\‚ä§\\ wenn ich gr√∂√üer als die angegebene @Zahl bin:",
                        "$~\\1 > 2\\",
                        "$~\\2 > 1\\"
                    ],
                    "names": [">", "greaterthan"],
                    "inputs": [
                        {
                            "doc": "$~Die @Nummer, mit der ich mich vergleichen kann.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "greaterOrEqual": {
                    "doc": [
                        "$~\\‚ä§\\ wenn I gr√∂√üer oder gleich der angegebenen @Zahl ist:",
                        "$~\\1 ‚â• 2\\",
                        "$~\\2 ‚â• 1\\",
                        "$~\\2 ‚â• 2\\"
                    ],
                    "names": ["‚â•", "greaterorequal"],
                    "inputs": [
                        {
                            "doc": "$~Die @Nummer, mit der ich mich vergleichen kann.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "equal": {
                    "doc": [
                        "$~\\‚ä§\\ wenn I gleich der angegebenen @Zahl ist:",
                        "$~\\1 = 2\\",
                        "$~\\2 = 2\\"
                    ],
                    "names": ["$~=", "$~gleich"],
                    "inputs": [
                        {
                            "doc": "$~Die @Nummer, mit der ich mich vergleichen kann.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "notequal": {
                    "doc": [
                        "$~\\‚ä§\\ wenn I gleich der angegebenen @Zahl ist:",
                        "$~\\1 ‚â† 2\\",
                        "$~\\2 ‚â† 2\\"
                    ],
                    "names": ["$~‚â†", "$~nichtgleich"],
                    "inputs": [
                        {
                            "doc": "$~Die @Nummer, mit der ich mich vergleichen kann.",
                            "names": "$~Nummer"
                        }
                    ]
                },
                "cos": {
                    "doc": [
                        "$~Berechnen Sie den Kosinus von mir.",
                        "$~\\œÄ.cos()\\"
                    ],
                    "names": ["cos", "cosine"],
                    "inputs": []
                },
                "sin": {
                    "doc": ["$~Berechnen Sie meinen Sinus.", "$~\\œÄ.cos()\\"],
                    "names": ["sin", "sine"],
                    "inputs": []
                },
                "min": {
                    "doc": [
                        "$~Finde die kleinste Anzahl von mir und anderen.",
                        "$~\\1.min(2 3 -1)\\"
                    ],
                    "names": "$~Mindest",
                    "inputs": [
                        {
                            "doc": "$~So viele Nummern wie du mir geben m√∂chtest!",
                            "names": "$~Zahlen"
                        }
                    ]
                },
                "max": {
                    "doc": [
                        "$~Finden Sie die gr√∂√üte Anzahl von mir und anderen.",
                        "$~\\1.max(2 3 4)\\"
                    ],
                    "names": "$~max",
                    "inputs": [
                        {
                            "doc": "$~So viele Nummern wie du mir geben m√∂chtest!",
                            "names": "$~Zahlen"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Eine arabische @Text-Darstellung meiner Ziffern.",
                "list": [
                    "$~Ich konvertiere eine Zahl in eine Liste von Zahlen von \\1\\ bis zu einer beliebigen angegebenen Zahl. Beispiel:",
                    "$~\\10‚Üí[]\\"
                ],
                "s2m": "$~Sekunden bis Minuten",
                "s2h": "$~Sekunden bis Stunden",
                "s2day": "$~Sekunden bis Tage",
                "s2wk": "$~Sekunden bis Wochen",
                "s2year": "$~Sekunden bis Jahre",
                "s2ms": "$~Sekunden in Millisekunden",
                "ms2s": "$~Millisekunden in Sekunden",
                "min2s": "$~Minuten bis Sekunden",
                "h2s": "$~Stunden bis Sekunden",
                "day2s": "$~Tage bis Sekunden",
                "wk2s": "$~Von Wochen bis Sekunden",
                "yr2s": "$~Jahre in Sekunden",
                "m2pm": "$~Meter in Pikometer",
                "m2nm": "$~Meter in Nanometer",
                "m2micro": "$~Meter in Mikrometer",
                "m2mm": "$~Meter in Millimeter",
                "m2cm": "$~Meter in Zentimeter",
                "m2dm": "$~Meter in Dezimeter",
                "m2km": "$~Meter in Kilometer",
                "m2Mm": "$~Meter in Megameter",
                "m2Gm": "$~Meter in Gigameter",
                "m2Tm": "$~Meter in Terameter",
                "pm2m": "$~Pikometer in Meter",
                "nm2m": "$~Nanometer in Meter",
                "micro2m": "$~Mikrometer in Meter",
                "mm2m": "$~Millimeter in Meter",
                "cm2m": "$~Zentimeter in Meter",
                "dm2m": "$~Dezimeter in Meter",
                "km2m": "$~Kilometer in Meter",
                "Mm2m": "$~Megameter in Meter",
                "Gm2m": "$~Gigameter in Meter",
                "Tm2m": "$~Terameter in Meter",
                "km2mi": "$~Kilometer in Meilen",
                "mi2km": "$~Meilen in Kilometer",
                "cm2in": "$~Zentimeter in Zoll",
                "in2cm": "$~Zoll in Zentimeter",
                "m2ft": "$~Meter in Fu√ü",
                "ft2m": "$~Fu√ü zu Meter",
                "g2mg": "$~Gramm in Milligramm",
                "mg2g": "$~Milligramm in Gramm",
                "g2kg": "$~Gramm in Kilogramm",
                "kg2g": "$~Kilogramm in Gramm",
                "g2oz": "$~Gramm in Unzen",
                "oz2g": "$~Unzen in Gramm",
                "oz2lb": "$~Unzen in Pfund",
                "lb2oz": "$~Pfund in Unzen"
            }
        },
        "List": {
            "doc": [
                "$~Ich bin eine Abfolge von Werten, gleich welcher Art!",
                "$~Sie k√∂nnen alles in mich eingeben: @Boolean, @Number, @Text, @None, sogar andere @List, @Set, @Map oder beliebige Ausdr√ºcke. Hier ist ein einfacher:",
                "$~\\['Apfel' 'Banane' 'Mango']\\",
                "$~Was mich besonders macht, ist, dass ich Ordnung halte und alles von 1 bis zur Anzahl der Gegenst√§nde in mir nummeriere.",
                "$~Meine Eintr√§ge sind nummeriert, beginnend bei 1. Sie k√∂nnen die Werte, die ich mit @ListAccess speichere, anhand ihrer Nummer abrufen:",
                "$~Der zweite Wert in dieser Liste ist beispielsweise \\['banana']\\",
                "$~\\['Apfel' 'Banane' 'Mango'][2]\\",
                "$~Ich kann alles in mir haben. Schau dir diese Liste an, mit @Text, @Nummer und @Zeit!",
                "$~\\['Apfel' 10 + 10 Zeit()]\\",
                "$~Wenn Sie mir eine Liste mit vielen Dingen geben, verallgemeinere ich sie, wenn sie einen gemeinsamen Typ haben. Aber manchmal meinen Sie diese spezifischen Dinge vielleicht w√∂rtlich. Wenn das der Fall ist, setzen Sie einfach ein ! hinter mich und ich stelle sicher, dass ich eine Liste mit genau diesen Werten darstelle.",
                "$~\\['Apfel' 'Banane' 'Mango']!\\",
                "$~Das ist so ziemlich alles. Aber ich kann mit meiner @FunctionDefinition allerlei spannende Dinge aufrufen!"
            ],
            "name": ["$~[]", "$~Auff√ºhren"],
            "kind": "$~Art",
            "out": "$~Ergebnis",
            "outofbounds": "$~au√üerhalb der Grenzen",
            "function": {
                "add": {
                    "doc": [
                        "$~Ich erstelle eine neue @Liste mit dem angegebenen Element am Ende.",
                        "$~\\['Apfel' 'Banane' 'Mango'].add('Wassermelone')\\"
                    ],
                    "names": ["$~mit", "$~hinzuf√ºgen"],
                    "inputs": [
                        {
                            "doc": "$~Ich bin der Wert, den Sie hinzuf√ºgen m√∂chten.",
                            "names": "$~Artikel"
                        }
                    ]
                },
                "append": {
                    "doc": [
                        "$~Ich erstelle eine neue @List mit meinen Werten, danach alle Werte der angegebenen @List.",
                        "$~\\['Apfel' 'Banane' 'Mango'].withList(['Wassermelone' 'Sternfrucht'])\\",
                        "$~Es ist jedoch etwas einfacher, @Spread wie folgt zu verwenden:",
                        "$~\\['Apfel' 'Banane' 'Mango' :['Wassermelone' 'Sternfrucht']]\\"
                    ],
                    "names": ["$~mitListe", "$~Anh√§ngen"],
                    "inputs": [
                        {
                            "doc": "$~Die Liste der hinzuzuf√ºgenden Werte.",
                            "names": "$~Liste"
                        }
                    ]
                },
                "replace": {
                    "doc": [
                        "$~Ich erstelle eine neue Liste, die den Wert am angegebenen Index durch den angegebenen Wert ersetzt.",
                        "$~\\['Apfel' 'Banane' 'Mango'].replace(1 'Kiwi')\\"
                    ],
                    "names": ["reemplazar"],
                    "inputs": [
                        {
                            "doc": "$~Der Index des zu ersetzenden Wertes",
                            "names": "$~Index"
                        },
                        {
                            "doc": "$~Der Wiederbeschaffungswert",
                            "names": "$~Wert"
                        }
                    ]
                },
                "length": {
                    "doc": "$~Die @Anzahl der Elemente in mir.",
                    "names": ["$~üìè", "$~L√§nge"],
                    "inputs": []
                },
                "random": {
                    "doc": [
                        "$~Eine zuf√§llig ausgew√§hlte Option aus meinen Artikeln oder @Keine, wenn ich keine habe.",
                        "$~\\['Apfel' 'Banane' 'Mango'].random()\\"
                    ],
                    "names": "$~zuf√§llig",
                    "inputs": []
                },
                "shuffled": {
                    "doc": [
                        "$~Erstellen Sie eine neue Liste mit den Artikeln in der letzten zuf√§lligen Reihenfolge.",
                        "$~\\['Apfel' 'Banane' 'Mango'].shuffled()\\"
                    ],
                    "names": "$~gemischt",
                    "inputs": []
                },
                "first": {
                    "doc": [
                        "$~Das erste Element in mir oder @None, wenn ich leer bin.",
                        "$~\\['Apfel' 'Banane' 'Mango'].first()\\"
                    ],
                    "names": "$~Erste",
                    "inputs": []
                },
                "last": {
                    "doc": [
                        "$~Das letzte Element in mir oder @None, wenn ich leer bin.",
                        "$~\\['Apfel' 'Banane' 'Mango'].first()\\"
                    ],
                    "names": "$~zuletzt",
                    "inputs": []
                },
                "has": {
                    "doc": [
                        "$~\\‚ä§\\, wenn ich einen Gegenstand in mir habe, der dem angegebenen Gegenstand entspricht.",
                        "$~\\['Apfel' 'Banane' 'Mango'].hat('Banane')\\"
                    ],
                    "names": "$~hat",
                    "inputs": [
                        {
                            "doc": "$~Der zu suchende Wert.",
                            "names": "$~Artikel"
                        }
                    ]
                },
                "join": {
                    "doc": [
                        "$~Ich f√ºge die Elemente meiner Liste zu @Text zusammen, getrennt durch das angegebene Trennzeichen @Text.",
                        "$~\\['Apfel' 'Banane' 'Mango'].join(', ')\\"
                    ],
                    "names": "$~verbinden",
                    "inputs": [
                        {
                            "doc": "$~Der Text, durch den die Elemente getrennt werden sollen, optional leer.",
                            "names": "$~Separator"
                        }
                    ]
                },
                "subsequence": {
                    "doc": [
                        "$~Ich erhalte eine Liste innerhalb dieser Liste, die mit dem von Ihnen angegebenen Index beginnt und mit dem letzten Element oder, falls Sie eines angeben, einem bestimmten Element endet.",
                        "$~\\['Apfel' 'Banane' 'Mango'].subsequence(2)\\",
                        "$~\\['Apfel' 'Banane' 'Mango'].subsequence(1 2)\\",
                        "$~Und siehe da! Wenn du Zahlen in der falschen Reihenfolge angibst, gebe ich dir die umgekehrte",
                        "$~\\['Apfel' 'Banane' 'Mango'].subsequence(3 1)\\",
                        "$~Wenn Sie mir als Index einen Wert kleiner als 1 nennen, gehe ich davon aus, dass Sie 1 meinen.",
                        "$~\\['Apfel' 'Banane' 'Mango'].subsequence(-1003243 2)\\",
                        "$~Und wenn Sie mir etwas geben, das gr√∂√üer ist als der gr√∂√üte Index, gehe ich davon aus, dass Sie das Ende meinen.",
                        "$~\\['Apfel' 'Banane' 'Mango'].subsequence(3 2304032432)\\"
                    ],
                    "names": "$~Folge",
                    "inputs": [
                        {
                            "doc": "$~Der Index des ersten Elements der gew√ºnschten Teilsequenz.",
                            "names": "$~Start"
                        },
                        {
                            "doc": "$~Der optionale Index des letzten Elements der gew√ºnschten Teilsequenz. Wenn Sie keinen angeben, endet Ihre Liste mit dem letzten Element in der Liste.",
                            "names": "$~Ende"
                        }
                    ]
                },
                "sansFirst": {
                    "doc": [
                        "$~Ich erstelle eine Liste ohne mein erstes Element.",
                        "$~\\['Apfel' 'Banane' 'Mango'].sansFirst()\\"
                    ],
                    "names": ["$~ohneVor", "$~sansFirst"],
                    "inputs": []
                },
                "sansLast": {
                    "doc": [
                        "$~Ich erstelle eine Liste ohne mein letztes Element.",
                        "$~\\['Apfel' 'Banane' 'Mango'].sansLast()\\"
                    ],
                    "names": ["$~ohneLetzte", "$~sansLast"],
                    "inputs": []
                },
                "sans": {
                    "doc": [
                        "$~Ich, aber ohne die ersten Vorkommen des angegebenen Wertes.",
                        "$~\\['Apfel' 'Banane' 'Mango' 'Apfel'].sans('Apfel')\\"
                    ],
                    "names": ["$~ohne", "$~ohne"],
                    "inputs": [
                        {
                            "doc": "$~Der Wert, dessen erstes Vorkommen entfernt werden soll.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "sansAll": {
                    "doc": [
                        "$~Ich, aber ohne alle Vorkommen des angegebenen Wertes.",
                        "$~\\['Apfel' 'Banane' 'Mango' 'Apfel'].sans('Apfel')\\"
                    ],
                    "names": ["$~ohneAlle", "$~sansAlle"],
                    "inputs": [
                        {
                            "doc": "$~Der Wert, dessen Vorkommen vollst√§ndig aus der Liste entfernt werden sollen.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "reverse": {
                    "doc": [
                        "$~Ich, aber umgekehrt!",
                        "$~\\['Apfel' 'Banane' 'Mango'].reverse()\\"
                    ],
                    "names": ["$~umgedreht", "$~umkehren"],
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "$~\\‚ä§\\, wenn meine Artikel und meine Bestellung genau mit der angegebenen @Liste √ºbereinstimmen.",
                        "$~\\['Apfel' 'Banane' 'Mango'] = ['Apfel' 'Mango' 'Banane']\\"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "$~Die @Liste, mit der ich mich vergleichen kann.",
                            "names": "$~Liste"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "$~\\‚ä§\\ wenn meine Artikel und meine Reihenfolge /nicht/ genau mit der angegebenen @Liste √ºbereinstimmen.",
                        "$~\\['Apfel' 'Banane' 'Mango'] ‚â† ['Apfel' 'Mango' 'Banane']\\"
                    ],
                    "names": ["$~‚â†", "$~nichtgleich"],
                    "inputs": [
                        {
                            "doc": "$~Die @Liste, mit der ich mich vergleichen kann.",
                            "names": "$~Liste"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "$~Geben Sie mir eine @FunctionDefinition, die einen Wert und einen optionalen Index als Eingabe verwendet und einen Wert erzeugt. Ich werde ihn dann f√ºr jedes meiner Elemente auswerten und meine Werte in neue Werte umwandeln.",
                        "$~Stellen Sie sich beispielsweise vor, ich w√§re eine Liste mit @Nummern und Sie wollten alle verdoppeln:",
                        "$~\\[2 4 6 8].translate(∆í(Zahl‚Ä¢#) Zahl ¬∑ 2)\\"
                    ],
                    "names": "$~√ºbersetzen",
                    "inputs": [
                        {
                            "doc": "$~Die @FunctionDefinition, die jedes Element √ºbersetzt.",
                            "names": "$~√úbersetzer"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "$~Das Element, das √ºbersetzt wird.",
                            "names": "$~Artikel"
                        },
                        {
                            "doc": "$~Der Index des zu √ºbersetzenden Elements.",
                            "names": "$~Index"
                        },
                        {
                            "doc": "$~Die Liste wird √ºbersetzt.",
                            "names": "$~Liste"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "$~Geben Sie mir eine @FunctionDefinition, die einen Wert und einen optionalen Index als Eingabe verwendet und einen @Boolean erzeugt, und ich erstelle eine neue Liste, die nur die Elemente enth√§lt, die sich als \\‚ä§\\ ergeben.",
                        "$~Stellen Sie sich zum Beispiel vor, ich w√§re eine Liste mit @Zahlen und Sie wollten nur die positiven:",
                        "$~\\[2 -4 8 -16].filter(∆í(Anzahl‚Ä¢#) Zahl ‚â• 0)\\"
                    ],
                    "names": "$~Filter",
                    "inputs": [
                        {
                            "doc": "$~Eine @FunctionDefinition, die jedes Element pr√ºft und \\‚ä§\\ ausgibt, wenn es beibehalten werden soll.",
                            "names": "$~Pr√ºfer"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~Der Artikel wird gepr√ºft.",
                            "names": "$~Artikel"
                        },
                        {
                            "doc": "$~Der Index des zu pr√ºfenden Elements.",
                            "names": "$~Index"
                        },
                        {
                            "doc": "$~Die Liste wird gefiltert.",
                            "names": "$~Liste"
                        }
                    ]
                },
                "all": {
                    "doc": [
                        "$~Geben Sie mir eine @FunctionDefinition, die einen Wert als Eingabe verwendet und einen @Boolean erzeugt, wenn er eine bestimmte Bedingung erf√ºllt. Ich erstelle \\‚ä§\\, wenn alle Elemente die Bedingung erf√ºllen.",
                        "$~Stellen Sie sich beispielsweise vor, ich w√§re eine Liste mit @Nummern und Sie wollten wissen, ob alles positiv ist:",
                        "$~\\[2 -4 8 -16].alle(∆í(Anzahl‚Ä¢#) Zahl ‚â• 0)\\"
                    ],
                    "names": "$~alle",
                    "inputs": [
                        {
                            "doc": "$~Die @FunctionDefinition, die \\‚ä§\\ erzeugt, wenn ein Element Ihre Bedingung erf√ºllt.",
                            "names": "$~Pr√ºfer"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~Der Artikel wird gepr√ºft.",
                            "names": "$~Artikel"
                        },
                        {
                            "doc": "$~Der Index des zu pr√ºfenden Elements.",
                            "names": "$~Index"
                        },
                        {
                            "doc": "$~Die Liste wird gepr√ºft.",
                            "names": "$~Liste"
                        }
                    ]
                },
                "until": {
                    "doc": [
                        "$~Geben Sie mir eine @FunctionDefinition, die einen Wert als Eingabe verwendet und einen @Boolean erzeugt, wenn er eine bestimmte Bedingung erf√ºllt. Ich erstelle eine neue @List, die alle Elemente enth√§lt, bis die Bedingung nicht mehr erf√ºllt ist.",
                        "$~Stellen Sie sich beispielsweise vor, ich w√§re eine Liste von @Text-Tieren und Sie wollten alles bis zum Eintrag \\'Ratte'\\:",
                        "$~\\['Katze' 'Hund' 'Ratte' 'Maus' 'Pony'].until(∆í(Tier‚Ä¢'') Tier = 'Ratte')\\"
                    ],
                    "names": "$~bis",
                    "inputs": [
                        {
                            "doc": "$~Die @FunctionDefinition, die \\‚ä§\\ erzeugt, wenn ich die Einbeziehung von Elementen beenden soll.",
                            "names": "$~Pr√ºfer"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~Der Artikel wird gepr√ºft.",
                            "names": "$~Artikel"
                        },
                        {
                            "doc": "$~Der Index des zu pr√ºfenden Elements.",
                            "names": "$~Index"
                        },
                        {
                            "doc": "$~Die Liste wird weiter sequenziert.",
                            "names": "$~Liste"
                        }
                    ]
                },
                "find": {
                    "doc": [
                        "$~Geben Sie mir eine @FunctionDefinition, die einen Wert als Eingabe verwendet und einen @Boolean erzeugt, wenn dieser bestimmten Kriterien entspricht. Ich werde dann das passende Element auswerten.",
                        "$~Stellen Sie sich beispielsweise vor, Sie m√∂chten das erste Tier finden, das den Vokal \\'e\\ hat:",
                        "$~\\['Katze' 'Hund' 'Ratte' 'Maus' 'Pony'].find(∆í(Tier‚Ä¢'') Tier.hat('e'))\\"
                    ],
                    "names": "$~finden",
                    "inputs": [
                        {
                            "doc": "$~Die @FunctionDefinition, die \\‚ä§\\ erzeugt, wenn sie Ihren Suchkriterien entspricht.",
                            "names": "$~Pr√ºfer"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~Der Artikel wird gepr√ºft.",
                            "names": "$~Artikel"
                        },
                        {
                            "doc": "$~Der Index des zu pr√ºfenden Elements.",
                            "names": "$~Index"
                        },
                        {
                            "doc": "$~Die Liste, die durchsucht wird.",
                            "names": "$~Liste"
                        }
                    ]
                },
                "combine": {
                    "doc": [
                        "$~Geben Sie mir eine @FunctionDefinition, die die letzte Kombination und einen n√§chsten Wert verwendet und eine n√§chste Kombination erstellt. Ich bewege mich dann vom ersten bis zum letzten meiner Elemente, erstelle aufeinanderfolgende Kombinationen und werte die Ergebnisse bis zur endg√ºltigen Kombination aus, die Ihre @FunctionDefinition ergibt.",
                        "$~Dies ist sehr hilfreich, um alle Elemente in mir zu einem einzigen Wert zu kombinieren. Stellen Sie sich beispielsweise vor, Sie m√∂chten eine Liste von Zahlen hinzuf√ºgen:",
                        "$~\\[3 9 2 8 1 4].kombiniere(0 ∆í(Summe‚Ä¢# Zahl‚Ä¢#) Summe + Zahl)\\"
                    ],
                    "names": "$~kombinieren",
                    "inputs": [
                        {
                            "doc": "$~Die Startkombination.",
                            "names": "$~anf√§nglich"
                        },
                        {
                            "doc": "$~Die @FunctionDefinition, die die letzte Kombination und den n√§chsten Wert nimmt und die n√§chste Kombination erzeugt.",
                            "names": "$~Kombinierer"
                        }
                    ],
                    "combiner": [
                        {
                            "doc": "$~Die aktuelle Kombination",
                            "names": "$~Kombination"
                        },
                        {
                            "doc": "$~Das n√§chste zu kombinierende Element.",
                            "names": "$~n√§chste"
                        },
                        {
                            "doc": "$~Der Index des n√§chsten Elements",
                            "names": "$~Index"
                        },
                        {
                            "doc": "$~Die Liste wird kombiniert.",
                            "names": "$~Liste"
                        }
                    ]
                },
                "sorted": {
                    "doc": [
                        "$~Ich kann eine Liste nehmen und eine neue Liste mit sortierten Werten erstellen. So:",
                        "$~\\[1 5 8 0 2].sortiert()\\",
                        "$~Ich kann es auch f√ºr @Text-Werte tun",
                        "$~\\['Orange' 'Kiwi' 'Banane' 'Apfel'].sortiert()\\",
                        "$~Und wenn Sie eine Liste mit Werten haben, die weder @Number noch @Text sind, k√∂nnen Sie mir eine @FunctionDefinition geben, die jedes Element in eine @Number umwandelt, damit ich es sortieren kann. Hier haben wir beispielsweise eine Liste mit Listen unterschiedlicher L√§nge. Wenn Sie mir eine Funktion geben, die jede Liste in ihre L√§nge umwandelt, kann ich nach ihrer L√§nge sortieren.",
                        "$~\\[[1] [2 3] [4 8 12] [8]].sortiert(∆í(Liste) Liste.L√§nge())\\"
                    ],
                    "names": "$~sortiert",
                    "inputs": [
                        {
                            "doc": "$",
                            "names": "$~Sequenzer"
                        }
                    ],
                    "sequencer": [
                        {
                            "doc": "$~Der Wert, der in eine @Nummer umgewandelt werden soll.",
                            "names": "$~Wert"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Zu einer @Text-Darstellung der Liste.",
                "set": "$~Zu einem @Set, hilfreich zum Entfernen von Duplikaten."
            }
        },
        "Set": {
            "doc": [
                "$~Ich bin eine Menge von Werten! Das hei√üt, ich kann eine beliebige Anzahl von Werten enthalten, auch keine Werte. Sie k√∂nnen mich folgenderma√üen gestalten:",
                "$~\\{1 2 3}\\",
                "$~Ich bin wirklich gut, wenn Sie eine Sammlung von Dingen ohne Duplikate aufbewahren m√∂chten.",
                "$~Das hei√üt, wenn Sie mir Werte geben, die ich bereits habe, ignoriere ich die Extras.",
                "$~Dieses Set enth√§lt beispielsweise viele Duplikate:",
                "$~\\{1 1 2 2 3 3}\\",
                "$~Ich bewerte es einfach als \\{1 2 3}\\.",
                "$~Wenn Sie sehen m√∂chten, ob ein Wert in mir steckt, kann @SetOrMapAccess helfen:",
                "$~\\{'Glas' 'Flasche' 'Glas'}{'Tasse'}\\",
                "$~Wenn Sie mir eine Reihe von Werten eines gemeinsamen Typs geben, gehe ich normalerweise davon aus, dass es sich um eine Liste dieses Typs handelt. Beispielsweise ist dieser Satz \\{''}\\, weil er komplett aus @Text besteht.",
                "$~\\{'hey' 'hi' 'hallo'}\\",
                "$~Sie m√∂chten aber vielleicht angeben, dass ich /nur/ diese Werte habe, damit ich Ihnen sagen kann, wenn Sie versuchen, einen nicht zul√§ssigen Wert zu verwenden. F√ºgen Sie in diesem Fall einfach ein ! am Ende von ‚Äûme‚Äú hinzu.",
                "$~\\{'hey' 'hi' 'hallo'}!{'yo'}\\",
                "$~Gibt es noch etwas, das du mit mir machen m√∂chtest? Sieh dir all die tollen @FunctionDefinition an, die ich habe!"
            ],
            "name": ["$~{}", "$~Satz"],
            "kind": "$~Art",
            "out": "$~Ergebnis",
            "function": {
                "size": {
                    "doc": "$~Ich sage Ihnen, wie viele Werte in mir stecken.",
                    "names": "$~Gr√∂√üe",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "$~Ich bin \\‚ä§\\, wenn das gegebene @Set und ich genau die gleichen Werte haben:",
                        "$~\\{1 2 3} = {2 3 4}\\"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "$~Das zu vergleichende @Set.",
                            "names": "$~Satz"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "$~Ich bin \\‚ä§\\, wenn das gegebene @Set und ich nicht die exakt gleichen Werte haben:",
                        "$~\\{1 2 3} ‚â† {2 3 4}\\"
                    ],
                    "names": ["$~‚â†", "$~nichtgleich"],
                    "inputs": [
                        {
                            "doc": "$~Das zu vergleichende @Set.",
                            "names": "$~Satz"
                        }
                    ]
                },
                "add": {
                    "doc": [
                        "$~Geben Sie mir einen Artikel zum Hinzuf√ºgen und ich erstelle ein neues @Set mit meinen Artikeln und dem angegebenen Artikel.",
                        "$~\\{1 2 3} + 4\\"
                    ],
                    "names": ["add", "+"],
                    "inputs": [
                        {
                            "doc": "$~Das hinzuzuf√ºgende Element",
                            "names": "$~Artikel"
                        }
                    ]
                },
                "remove": {
                    "doc": [
                        "$~Geben Sie mir ein Element zum Entfernen und ich erstelle ein neues @Set ohne das Element.",
                        "$~\\{1 2 3} - 2\\",
                        "$~Wenn ich den Artikel nicht habe, bewerte ich ihn einfach selbst."
                    ],
                    "names": ["remove", "-"],
                    "inputs": [
                        {
                            "doc": "$~Das zu entfernende Element.",
                            "names": "$~Artikel"
                        }
                    ]
                },
                "union": {
                    "doc": [
                        "$~Geben Sie mir @Set und ich erstelle ein neues @Set, das meine Elemente und die Elemente des Sets enth√§lt.",
                        "$~\\{1 2 3} ‚à™ {3 4 5}\\"
                    ],
                    "names": ["union", "‚à™"],
                    "inputs": [
                        {
                            "doc": "$~Das @Set zum Kombinieren mit mir.",
                            "names": "$~Satz"
                        }
                    ]
                },
                "intersection": {
                    "doc": [
                        "$~Geben Sie mir @Set und ich erstelle ein neues @Set, das nur die Elemente enth√§lt, die wir gemeinsam haben.",
                        "$~\\{1 2 3} ‚à© {3 4 5}\\"
                    ],
                    "names": ["intersection", "‚à©"],
                    "inputs": [
                        {
                            "doc": "$~Das Set zum Vergleichen mit mir.",
                            "names": "$~Satz"
                        }
                    ]
                },
                "difference": {
                    "doc": [
                        "$~Geben Sie mir @Set und ich erstelle ein neues @Set, das nur die Elemente enth√§lt, die wir gemeinsam haben.",
                        "$~\\{1 2 3}.Differenz({3 4 5})\\"
                    ],
                    "names": "$~Unterschied",
                    "inputs": [
                        {
                            "doc": "$~Das Set, dessen Elemente von mir entfernt werden sollen.",
                            "names": "$~Satz"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "$~Geben Sie mir eine @FunctionDefinition, die ein Element annimmt und \\‚ä§\\ erzeugt, wenn es behalten werden soll, und ich erstelle ein @Set, das nur die Elemente enth√§lt, die Ihren Kriterien entsprechen.",
                        "$~Lassen Sie uns zum Beispiel die ungeraden Zahlen in mir finden:",
                        "$~\\{1 2 3 4 5 6 7 8 9}.filter(∆í(Anzahl‚Ä¢#) (Anzahl % 2) = 1)\\"
                    ],
                    "names": "filter",
                    "inputs": [
                        {
                            "doc": "$~Die @FunctionDefinition, die ein Element √ºberpr√ºft, um festzustellen, ob es behalten werden soll.",
                            "names": "$~Pr√ºfer"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~Der Artikel wird gepr√ºft.",
                            "names": "$~Wert"
                        },
                        {
                            "doc": "$~Der zu filternde Satz",
                            "names": "$~Satz"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "$~Geben Sie mir eine @FunctionDefinition, die ein Element nimmt und darauf basierend ein neues Element erstellt. Anschlie√üend √ºbersetze ich alle Elemente in mir in ein neues @Set (und entferne dabei alle Duplikate).",
                        "$~Lassen Sie uns beispielsweise alle meine @Zahlen in @Text umwandeln:",
                        "$~\\{1 2 3 4 5 6 7 8 9}.translate(∆í(Zahl‚Ä¢#) Zahl‚Üí'')\\"
                    ],
                    "names": "translate",
                    "inputs": [
                        {
                            "doc": "$~Die @FunctionDefinition, die eines meiner Elemente in das gew√ºnschte neue Element √ºbersetzt.",
                            "names": "$~Satz"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "$~Das Element, das √ºbersetzt wird.",
                            "names": "$~Wert"
                        },
                        {
                            "doc": "$~Der zu √ºbersetzende Satz",
                            "names": "$~Satz"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Eine @Text-Darstellung eines @Set",
                "list": "$~Eine @List-Darstellung der Elemente im Set."
            }
        },
        "Map": {
            "doc": [
                "$~Ich bringe Werte zusammen, indem ich *Schl√ºssel* auf *Werte* abbilde. Zum Beispiel:",
                "$~\\{'amy': 6 Punkte 'tony': 3 Punkte 'shiela': 8 Punkte}\\",
                "$~Meine Schl√ºssel k√∂nnen beliebige Werte haben und meine Werte k√∂nnen beliebige Werte haben.",
                "$~Manche Leute stellen mich gerne als eine Art Index oder W√∂rterbuch vor: Sie geben mir etwas und ich gebe Ihnen die Zuordnung.",
                "$~Wenn Sie √ºberpr√ºfen m√∂chten, worauf etwas abgebildet ist, k√∂nnen Sie @SetOrMapAccess einen Schl√ºssel geben und Sie erhalten den Wert:",
                "$~\\{'amy': 6 Punkte 'tony': 3 Punkte 'shiela': 8 Punkte}{'amy'}\\",
                "$~Wenn es keinen passenden Schl√ºssel gibt, gebe ich Ihnen @None.",
                "$~\\{'amy': 6 Punkte 'tony': 3 Punkte 'shiela': 8 Punkte}{'jen'}\\",
                "$~Sie k√∂nnen auch eine leere Karte wie folgt erstellen:",
                "$~\\{:}\\",
                "$~Normalerweise sehe ich mir die Schl√ºssel und Werte an, die Sie mir geben, und denke mir einen Typ aus, der sie alle repr√§sentiert. So sieht eine Zuordnung von Zahlen zu Zahlen aus:",
                "$~\\{1:1 2:2 3:3}\\",
                "$~Angenommen, Sie m√∂chten sicherstellen, dass es sich ausschlie√ülich um diese Werte handelt, f√ºgen Sie am Ende von ‚Äûme‚Äú einfach ein ! hinzu, und ich verallgemeinere nicht. So k√∂nnen Sie erkennen, ob Sie einen Wert abrufen m√∂chten, den Sie nicht beabsichtigt haben.",
                "$~\\{1:1 2:2 3:3}!{4}\\",
                "$~Ich kann mit meinen Paarungen viele wunderbare Dinge erreichen."
            ],
            "name": ["$~{:}", "$~Karte"],
            "key": "$~Schl√ºssel",
            "value": "$~Wert",
            "result": "$~Ergebnis",
            "function": {
                "size": {
                    "doc": "$~Ich sage Ihnen, wie viele Werte in mir stecken.",
                    "names": "$~Gr√∂√üe",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "$~\\{‚ä§}\\, wenn meine Paarungen genau dieselben sind wie die angegebenen @Maps.",
                        "$~\\{1:1 2:2} = {1:1 2:3}\\"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "$~Die @Map zum Vergleichen.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "$~\\{‚ä§}\\ wenn meine Paarungen /nicht/ genau dieselben sind wie die der angegebenen @Maps.",
                        "$~\\{1:1 2:2} ‚â† {1:1 2:3}\\"
                    ],
                    "names": ["$~‚â†", "$~nichtgleich"],
                    "inputs": [
                        {
                            "doc": "$~Die @Map zum Vergleichen.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "set": {
                    "doc": [
                        "$~Ich erstelle eine neue @Map mit denselben Paarungen, aber mit der neuen Paarung, die Sie mir geben. Wenn ich den Schl√ºssel bereits habe, kopple ich ihn mit dem neuen Wert.",
                        "$~\\{'amy': 6 Punkte 'tony':3 Punkte}.pair('jen' 0 Punkte)\\"
                    ],
                    "names": "$~Paar",
                    "inputs": [
                        {
                            "doc": "$~Schl√ºssel zum Koppeln mit einem Wert.",
                            "names": "$~Schl√ºssel"
                        },
                        {
                            "doc": "$~Der mit dem Schl√ºssel zu koppelnde Wert",
                            "names": "$~Wert"
                        }
                    ]
                },
                "unset": {
                    "doc": [
                        "$~Ich erstelle eine neue @Map ohne den Schl√ºssel, den Sie mir geben, und entferne die Kopplung.",
                        "$~\\{'amy': 6 Punkte 'tony':3 Punkte}.unpair('amy')\\"
                    ],
                    "names": "$~Paarungaufheben",
                    "inputs": [
                        {
                            "doc": "$~Der Schl√ºssel zum Vergessen.",
                            "names": "$~Schl√ºssel"
                        }
                    ]
                },
                "remove": {
                    "doc": [
                        "$~Ich erstelle eine neue @Map ohne Schl√ºssel, die den Wert haben.",
                        "$~\\{'amy': 0 Punkte 'jen': 0 Punkte 'tony':3 Punkte}.entfernen(0 Punkte)\\"
                    ],
                    "names": "$~entfernen",
                    "inputs": [
                        {
                            "doc": "$~Der von mir zu entfernende Wert, zusammen mit allen Schl√ºsseln, mit denen er gekoppelt ist.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "$~Geben Sie mir eine @FunctionDefinition, die einen Schl√ºssel und einen Wert annimmt und als \\‚ä§\\ auswertet, wenn eine Paarung beibehalten werden soll. Ich erstelle eine neue @Map, die Ihren Kriterien entspricht.",
                        "$~Hier m√∂chten wir beispielsweise alle Paarungen behalten, die Amy sind oder mehr als null Punkte haben.",
                        "$~\\{'amy': 0 Punkte 'jen': 0 Punkte 'tony':3 Punkte}.filter(∆í(Schl√ºssel‚Ä¢'' Wert‚Ä¢#Punkte) (Schl√ºssel = 'amy') | (Wert > 0 Punkte))\\"
                    ],
                    "names": "filter",
                    "inputs": [
                        {
                            "doc": "$~Die @FunctionDefinition, die entscheidet, ob eine Paarung beibehalten wird.",
                            "names": "$~Pr√ºfer"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~Der Schl√ºssel wird √ºberpr√ºft.",
                            "names": "$~Schl√ºssel"
                        },
                        {
                            "doc": "$~Der Wert, der √ºberpr√ºft wird.",
                            "names": "$~Wert"
                        },
                        {
                            "doc": "$~Die Karte wird gefiltert.",
                            "names": "$~Karte"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "$~Geben Sie mir eine @FunctionDefinition, die einen Schl√ºssel und einen Wert annimmt und den Wert in einen neuen Wert umwandelt. Ich erstelle eine neue @Map mit denselben Schl√ºsseln, aber aktualisierten Werten.",
                        "$~Geben wir beispielsweise jedem einen Punkt, weil er so nett war.",
                        "$~\\{'amy': 5 Punkte 'jen': 3 Punkte 'tony': 0 Punkte}.translate(∆í(Schl√ºssel‚Ä¢'' Wert‚Ä¢#Punkte) Wert + 1 Punkt)\\"
                    ],
                    "names": "translate",
                    "inputs": [
                        {
                            "doc": "$~Die @FunctionDefinition, die jeden Wert √ºbersetzt.",
                            "names": "$~√úbersetzer"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "$~Der Schl√ºssel des zu √ºbersetzenden Werts.",
                            "names": "$~Schl√ºssel"
                        },
                        {
                            "doc": "$~Der zu √ºbersetzende Wert.",
                            "names": "$~Wert"
                        },
                        {
                            "doc": "$~Die Karte wird √ºbersetzt.",
                            "names": "$~Karte"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Eine @Text-Darstellung der Zuordnung.",
                "set": "$~Die Schl√ºssel der @Map",
                "list": "$~Eine Liste der Werte in der @Map"
            }
        },
        "Table": {
            "doc": [
                "$~Ich bin eine Reihe von Tabellenzeilen! Ich kann Ihnen dabei helfen, gro√üe Wertesammlungen mit derselben Struktur zu verfolgen.",
                "$~Stellen Sie sich beispielsweise vor, Sie m√∂chten den √úberblick √ºber eine Reihe von Steinen behalten:",
                "$~\\‚é°Name‚Ä¢'' Farbe‚Ä¢''‚é¶\n‚é°'Obsidian' 'schwarz'‚é¶\n‚é°'Bimsstein' 'grau'‚é¶\n‚é°'Citrin' 'gelb'‚é¶\\",
                "$~@Bind kann Ihnen beim Benennen helfen! Und dann k√∂nnen Sie beispielsweise eine √ºberarbeitete Tabelle mit einer neuen Zeile erstellen @Insert:",
                "$~\\Gesteine: ‚é°Name‚Ä¢'' Farbe‚Ä¢''‚é¶\n‚é°'Obsidian' 'schwarz'‚é¶\n‚é°'Bimsstein' 'grau'‚é¶\n‚é°'Citrin' 'gelb'‚é¶\nGesteine ‚é°+ 'Quarz' 'wei√ü'‚é¶\\",
                "$~Wenn Sie √ºbereinstimmende Zeilen suchen, k√∂nnen Sie mit @Select Zeilen ausw√§hlen, die einer Bedingung entsprechen:",
                "$~\\Steine: ‚é°Name‚Ä¢'' Farbe‚Ä¢''‚é¶\n‚é°'Obsidian' 'schwarz'‚é¶\n‚é°'Bimsstein' 'grau'‚é¶\n‚é°'Citrin' 'gelb'‚é¶\nSteine ‚é°?‚é¶ Farbe = 'grau'\\",
                "$~Oder Sie m√∂chten m√∂glicherweise eine √ºberarbeitete Tabelle erstellen, die f√ºr Zeilen, die eine Bedingung erf√ºllen, andere Werte enth√§lt:",
                "$~\\Steine: ‚é°Name‚Ä¢'' Farbe‚Ä¢''‚é¶\n‚é°'Obsidian' 'schwarz'‚é¶\n‚é°'Bimsstein' 'grau'‚é¶\n‚é°'Citrin' 'gelb'‚é¶\nSteine ‚é°: Farbe: 'schwarz' ‚é¶ Name = 'Bimsstein'\\",
                "$~Oder Sie m√∂chten m√∂glicherweise Zeilen l√∂schen, die einer Bedingung entsprechen:",
                "$~\\rocks: ‚é°name‚Ä¢'' farbe‚Ä¢''‚é¶\n‚é°'Obsidian' 'schwarz'‚é¶\n‚é°'Bimsstein' 'grau'‚é¶\n‚é°'Citrin' 'gelb'‚é¶\nrocks ‚é°- name.has('i')\\",
                "$~Und wenn Sie jemals bestimmte Werte von mir erhalten m√∂chten, k√∂nnen Sie jede Tabelle in eine Liste umwandeln und mit @PropertyReference auf einzelne Zeilen zugreifen",
                "$~\\rocks: ‚é°Name‚Ä¢'' Farbe‚Ä¢''‚é¶\n‚é°'Obsidian' 'schwarz'‚é¶\n‚é°'Bimsstein' 'grau'‚é¶\n‚é°'Citrin' 'gelb'‚é¶\n(rocks ‚Üí [])[1].name\\"
            ],
            "name": ["$~‚é°‚é¶", "$~Tisch"],
            "row": "$~Reihe",
            "function": {
                "equals": {
                    "doc": "$~Ich √ºberpr√ºfe, ob ich genau dieselben Zellen in genau derselben Reihenfolge wie eine andere @Tabelle habe.",
                    "names": ["$~=", "$~istgleich"],
                    "inputs": [
                        {
                            "doc": "$~Die andere zu pr√ºfende Tabelle.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "notequal": {
                    "doc": "$~Ich √ºberpr√ºfe, ob meine Zellen anders sind oder eine andere Reihenfolge als eine andere @Tabelle aufweisen.",
                    "names": ["$~‚â†", "$~nichtgleich"],
                    "inputs": [
                        {
                            "doc": "$~Die andere zu pr√ºfende Tabelle.",
                            "names": "$~Wert"
                        }
                    ]
                }
            },
            "conversion": {
                "list": "$~Ich konvertiere eine @Table in eine Liste von Zeilen, wobei jede Zeile eine @Structure mit ihren Spaltennamen als Eigenschaften ist.",
                "text": "$~Ich konvertiere einfach eine @Tabelle in Text."
            }
        },
        "Structure": {
            "doc": "$~Siehe @StructureDefinition.",
            "name": ["$~Struktur"],
            "function": {
                "equals": {
                    "doc": "$~Ich √ºberpr√ºfe, ob meine Eigenschaften dieselben Namen und Werte haben wie die Eigenschaften einer anderen Struktur.",
                    "names": ["$~=", "$~istgleich"],
                    "inputs": [
                        {
                            "doc": "$~Die andere zu pr√ºfende Struktur.",
                            "names": "$~Wert"
                        }
                    ]
                },
                "notequal": {
                    "doc": "$~Ich √ºberpr√ºfe, ob sich meine Eigenschaften hinsichtlich Name und Werten in irgendeiner Weise von denen einer anderen Struktur unterscheiden.",
                    "names": ["$~‚â†", "$~nichtgleich"],
                    "inputs": [
                        {
                            "doc": "$~Die andere zu pr√ºfende Struktur.",
                            "names": "$~Wert"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Ich konvertiere zu @Text."
            }
        }
    },
    "input": {
        "Random": {
            "doc": [
                "$~17!",
                "$~/@FunctionDefinition hier, ich werde das erkl√§ren./",
                "$~@Random ist also eine interessante Funktion, die Zufallszahlen erzeugt. Das ist deshalb so interessant, weil bei jeder Auswertung etwas anderes entsteht.",
                "$~Dadurch entsteht ein wunderbares Chaos, das mit Unvorhersehbarkeit einhergeht.",
                "$~Standardm√§√üig werden @Number-Werte zwischen \\0\\ und \\1\\ ausgegeben:",
                "$~\\Zuf√§llig()\\",
                "$~Sie k√∂nnen ihm jedoch einen Wert zuweisen, und es werden Werte zwischen \\0\\ und dem folgenden Wert generiert:",
                "$~\\Zuf√§llig(10)\\",
                "$~Wenn Sie zwei Werte eingeben, werden Werte zwischen diesen beiden Werten generiert:",
                "$~\\Zufall(-10 10)\\",
                "$~Wenn Ihre Bereiche Einheiten haben, bleiben diese erhalten (und wenn sie nicht √ºbereinstimmen, wird die Einheit des Minimums verwendet):",
                "$~\\Zufall(-10m 10m)\\",
                "$~Und wenn Sie Zahlen mit einer bestimmten Anzahl signifikanter Ziffern nach dem Komma angeben, bleibt diese Genauigkeit erhalten.",
                "$~\\Zuf√§llig(1,00 10,00)\\"
            ],
            "names": ["$~üé≤", "$~Zuf√§llig"],
            "inputs": [
                {
                    "names": "$~Mindest",
                    "doc": "$~Der Mindestwert, der erstellt wird, oder, wenn er gr√∂√üer als 0 ist, der H√∂chstwert. Wenn @None angegeben ist, ist der Mindestwert \\0\\."
                },
                {
                    "names": "$~max",
                    "doc": "$~Der maximale Wert, der erstellt wird, oder, wenn er kleiner als der angegebene Mindestwert ist, der Mindestwert. Wenn @None angegeben ist, ist der H√∂chstwert \\1\\."
                }
            ]
        },
        "Choice": {
            "doc": [
                "$~/Klick, tipp!/",
                "$~/@FunctionDefinition hier, ich werde das erkl√§ren./",
                "$~Stellen Sie sich @Choice wie einen Stream von @Phrase/Namen vor, die von Ihrem Publikum ausgew√§hlt werden. Wenn jemand auf eine @Phrase mit einem Namen klickt, tippt oder sie mit der Tastatur ausw√§hlt, indem er /Enter/ dr√ºckt, hat @Choice einen neuen Wert, der dem Namen entspricht.",
                "$~Die beste M√∂glichkeit, es zu verwenden, besteht darin, eine Performance mit benannten ausw√§hlbaren Phrasen @Phrase zu erstellen und dann mithilfe einer @Reaktion zu entscheiden, was zu tun ist, wenn dieser Name ausgew√§hlt wird.",
                "$~Hier ist das einfachste Beispiel:",
                "$~\\Group(\nStack() \n[\nPhrase('eins' w√§hlbar:‚ä§ Name:'1') \nPhrase('zwei' w√§hlbar:‚ä§ Name:'2') \nPhrase(Choice())\n]\n)\\",
                "$~Kopieren Sie dies in den Editor und w√§hlen Sie dann eine der beiden @Phrase aus. Sie werden sehen, dass die dritte @Phrase den ausgew√§hlten Namen anzeigt."
            ],
            "names": ["$~üîò", "$~Auswahl"]
        },
        "Button": {
            "doc": [
                "$~/klick klick klick/",
                "$~/@FunctionDefinition hier, ich werde das erkl√§ren./",
                "$~@Button ist eine gro√üartige M√∂glichkeit, einer Maus oder einem Trackpad zuzuh√∂ren. Nat√ºrlich sind eine Maus oder ein Trackpad nicht die ideale Wahl, um einem Publikum zuzuh√∂ren, da nicht jeder sie verwenden kann. Die zug√§nglichere Wahl ist @Choice.",
                "$~Wenn Sie aber /wirklich/ auf eine Maustaste achten m√ºssen, ist dies die richtige Vorgehensweise. Es wird ein Stream von @Boolean bereitgestellt, der angibt, ob die prim√§re Taste oben \\‚ä•\\ oder unten \\‚ä§\\ ist.",
                "$~Hier ist ein einfaches Beispiel:",
                "$~\\Phrase(Schaltfl√§che() ‚Üí '')\\",
                "$~Dies erzeugt einfach eine @Phrase, die den Wert des Streams als Text darstellt. Wenn Sie sie in den Editor kopieren und anklicken, sehen Sie, wie sie zwischen \\‚ä•\\ und \\‚ä§\\ hin- und herschaltet."
            ],
            "names": ["$~üñ±Ô∏è", "$~Taste"],
            "down": {
                "names": "$~runter",
                "doc": "$~Wenn @None, liefert der Stream sowohl Up- als auch Down-Werte. Wenn @Boolean, liefert er nur den angegebenen @Boolean-Wert."
            }
        },
        "Pointer": {
            "doc": [
                "$~/whrrrrrr/",
                "$~/@FunctionDefinition hier, ich werde das erkl√§ren./",
                "$~Sie kennen sich mit M√§usen, Trackpads und Touchscreens aus? Manchmal m√∂chten Sie wissen, wohin ein Publikum zeigt. Genau das bietet @Pointer.",
                "$~Nat√ºrlich ist dies keine barrierefreie Option: Nicht jeder kann sehen oder problemlos zeigen. Stellen Sie also wirklich sicher, dass Sie durch die Verwendung dieses Streams niemanden von der Teilnahme ausschlie√üen.",
                "$~Wenn Sie sicher sind, dass niemand ausgeschlossen ist, ist die Verwendung von @Pointer so einfach wie das Erstellen eines Streams:",
                "$~\\Zeiger()\\",
                "$~Der bereitgestellte @Place entspricht der Stelle auf @Stage, auf die der Zeiger zeigt."
            ],
            "names": ["$~üëÜüèª", "$~Zeiger"]
        },
        "Key": {
            "doc": [
                "$~/klick/",
                "$~/@FunctionDefinition hier, ich werde das erkl√§ren./",
                "$~Tastaturen haben viele Tasten, nicht wahr? @Key sagt Ihnen, welche Taste jemand dr√ºckt und losl√§sst.",
                "$~Versuche dies",
                "$~\\Schl√ºssel()\\",
                "$~Sehen Sie, wie eine Taste, die Sie dr√ºcken, auf @Stage angezeigt wird? Bei jedem Tastendruck wird dem Stream ein neuer @Text hinzugef√ºgt, der die gedr√ºckte Taste beschreibt.",
                "$~Bei einem Schl√ºssel, der ein Zeichen darstellt, ist der Wert das Zeichen als @Text.",
                "$~Bei Sondertasten, wie der /Escape/-Taste, wird @Text verwendet, der die Taste unter Verwendung eines <vordefinierten Namens@https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values> beschreibt und leider nur auf Englisch verf√ºgbar ist.",
                "$~Wenn Sie nur Informationen zu einem bestimmten Schl√ºssel w√ºnschen, k√∂nnen Sie diesen angeben:",
                "$~\\Schl√ºssel('a')\\",
                "$~Und wenn Sie nur wissen m√∂chten, wann eine @Taste losgelassen und nicht gedr√ºckt wird, k√∂nnen Sie einen @Boolean angeben:",
                "$~\\Schl√ºssel('a' ‚ä•)\\"
            ],
            "names": ["$~‚å®Ô∏è", "$~Schl√ºssel"],
            "key": {
                "names": "$~Schl√ºssel",
                "doc": "$~Wenn @None, werden alle Schl√ºssel bereitgestellt. Wenn es sich um einen bestimmten @Text handelt, wird nur dieser Schl√ºssel bereitgestellt."
            },
            "down": {
                "names": "$~runter",
                "doc": "$~WENN @None, dann generiert die Taste ‚ÄûTaste gedr√ºckt‚Äú Eingaben. Wenn \\‚ä§\\, dann werden nur ‚ÄûTaste gedr√ºckt‚Äú-Eingaben bereitgestellt, und wenn \\‚ä•\\, dann werden nur ‚ÄûTaste loslassen‚Äú-Eingaben bereitgestellt."
            }
        },
        "Time": {
            "doc": [
                "$~/tick tick tick/",
                "$~@FunctionDefinition hier, ich erkl√§re @Time, da es nicht spricht.",
                "$~Die Zeit ist ein Strom, der mit einer bestimmten Frequenz tickt.",
                "$~Jedes Mal f√ºhrt @Program eine Neuauswertung mit dem neuen Zeitwert durch.",
                "$~Zum Beispiel:",
                "$~\\Zeit()\\",
                "$~Wenn Sie die Zeit als @Time/Frequenz angeben, tickt es mit dieser Rate. Beispiel:",
                "$~\\Zeit(1000ms)\\",
                "$~Es gibt jedoch Grenzen daf√ºr, wie klein es sein kann, da @Program Zeit zur Auswertung braucht, bevor es auf den n√§chsten Tick reagieren kann.",
                "$~Der kleinste Wert liegt wahrscheinlich bei etwa \\20ms\\."
            ],
            "names": ["$~üïï", "$~Zeit"],
            "frequency": {
                "names": ["$~Frequenz"],
                "doc": "$~Dies ist die Frequenz, mit der die Zeit ticken soll. Der Standardwert ist \\33ms\\, was etwa 30 Mal pro Sekunde entspricht."
            },
            "relative": {
                "names": ["$~relativ"],
                "doc": "$~Wenn \\‚ä§\\, beginnt die Zeit bei 0, wenn das Programm zum ersten Mal ausgewertet wird. Andernfalls beginnt sie mit der Anzahl der Millisekunden seit Beginn des heutigen Tages, UTC (Coordinated Universal Time), sodass Sie die Tageszeit im Auge behalten k√∂nnen."
            }
        },
        "Volume": {
            "doc": [
                "$~/bzzzzzzz/",
                "$~@FunctionDefinition hier, ich √ºbernehme das Mikrofon.",
                "$~Dieser Stream ist eine Reihe von Lautst√§rken zwischen 0 und 1, die mit der von Ihnen gew√§hlten Frequenz abgetastet werden. Standardm√§√üig betr√§gt die Frequenz \\30 Hz\\, also 30 Mal pro Sekunde, Sie k√∂nnen sie jedoch auf einen niedrigeren Wert √§ndern.",
                "$~\\Volumen()\\",
                "$~So k√∂nnen Sie hervorragend h√∂ren, wie laut das Publikum ist!"
            ],
            "names": ["$~üé§", "$~Volumen"],
            "frequency": {
                "names": ["$~Frequenz"],
                "doc": "$~Die Zeit zwischen den Probenahmen."
            }
        },
        "Pitch": {
            "doc": [
                "$~/hmmmmm/",
                "$~@FunctionDefinition hier, lass uns √ºber die Tonh√∂he reden!",
                "$~Dieser Stream ist eine Reihe von Frequenzen in Hertz, die die Tonh√∂he angeben und mit der von Ihnen gew√§hlten Frequenz abgetastet werden. Wir haben festgestellt, dass die menschliche Stimme zwischen 20 Hz und 5000 Hz liegt. Planen Sie also mit Zahlen in diesem Bereich.",
                "$~\\Tonh√∂he()\\",
                "$~Dies eignet sich hervorragend, um den Tonfall zu h√∂ren, wenn jemand spricht oder singt."
            ],
            "names": ["$~üéµ", "$~Tonh√∂he"],
            "frequency": {
                "names": ["$~Frequenz"],
                "doc": "$~Die Zeit zwischen den Probenahmen."
            }
        },
        "Camera": {
            "doc": [
                "$~/bzzzzzzz/",
                "$~@FunctionDefinition hier, ich kann @Camera erkl√§ren!",
                "$~@Camera stellt also eine @List von @Color aus Ihrer Welt bereit. Diese Liste stellt im Wesentlichen ein Bild dar, aber Sie entscheiden, was Sie damit machen.",
                "$~Sie k√∂nnten versuchen, das Bild mit einer Reihe von @Phrase darzustellen, das k√∂nnte ziemlich cool aussehen! Versuchen Sie, dies zu kopieren...",
                "$~\\colors: Kamera(32px 24px 33ms)\n\nB√ºhne(\ncolors.combine(\n[] \n∆í(phrases‚Ä¢[Phrase] row‚Ä¢[Color] y‚Ä¢#) \nphrases.append(\nrow.translate(\n∆í(color‚Ä¢Color x‚Ä¢#)\nPhrase('o' place: Place((x - 1) ¬∑ 0.5m y ¬∑ -0.5m) color: color Dauer: 0s\n)\n)\n)\n)\n)\\",
                "$~Sie k√∂nnten die Farben aber auch analysieren, um zu entscheiden, ob ein Licht an oder aus ist oder ob eine bestimmte Farbe h√§ufig vorkommt, sodass das Publikum durch die gezeigten Farben Einfluss auf die Auff√ºhrung nehmen kann."
            ],
            "names": ["C√°mara"],
            "width": {
                "names": ["$~Breite"],
                "doc": "$~Die Anzahl der @Color, die in einer Zeile abgetastet werden soll."
            },
            "height": {
                "names": ["$~H√∂he"],
                "doc": "$~Die Anzahl der @Colors, die in einer Spalte abgetastet werden sollen."
            },
            "frequency": {
                "names": ["$~Frequenz"],
                "doc": "$~Die Zeit zwischen @Color-Samples."
            }
        },
        "Motion": {
            "names": "movimiento",
            "doc": [
                "$~/boing, boing, boing/",
                "$~/Hallo! @FunctionDefinition hier. Wie w√§r‚Äôs, wenn ich @Motion erkl√§re?",
                "$~Im Grunde ist @Motion ein Stream von @Phrase. Sie geben ihm eine Start-@Phrase und dann verfeinert es diese mit einer neuen Position und Rotation basierend auf der Schwerkraft.",
                "$~Damit k√∂nnen Sie ganz einfache Dinge tun, wie zum Beispiel h√ºpfende Emojis erstellen:",
                "$~\\Bewegung(Phrase('o') Startort: Ort(0m 10m))\\",
                "$~Sehen Sie, wie das o h√ºpft? Bei der ersten Auswertung geben wir ihm einen Platz ganz oben auf @Stage, aber danach bekommt es @None, was es @Motion erm√∂glicht, es an die Position zu verschieben, an die es durch die Schwerkraft gesetzt w√ºrde.",
                "$~Schauen Sie sich unten die vielen anderen Konfigurationsm√∂glichkeiten an."
            ],
            "place": {
                "doc": "$~Der Startplatz.",
                "names": "$~Ort"
            },
            "velocity": {
                "doc": "$~Die Startgeschwindigkeit",
                "names": "$~Geschwindigkeit"
            },
            "nextplace": {
                "doc": "$~Der n√§chste Ort, die Au√üerkraftsetzung der Physik.",
                "names": "$~n√§chsterOrt"
            },
            "nextvelocity": {
                "doc": "$~Der n√§chste Ort, √ºbergeordnete Geschwindigkeit.",
                "names": "$~n√§chsteGeschwindigkeit"
            }
        },
        "Scene": {
            "doc": [
                "$~/Buuh, buuh, buuh/",
                "$~/Hallo, hier ist @FunctionDefinition! Ich sehe, Sie haben @Scene gefunden.",
                "$~Ich finde @Scene besonders cool. Die Grundidee ist, dass man ihm eine Liste von @Phrase oder @Group gibt und es diese dann der Reihe nach anzeigt und bei der letzten anh√§lt.",
                "$~Um das Timing zu steuern, k√∂nnen Sie entweder die @Phrase/Dauer f√ºr jeden Ausgang festlegen, und dieser wird so lange angezeigt, bevor zum n√§chsten √ºbergegangen wird, und Sie k√∂nnen die √úberg√§nge @Phrase/entering oder @Phrase/exiting verwenden, die Sie m√∂glicherweise festgelegt haben. Wenn Sie sie auf eine @Sequence festlegen, wird deren Dauer verwendet.",
                "$~Damit k√∂nnen Sie beispielsweise diese kleine @Scene ausf√ºhren, die die folgenden drei S√§tze nacheinander anzeigt:",
                "$~\\Szene([\nPhrase('Hallo' Dauer: 1s)\nPhrase('Wie geht es dir?' Dauer: 2s Drehung: 5¬∞ Eintritt: Pose(Drehung: 0¬∞))\nPhrase('Mir geht es gut')\n])\\",
                "$~Sehen Sie, wie die erste Ausgabe eine Sekunde lang angezeigt wird, dann die n√§chste zwei Sekunden lang, jedoch mit einer Animation in einer Drehung um f√ºnf Grad, und dann die letzte angezeigt wird?",
                "$~Sie k√∂nnen mit @Scene sehr aufwendige Ausgabe- und Animationssequenzen erstellen und Teile davon sogar dynamisch oder interaktiv gestalten, wie mit jeder anderen @Phrase oder @Group.",
                "$~Wenn Sie eine verschachtelte animierte Ausgabe haben (eine @Group mit einer darin enthaltenen animierten @Phrase), wartet @Scene, bis der gesamte animierte Inhalt in der @Group fertig ist.",
                "$~Oh, und noch ein letztes kleines Geheimnis! Sie k√∂nnen sogar @Boolean in die Liste einf√ºgen, und wenn sie \\‚ä•\\ sind, pausiert @Scene und wartet, bis es wahr wird.",
                "$~Wenn Sie beispielsweise eine Sequenz von @Phrase erstellen und nur fortfahren m√∂chten, wenn sich @Button √§ndert, k√∂nnten Sie Folgendes tun:",
                "$~\\click: ‚àÜ Button()\nScene([\nPhrase('Hallo')\nclick\nPhrase('Wie geht es dir?' Dauer: 0,25 s Rotation: 5¬∞ Eintritt: Pose(Rotation: 0¬∞))\nclick\nPhrase('Mir geht es gut')\n])\\",
                "$~Sehen Sie, wie es nach jeder @Phrase pausiert und wartet, bis sich @Button √§ndert, bevor es fortf√§hrt?"
            ],
            "names": ["$~üé¨", "$~Szene"],
            "outputs": {
                "names": "$~Ausg√§nge",
                "doc": "$~Die Liste der nacheinander anzuzeigenden Ausgaben."
            }
        },
        "Chat": {
            "doc": [
                "$~/Hallo! @FunctionDefinition hier. Du willst also chatten?",
                "$~Die Grundidee eines Chat-Streams besteht darin, dass das Publikum eine Nachricht eingibt und das Programm dann darauf antwortet.",
                "$~Dieses einfache Programm pr√ºft beispielsweise, ob die Nachricht ‚ÄûHallo‚Äú lautet. Wenn dies der Fall ist, wird das Programm als ‚Äûhi‚Äú ausgewertet. Andernfalls wird es als ‚Äûh√§?‚Äú ausgewertet.",
                "$~\\Chat().has('hallo') ? 'hi!' 'h√§?'\\",
                "$~Das ist es! Sie k√∂nnen damit alle m√∂glichen Darbietungen erstellen, wie Chatbots, Textabenteuer oder textbasierte Steuerungsschemata f√ºr andere Arten von Darbietungen."
            ],
            "names": ["$~üó£Ô∏è", "$~Plaudern"]
        },
        "Placement": {
            "doc": [
                "$~/Hey, hier ist @FunctionDefinition. Lass uns dar√ºber reden, wie wir weiterkommen!/",
                "$~Es gibt also viele M√∂glichkeiten, uns auf der @Stage zu platzieren. Sie k√∂nnen uns einen expliziten @Place zuweisen. Sie k√∂nnen @Motion verwenden und die Schwerkraft ihre Arbeit machen lassen. Sie k√∂nnen uns auch in eine @Group setzen und uns dort auf eine bestimmte Weise anordnen lassen.",
                "$~Aber manchmal m√∂chten Sie dem /Publikum/ die Kontrolle dar√ºber geben, wo wir uns auf der @B√ºhne befinden. Daf√ºr gibt es @Placement.",
                "$~Und so funktioniert es: Du erstellst einfach ein @Placement und gibst es an unseren @Place weiter:",
                "$~\\Phrase('hi' Ort: Platzierung())\\",
                "$~Jedes Mal, wenn das Publikum eine Pfeiltaste dr√ºckt oder auf die B√ºhne klickt oder tippt, erstellt das @Placement einen neuen @Place, der sich in die gew√ºnschte Richtung bewegt.",
                "$~Versuchen Sie, dies in Ihr Programm zu kopieren und es mit dem Zeiger oder der Tastatur in Pfeilrichtung zu verschieben.",
                "$~Sie k√∂nnen die @Placement anpassen, indem Sie die Bewegung in bestimmten Dimensionen aktivieren und deaktivieren, die Bewegungsweite eines @Place √§ndern und den anf√§nglichen @Place √§ndern, mit dem der Stream beginnt."
            ],
            "names": ["$~‚ú•", "$~Platzierung"],
            "inputs": [
                {
                    "doc": "$~Der erste Ort, an dem man beginnen kann.",
                    "names": "$~Start"
                },
                {
                    "doc": "$~Um wie viele Meter sich der Ort bewegen soll, wenn das Publikum eine Bewegung verlangt.",
                    "names": "$~Distanz"
                },
                {
                    "doc": "$~Wenn ‚Äûtrue‚Äú, ist eine Bewegung auf der horizontalen Achse m√∂glich. Standardm√§√üig aktiviert.",
                    "names": "$~horizontal"
                },
                {
                    "doc": "$~Wenn ‚Äûtrue‚Äú, ist eine Bewegung auf der vertikalen Achse m√∂glich. Standardm√§√üig aktiviert.",
                    "names": "$~Vertikale"
                },
                {
                    "doc": "$~Wenn wahr, erm√∂glicht es die Bewegung auf der Z-Achse mit den Tasten + und -.",
                    "names": "$~Tiefe"
                }
            ]
        },
        "Webpage": {
            "doc": [
                "$~/Hey, hier ist @FunctionDefinition. Lass uns dar√ºber reden, wie man Webseiten aus dem Internet bekommt!/",
                "$~Als wir zum ersten Mal von Ihrem Internet h√∂rten, fanden wir es faszinierend. Eine ganze Welt voller vernetzter Computer, die Dokumente miteinander teilen? Das ist unglaublich!",
                "$~Also haben wir einen Stream erstellt, der damit verbunden ist. Sie geben uns eine URL und wir holen uns den gesamten Text. So:",
                "$~\\Webseite('https://wordplay.dev')\\",
                "$~Und es gibt anscheinend dieses Ding namens <CSS@https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/What_is_CSS>, das Ihnen gef√§llt, wenn Sie Dinge auf einer Webseite abfragen. Geben Sie uns eine CSS-Auswahlabfrage und wir erhalten nur den Text, der dieser Abfrage entspricht. Wie dieses Beispiel, das die √úberschriften der ersten Ebene erh√§lt.",
                "$~\\Webseite('https://wordplay.dev' 'h1')\\",
                "$~Dabei kann vieles schiefgehen. Wenn Sie Ihre Internetverbindung verlieren, die URL nichts ergibt, die URL nicht √∂ffentlich ist oder es sich nicht um eine HTML-Seite handelt ‚Ä¶ All dies kann zu einer Ausnahme f√ºhren. Wenn Sie eine Seite finden, die funktioniert, erhalten Sie eine @Nummer, die den Prozentsatz der Fertigstellung angibt, und dann eine @Liste der W√∂rter auf der Seite."
            ],
            "names": ["$~üîó", "$~Website"],
            "url": {
                "doc": "$~Die abzurufende URL der HTML-Webseite.",
                "names": "$~URL(URL)"
            },
            "query": {
                "doc": "$~Die auszuwertende CSS-Abfrage im HTML",
                "names": "$~Abfrage"
            },
            "frequency": {
                "doc": "$~Die Anzahl der Minuten, die vergehen sollen, bevor die Seite erneut abgerufen wird.",
                "names": "$~Frequenz"
            },
            "error": {
                "invalid": "$~Dies ist keine g√ºltige URL",
                "unvailable": "$~diese URL ist nicht zug√§nglich",
                "notHTML": "$~Die Antwort war kein HTML",
                "noConnection": "$~keine Verbindung zu Wordplay",
                "limit": "$~zu viele Anfragen an diese Domain"
            }
        },
        "Collision": {
            "names": "$~Kollision",
            "doc": [
                "$~/Hallo! @FunctionDefinition hier. Sieh dir diesen coolen Input an./",
                "$~Damit k√∂nnen Sie herausfinden, wann @Output aufeinander st√∂√üt! Dies ist eine gro√üartige M√∂glichkeit, etwas zu tun, wenn wir aufeinander sto√üen, abgesehen vom normalen gegenseitigen Abprallen, das @Output m√∂glicherweise bewirkt.",
                "$~Geben Sie mir einfach den Namen @Output und ich erstelle einen neuen @Rebound-Wert, wenn er auf einen anderen Namen trifft. Ein @Rebound enth√§lt Informationen zu den kollidierten Namen und der Richtung ihrer Kollision.",
                "$~Und wenn Sie mir zwei Namen geben, erstelle ich nur dann einen neuen Wert, wenn die beiden Namen aufeinandertreffen.",
                "$~Gleich nachdem ich einen neuen Wert eingegeben habe, erstelle ich ein \\√∏\\, da die Kollision nach ihrem Auftreten beendet ist. Dies zeigt an, dass keine weitere Kollision mehr vorliegt."
            ],
            "subject": {
                "names": "$~Thema",
                "doc": "$~Der Name des @Outputs, bei dem ich nach Kollisionen suchen soll."
            },
            "object": {
                "names": "$~andere",
                "doc": "$~Der Name des anderen @Outputs, bei dem ich nach Kollisionen suchen soll."
            }
        },
        "Rebound": {
            "names": "$~Rebound",
            "doc": "$~Ich komme von @Collision und stelle dar, mit wem kollidiert ist und in welcher Richtung die Kollision stattgefunden hat. Verwenden Sie mich, um zu entscheiden, ob auf eine Kollision auf eine besondere Art und Weise reagiert werden soll, die von der normalen Physik abweicht.",
            "direction": {
                "names": "$~Richtung",
                "doc": "$~Richtung und Ausma√ü des Aufpralls im Verh√§ltnis zum Kollisionsobjekt"
            },
            "subject": {
                "names": "$~Thema",
                "doc": "$~Der Name der Ausgabe, die vom Betreff betroffen war."
            },
            "object": {
                "names": "$~Objekt",
                "doc": "$~Der Name der Ausgabe, die das Thema traf"
            }
        },
        "Direction": {
            "names": "$~Richtung",
            "doc": "$~Ich bin eine Richtung und Gr√∂√üe entlang der x- und y-Achse.",
            "x": {
                "names": "$~X",
                "doc": "$~Die Richtung und Gr√∂√üe der Richtung entlang der x-Achse."
            },
            "y": {
                "names": "$~j",
                "doc": "$~Die Richtung und Gr√∂√üe der Richtung entlang der Y-Achse."
            }
        }
    },
    "output": {
        "Output": {
            "names": "$~Ausgabe",
            "doc": [
                "$~Ich bin keine @StructureDefinition, die man tats√§chlich erstellen kann. Aber ich bin eine sehr wichtige, da ich die wichtigsten Elemente unseres Tanzes inspiriere: @Phrase, @Gruppe und @B√ºhne.",
                "$~Lernen Sie sie kennen, um mehr √ºber ihre Verwendung zu erfahren."
            ]
        },
        "Stage": {
            "names": ["$~üé≠", "$~B√ºhne"],
            "doc": [
                "$~HALLO. DIE B√úHNE IST HIER. SAG MIR, WAS ICH ZEIGEN SOLL, UND ICH ZEIGE ES.",
                "$~\\Stage([Phrase('Zeugsfffff')])\\",
                "$~WENN DU WILLST, GIB MIR EINE HINTERGRUND-Farbe und ich werde die B√ºhne entsprechend beleuchten.",
                "$~\\Stage([Phrase('stufffffff')] Hintergrund: Farbe(75% 50 100¬∞)\\",
                "$~SIE K√ñNNEN MIR AUCH EINEN RAHMENRAND GEBEN UND ICH WERDE IHN ZUSCHNEIDEN.",
                "$~\\Stage([Phrase('stufffffff')] Hintergrund: Farbe(75% 50 100¬∞) Rahmen: Rechteck(-1m -1m 1m 1m))\\"
            ],
            "description": {
                "names": "$!",
                "doc": "$!"
            },
            "content": {
                "doc": "$~Die Liste der auf der B√ºhne anzuzeigenden @Outputs.",
                "names": "$~Inhalt"
            },
            "frame": {
                "doc": "$~Die Form und Gr√∂√üe des Rahmens, der um die B√ºhne herum platziert wird und alles au√üerhalb davon verbirgt.",
                "names": "$~rahmen"
            },
            "size": {
                "doc": "$~LIKE @Gruppe/Gr√∂√üe",
                "names": "$~Gr√∂√üe"
            },
            "face": {
                "doc": "$~LIKE @Gruppe/Gesicht",
                "names": "$~Gesicht"
            },
            "place": {
                "doc": "$~WENN ICH EINE KAMERA W√ÑRE, W√úRDE ICH HIERHIN SCHAUEN",
                "names": "$~Ort"
            },
            "name": {
                "doc": ["$~DAS GLEICHE WIE @Phrase/Name!"],
                "names": "$~Name"
            },
            "selectable": {
                "doc": "$~GLEICH WIE @Phrase/ausw√§hlbar!",
                "names": "$~w√§hlbar"
            },
            "color": {
                "doc": "$~DAS GLEICHE WIE @Group/color",
                "names": "$~Farbe"
            },
            "background": {
                "doc": "$~DAS GLEICHE WIE @Group/background",
                "names": "$~Hintergrund"
            },
            "opacity": {
                "doc": "$~DAS GLEICHE WIE @Group/opacity",
                "names": "$~Opazit√§t"
            },
            "offset": {
                "doc": "$~DAS GLEICHE WIE @Group/Offset",
                "names": "$~Versatz"
            },
            "rotation": {
                "doc": "$~DAS GLEICHE WIE @Group/rotation",
                "names": ["$~üìê", "$~Drehung"]
            },
            "scale": {
                "doc": "$~DAS GLEICHE WIE @Group/scale",
                "names": "$~Skala"
            },
            "flipx": {
                "doc": "$~GLEICH WIE @Group/flipx",
                "names": "$~flipx"
            },
            "flipy": {
                "doc": "$~DAS GLEICHE WIE @Group/flipy",
                "names": "$~flippig"
            },
            "entering": {
                "doc": "$~DAS GLEICHE WIE @Group/entering",
                "names": "$~Eingabe"
            },
            "resting": {
                "doc": "$~DAS GLEICHE WIE @Gruppe/Ruhen!",
                "names": "$~Ruhen"
            },
            "moving": {
                "doc": "$~DAS GLEICHE WIE @Group/moving!",
                "names": "$~ziehenum"
            },
            "exiting": {
                "doc": "$~DAS GLEICHE WIE @Group/exiting!",
                "names": "$~Ausstieg"
            },
            "duration": {
                "doc": "$~GLEICH WIE @Phrase/Dauer!",
                "names": ["duraci√≥n"]
            },
            "style": {
                "doc": "$~DAS GLEICHE WIE @Phrase/Stil!",
                "names": "$~Stil"
            },
            "gravity": {
                "doc": "$~Die Schwerkraft, die auf die Ausgabe angewendet werden soll, deren Platz in @Motion ist.",
                "names": "$~Schwere"
            },
            "defaultDescription": "$~Stufe $2[$2 |]von $1 gibt $3 aus[mit Rahmen $3|] $4"
        },
        "Group": {
            "names": ["$~üî≥", "$~Gruppe"],
            "doc": [
                "$~Oh, hallo, wie geht es dir? Mir geht es immer gut, wenn andere da sind, also ist es toll, mit dir zusammen zu sein!",
                "$~Ich gruppiere @Phrase und @Group auf @Stage und platziere sie in einem @Arrangement, sodass eine gewisse Reihenfolge ihrer Platzierung gegeben ist.",
                "$~Damit es funktioniert, m√ºssen Sie mir ein @Arrangement und anschlie√üend eine @Liste mit anzuordnenden @Ausgaben geben.",
                "$~Hier bin ich beispielsweise mit einer @Stack-Anordnung und einigen @Phrase zum vertikalen Stapeln:",
                "$~\\Gruppe(Stapel() [Phrase('erste') Phrase('zweite')])\\",
                "$~Wie ich die Dinge genau arrangiere, h√§ngt von dem @Arrangement ab, das Sie mir geben."
            ],
            "description": {
                "names": "$!",
                "doc": "$!"
            },
            "content": {
                "doc": "$~Die Liste der anzuordnenden @Outputs.",
                "names": "$~Inhalt"
            },
            "layout": {
                "doc": "$~Die zu verwendende Anordnung, um @Output an ihren Pl√§tzen zu platzieren.",
                "names": "$~Layout"
            },
            "matter": {
                "doc": "$~Wie ich reagieren sollte, wenn ich mit etwas anderem, das Materie hat, zusammensto√üen w√ºrde.",
                "names": "$~Gegenstand"
            },
            "size": {
                "doc": "$~Wie gro√ü m√ºsste der wunderbare Inhalt in mir sein, wenn er nicht seine eigene Gr√∂√üe h√§tte!",
                "names": "$~Gr√∂√üe"
            },
            "face": {
                "doc": "$~Der Name der Schriftart sollte in meinem Inhalt enthalten sein, es sei denn, Sie haben eine eigene Schriftart zum Verwenden.",
                "names": "$~Gesicht"
            },
            "place": {
                "doc": "$~Der Platz auf der B√ºhne, an dem ich sein sollte. Der Inhalt in mir wird relativ dorthin angeordnet.",
                "names": "$~Ort"
            },
            "name": {
                "doc": ["$~Das Gleiche wie @Phrase/Name!"],
                "names": "$~Name"
            },
            "selectable": {
                "doc": "$~Das gleiche wie @Phrase/selectable!",
                "names": "$~w√§hlbar"
            },
            "color": {
                "doc": "$~Die @Color, die der Inhalt in mir haben sollte, sofern er nicht √ºber eine eigene Farbe verf√ºgt.",
                "names": "$~Farbe"
            },
            "background": {
                "doc": "$~Die @Color-Projizierung hinter mir.",
                "names": "$~Hintergrund"
            },
            "opacity": {
                "doc": "$~Wie transparent alles in mir sein soll, zwischen \\0\\ und \\1\\, sofern es nicht durch eine andere @Pose √ºberschrieben wird.",
                "names": "$~Opazit√§t"
            },
            "offset": {
                "doc": "$~Ein @Place, der angibt, wie weit es von meinem normalen @Place entfernt sein soll, sofern es nicht durch eine andere @Pose √ºberschrieben wird. Hilfreich zum Wackeln an Ort und Stelle.",
                "names": "$~Versatz"
            },
            "rotation": {
                "doc": "$~Wie geneigt sollte ich um meinen Mittelpunkt sein, meine @Pose hat eine andere.",
                "names": ["$~üìê", "$~Drehung"]
            },
            "scale": {
                "doc": "$~Wie gro√ü ich im Verh√§ltnis zu meiner Originalgr√∂√üe sein sollte.",
                "names": "$~Skala"
            },
            "flipx": {
                "doc": "$~Das Gleiche wie @Phrase/flipx!",
                "names": "$~flipx"
            },
            "flipy": {
                "doc": "$~Dasselbe wie @Phrase/flipy",
                "names": "$~flippig"
            },
            "entering": {
                "doc": "$~Dasselbe wie @Phrase/entering!",
                "names": "$~Eingabe"
            },
            "resting": {
                "doc": "$~Dasselbe wie @Phrase/resting!",
                "names": "$~Ruhen"
            },
            "moving": {
                "doc": "$~Dasselbe wie @Phrase/moving!",
                "names": "$~ziehenum"
            },
            "exiting": {
                "doc": "$~Dasselbe wie @Phrase/exiting!",
                "names": "$~Ausstieg"
            },
            "duration": {
                "doc": "$~Dasselbe wie @Phrase/Dauer!",
                "names": ["duraci√≥n"]
            },
            "style": {
                "doc": "$~Dasselbe wie @Phrase/Stil!",
                "names": "$~Stil"
            },
            "defaultDescription": "$~$1[$1|] $2 $3"
        },
        "Phrase": {
            "names": ["üí¨", "Satzglied"],
            "doc": "Hallo, hallo? Erinnerst du mich? Wie k√∂nnte jemand /mich/ vergessen? Ich bin das geniale @Phrase und ich bin bereit, die sch√∂nste aller @Text auf der B√ºhne zu darstellen.",
            "description": {
                "names": "$!",
                "doc": "$!"
            },
            "text": {
                "doc": "$~Die auf @Stage anzuzeigenden Charaktere.",
                "names": "$~Text"
            },
            "size": {
                "doc": "$~Wie gro√ü ich sein sollte, in Metern!",
                "names": "$~Gr√∂√üe"
            },
            "face": {
                "doc": "$~Der Name der Schriftart, die ich verwenden soll.",
                "names": "$~Gesicht"
            },
            "place": {
                "doc": "$~Der Platz auf der B√ºhne, an dem ich sein sollte.",
                "names": "$~Ort"
            },
            "wrap": {
                "doc": "$~Die Kante, an der ich Symbole umbrechen soll oder \\√∏\\, wenn ich sie nicht umbrechen soll.",
                "names": ["$~‚Üµ", "$~wickeln"]
            },
            "alignment": {
                "doc": "$~Wenn eine @Phrase/Wrap-Grenze festgelegt ist, ob ich Symbole am Anfang, in der Mitte oder am Ende der Kante ausrichten soll.",
                "names": "$~Ausrichtung"
            },
            "direction": {
                "doc": "$~Ob Symbole horizontal oder vertikal geschrieben werden und ob der Text nach links oder rechts umbrochen wird, wenn ‚Äûvertikal‚Äú und ‚Äû@Phrase/wrap‚Äú festgelegt sind.",
                "names": "$~Richtung"
            },
            "matter": {
                "doc": "$~Die Eigenschaften, die ich verwenden soll, wenn ich gegen Dinge sto√üe!",
                "names": "$~Gegenstand"
            },
            "aura": {
                "doc": "$~Die optionale @Aura, die hinter mir angezeigt wird. Bring mich zum Leuchten!",
                "names": "$~Aura"
            },
            "name": {
                "doc": [
                    "$~Ein Name, den du mir gibst! Das ist f√ºr vieles hilfreich.",
                    "$~Erstens: Wenn ich einen Namen habe, verwende ich ihn, um mich in den Beschreibungen des Screenreaders zu beschreiben.",
                    "$~Zweitens: Beim Animieren haben Sie m√∂glicherweise mehrere unterschiedliche Ausdr√ºcke, die denselben Inhalt auf der B√ºhne darstellen sollen. Geben Sie ihnen denselben Namen, und sie werden als einer animiert.",
                    "$~Schlie√ülich bin ich mit @Choice hilfreich: Die Namen, die Sie mir geben, erscheinen in diesem Stream.",
                    "$~Sie k√∂nnen mir viele verschiedene Namen in jeweils einer anderen Sprache geben, wenn das hilfreich ist. Ich verwende immer den Namen in der ersten ausgew√§hlten Sprache."
                ],
                "names": "$~Name"
            },
            "selectable": {
                "doc": "$~Wenn \\‚ä§\\, bedeutet dies, dass I √ºber einen Zeiger oder eine Tastatur ausgew√§hlt werden kann.",
                "names": "$~w√§hlbar"
            },
            "color": {
                "doc": "$~Die @Color I sollte standardm√§√üig sein, sofern sie nicht durch eine andere @Pose √ºberschrieben wird.",
                "names": "$~Farbe"
            },
            "background": {
                "doc": "$~Die @Color-Projizierung hinter mir.",
                "names": "$~Hintergrund"
            },
            "opacity": {
                "doc": "$~Wie transparent ich standardm√§√üig sein soll, zwischen \\0\\ und \\1\\, sofern es nicht durch eine andere @Pose √ºberschrieben wird. Hilfreich zum Ein- und Ausblenden.",
                "names": "$~Opazit√§t"
            },
            "offset": {
                "doc": "$~Ein @Place, der angibt, wie weit es von meinem @Place entfernt sein soll, sofern es nicht durch eine andere @Pose √ºberschrieben wird. Hilfreich zum Wackeln an Ort und Stelle.",
                "names": "$~Versatz"
            },
            "rotation": {
                "doc": "$~Der Betrag in Grad, um den ich um seinen Mittelpunkt gedreht werden soll, sofern er nicht durch eine andere @Pose √ºberschrieben wird.",
                "names": "$~Drehung"
            },
            "scale": {
                "doc": "$~Wie vergr√∂√üert soll ich im Verh√§ltnis zur Originalgr√∂√üe sein, sofern dies nicht durch eine andere @Pose √ºberschrieben wird.",
                "names": "$~Skala"
            },
            "flipx": {
                "doc": "$~Ob ich auf der X-Achse gespiegelt werden soll, sofern dies nicht durch eine andere @Pose √ºberschrieben wird.",
                "names": "$~flipx"
            },
            "flipy": {
                "doc": "$~Ob ich auf der Y-Achse gespiegelt werden soll, sofern dies nicht durch eine andere @Pose √ºberschrieben wird.",
                "names": "$~flippig"
            },
            "entering": {
                "doc": "$~Die @Pose oder @Sequenz, die ich beim Betreten der B√ºhne machen sollte.",
                "names": "$~Eingabe"
            },
            "resting": {
                "doc": "$~Die @Pose oder @Sequence sollte ich ausf√ºhren, nachdem ich die B√ºhne betreten habe, bevor ich sie verlasse und w√§hrend sich mein @Place nicht √§ndert. Wenn Sie mir keine geben, verwende ich einfach meine Standardeinstellungen.",
                "names": "$~Ruhen"
            },
            "moving": {
                "doc": "$~Die @Pose oder @Sequence, die ich beim Wechseln der Pl√§tze auf der B√ºhne verwenden sollte, anstelle meiner Standardeinstellungen.",
                "names": "$~ziehenum"
            },
            "exiting": {
                "doc": "$~Die @Pose oder @Sequence sollte vor dem Verlassen der B√ºhne ausgef√ºhrt werden.",
                "names": "$~Ausstieg"
            },
            "duration": {
                "doc": "$~Die anzuwendende Dauer beim Wechsel an eine andere Stelle auf der B√ºhne.",
                "names": ["$~‚è≥", "$~Dauer"]
            },
            "style": {
                "doc": "$~Der zu verwendende Animationsstil beim Wechsel an eine andere Stelle auf der B√ºhne.",
                "names": "$~Stil"
            },
            "defaultDescription": "$~$3[$3 Takt |]Phrase $1 $2[benannt $2|] $4[$4|] $5"
        },
        "Arrangement": {
            "names": ["Arrangement"],
            "doc": "$~Ich bin eine Inspiration f√ºr die vielen anderen Arten der Anordnung im Verse, einschlie√ülich @Row, @Stack, @Grid und @Free. Ich arbeite eng mit @Group zusammen, um"
        },
        "Row": {
            "names": ["Fila"],
            "doc": "$~Ich bin @Row, eine horizontale @Anordnung von @Output, mit optionaler Polsterung dazwischen. Kennen Sie meinen Zwilling @Stack?",
            "description": "$~Reihe von $1-Phrasen und Gruppen",
            "alignment": {
                "doc": "$~Ob der Text in jeder Spalte am Anfang, in der Mitte oder am Ende ausgerichtet werden soll.",
                "names": "$~Ausrichtung"
            },
            "padding": {
                "doc": "$~Die Menge an Polsterung, die zwischen den Ausgaben eingef√ºgt werden soll.",
                "names": "$~Polsterung"
            }
        },
        "Stack": {
            "names": ["$~‚¨á", "$~Stapel"],
            "doc": "$~Ich bin @Stack, eine vertikale @Anordnung von @Output, mit optionaler Polsterung dazwischen. Kennen Sie meinen Zwilling @Row?",
            "description": "$~Stapel von 1-Dollar-Phrasen und Gruppen",
            "padding": {
                "doc": "$~Die Menge an Polsterung, die zwischen den Ausgaben eingef√ºgt werden soll.",
                "names": "$~Polsterung"
            },
            "alignment": {
                "doc": "$~Ob der Text in jeder Zeile am Anfang, in der Mitte oder am Ende ausgerichtet werden soll.",
                "names": "$~Ausrichtung"
            }
        },
        "Grid": {
            "names": ["$~‚ñ¶", "$~Netz"],
            "doc": "$~Ich bin das Raster von @Output. Geben Sie mir die Zeilen- und Spaltenanzahl und ich erstelle eine √ºbersichtliche Anordnung mit optionaler Polsterung und Zellengr√∂√üen.",
            "description": "$~$1 Zeile $2 Spaltenraster",
            "rows": {
                "doc": "$~Wie viele Zeilen sollen im Raster erstellt werden?",
                "names": "$~Reihen"
            },
            "columns": {
                "doc": "$~Wie viele Spalten im Raster erstellt werden sollen.",
                "names": "$~S√§ulen"
            },
            "padding": {
                "doc": "$~Wie viel Polsterung zwischen den Zellen platziert werden soll.",
                "names": "$~Polsterung"
            },
            "cellWidth": {
                "doc": "$~Wie breit die Zellen sein sollen.",
                "names": "$~Zellenbreite"
            },
            "cellHeight": {
                "doc": "$~Wie hoch die Zellen sein sollen.",
                "names": "$~Zellenpolsterung"
            }
        },
        "Free": {
            "names": ["$~Frei"],
            "doc": [
                "$~Ich sage: Egal. Setz dich, wo du willst. Setz dich einfach irgendwo hin! Achte darauf, dass alle @Outputs, die du mir gibst, einen @Place haben, sonst wissen sie nicht, wohin sie gehen sollen.",
                "$~Oh, und denken Sie daran, dass der @Place, den Sie jedem @Output geben, relativ zum @Place der @Group ist! Wenn Sie sich also fragen, warum Dinge nicht dort erscheinen, wo Sie es erwarten, versuchen Sie, der @Group ebenfalls einen Platz zu geben."
            ],
            "description": "$~Freiform-Ausgaben f√ºr 1 USD"
        },
        "Shape": {
            "names": ["$~‚¨ü", "$~Form"],
            "doc": "$~Ich bin eine Inspiration f√ºr alle Formen. Ich bin n√ºtzlich, um @Stage zu sagen, welche Form es haben soll.",
            "form": {
                "doc": "$~Ich bin die Art von Form, die angezeigt werden soll. Jede Form erfordert andere Informationen, um ihre Anordnung zu definieren.",
                "names": "$~bilden"
            },
            "name": {
                "doc": "$~Ich bin der Name, den Sie f√ºr Animationen und @Collision verwenden k√∂nnen. Wenn ich beispielsweise den Boden darstelle, m√∂chten Sie mich vielleicht ‚ÄûBoden‚Äú nennen.",
                "names": "$~Name"
            },
            "selectable": {
                "doc": "$~Ob ich im Rahmen von @Choice ausgew√§hlt werden kann.",
                "names": "$~w√§hlbar"
            },
            "color": {
                "doc": "$~Die Farbe meiner R√§nder.",
                "names": "$~Farbe"
            },
            "background": {
                "doc": "$~Die Farbe meines Hintergrunds.",
                "names": "$~Hintergrund"
            },
            "opacity": {
                "doc": "$~Wie transparent ich sein sollte.",
                "names": "$~Opazit√§t"
            },
            "offset": {
                "doc": "$~Wie weit soll ich von meinem Platz entfernt erscheinen, w√§hrend ich an Ort und Stelle bleibe?",
                "names": "$~Versatz"
            },
            "rotation": {
                "doc": "$~Wie gedreht ich sein sollte. Dies wirkt sich auf @Collision aus.",
                "names": "$~Drehung"
            },
            "scale": {
                "doc": "$~Wie stark ich vergr√∂√üert werden sollte, ohne dass sich meine tats√§chliche Gr√∂√üe √§ndert.",
                "names": "$~Skala"
            },
            "flipx": {
                "doc": "$~Ob ich an meiner x-Achse gespiegelt werden soll.",
                "names": "$~flipx"
            },
            "flipy": {
                "doc": "$~Ob ich an meiner Y-Achse gespiegelt werden soll.",
                "names": "$~flippig"
            },
            "entering": {
                "doc": "$~Die @Pose oder @Sequence sollte ich beim Betreten der @Stage ausf√ºhren.",
                "names": "$~Eingabe"
            },
            "resting": {
                "doc": "$~Die @Pose oder @Sequence sollte ich nach dem Eintreten und w√§hrend ich mich nicht bewege, ausf√ºhren.",
                "names": "$~Ruhen"
            },
            "moving": {
                "doc": "$~Die @Pose oder @Sequence sollte ich beim Wechseln der Orte ausf√ºhren.",
                "names": "$~ziehenum"
            },
            "exiting": {
                "doc": "$~Die @Pose oder @Sequence, die ich beim Verlassen von @Stage ausf√ºhren sollte.",
                "names": "$~Ausstieg"
            },
            "duration": {
                "doc": "$~Wie lange meine Animationen dauern sollen, wenn es sich um eine einzelne @Pose handelt.",
                "names": "$~Dauer"
            },
            "style": {
                "doc": "$~Der Animationsstil, den ich verwenden sollte.",
                "names": "$~Stil"
            },
            "description": {
                "doc": [
                    "$~Eine Beschreibung f√ºr Zuschauer, die keine visuelle Ausgabe sehen k√∂nnen."
                ],
                "names": "$~Beschreibung"
            }
        },
        "Form": {
            "doc": "$~Ich bin eine abstrakte Form, wie ein @Rechteck oder ein @Kreis.",
            "names": ["$~Bilden"]
        },
        "Rectangle": {
            "names": ["$~Rechteck"],
            "doc": "$~Ich bin ein Rechteck und n√ºtzlich, um @Stage eine Begrenzung in der von Ihnen gew√§hlten Gr√∂√üe zu geben.",
            "left": {
                "doc": "$~Der linke Rand der B√ºhne auf der x-Achse",
                "names": "$~links"
            },
            "top": {
                "doc": "$~Die Oberkante der B√ºhne auf der Y-Achse",
                "names": "$~Spitze"
            },
            "right": {
                "doc": "$~Der rechte Rand der B√ºhne auf der x-Achse",
                "names": "$~Rechts"
            },
            "bottom": {
                "doc": "$~Die Unterkante der B√ºhne auf der Y-Achse",
                "names": "$~unten"
            },
            "z": {
                "doc": "$~Die Tiefenposition des Rechtecks.",
                "names": "$~z"
            }
        },
        "Circle": {
            "doc": "$~Ich bin ein Kreis, n√ºtzlich zum Erstellen von Formen auf @Stage.",
            "names": ["$~Kreis"],
            "radius": {
                "doc": "$~Der Radius des Kreises",
                "names": "$~Radius"
            },
            "x": {
                "doc": "$~Der horizontale Mittelpunkt des Kreises.",
                "names": "$~X"
            },
            "y": {
                "doc": "$~Der vertikale Mittelpunkt des Kreises.",
                "names": "$~j"
            },
            "z": {
                "doc": "$~Die Tiefenposition des Kreises.",
                "names": "$~z"
            }
        },
        "Polygon": {
            "doc": "$~Ich bin ein ‚Äûregelm√§√üiges‚Äú Polygon mit gleich langen Seiten und Winkeln, n√ºtzlich zum Erstellen von Formen auf @Stage.",
            "names": ["$~Vieleck"],
            "radius": {
                "doc": "$~Der Radius des Polygons",
                "names": "$~Radius"
            },
            "sides": {
                "doc": "$~Die Anzahl der Seiten des Polygons",
                "names": "$~Seiten"
            },
            "x": {
                "doc": "$~Der horizontale Mittelpunkt des Polygons.",
                "names": "$~X"
            },
            "y": {
                "doc": "$~Der vertikale Mittelpunkt des Polygons.",
                "names": "$~j"
            },
            "z": {
                "doc": "$~Die Tiefenposition des Polygons.",
                "names": "$~z"
            }
        },
        "Pose": {
            "names": ["$~ü§™", "$~Pose"],
            "doc": [
                "$~Wissen Sie, wenn jemand eine ganz erstaunliche Haltung einnimmt, inneh√§lt und alle zuschauen? Das bin ich. Ich erfasse eine Pose f√ºr @Output und bin der Baustein ihrer Bewegungen.",
                "$~Zu einer Pose geh√∂rt so viel. Schauen Sie sich meine vielen Anregungen an, um zu sehen, welche Arten von Posen Sie machen k√∂nnten!"
            ],
            "style": {
                "doc": "$~Der beim Wechsel zu dieser Pose zu verwendende Animationsstil.",
                "names": "$~Stil"
            },
            "color": {
                "doc": "$~Die @Color a @Output sollte in dieser Pose sein, statt in der Standardpose.",
                "names": "$~Farbe"
            },
            "opacity": {
                "doc": "$~Wie transparent ein @Output sein soll, zwischen \\0\\ und \\1\\, statt der Standardeinstellung. Hilfreich zum Ein- und Ausblenden.",
                "names": "$~Opazit√§t"
            },
            "offset": {
                "doc": "$~Ein @Place, der angibt, wie weit es von der Stelle eines @Outputs entfernt sein soll, statt der Standardeinstellung. Hilfreich zum Wackeln an Ort und Stelle.",
                "names": "$~Versatz"
            },
            "rotation": {
                "doc": "$~Wie rotiert ein @Output sein soll, anstelle der Standardeinstellung.",
                "names": "$~Drehung"
            },
            "scale": {
                "doc": "$~Wie vergr√∂√üert ein @Output im Verh√§ltnis zu seiner Originalgr√∂√üe sein soll, statt der Standardgr√∂√üe.",
                "names": "$~Skala"
            },
            "flipx": {
                "doc": "$~Ob ein @Output an der X-Achse gespiegelt werden soll, statt der Standardeinstellung.",
                "names": "$~flipx"
            },
            "flipy": {
                "doc": "$~Ob ein @Output an der Y-Achse gespiegelt werden soll, statt der Standardeinstellung.",
                "names": "$~flippig"
            },
            "description": "$~$1[transparent $1|] $2[um $2 Grad gedreht|] $3[3 skaliert|] $4[horizontal gespiegelt|] $5[vertikal gespiegelt|] $6[Schatten unscharf $6 Pixel]"
        },
        "Color": {
            "names": ["$~üåà", "$~Farbe"],
            "doc": [
                "$~Ich bin eine sichtbare Farbe, die aus drei wesentlichen Dimensionen besteht.",
                "$~Hier sind einige g√§ngige Farben im Farbkreis, mit mittlerer Helligkeit und hoher Farbs√§ttigung:",
                "$~\\Farbe(50% 100 0¬∞)\\",
                "$~\\Farbe(50% 100 30¬∞)\\",
                "$~\\Farbe(50% 100 60¬∞)\\",
                "$~\\Farbe(50% 100 90¬∞)\\",
                "$~\\Farbe(50% 100 120¬∞)\\",
                "$~\\Farbe(50% 100 150¬∞)\\",
                "$~\\Farbe(50% 100 180¬∞)\\",
                "$~\\Farbe(50% 100 210¬∞)\\",
                "$~\\Farbe(50% 100 240¬∞)\\",
                "$~\\Farbe(50% 100 270¬∞)\\",
                "$~\\Farbe(50% 100 300¬∞)\\",
                "$~\\Farbe(50% 100 330¬∞)\\"
            ],
            "lightness": {
                "doc": "$~Wie hell sollte ich sein, von \\0\\ bis \\1\\, von Schwarz bei \\0\\ √ºber Grau bei \\0,5\\ bis Wei√ü bei \\1\\.",
                "names": ["luminosidad"]
            },
            "chroma": {
                "doc": "$~Wie viel Farbe soll ich haben, von \\0\\ bis \\‚àû\\. Keine Farbe bedeutet grau, h√∂here Zahlen bedeuten mehr Farbe.",
                "names": ["croma"]
            },
            "hue": {
                "doc": "$~Welche Farbe sollte ich auf einem Farbkreis haben, von Magenta \\0\\, Rot \\30\\, Gr√ºn \\120\\ bis Blau \\270\\.",
                "names": ["matiz"]
            }
        },
        "Sequence": {
            "names": ["$~üíÉ", "$~Reihenfolge"],
            "doc": [
                "$~Oh. Meine G√ºte. Herr Direktor, Sie sehen heute fantastisch aus! Wollen Sie mit mir tanzen? Das ist ganz einfach.",
                "$~Sie m√ºssen mir lediglich eine @Map geben, in der jeder Schl√ºssel darstellt, wie weit wir im Tanz sind, und jeder Wert dieser Schl√ºssel ist eine @Pose.",
                "$~Es gibt /so/ viele verschiedene M√∂glichkeiten, damit zu animieren! Hier ist beispielsweise eine einfache:",
                "$~\\Phrase('hi' ruhend:Sequenz({0%: Pose(Rotation: 360¬∞) 100%: Pose(Rotation: 0¬∞)})\\",
                "$~Hier steht: /am Anfang (0%), bei Neigung 360 beginnen und bei Neigung 0 enden/. Das wird uns ewig im Kreis herumwirbeln, da ich als Ruhepose der @Phrase eingestellt bin!",
                "$~Probieren Sie Ihre eigenen kreativen T√§nze aus, indem Sie mit anderen Eingaben spielen."
            ],
            "poses": {
                "doc": "$~Eine @Map mit Prozentwerten zwischen 0 % und 100 %, jeweils gepaart mit einer @Pose. Sie m√ºssen nicht alle Prozentwerte angeben. Ich verschiebe einen @Output reibungslos zwischen denen, die Sie mir geben.",
                "names": "$~Posen"
            },
            "duration": {
                "doc": "$~Wie lange soll ich diesen Tanz machen? Wenn ich ihn wiederhole, verl√§ngere ich die Dauer nicht, sondern tanze einfach schneller.",
                "names": ["$~‚è≥", "$~Dauer"]
            },
            "style": {
                "doc": "$~Welchen Stil soll ich zum Tanzen verwenden?",
                "names": "$~Stil"
            },
            "count": {
                "doc": "$~Wie oft die Sequenz wiederholt werden soll, bevor sie beendet ist. Dies ist sehr hilfreich, wenn ich die B√ºhne betrete, mich auf die B√ºhne bewege oder sie verlasse, aber bei einer Ruhesequenz wird es ignoriert, da ich ewig ruhen kann.",
                "names": "$~z√§hlen"
            }
        },
        "Place": {
            "names": ["Posici√≥n"],
            "doc": "$~Ich bin ein Standort auf @Stage. Alle meine Eingaben sind optional, da ich standardm√§√üig in der Mitte bin.",
            "x": {
                "doc": "$~Eine Position auf der x-Achse.",
                "names": "$~X"
            },
            "y": {
                "doc": "$~Eine Position auf der y-Achse",
                "names": "$~j"
            },
            "z": {
                "doc": "$~Eine Position auf der Z-Achse",
                "names": "$~z"
            },
            "rotation": {
                "doc": "$~Drehung an dieser Stelle",
                "names": ["$~üìê", "$~Drehung"]
            }
        },
        "Velocity": {
            "doc": "$~Ich bin ein Standort auf @Stage. Alle meine Eingaben sind optional, da ich standardm√§√üig in der Mitte bin.",
            "names": ["$~üí®", "$~Geschwindigkeit"],
            "x": {
                "doc": "$~Wie viele Meter pro Sekunde auf der X-Achse zur√ºckgelegt werden sollen.",
                "names": "$~X"
            },
            "y": {
                "doc": "$~Wie viele Meter pro Sekunde auf der Y-Achse zur√ºckgelegt werden sollen.",
                "names": "$~j"
            },
            "angle": {
                "doc": "$~Um wie viele Grad soll pro Sekunde gedreht werden?",
                "names": ["$~Winkel", "$~¬∞"]
            }
        },
        "Matter": {
            "doc": "$~Ich bin die physikalischen Eigenschaften der Ausgabe, die beeinflussen, wie ich mit anderen Ausgaben auf der B√ºhne interagiere.",
            "names": ["$~‚öõÔ∏è", "$~Gegenstand"],
            "mass": {
                "doc": "$~Ein Gewicht in Kilogramm",
                "names": "$~Masse"
            },
            "bounciness": {
                "doc": "$~Wie viel von meiner Energie brauche ich, um eine Kollision aufrechtzuerhalten? 0 bedeutet keine, 1 bedeutet die volle Energie.",
                "names": "$~Sprungkraft"
            },
            "friction": {
                "doc": "$~Um wie viel soll weiter gerutscht werden? 0 bedeutet keine, 1 bedeutet f√ºr immer.",
                "names": "$~Reibung"
            },
            "roundedness": {
                "doc": "$~Wie stark die Ecken der Ausgabe gerundet werden sollen; 0 bedeutet keine und 1 bedeutet 100¬†% der Gr√∂√üe, wodurch die Gr√∂√üen kreisf√∂rmig werden.",
                "names": "$~Rundung"
            },
            "text": {
                "doc": "$~Ob es mit anderen Ausgaben kollidieren kann.",
                "names": "$~Text"
            },
            "shapes": {
                "doc": "$~Ob es mit anderen Formen kollidieren kann.",
                "names": "$~Boden"
            }
        },
        "Aura": {
            "doc": [
                "$~Ich bin eine AURA. Ich bringe @Phrase zum GL√úHEN! So:",
                "$~\\Phrase(\n'Ich LEUCHTE!' \nAura: Aura(Farbe(50% 100 118¬∞) 0,1m 0m 0,1m\n)\\"
            ],
            "names": ["$~üîÆ", "$~Aura"],
            "color": {
                "doc": "$~Die @Farbe, die die @Aura haben sollte.",
                "names": "$~Farbe"
            },
            "blur": {
                "doc": "$~Wie verschwommen die @Aura sein soll. \\0m\\ bedeutet √ºberhaupt nicht verschwommen.",
                "names": "$~verwischen"
            },
            "offsetX": {
                "doc": "$~Wie weit links oder rechts ich erscheinen soll. \\0m\\ liegt direkt darunter.",
                "names": "$~OffsetX"
            },
            "offsetY": {
                "doc": "$~Wie weit oben oder unten ich erscheinen soll.\\0m\\ steht direkt darunter.",
                "names": "$~OffsetY"
            }
        },
        "Easing": {
            "straight": "$~gerade",
            "cautious": "$~zur√ºckhaltend",
            "pokey": "$~spitz",
            "zippy": "$~flink"
        },
        "sequence": {
            "sway": {
                "doc": "$~Ich erstelle eine @Sequence, die um den Mittelpunkt eines @Outputs hin und her schwankt.",
                "names": ["vaiv√©n"],
                "angle": {
                    "doc": "$~Wie stark die Neigung beim Schwanken sein soll.",
                    "names": ["√°ngulo"]
                }
            },
            "bounce": {
                "doc": "$~Ich erstelle eine @Sequence, die @Output eine bestimmte H√∂he zur√ºckprallen l√§sst.",
                "names": ["rebotar"],
                "height": {
                    "doc": "$~Wie hoch der Sprung erfolgen soll.",
                    "names": ["altura"]
                }
            },
            "spin": {
                "doc": "$~Ich erstelle eine @Sequence, die @Output um ihren Mittelpunkt rotiert.",
                "names": ["girar"]
            },
            "fadein": {
                "doc": "$~Ich erstelle eine @Sequence, die @Output von unsichtbar auf sichtbar einblendet.",
                "names": ["revelar"]
            },
            "popup": {
                "doc": "$~Ich erstelle eine @Sequence, die @Output schnell skaliert, anstatt es auf die Normalgr√∂√üe zu verkleinern.",
                "names": ["surgir"]
            },
            "shake": {
                "doc": "$~Ich erstelle eine @Sequence, die es so aussehen l√§sst, als ob ein @Output Angst h√§tte.",
                "names": ["agitar"]
            },
            "fadeout": {
                "doc": "$~Ich erstelle eine @Sequence, die @Output von sichtbar auf unsichtbar blendet. Probieren Sie mich in einer aufregenden @Sequence aus!",
                "names": ["$~ausblenden"]
            }
        },
        "Source": {
            "names": "$~Quelle",
            "doc": [
                "$~Sie wissen, dass Projekte mehr als eine @Source-Datei haben k√∂nnen? Ich lasse Sie eine @Source basierend auf der Logik Ihres Projekts erstellen. Das ist wirklich hilfreich, wenn Sie einige Daten zwischen verschiedenen Auswertungen Ihres Projekts speichern m√∂chten.",
                "$~Stellen Sie sich beispielsweise vor, Sie m√∂chten einen einfachen Z√§hler erstellen, der bei jedem Dr√ºcken einer Maustaste um eins hochz√§hlt. Sie k√∂nnten ihn verwenden, um sich zu merken, wie oft Sie etwas getan haben.",
                "$~\\‚Üì z√§hlen\n[\nPhrase(`\\z√§hle\\ mal!`)\nSource('z√§hle' z√§hlen ‚Ä¶ ‚àÜ Button() ‚Ä¶ z√§hlen + 1 )\n]\\",
                "$~Versuchen Sie, es zu kopieren, eine neue @Source mit dem Namen /count/ zu erstellen und darin 0 einzugeben, um die Z√§hlung bei 0 zu starten. Dieses kleine Projekt ruft den Wert in der /count/-Quelle ab und bearbeitet die /count/-@Source bei jedem Dr√ºcken der Maustaste so, dass sie dem aktuellen /count/-Wert plus /1/ entspricht."
            ],
            "name": {
                "names": "$~Name",
                "doc": "$~Der Name der zu erstellenden oder zu aktualisierenden Quelldatei."
            },
            "value": {
                "names": "$~Wert",
                "doc": "$~Der Datenwert, mit dem die Quelldatei erstellt oder aktualisiert werden soll."
            },
            "DynamicEditLimitException": {
                "description": "$~dynamisches Quelltext-Bearbeitungslimit",
                "explanation": "$~Dieses Projekt hat Daten zu oft und zu schnell in @Source-Dateien gespeichert. Stellen Sie sicher, dass @Source nur als Reaktion auf eine Eingabe und nicht zu schnell aktualisiert wird."
            },
            "ReadOnlyEditException": {
                "description": "$~Nur-Lese-Quellcode bearbeiten",
                "explanation": "$~Dieses Projekt speichert Daten, aber Sie haben keine Rechte, diese zu bearbeiten. Kopieren Sie die Daten, wenn Sie sie ausprobieren m√∂chten."
            },
            "EmptySourceNameException": {
                "description": "$~leerer Quellname",
                "explanation": "$~Die angegebene @Source hatte einen leeren Namen, deshalb konnten wir sie nicht speichern."
            },
            "ProjectSizeLimitException": {
                "description": "$~Projektgr√∂√üenbeschr√§nkung",
                "explanation": "$~Dieses Projekt hat zu viel Text, deshalb k√∂nnen wir es nicht speichern."
            }
        }
    },
    "ui": {
        "font": {
            "app": "Noto Sans",
            "code": "Noto Sans Mono"
        },
        "phrases": {
            "welcome": "Wilkommen"
        },
        "widget": {
            "confirm": {
                "cancel": "$~stornieren"
            },
            "dialog": {
                "close": "$~schlie√üen"
            },
            "loading": {
                "message": "$~Schriftarten und Text werden geladen, danke f√ºrs Warten!"
            },
            "home": "Startseite"
        },
        "tile": {
            "toggle": {
                "fullscreen": {
                    "on": "$~Vollbild verlassen",
                    "off": "$~auf Vollbild erweitern"
                },
                "show": {
                    "on": "$~verstecken",
                    "off": "$~zeigen"
                }
            },
            "label": {
                "output": "$~B√ºhne",
                "palette": "$~Palette",
                "docs": "$~F√ºhrung",
                "source": "$~Quelle",
                "collaborate": "$~zusammenarbeiten"
            },
            "button": {
                "collapse": "$~Fenster ausblenden"
            }
        },
        "project": {
            "error": {
                "unknown": "$~Dieses Projekt existiert nicht oder ist nicht √∂ffentlich.",
                "translate": "$~Beim √úbersetzen Ihres Projekts ist ein Problem aufgetreten.",
                "tile": "$~Hoppla, da ist ein Fehler aufgetreten.",
                "reset": "$~Versuch zum Zur√ºcksetzen..."
            },
            "button": {
                "showCollaborators": "$~Dialog f√ºr Mitarbeiter anzeigen",
                "removeCollaborator": "$~Mitarbeiter entfernen",
                "copy": "$~Projekt als Text in die Zwischenablage kopieren",
                "addSource": "$~erstelle eine neue $source",
                "duplicate": "$~Dieses Projekt kopieren",
                "revert": "$~zum Originalcode zur√ºckkehren",
                "focusOutput": "$~Fokus Tastatur auf der B√ºhne",
                "focusSource": "$~Konzentrieren Sie sich auf die n√§chste Quelle",
                "focusDocs": "$~Fokus auf die Dokumentation",
                "focusPalette": "$~Konzentrieren Sie sich auf die Palette",
                "focusCycle": "$~Konzentriere dich auf die n√§chste Kachel",
                "unsaved": "$~Speicherfehler anzeigen",
                "translate": "$~Bearbeiten Sie die Sprachen dieses Projekts und √ºbersetzen Sie es in andere Sprachen.",
                "primary": "$~als prim√§re Lokalit√§t f√ºr dieses Projekt festlegen"
            },
            "field": {
                "name": {
                    "description": "$~Projektnamen bearbeiten",
                    "placeholder": "$~Name"
                }
            },
            "help": "$~Tastaturk√ºrzel anzeigen",
            "collapsed": "$~Alle Ihre Fenster sind ausgeblendet! Sie finden sie in der Symbolleiste unten",
            "save": {
                "projectsNotSavedLocally": "$~Beim Speichern von Projekten in Ihrem Browser ist ein Problem aufgetreten.",
                "projectsCannotNotSaveLocally": "$~Ihr Browser unterst√ºtzt das Speichern von Projekten nicht.",
                "projectContainedPII": "$~Zum Schutz Ihrer Privatsph√§re wurde ein Projekt mit potenziell pers√∂nlich identifizierbaren Informationen nicht online gespeichert. √úberpr√ºfen Sie das Projekt, um festzustellen, ob die Informationen identifizierend sind.",
                "projectsNotLoadingOnline": "$~Online-Projekte k√∂nnen nicht geladen werden.",
                "projectNotSavedOnline": "$~Projekte k√∂nnen nicht online gespeichert werden.",
                "settingsUnsaved": "$~Einstellungen k√∂nnen nicht online gespeichert werden."
            },
            "dialog": {
                "unsaved": "$~Nicht gespeicherte Arbeit ‚Ä¶",
                "translate": {
                    "header": "$~Sprachen",
                    "explanation": [
                        "$~Dies sind die Sprachen, die Ihr Projekt verwendet.",
                        "$~Um zu versuchen, Ihr Projekt in andere Sprachen zu √ºbersetzen, w√§hlen Sie eine prim√§re Ausgangssprache und dann eine neue Sprache.",
                        "$~/Es werden nicht alle Sprachen unterst√ºtzt und die √úbersetzungen k√∂nnen unvollst√§ndig sein. √úberpr√ºfen Sie daher die Ergebnisse!/"
                    ]
                }
            },
            "subheader": {
                "source": "$~Quelle",
                "destination": "$~Ziel"
            }
        },
        "gallery": {
            "untitled": "$~Ohne Titel",
            "undescribed": "$~Keine Beschreibung",
            "subheader": {
                "curators": {
                    "header": "$~KuratorInnen",
                    "explanation": "$~Ersteller, die diese Galerie verwalten."
                },
                "creators": {
                    "header": "$~Sch√∂pfer",
                    "explanation": "$~Sch√∂pfer, die zu dieser Galerie beitragen."
                },
                "delete": {
                    "header": "$~L√∂schen",
                    "explanation": "$~Durch das L√∂schen dieser Galerie werden ihre Projekte nicht gel√∂scht. Die Galerie wird dauerhaft gel√∂scht."
                }
            },
            "confirm": {
                "delete": {
                    "description": "$~Galerie l√∂schen",
                    "prompt": "$~l√∂schen"
                },
                "remove": {
                    "description": "$~Projekt aus der Galerie entfernen",
                    "prompt": "$~entfernen"
                }
            },
            "error": {
                "unknown": "$~Diese Galerie existiert nicht oder ist nicht √∂ffentlich."
            },
            "field": {
                "name": {
                    "description": "$~Galeriename",
                    "placeholder": "$~Name"
                },
                "description": {
                    "description": "$~Galeriebeschreibung",
                    "placeholder": "$~Beschreiben Sie Ihre Galerie. Was ist ihr Thema, ihre Ziele oder ihre Community?"
                }
            }
        },
        "source": {
            "label": "$~Programmeditor",
            "empty": [
                "$~Lass uns anfangen! Du kannst ‚Ä¶",
                "$~‚Ä¢ √ñffnen üìï und ziehen üñ±Ô∏è Sie uns zu diesem Programm.",
                "$~‚Ä¢ Geben Sie $1 ein und w√§hlen Sie uns aus dem Men√º.",
                "$~‚Ä¢ Schreiben Sie uns mit ‚å®Ô∏è.",
                "$~‚Ä¢ Durchsuchen Sie die <galleries@://galleries> zur Inspiration.",
                "$~Wenn Sie nicht weiterkommen, <erfahren Sie mehr@://erfahren Sie>."
            ],
            "overwritten": "$~Habe eine aktuellere Version erhalten!",
            "confirm": {
                "delete": {
                    "description": "$~l√∂sche diese $source",
                    "prompt": "$~l√∂schen"
                }
            },
            "toggle": {
                "blocks": {
                    "on": "$~Blockhintergr√ºnde ausblenden",
                    "off": "$~Blockhintergr√ºnde anzeigen"
                },
                "glyphs": {
                    "on": "$~die passenden Glyphen ausblenden",
                    "off": "$~Erweitern Sie die passenden Glyphen"
                }
            },
            "button": {
                "selectOutput": "$~diese Ausgabe auf der B√ºhne zeigen",
                "expandSequence": "$~Erweitern Sie diesen ausgeblendeten Code"
            },
            "field": {
                "name": {
                    "description": "$~Quellnamen bearbeiten",
                    "placeholder": "$~Name"
                }
            },
            "menu": {
                "label": "$~Autovervollst√§ndigungsmen√º",
                "show": "$~Autovervollst√§ndigungsmen√º anzeigen",
                "back": "$~Untermen√º verlassen"
            },
            "cursor": {
                "priorLine": "$~Bewegen Sie den Cursor zur Zeile davor.",
                "nextLine": "$~Bewegen Sie den Cursor zur n√§chsten Zeile.",
                "priorInline": "$~Bewegen Sie den Cursor zur Position davor.",
                "nextInline": "$~Bewegen Sie den Cursor zur Position danach",
                "lineStart": "$~Cursor an den Zeilenanfang bewegen",
                "lineEnd": "$~Cursor ans Zeilenende bewegen",
                "sourceStart": "$~Bewegen Sie den Cursor zum Anfang der Quelle.",
                "sourceEnd": "$~Bewegen Sie den Cursor an das Ende der Quelle.",
                "priorNode": "$~w√§hle Nachbarn vor",
                "nextNode": "$~w√§hle Nachbar nach",
                "parent": "$~Container ausw√§hlen",
                "selectAll": "$~Programm ausw√§hlen",
                "incrementLiteral": "$~Erh√∂hen Sie die Zahl, den Text oder den Boolean-Wert",
                "decrementLiteral": "$~Verringern Sie die Zahl, den Text oder den Booleschen Wert",
                "insertSymbol": "$~f√ºge $1 ein",
                "insertTab": "$~Registerkarte einf√ºgen",
                "insertTrue": "$~F√ºge ‚Äûtrue‚Äú ein",
                "insertFalse": "$~false einf√ºgen",
                "insertNone": "$~kein Symbol einf√ºgen",
                "insertNotEqual": "$~Einf√ºgen ungleich",
                "insertProduct": "$~Produktsymbol einf√ºgen",
                "insertQuotient": "$~Quotientensymbol einf√ºgen",
                "insertDegree": "$~Gradsymbol einf√ºgen",
                "insertFunction": "$~Einf√ºgefunktion",
                "insertLessOrEqual": "$~einf√ºgen kleiner oder gleich",
                "insertGreaterOrEqual": "$~einf√ºgen gr√∂√üer als oder gleich",
                "insertStream": "$~Streamsymbol einf√ºgen",
                "insertChange": "$~√Ñnderungssymbol einf√ºgen",
                "insertConvert": "$~Konvertierungssymbol einf√ºgen",
                "insertPrevious": "$~vorheriges Symbol einf√ºgen",
                "insertType": "$~Typsymbol einf√ºgen",
                "insertTable": "$~Symbol zum √ñffnen der Tabelle einf√ºgen",
                "insertTableClose": "$~Symbol zum Schlie√üen der Tabelle einf√ºgen",
                "insertBorrow": "$~einf√ºgen ausleihen",
                "insertShare": "$~teilen",
                "insertLine": "$~Zeilenumbruch einf√ºgen",
                "backspace": "$~Auswahl oder vorheriges Symbol l√∂schen",
                "delete": "$~Auswahl oder n√§chstes Symbol l√∂schen",
                "cut": "$~Auswahl ausschneiden",
                "copy": "$~Auswahl kopieren",
                "paste": "$~Einf√ºgen von Tastaturinhalten",
                "parenthesize": "$~Auswahl in Klammern setzen",
                "enumerate": "$~Auswahl aufz√§hlen",
                "type": "$~Typzeichen",
                "undo": "$~vorherige Bearbeitung r√ºckg√§ngig machen",
                "redo": "$~R√ºckg√§ngig gemachte Bearbeitung wiederholen",
                "search": "$~Suche nach einzuf√ºgenden Sonderzeichen",
                "tidy": "$~ordentlicher Abstand",
                "elide": "$~Elision umschalten",
                "insertDocs": "$~Erkl√§rungssymbol einf√ºgen"
            }
        },
        "annotations": {
            "label": "$~Konflikte und Hilfe",
            "cursor": "$~Dies ist *$1*$2[ und sie sind vom Typ $2|]. $3[ Sie befinden sich innerhalb einer *$3*.|]",
            "cursorParent": "$~Sie befinden sich innerhalb eines *$1*$2[ vom Typ $2|].",
            "learn": "$~/Erfahren Sie mehr/",
            "evaluating": "$~Oh Spa√ü, lass es uns auswerten!",
            "space": "$~Das ist Weltraum! Wer h√§tte gedacht, dass nichts so viel aussagen kann?",
            "button": {
                "resolution": "$~Diesen Konflikt l√∂sen"
            }
        },
        "output": {
            "label": "$~Programmausgabe",
            "toggle": {
                "grid": {
                    "on": "$~Gitternetzlinien ausblenden",
                    "off": "$~Gitternetzlinien anzeigen"
                },
                "fit": {
                    "on": "$~Zoom manuell steuern",
                    "off": "$~Zoom an Inhalt anpassen"
                },
                "paint": {
                    "on": "$~Farbausgabe",
                    "off": "$~Ausgabe platzieren"
                }
            },
            "field": {
                "key": {
                    "description": "$~Tastendr√ºcke abh√∂ren",
                    "placeholder": "$~Nachricht"
                }
            },
            "button": {
                "submit": "$~diese Chat-Nachricht senden"
            },
            "options": {
                "locale": "$~W√§hlen Sie die Sprache f√ºr die Ausgabe"
            }
        },
        "timeline": {
            "label": "$~Zeitleiste",
            "slider": "$~Zeitschieberegler",
            "button": {
                "play": "$~das Programm bis zum Ende auswerten und auf Eingaben in Echtzeit reagieren",
                "pause": "$~das Programm anhalten, um vorw√§rts und r√ºckw√§rts gehen zu k√∂nnen",
                "backStep": "$~einen Schritt zur√ºck",
                "backNode": "$~Schritt zur vorherigen Auswertung des Cursors",
                "backInput": "$~einen Eingang zur√ºck",
                "out": "$~Aus dieser Funktion aussteigen",
                "forwardStep": "$~Schritt vorw√§rts einen",
                "forwardNode": "$~Schritt zur n√§chsten Auswertung des Cursors",
                "forwardInput": "$~Schritt vorw√§rts zum n√§chsten Stream-Eingang",
                "present": "$~bis zum Ende",
                "start": "$~zu Beginn",
                "reset": "$~Leistung neu starten"
            }
        },
        "docs": {
            "label": "$~Dokumentationsbrowser",
            "link": "$~Konzept $1 in der Dokumentation anzeigen",
            "learn": "$~Lern mehr ‚Ä¶",
            "nodoc": "$~Wer bin ich? Was bin ich? Was ist mein Ziel?",
            "button": {
                "home": "$~nach Hause zur√ºckkehren",
                "back": "$~Zur√ºck zur vorherigen"
            },
            "field": {
                "search": "$~Suche nach Konzepten mit W√∂rtern"
            },
            "header": {
                "inputs": "$~Eing√§nge",
                "interfaces": "$~Schnittstellen",
                "properties": "$~Eigenschaften",
                "functions": "$~Funktionen",
                "conversions": "$~Konvertierungen"
            }
        },
        "dialog": {
            "share": {
                "header": "$~Weitergabe",
                "explanation": "$~Steuern Sie, wer dieses Projekt bearbeiten und sehen kann.",
                "subheader": {
                    "gallery": {
                        "header": "$~Galerie",
                        "explanation": "$~F√ºgen Sie dieses Projekt einer Galerie neben anderen Erstellern hinzu oder erstellen Sie eine Galerie auf Ihrer Seite <projects@://projects>. Wenn Sie ein Projekt einer √∂ffentlichen Galerie hinzuf√ºgen, wird Ihr Projekt √∂ffentlich."
                    },
                    "public": {
                        "header": "$~√ñffentlich/Privat",
                        "explanation": "$~√ñffentliche Projekte und Galerien k√∂nnen von jedem auf der Welt gesehen werden. Unser Ziel ist es, dass diese Inhalte Best√§tigung und Freude bringen, und das √∂ffentliche Teilen ist eine M√∂glichkeit, dies zu erreichen. Aber es bedeutet auch, einige Regeln einzuhalten. Sie versprechen, dass Ihr Projekt Folgendes nicht tut:"
                    },
                    "pii": {
                        "header": "$~Pers√∂nliche Angaben",
                        "explanation": "$~Das √∂ffentliche Teilen personenbezogener Daten (PII) kann die Urheber gef√§hrden. Daher erkennen wir m√∂gliche PII und warnen die Urheber, die sensiblen Daten entweder zu entfernen oder als nicht sensibel zu kennzeichnen.\n\nNachfolgend finden Sie eine Liste m√∂glicher PII in diesem Projekt, das Sie als nicht sensibel gekennzeichnet haben. Sie k√∂nnen auf die Schaltfl√§che daneben klicken, um es wieder als sensibel zu kennzeichnen. Dies bedeutet jedoch, dass Ihr Projekt nicht mehr online gespeichert wird."
                    }
                },
                "field": {
                    "emailOrUsername": {
                        "placeholder": "$~E-Mail Adresse oder Benutzername",
                        "description": "$~E-Mail oder Benutzername der Person, der Sie Bearbeitungszugriff gew√§hren m√∂chten"
                    }
                },
                "mode": {
                    "public": {
                        "label": "$~Sichtweite",
                        "modes": ["$~Privat", "$~√∂ffentlich"]
                    }
                },
                "error": {
                    "unknown": "$~Wir kennen keinen Ersteller mit dieser E-Mail.",
                    "anonymous": "$~Zum Teilen m√ºssen Sie angemeldet sein."
                },
                "button": {
                    "submit": "$~Teilen Sie das Projekt mit dieser E-Mail-Adresse",
                    "sensitive": {
                        "tip": "$~Diesen Text erneut als vertraulich markieren",
                        "label": "$~empfindlich"
                    }
                },
                "options": {
                    "gallery": "$~Galerieauswahl"
                }
            },
            "settings": {
                "header": "$~Einstellungen",
                "explanation": "$~√Ñndern Sie die Layout-, Ger√§te- und Designeinstellungen.",
                "button": {
                    "show": "$~Einstellungsdialog anzeigen"
                },
                "mode": {
                    "layout": {
                        "label": "$~Layout",
                        "modes": [
                            "$~automatisch",
                            "$~horizontal",
                            "$~Vertikale",
                            "$~frei"
                        ]
                    },
                    "animate": {
                        "label": "$~Animationen",
                        "modes": [
                            "$~Animationen aus",
                            "$~normale Geschwindigkeit",
                            "$~halbe Geschwindigkeit",
                            "$~dritte Geschwindigkeit",
                            "$~Viertelgeschwindigkeit"
                        ]
                    },
                    "dark": {
                        "label": "$~Thema",
                        "modes": [
                            "$~helle Farben",
                            "$~dunkle Farben",
                            "$~Ger√§teeinstellungen verwenden"
                        ]
                    },
                    "space": {
                        "label": "$~Leerzeichenanzeige",
                        "modes": [
                            "$~Leerzeichen- und Tabulatoranzeigen explizit anzeigen",
                            "$~Leerzeichen und Tabulatoren nicht anzeigen"
                        ]
                    },
                    "writing": {
                        "label": "$~Schreiblayout",
                        "modes": [
                            "$~horizontal, von links nach rechts",
                            "$~vertikal, von rechts nach links",
                            "$~vertikal, von links nach rechts"
                        ]
                    },
                    "localized": {
                        "label": "$~Codelokalisierung",
                        "modes": [
                            "$~Code nicht lokalisieren",
                            "$~Code lokalisieren, wenn verf√ºgbar",
                            "$~Code lokalisieren, aber Symbole bevorzugen"
                        ]
                    },
                    "lines": {
                        "label": "$~Zeilennummern",
                        "modes": [
                            "$~Zeilennummern im Textmodus anzeigen",
                            "$~Zeilennummern im Textmodus nicht anzeigen"
                        ]
                    }
                },
                "options": {
                    "mic": "$~ausgew√§hltes Mikrofon",
                    "camera": "$~ausgew√§hlte Kamera",
                    "face": "$~Schriftart"
                }
            },
            "locale": {
                "header": "$~Sprache",
                "explanation": "$~W√§hlen Sie Ihre Sprachen und Regionen.",
                "subheader": {
                    "selected": "$~Ausgew√§hlt",
                    "supported": "$~Verf√ºgbar",
                    "coming": "$~Demn√§chst",
                    "help": "$~Helfen Sie uns beim √úbersetzen ‚Ä¶"
                },
                "button": {
                    "show": "$~Gebietsschema √§ndern",
                    "add": "$~dieses Gebietsschema hinzuf√ºgen",
                    "remove": "$~Dieses Gebietsschema entfernen",
                    "replace": "$~durch dieses Gebietsschema ersetzen"
                }
            },
            "help": {
                "header": "$~Verkn√ºpfungen",
                "explanation": "$~Verwenden Sie diese Tastaturbefehle f√ºr eine effizientere Bearbeitung.",
                "subheader": {
                    "moveCursor": "$~Bewegen",
                    "editCode": "$~Bearbeiten",
                    "insertCode": "$~Einf√ºgen",
                    "debug": "$~Debuggen"
                }
            }
        },
        "palette": {
            "label": "$~Palette",
            "labels": {
                "mixed": "$~gemischt",
                "computed": "$~berechnet",
                "default": "$~Standard",
                "inherited": "$~vererbt",
                "notSequence": "$~keine Sequenz",
                "notContent": "$~kein Inhaltsverzeichnis",
                "format": "$~Format",
                "weight": "$~Gewicht",
                "light": "$~Licht",
                "normal": "$~normal",
                "bold": "$~deutlich",
                "extra": "$~extra",
                "italic": "$~kursiv",
                "underline": "$~unterstreichen"
            },
            "button": {
                "revert": "$~auf Standard zur√ºcksetzen",
                "set": "$~diese Eigenschaft bearbeiten",
                "addPhrase": "$~f√ºge danach eine Phrase hinzu",
                "addGroup": "$~f√ºge danach eine Gruppe hinzu",
                "addShape": "$~f√ºge danach eine Form hinzu",
                "addMotion": "$~Ort f√ºr Motion Stream festlegen",
                "addPlacement": "$~Ort auf Platzierungsstream setzen",
                "remove": "$~diesen Inhalt entfernen",
                "up": "$~diesen Inhalt nach oben verschieben",
                "down": "$~diesen Inhalt nach unten verschieben",
                "edit": "$~diesen Inhalt bearbeiten",
                "sequence": "$~in Sequenz umwandeln",
                "createPhrase": "$~Erstellen Sie eine Phrase, die den vorhandenen Wert als Text anzeigt",
                "createGroup": "$~Erstellen Sie eine Gruppe, die jede vorhandene Phrase umschlie√üt",
                "createStage": "$~Erstellen Sie eine B√ºhne, die eine vorhandene Gruppe oder Phrase umschlie√üt"
            },
            "prompt": {
                "offerPhrase": "$~Was f√ºr einen tollen Wert Sie geschaffen haben! Soll ich es auf @Stage zeigen?",
                "offerGroup": "$~Was f√ºr eine wunderbare @Phrase du erstellt hast. M√∂chtest du sie in einer @Gruppe zusammenf√ºhren, um sie zu ordnen?",
                "offerStage": "$~SEHR GUT @Programm. F√úGEN SIE MICH HINZU, UM BELEUCHTUNG, FARBEN UND RAHMEN ZU STEUERN.",
                "pauseToEdit": "$~Wenn Sie die Phase ‚è∏Ô∏è, k√∂nnen Sie ein üí¨, üî≥ oder üé≠ zum Bearbeiten ausw√§hlen!",
                "editing": "$~Bearbeite mich!"
            },
            "field": {
                "coordinate": "$~Koordinate bearbeiten",
                "text": "$~Text bearbeiten"
            },
            "sequence": {
                "button": {
                    "add": "$~Pose hinzuf√ºgen",
                    "remove": "$~Pose entfernen",
                    "up": "$~Pose nach oben bewegen",
                    "down": "$~Pose nach unten verschieben"
                },
                "field": {
                    "percent": "$~Prozent bearbeiten"
                }
            }
        },
        "save": {
            "saving": "Speichern",
            "saved": "Online gespeichert",
            "local": "Im Browser gespeichert",
            "unsaved": "Ungespeichert"
        },
        "page": {
            "unknown": {
                "header": "$~Iiihhh!",
                "message": "$~Wo ist dieser Ort? K√∂nnen wir nach Hause gehen?"
            },
            "landing": {
                "value": "$~Erstellen Sie mit uns interaktive Geschichten mit W√∂rtern, Symbolen, Emojis und Code!",
                "description": [
                    "$~Wordplay ist eine Programmiersprache, die Ihnen Folgendes erm√∂glicht:",
                    "$~‚Ä¢ W√∂rter und Emojis spielerisch animieren ü§™",
                    "$~‚Ä¢ Nutze Zeit üï¶, Ton üé§, Websites üîó und Physik üåé",
                    "$~‚Ä¢ Teilen ü§ù mit Freunden, Gruppen oder jedem",
                    "$~‚Ä¢ Code in jeder Weltsprache üåê",
                    "$~‚Ä¢ Bearbeiten mit M√§usen üñ±Ô∏è, Touch üëÜ und Tastaturen ‚å®Ô∏è",
                    "$~‚Ä¢ Vorw√§rts-‚è© und R√ºckw√§rts-‚è™-Debuggen",
                    "$~‚Ä¢ Mit Bildschirmen üñ•Ô∏è und Bildschirmleseprogrammen üîä anzeigen",
                    "$~F√ºr immer kostenlos von der <University of Washington@https://ischool.uw.edu/>."
                ],
                "beta": [
                    "$~Wordplay befindet sich in der *Beta*-Phase und funktioniert daher m√∂glicherweise nicht wie vorgesehen oder ist nicht vollst√§ndig. Melden Sie Fehler und teilen Sie Ideen in <GitHub@https://github.com/wordplaydev/wordplay/issues>, sehen Sie sich unsere <1.0-Pl√§ne@https://github.com/wordplaydev/wordplay/milestones/1.0> an und <contribute@https://github.com/wordplaydev/wordplay/wiki/contribute>."
                ],
                "link": {
                    "about": "Warum existiert diese Website?",
                    "learn": "Ein dramatisches Tutorial mit einer schillernden Besetzung von Charakturen",
                    "projects": "Wo du deine Auff√ºhrungen machen und teilen kannst",
                    "galleries": "Erleben Sie die Leistungen anderer",
                    "rights": "Unsere und deine Verantwortungen",
                    "guide": "Suchen und st√∂bern Sie in der Sprachreferenz",
                    "community": {
                        "label": "Gemeinschaft",
                        "subtitle": "Chatten Sie mit uns auf Discord."
                    },
                    "contribute": {
                        "label": "Beitragen",
                        "subtitle": "Helfen Sie uns, Wordplay zu erstellen."
                    }
                }
            },
            "learn": {
                "header": "Lernen",
                "error": "$~Wir konnten kein Tutorial f√ºr diese Sprache finden.",
                "button": {
                    "next": "$~n√§chste Pause im Dialog",
                    "previous": "$~vorherige Pause im Dialog"
                },
                "options": {
                    "lesson": "$~aktuelle Lektion"
                }
            },
            "projects": {
                "header": "Projekte",
                "projectprompt": "$~Bereit, etwas zu sagen? Erstellen Sie ein Projekt oder arbeiten Sie an einem. Wenn Sie nicht weiterkommen, <learning@://learn> weiter.",
                "archiveheader": "$~Archiviert",
                "archiveprompt": "$~Dies sind Projekte, die Sie archiviert haben. Nur Eigent√ºmer k√∂nnen sie dauerhaft l√∂schen oder aus dem Archiv entfernen. Archivierte Projekte werden 30 Tage nach ihrer letzten Bearbeitung dauerhaft gel√∂scht.",
                "galleriesheader": "Galerien",
                "galleryprompt": "$~Erstellen und kuratieren Sie Galerien, um eine Projektsammlung mit anderen zu teilen.",
                "add": {
                    "header": "$~Neues Projekt",
                    "explanation": "$~W√§hlen Sie eine Vorlage, um ein neues Projekt zu erstellen."
                },
                "button": {
                    "newproject": "$~neues Projekt",
                    "editproject": "$~Dieses Projekt bearbeiten",
                    "newgallery": "$~neue Galerie",
                    "unarchive": "$~Dieses Projekt aus dem Archiv nehmen",
                    "viewcode": "$~Code dieses Projekts anzeigen"
                },
                "confirm": {
                    "archive": {
                        "description": "$~Diesen Auftritt archivieren",
                        "prompt": "$~Archiv"
                    },
                    "delete": {
                        "description": "$~diesen Auftritt endg√ºltig l√∂schen",
                        "prompt": "$~Unwiederuflich l√∂schen"
                    }
                },
                "error": {
                    "noaccess": "$~Wir konnten nicht auf das Internet zugreifen.",
                    "nogalleryedits": "$~Sie m√ºssen angemeldet sein, um Galerien erstellen und √§ndern zu k√∂nnen.",
                    "newgallery": "$~Wir konnten keine neue Galerie erstellen.",
                    "nodeletes": "$~Sie m√ºssen angemeldet sein, um archivierte Projekte zu l√∂schen.",
                    "delete": "$~Hoppla, wir konnten das Projekt nicht l√∂schen!"
                }
            },
            "galleries": {
                "header": "Galerien",
                "prompt": "$~Dies sind Leistungen, die andere erbracht haben. Erleben Sie sie, studieren Sie sie oder adaptieren Sie sie f√ºr Ihre eigene Aussage.",
                "examples": "Beispiele"
            },
            "about": {
                "header": "√úber uns",
                "content": [
                    "$~Hatten Sie schon einmal das Gef√ºhl, dass Programmieren nur etwas f√ºr Westler mit guten Englischkenntnissen und ohne Behinderung ist, die mit Computern aufgewachsen sind?",
                    "$~Ja, wir auch.",
                    "$~Das ist kein Zufall. Seit es Computer gibt, wurden Programmiersprachen gr√∂√ütenteils von derselben Gruppe von Menschen entworfen und entwickelt ‚Äì haupts√§chlich von wei√üen, englischsprachigen M√§nnern mit cis-Gesichtsausdruck in der Wissenschaft und Industrie in den USA und Europa und ein paar unglaublichen Mathematikerinnen. Sie arbeiteten in einer Zeit postkolonialer Macht, in der der Gewinner alles bekam, und Programmiersprachen waren ein wichtiges Instrument zur Sicherung dieser Macht.",
                    "$~Diese Geschichte hat zu einer Vision der Datenverarbeitung gef√ºhrt, bei der es in erster Linie um Geschwindigkeit, Logik, Profit und Dominanz geht.",
                    "$~Das ist ungerecht. Denn Computer sind heute ‚Äì im Guten wie im Schlechten ‚Äì sichtbar und unsichtbar Teil des t√§glichen Lebens, und die Menschen, die sie nutzen k√∂nnen, sind diejenigen, die ihren Sch√∂pfern am √§hnlichsten sind. Der Rest der Menschheit bleibt dieser Macht ausgeliefert, denn um sich etwas anderes vorzustellen, muss man lesen und schreiben k√∂nnen, und Sprachbarrieren, Zugangsbarrieren, wirtschaftliche H√ºrden und Ungleichheiten im √∂ffentlichen Bildungssystem verhindern dies.",
                    "$~*Wordplay* m√∂chte dazu beitragen, dies zu √§ndern. Es handelt sich um eine Programmierplattform, die global konzipiert ist und alle Sprachen der Welt unterst√ºtzt, aber auch etwas √ºber die Sprachen der Welt dreht. Eine Plattform, auf der jeder mit seinen F√§higkeiten kreativ sein und interaktive Inhalte teilen kann, die jeder erleben kann. F√ºr Jugendliche und junge Erwachsene, die sich spielerisch und kunstvoll durch interaktive W√∂rter, Emojis und Typografie ausdr√ºcken m√∂chten. Nicht mit dem Ziel, selbst Macht zu erlangen, sondern um eine computergest√ºtzte Welt zu schaffen, die die unglaubliche St√§rke und Notwendigkeit unserer sch√∂nen Unterschiede anerkennt.",
                    "$~Wir sind eine Gemeinschaft von Designern, P√§dagogen und Entwicklern, die versuchen, diese Vision zum Leben zu erwecken. Wir sind People of Color, wir sind Transsexuelle, wir sind Queers, wir sind Behinderte, wir sind Immigranten, wir sind Fl√ºchtlinge. Unser Zentrum ist die <University of Washington@https://washington.edu> <Information School@https://ischool.uw.edu/> in Seattle, Washington, USA, einem Ort, der danach strebt, alle willkommen zu hei√üen und die bis heute andauernden behindertenfeindlichen und rassistischen Verw√ºstungen des Kolonialismus r√ºckg√§ngig zu machen. Die Entwicklung dieser Programmiersprache und Plattform ist ein kleiner Teil dieser Mission und bietet einen Einblick in eine Zukunft der Computertechnik, in die /jeder/ geh√∂rt.",
                    "$~Wir freuen uns √ºber Ihre Hilfe. Erfahren Sie, <wie Sie beitragen k√∂nnen@https://github.com/wordplaydev/wordplay/wiki/contribute>, <spenden@://donate> oder verfolgen Sie unseren <Fortschritt@https://github.com/amyjko/wordplay/milestones>. Schreiben Sie unserer Community-Organisatorin <Amy@https://amyjko.phd>, wenn Sie Fragen haben."
                ]
            },
            "login": {
                "header": "Anmeldung",
                "anonymous": "Anmeldung",
                "prompt": {
                    "forgot": "$~*Passwort vergessen?* Leider k√∂nnen wir Ihr Konto nicht wiederherstellen, da wir keine Kontaktinformationen erfassen.",
                    "email": "$~Haben Sie ein Nur-E-Mail-Konto? Melden Sie sich an, indem Sie Ihre E-Mail-Adresse angeben. Wenn ein Konto damit verkn√ºpft ist, senden wir Ihnen eine E-Mail mit einem Anmeldelink. Neue Nur-E-Mail-Konten werden aus Datenschutzgr√ºnden nicht unterst√ºtzt.",
                    "enter": "$~Offenbar stammt Ihr Anmeldelink von einem anderen Browser oder Ger√§t. K√∂nnen Sie Ihre E-Mail-Adresse noch einmal eingeben, damit wir sicher sind, dass Sie es sind?",
                    "tooyoung": "$~Sie m√ºssen mindestens 13 Jahre alt sein, um sich mit einer E-Mail anzumelden.",
                    "passwordrule": "$~Passw√∂rter m√ºssen mindestens 10 Zeichen lang sein. Wenn Sie keinen Passwort-Manager verwenden, w√§hlen Sie drei lange W√∂rter, die Sie sich gut merken k√∂nnen.",
                    "passwordreminder": "$~Es sieht so aus, als ob Sie noch kein Konto haben. Geben Sie Ihr Passwort erneut ein und stellen Sie sicher, dass Sie es sicher und korrekt gespeichert haben, da es nicht wiederherstellbar ist.",
                    "play": "$~Sie sind angemeldet, wir k√∂nnen Ihre Projekte jetzt online speichern! M√∂chten Sie etwas erstellen?",
                    "changeEmail": "$~M√∂chten Sie Ihre E-Mail-Adresse √§ndern? Senden Sie eine neue und wir senden eine Best√§tigung an die alte.",
                    "changePassword": "$~M√∂chten Sie Ihr Passwort √§ndern? Senden Sie ein Neues und wiederholen Sie es.",
                    "logout": "$~Verwenden Sie ein gemeinsam genutztes Ger√§t und m√∂chten Ihre Projekte privat halten? Melden Sie sich ab und wir *l√∂schen* Ihre Projekte von diesem Ger√§t, sie werden jedoch online gespeichert.",
                    "sent": "$~Wenn diese E-Mail mit einem Konto verkn√ºpft ist, wird eine E-Mail mit einem Anmeldelink gesendet. Es kann einige Minuten dauern, bis dieser angezeigt wird. Wenn mit dieser E-Mail kein Konto verkn√ºpft ist, erhalten Sie nichts.",
                    "success": "$~Account erstellt!",
                    "confirm": "$~√úberpr√ºfen Sie Ihre alte E-Mail-Adresse, um Ihre neue Adresse zu best√§tigen.",
                    "delete": "$~M√∂chten Sie, dass wir alles vergessen, was Sie hier gemacht haben? Dies kann nicht r√ºckg√§ngig gemacht werden.",
                    "reallyDelete": "$~Sind Sie sicher? Ihr Konto und Ihre Einstellungen werden sofort gel√∂scht und Ihre Projekte werden zur L√∂schung vorgemerkt. Mitarbeiter Ihrer Projekte verlieren sofort den Zugriff darauf. Geben Sie Ihre E-Mail-Adresse oder Ihren Benutzernamen ein, um zu best√§tigen, dass Sie dies w√ºnschen.",
                    "name": "$~W√§hlenSieeinEmojiaus,umsichanderenvorzustellen.",
                    "login": "$~Melden Sie sich an, um Ihre Projekte zu speichern, zusammenzuarbeiten und sie zu teilen:",
                    "join": "$~Oder <create an account@://join>, um zu beginnen."
                },
                "error": {
                    "expired": "$~Dieser Link ist abgelaufen.",
                    "invalid": "$~Dieser Link ist ung√ºltig.",
                    "email": "$~Diese E-Mail war ung√ºltig.",
                    "offline": "$~Wir konnten die Cloud ‚òÅÔ∏è nicht erreichen.",
                    "failure": "$~Anmeldung nicht m√∂glich :(",
                    "unchanged": "$~Wir konnten Ihre E-Mail-Adresse nicht √§ndern, wissen aber nicht, warum.",
                    "delete": "$~Wir konnten Ihr Konto nicht l√∂schen, wissen aber nicht, warum.",
                    "wrongPassword": "$~Kein g√ºltiger Benutzername und Passwort. Entweder ist Ihr Passwort falsch oder jemand anderes hat diesen Benutzernamen.",
                    "tooMany": "$~Sie haben zu oft erfolglos versucht, sich anzumelden. Sie m√ºssen warten, bevor Sie es erneut versuchen k√∂nnen."
                },
                "feedback": {
                    "changing": "$~Neue E-Mail wird gesendet ‚Ä¶",
                    "deleting": "$~Okay, Ihre Projekte und Einstellungen werden gel√∂scht ‚Ä¶",
                    "updatedPassword": "$~Ihr Passwort wurde aktualisiert.",
                    "match": "$~Dies muss mit dem Benutzernamen Ihres Kontos √ºbereinstimmen."
                },
                "field": {
                    "email": {
                        "description": "$~Login-E-Mail bearbeiten",
                        "placeholder": "$~Email"
                    },
                    "username": {
                        "description": "$~Login-Benutzername, verwenden Sie keine personenbezogenen Daten",
                        "placeholder": "$~Nutzername"
                    },
                    "password": {
                        "description": "$~Login-Passwort, mindestens 10 Zeichen",
                        "placeholder": "$~Passwort"
                    },
                    "currentPassword": {
                        "description": "$~Ihr aktuelles Login-Passwort",
                        "placeholder": "$~Aktuelles Passwort"
                    },
                    "newPassword": {
                        "description": "$~Dein neues Passwort",
                        "placeholder": "$~Neues Kennwort"
                    }
                },
                "button": {
                    "logout": {
                        "tip": "$~Abmelden von Ihrem Konto",
                        "label": "$~Ausloggen"
                    },
                    "login": "$~Mit dieser E-Mail anmelden, einen Login-Link senden",
                    "updateEmail": "$~√Ñndere deine E-Mail",
                    "updatePassword": "$~neues Passwort eingeben",
                    "delete": {
                        "tip": "$~L√∂sche deinen Account",
                        "label": "$~meine Daten l√∂schen‚Ä¶"
                    },
                    "reallyDelete": {
                        "tip": "$~l√∂sche dein Konto f√ºr immer",
                        "label": "$~L√∂sche es!!!"
                    }
                },
                "toggle": {
                    "reveal": {
                        "on": "$~Passwort anzeigen",
                        "off": "$~Passwort verbergen"
                    }
                },
                "subtitle": "$~Speichern, zusammenarbeiten und teilen"
            },
            "join": {
                "header": "$~Verbinden",
                "prompt": {
                    "create": "$~Erstellen Sie ein Konto, um Ihre Projekte zu speichern, mit anderen zusammenzuarbeiten und Ihre Arbeit zu teilen.",
                    "username": "$~Benutzernamen m√ºssen mindestens 5 Zeichen lang sein, d√ºrfen keine E-Mail-Adresse sein und d√ºrfen weder Ihren Namen noch andere identifizierende Informationen enthalten.",
                    "password": "$~Passw√∂rter m√ºssen mindestens /10 Zeichen/ lang sein. Geben Sie es zweimal ein und notieren Sie es an einem sicheren Ort, z. B. in einem Passwortmanager. *Es gibt keine M√∂glichkeit, Ihr Konto wiederherzustellen*, wenn Sie es verlieren, da wir keine Kontaktinformationen erfassen."
                }
            },
            "rights": {
                "header": "Rechte",
                "content": [
                    "$~Hallo!",
                    "$~Lassen Sie uns einige Erwartungen hinsichtlich Ihrer und unserer Rechte festlegen (auch im Lichte von Richtlinien wie <COPPA@https://www.ecfr.gov/current/title-16/chapter-I/subchapter-C/part-312> und <GDPR@https://gdpr.eu/compliance-checklist-us-companies/>).",
                    "$~Zun√§chst einmal sollten Sie wissen, dass wir kein kommerzielles Unternehmen sind. Wir sind ein gemeinschaftsbasiertes Forschungsprojekt an einer gemeinn√ºtzigen Universit√§t. Unser Ziel ist es, eine Plattform zu schaffen, die Ihnen Freude bereitet und uns hilft, Entdeckungen √ºber eine gerechtere und fairere Computerwelt zu machen. Wir haben kein Interesse daran, mit dieser Plattform Geld zu verdienen. Jegliches Geld, das wir sammeln (normalerweise durch √∂ffentliche Mittel), wird verwendet, um die Plattform zu erhalten, und nicht, um jemanden zu bereichern, der daran arbeitet (oder dazu beitr√§gt).",
                    "$~Da wir keinen Gewinn anstreben, k√∂nnen wir auch keine Versprechungen zur Zuverl√§ssigkeit, Verf√ºgbarkeit oder Langlebigkeit dieser Plattform machen. Dennoch ist <Amy@https://amyjko.phd> langfristig f√ºr die Aufrechterhaltung der Plattform engagiert und hat als Professorin mit Festanstellung einen ziemlich sicheren Job.",
                    "$~Damit kommen wir zu *Daten*. Folgendes sammeln und speichern wir in der Cloud:",
                    "$~‚Ä¢ Ihre *Projekte*. Wir speichern alle Projekte, zu denen Sie beitragen, und Ihre √Ñnderungen daran, es sei denn, diese Projekte scheinen personenbezogene Daten wie Telefonnummern, E-Mail-Adressen, Benutzernamen, Steuernummern oder Adressen zu enthalten.",
                    "$~‚Ä¢ Ihre *Einstellungen*. Dazu geh√∂ren die von Ihnen gew√§hlten Sprachen, Ihre Animationseinstellungen und Ihr Lernfortschritt. Alles andere wird nur auf Ihrem Ger√§t gespeichert.",
                    "$~‚Ä¢ Aggregierte *Aktivit√§t*. Wir verfolgen Anmeldungen und die von Ihnen besuchten Seiten, jedoch nicht auf eine Weise, die Sie identifizieren, Sie auf der Website verfolgen oder Sie auf anderen Websites verfolgen kann. Wir verwenden Google Analytics im Modus ‚ÄûZustimmung verweigert‚Äú, der nur minimale nicht identifizierbare Informationen √ºber Seitenaufrufe sammelt, ohne Cookies zu speichern oder IP-Adressinformationen an Google zu senden. Wir verwenden diese aggregierten Informationen, um Spenden zu sammeln, indem wir melden, wie stark die Plattform genutzt wird.",
                    "$~Wir speichern nichts anderes. Unsere <source@https://github.com/amyjko/wordplay/tree/main/src> ist √∂ffentlich, sodass jeder dies √ºberpr√ºfen und unbeabsichtigtes Tracking melden kann.",
                    "$~*Sie* besitzen Ihre Daten, nicht wir. Das bedeutet:",
                    "$~‚Ä¢ Sie bestimmen, wer auf Ihre Projekte zugreifen kann. Sie sind standardm√§√üig privat, Sie k√∂nnen sie jedoch mit Einzelpersonen oder Gruppen teilen oder sie vollst√§ndig √∂ffentlich machen.",
                    "$~‚Ä¢ Sie k√∂nnen jedes Projekt oder Ihren eigenen Account jederzeit vollst√§ndig l√∂schen.",
                    "$~‚Ä¢ Sie k√∂nnen jederzeit einen Export jedes Projekts oder Ihres gesamten Kontos erhalten.",
                    "$~So verwenden wir Ihre Daten und so nicht:",
                    "$~‚Ä¢ Wir geben Ihre Daten an niemanden weiter, es sei denn, dies ist gesetzlich ausdr√ºcklich vorgeschrieben. Es ist immer m√∂glich, dass Ihre Daten ohne Ihre Erlaubnis entwendet werden (ein ‚ÄûDatenversto√ü‚Äú). Wenn wir feststellen, dass dies geschehen ist, benachrichtigen wir Sie dar√ºber unter Verwendung der E-Mail-Adresse, die Sie uns mitgeteilt haben.",
                    "$~‚Ä¢ Wir werden Sie nicht √ºber Ihre E-Mail-Adresse kontaktieren, es sei denn, Sie 1) nehmen eine Konto√§nderung vor, die dies erforderlich macht, 2) Sie erteilen uns ausdr√ºcklich Ihre Zustimmung zur Kontaktaufnahme oder 3) es liegt eine der oben genannten Datenschutzverletzungen vor.",
                    "$~‚Ä¢ Wir k√∂nnen Projekte auf der Plattform analysieren, um zu verstehen, was jeder macht und wie er es macht. Wir k√∂nnen diese aggregierten, anonymisierten Erkenntnisse in akademischen Ver√∂ffentlichungen teilen. Wir werden dies nur unter der Aufsicht eines institutionellen √úberpr√ºfungsausschusses tun, wie es das US-Bundesgesetz vorschreibt.",
                    "$~Zum Schluss noch ein Hinweis zur Redefreiheit. Sie k√∂nnen auf dieser Plattform *privat* alles sagen, was Sie m√∂chten. Projekte sind standardm√§√üig privat, und wenn Sie sie mit bestimmten E-Mail-Adressen teilen, gelten sie weiterhin als privat. In privaten Projekten moderieren wir nichts.",
                    "$~Aber ein Projekt *√∂ffentlich* zu machen oder es in eine √∂ffentliche Galerie aufzunehmen, ist ein Privileg. Dies ist eine Plattform f√ºr Liebe, Best√§tigung, Respekt und W√ºrde. Daher erwarten wir, dass keiner Ihrer *√∂ffentlichen* Inhalte:"
                ],
                "consequences": [
                    "$~Wenn wir ein Projekt oder eine Galerie finden, die gegen diese Regeln verst√∂√üt, warnen wir die Ersteller, bevor sie es ansehen k√∂nnen, oder blockieren es. Wenn Sie diese Regeln wiederholt verletzen, verlieren Sie das Recht, √∂ffentlich zu posten."
                ]
            },
            "donate": {
                "header": "Spenden",
                "prompt": "Um zug√§ngliche und weltweite Programmierungen zu bef√§higen",
                "content": [
                    "$~Wordplay ist ein kostenloses, Community-basiertes Projekt, das von der <University of Washington@https://washington.edu> unterst√ºtzt wird. Wir sind auf Spenden von Menschen angewiesen, die an unsere Mission glauben, zug√§ngliche, sprachintegrative und lehrreiche Programmiersprachen zu entwickeln.",
                    "$~Hier sind unsere aktuellen Kosten:",
                    "$~‚Ä¢ Wir entsch√§digen die Studierenden der University of Washington, insbesondere diejenigen mit Behinderungen oder deren Muttersprache nicht Englisch war, f√ºr die Weiterentwicklung und Pflege des Projekts. Dies entspricht etwa 90 % unserer Kosten.",
                    "$~‚Ä¢ Wir vergeben Stipendien an Lehrer, mit denen wir zusammenarbeiten, um mehrsprachige, zug√§ngliche Lehrpl√§ne zu entwickeln.",
                    "$~‚Ä¢ Wir bezahlen Google f√ºr <Firebase@https://firebase.google.com/> Bandbreite und Speicher sowie <Workspace@https://workspace.google.com/>-Dienste.",
                    "$~‚Ä¢ Wir zahlen <Squarespace@https://www.squarespace.com/> j√§hrlich f√ºr die Domain.",
                    "$~Unsere derzeitigen Kosten betragen ca. 60.000 USD pro Jahr, ausgehend von 5 Studenten zu je 20 USD/Stunde, 10 Stunden/Woche w√§hrend des akademischen Jahres (36 Wochen) und 2 Studenten im Sommer (12 Wochen) plus Cloud-Dienste.",
                    "$~Wenn 2.400 Menschen 25 US-Dollar pro Jahr spenden w√ºrden, w√§ren damit unsere laufenden Kosten gedeckt. Der dar√ºber hinausgehende Betrag w√ºrde zur Verg√ºtung weiterer Sch√ºler und Lehrer verwendet.",
                    "$~K√∂nnen Sie einer dieser 2.400 Menschen sein? Wenn ja, hier ist unser Spendenlink f√ºr die University of Washington:"
                ]
            },
            "guide": {
                "header": "$~F√ºhrung",
                "description": "$~Dies ist eine Referenz f√ºr jeden Teil der Programmiersprache Wordplay. Suchen Sie nach einem Konzept oder durchsuchen Sie die Liste, um mehr zu erfahren."
            }
        },
        "edit": {
            "node": "$~$1$2[, Typ $2|]",
            "before": "$~vor $1[$1|Ende]",
            "inside": "$~in $1, zwischen $2[$2|Start] und $3[$3|Ende]",
            "between": "$~zwischen 1 und 2 US-Dollar",
            "line": "$~leere Zeile zwischen $1[$1|Start] und $2[$2|Ende]",
            "conflicts": "$~$1 Konflikte",
            "assign": "$~/$2[M√∂chte gern mitmachen|Erw√§gt, auszusteigen]‚Ä¶/",
            "append": "$~/Begierig, einzuf√ºgen‚Ä¶/",
            "remove": "$~/Erw√§gt, zu gehen‚Ä¶/",
            "replace": "$~/Will eingreifen‚Ä¶/",
            "wrap": "$~Elternheizung",
            "unwrap": "$~auspacken",
            "bind": "$~Nennen Sie diesen Ausdruck"
        },
        "template": {
            "unwritten": "$~Wird noch bekannt gegeben",
            "unparsable": "$~Nicht analysierbare Vorlage: $1"
        },
        "collaborate": {
            "label": "$~zusammenarbeiten",
            "role": {
                "owner": "$~Eigent√ºmer",
                "collaborators": "$~Mitarbeiter",
                "curators": "$~Kuratoren"
            },
            "field": {
                "message": {
                    "description": "$~Die zu √ºbermittelnde Chat-Nachricht",
                    "placeholder": "$~Geben Sie eine Nachricht ein"
                }
            },
            "button": {
                "submit": {
                    "label": "$~Schicken",
                    "tip": "$~Senden Sie eine Nachricht an Ihre Mitarbeiter"
                },
                "start": {
                    "label": "$~Einen Chat starten",
                    "tip": "$~Beginnen Sie eine Diskussion mit sich selbst oder anderen."
                },
                "delete": "$~diese Nachricht l√∂schen"
            },
            "error": {
                "unowned": "$~Dieses Projekt hat keinen Eigent√ºmer, daher ist kein Chat m√∂glich.",
                "offline": "$~Dieser Chat konnte nicht geladen werden.",
                "empty": "$~Keine Nachrichten.",
                "deleted": "$~Diese Nachricht wurde gel√∂scht."
            },
            "prompt": {
                "solo": "$~Chatten Sie mit sich selbst oder f√ºgen Sie einen Mitarbeiter hinzu, der bearbeiten und chatten kann.",
                "owner": "$~Mitarbeiter k√∂nnen dieses Projekt bearbeiten und dar√ºber chatten.",
                "collaborator": "$~Sie sind ein Mitarbeiter. Sie k√∂nnen dieses Projekt bearbeiten und dar√ºber chatten.",
                "curator": "$~Sie sind Kurator der Galerie dieses Projekts. Sie k√∂nnen dieses Projekt bearbeiten und dar√ºber chatten."
            }
        }
    },
    "moderation": {
        "warning": {
            "header": "$~Warnung",
            "explanation": "$~Ein Moderator hat entschieden, dass dieser Inhalt:"
        },
        "blocked": {
            "header": "$~verstopft",
            "explanation": "$~Ein Moderator hat entschieden, dass dieser Inhalt:"
        },
        "unmoderated": {
            "header": "$~Notiz",
            "explanation": "$~Dieser Inhalt wurde noch nicht moderiert. Er kann:"
        },
        "moderate": {
            "header": "$~M√§√üig",
            "explanation": "$~√úberpr√ºfen Sie dieses Projekt und entscheiden Sie, ob sein Inhalt eines der folgenden Dinge tut. Wenn dies der Fall ist, wird der Inhalt gewarnt oder blockiert. Sie k√∂nnen diesen Schritt √ºberspringen, wenn Sie sich nicht sicher sind."
        },
        "flags": {
            "violence": "$~Gewalt, Verletzungen oder Selbstverletzungen gegen√ºber anderen anstiften, dazu ermutigen oder sie feiern.",
            "dehumanization": "$~Entmenschlichung von Einzelpersonen oder Gruppen aufgrund ihrer Rasse, ethnischen Zugeh√∂rigkeit, nationalen Herkunft, Kaste, sexuellen Orientierung, ihres Geschlechts, ihrer Religion, ihres Alters, ihrer F√§higkeiten oder ihres Aussehens.",
            "disclosure": "$~Private Informationen √ºber andere Personen preisgeben, wie etwa Namen, Kontaktdaten oder Postanschriften",
            "misinformation": "$~Falsche, irref√ºhrende, t√§uschende oder manipulative Informationen enthalten"
        },
        "progress": "$~*$1* moderiert, *$2* verbleibend",
        "button": {
            "submit": {
                "tip": "$~Diese Moderationseinstellungen speichern",
                "label": "$~speichern"
            },
            "skip": {
                "tip": "$~Dieses Projekt √ºberspringen",
                "label": "$~√ºberspringen"
            }
        }
    },
    "gallery": {
        "games": {
            "name": "$~Spiele",
            "description": "$~Interaktive Spiele mit W√∂rtern und Symbolen."
        },
        "visualizations": {
            "name": "$~Visualisierungen",
            "description": "$~Visualisierungen von und √ºber Text."
        },
        "motion": {
            "name": "$~Bewegung",
            "description": "$~Beispiele f√ºr Bewegungen und Kollisionen."
        },
        "av": {
            "name": "$~Audio/Video",
            "description": "$~Verwenden von Lautst√§rke, Tonh√∂he und Video als Eingabe."
        },
        "tools": {
            "name": "$~Werkzeuge",
            "description": "$~Einfache Dienstprogramme und Anwendungen."
        }
    }
}
