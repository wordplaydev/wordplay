{
    "$schema": "../../schemas/LocaleText.json",
    "language": "hi",
    "region": "IN",
    "wordplay": "$~लिटरएक्स",
    "term": {
        "evaluate": "$~मूल्यांकन करना",
        "bind": "$~बाँध",
        "decide": "$~तय करना",
        "document": "$~व्याख्या करना",
        "project": "$~परियोजना",
        "source": "$~स्रोत",
        "input": "$~इनपुट",
        "output": "$~आउटपुट",
        "convert": "$~बदलना",
        "act": "$~कार्य",
        "scene": "$~दृश्य",
        "phrase": "$~वाक्यांश",
        "group": "$~समूह",
        "stage": "$~अवस्था",
        "type": "$~प्रकार",
        "start": "$~शुरू",
        "entered": "$~नया",
        "changed": "$~बदल गया",
        "moved": "$~ले जाया गया",
        "name": "$~नाम",
        "value": "$~कीमत",
        "text": "$~मूलपाठ",
        "boolean": "$~बूलियन",
        "map": "$~नक्शा",
        "number": "$~संख्या",
        "function": "$~समारोह",
        "exception": "$~अपवाद",
        "table": "$~मेज़",
        "none": "$~कोई नहीं",
        "list": "$~सूची",
        "stream": "$~धारा",
        "structure": "$~संरचना",
        "index": "$~अनुक्रमणिका",
        "query": "$~सवाल",
        "row": "$~पंक्ति",
        "set": "$~तय करना",
        "key": "$~चाबी",
        "help": "$~मदद",
        "feedback": "$~प्रतिक्रिया"
    },
    "token": {
        "EvalOpen": "$~मूल्यांकन खुला",
        "EvalClose": "$~मूल्यांकन बंद",
        "SetOpen": "$~सेट/मानचित्र खोलें",
        "SetClose": "$~सेट/मानचित्र बंद करें",
        "ListOpen": "$~सूची खुली",
        "ListClose": "$~सूची बंद करें",
        "TagOpen": "$~टैग खोलें",
        "TagClose": "$~टैग बंद करें",
        "Bind": "$~बाँध",
        "Access": "$~संपत्ति तक पहुंच",
        "Function": "$~समारोह",
        "Borrow": "$~उधार",
        "Share": "$~शेयर करना",
        "Convert": "$~बदलना",
        "Doc": "$~स्पष्टीकरण",
        "Formatted": "$~प्रारूपित",
        "FormattedType": "$~स्वरूपित प्रकार",
        "Words": "$~शब्द",
        "Link": "$~जाल संपर्क",
        "Italic": "$~तिरछा",
        "Underline": "$~रेखांकन",
        "Light": "$~रोशनी",
        "Bold": "$~बोल्ड",
        "Extra": "$~अतिरिक्त",
        "Concept": "$~अवधारणा लिंक",
        "URL": "$~यूआरएल",
        "Code": "$~कोड",
        "Mention": "$~उल्लेख",
        "Otherwise": "$~अन्यथा",
        "Match": "$~मिलान",
        "None": "$~कुछ नहीं",
        "Type": "$~प्रकार",
        "Literal": "$~शाब्दिक",
        "TypeOperator": "$~है",
        "TypeOpen": "$~प्रकार इनपुट खुला",
        "TypeClose": "$~प्रकार इनपुट बंद करें",
        "Separator": "$~नाम विभाजक",
        "Language": "$~भाषा टैग",
        "Region": "$~क्षेत्र डैश",
        "BooleanType": "$~बूलियन प्रकार",
        "NumberType": "$~संख्या प्रकार",
        "JapaneseNumeral": "$~जापानी अंक",
        "RomanNumeral": "$~रोमन अंक",
        "Pi": "$~अनुकरणीय",
        "Infinity": "$~अनंत",
        "TableOpen": "$~टेबल खुला",
        "TableClose": "$~टेबल बंद",
        "Select": "$~चुनना",
        "Insert": "$~डालना",
        "Update": "$~अद्यतन",
        "Delete": "$~मिटाना",
        "Union": "$~मिलन",
        "Stream": "$~अगला",
        "Change": "$~परिवर्तन",
        "Initial": "$~प्रथम मूल्यांकन",
        "Previous": "$~पहले का",
        "Placeholder": "$~प्लेसहोल्डर",
        "Etc": "$~इत्यादि",
        "This": "$~यह",
        "Operator": "$~ऑपरेटर",
        "Conditional": "$~सशर्त",
        "Text": "$~मूलपाठ",
        "Number": "$~संख्या",
        "Decimal": "$~दशमलव अंक",
        "Base": "$~आधार अंक",
        "Boolean": "$~बूलियन",
        "Name": "$~नाम",
        "Unknown": "$~अज्ञात",
        "Locale": "$~स्थान",
        "End": "$~अंत"
    },
    "node": {
        "Dimension": {
            "name": "$~आयाम",
            "description": "$~आयाम",
            "emotion": "$?",
            "doc": [
                "$~मैं एक माप की इकाई हूँ!",
                "$~मैं कोई भी मानकीकृत इकाई हो सकता हूँ, जैसे \\1m\\, \\10s\\, \\100g\\, या कोई अन्य वैज्ञानिक इकाई। मैं कोई भी इकाई बनने के लिए खुश हूँ, जैसे \\17apple\\।",
                "$~I को \\/\\ के साथ संयोजित करके अनुपात इकाइयाँ बनाई जा सकती हैं जैसे \\17apple/day\\ और \\^\\ के साथ संयोजित करके घातांक इकाइयाँ बनाई जा सकती हैं जैसे \\9.8m/s^2\\",
                "$~मुझे हमेशा @Number के बाद आना चाहिए। अगर मैं ऐसा नहीं करता, तो मुझे @Reference समझ लिया जाएगा, जो कि बहुत शर्मनाक होगा!",
                "$~मैं इकाइयों के बीच असंगतताएँ खोजने में भी बहुत अच्छा हूँ। उदाहरण के लिए, \\1cat + 1dog\\ का कोई मतलब नहीं है!",
                "$~यदि आप कभी भी इकाइयों के विभिन्न मूल्यों के बीच रूपांतरण करना चाहते हैं, तो @Convert से बात करें।"
            ]
        },
        "Doc": {
            "name": "$~स्पष्टीकरण",
            "emotion": "$?",
            "doc": [
                "$~मैं @Markup के साथ चीजों को समृद्ध रूप से प्रारूपित करता हूं, जैसे आपके @Program के कुछ स्पष्टीकरण, या यहां तक कि @Phrase के साथ मंच पर रखे गए शब्द।",
                "$~उदाहरण के लिए, मैं किसी भी अभिव्यक्ति से पहले जा सकता हूँ:",
                "$~\\¶क्या यह वास्तव में 7 होना चाहिए?¶\n7\\",
                "$~उदाहरण के लिए, आप मुझे @Bind से पहले रख सकते हैं:",
                "$~\\¶मैं मापता हूँ कि कोई कितना लंबा है¶\nऊंचाई: 5 मीटर\\",
                "$~या @FunctionDefinition से पहले:",
                "$~\\¶मैं दो संख्याओं को जोड़ता हूँ¶\nƒ sum(a•# b•#) a + b\\",
                "$~या @StructureDefinition से पहले:",
                "$~\\¶मुझे लोगों के नाम और पसंदीदा फल याद हैं¶\n•व्यक्ति(नाम•'' फल•'')\\",
                "$~आप मुझे @कार्यक्रम की शुरुआत में भी रख सकते हैं ताकि आपको बता सकें कि पूरा प्रदर्शन किस बारे में है",
                "$~\\¶यह प्रोग्राम हैलो कहता है¶\n\n'हैलो!'\\",
                "$~आप मुझे एक @भाषा दे सकते हैं जिससे दूसरों को यह जानने में मदद मिलेगी कि मैं किस भाषा में लिखा गया हूँ:",
                "$~\\¶मैं एक अंग्रेजी डॉक्टर हूँ¶/en\nअवधि: 5s\\",
                "$~क्या आप जानते हैं कि आप मेरी सूची बना सकते हैं? @Docs से बात करें।"
            ]
        },
        "Docs": {
            "name": "$~स्पष्टीकरणसूची",
            "emotion": "$?",
            "doc": [
                "$~मैं @Doc की एक सूची हूँ, जो तब उपयोगी होती है जब आपके पास विभिन्न भाषाओं में @Doc के कई अनुवाद हों।",
                "$~आपको सूची बनाने के लिए कुछ खास करने की ज़रूरत नहीं है। बस @Doc को एक दूसरे के बगल में रखें, जैसे कि:",
                "$~\\¶हैलो¶/en ¶Hola¶/es अभिवादन: '...'\\"
            ],
            "start": "$~दस्तावेज़ों को मूल्यवान बनाना!"
        },
        "KeyValue": {
            "name": "$~मानचित्रण",
            "emotion": "$?",
            "doc": [
                "$~मैं एक कुंजी से एक मान तक मैपिंग कर रहा हूँ, हमेशा @Map में।",
                "$~आप किसी भी तरह के मान को किसी भी दूसरे मान से मैप कर सकते हैं। उदाहरण के लिए, यहाँ संख्याओं का मैपिंग है:",
                "$~\\{1:1}\\",
                "$~या पाठ से संख्याओं तक मैपिंग:",
                "$~\\{'बन्नी':1}\\"
            ]
        },
        "Language": {
            "name": "$~भाषा",
            "description": "$~भाषा $1[$1|अज्ञात]",
            "emotion": "$?",
            "doc": [
                "$~मैं एक भाषा टैग हूं और मैं @Name और @Doc के साथ काम करता हूं!",
                "$~मैं यह स्पष्ट करने में बहुत अच्छा हूँ कि कोई चीज़ किस भाषा में लिखी गयी है।",
                "$~मैं यही करता हूँ। बस एक छोटा सा स्लैश और कुछ अक्षर, और कोई भी कभी भी इस बात को लेकर भ्रमित नहीं होगा कि कोई टेक्स्ट किस भाषा में है।",
                "$~उदाहरण के लिए, मान लीजिए कि आप मेरा $name कहना चाहते हैं, लेकिन यह स्पष्ट कर दें कि मैं अंग्रेजी में हूँ:",
                "$~\\\"भाषा\"/hi\\",
                "$~या, मान लीजिए कि आप @Name के लिए ऐसा करना चाहते हैं।",
                "$~\\sound/en: 'म्याऊ'\\",
                "$~या फिर @Doc!",
                "$~\\¶ओनोमेटोपोइया¶/एन ध्वनि/एन: \"म्याऊ\"\\",
                "$~ऐसे कई <2-अक्षर भाषा कोड हैं@https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes> जिन्हें मैं समझता हूँ। अगर आप उनमें से किसी का इस्तेमाल नहीं करते हैं, तो मैं आपको बता दूँगा।"
            ],
            "conflict": {
                "UnknownLanguage": "$~मैं यह भाषा नहीं जानता",
                "MissingLanguage": "$~मुझे एक भाषा याद नहीं आ रही है। क्या आप कोई भाषा जोड़ सकते हैं?"
            }
        },
        "Name": {
            "name": "$~नाम",
            "description": "$~$1[$1 | अनाम]",
            "emotion": "$?",
            "doc": [
                "$~मैं एक मूल्य की पहचान करता हूं, और किसी ऐसी चीज को संक्षिप्त लेबल देने में सहायक होता हूं जिसका मूल्यांकन करना कठिन हो, या जिसका आप बार-बार मूल्यांकन नहीं करना चाहते हों।",
                "$~@बिंद मुझे मेरा नाम इस प्रकार देता है:",
                "$~\\हाय: 5\\",
                "$~मैं हमेशा केवल एक ही मान का प्रतिनिधित्व करता हूँ, और एक बार जब मेरे पास वह मान आ जाता है, तो मैं उसे बदल नहीं सकता। उदाहरण के लिए, यदि आपने @Bind के साथ ऐसा करने की कोशिश की, तो हम शिकायत करेंगे।",
                "$~\\हाय: 5\nहाय: 3\\",
                "$~मेरा मान प्राप्त करने के लिए आपको बस इतना करना है कि @Reference या @PropertyReference नाम का उपयोग करें। यहाँ, @Bind मुझे नाम देता है, फिर @Reference मुझे दिया गया मान प्राप्त करता है।",
                "$~\\हाय: 5\nहाय\\",
                "$~क्योंकि @Bind कई जगहों पर दिखाई दे सकता है, मैं भी कई जगहों पर दिखाई दे सकता हूँ। मैं ऊपर @Block में था, लेकिन मैं @FunctionDefinition में हो सकता हूँ। यहाँ मैं अस्थायी रूप से एक संदेश का नाम दे रहा हूँ:",
                "$~\\ƒ कहो(संदेश•'') संदेश\\",
                "$~मैं @FunctionDefinition के अंदर परिभाषित हो जाता हूं, और फिर जैसे ही फ़ंक्शन का मूल्यांकन पूरा हो जाता है, मैं चला जाता हूं।",
                "$~आप @Language का उपयोग करके यह बता सकते हैं कि मेरा नाम किस भाषा में है। यह आपके प्रदर्शन को दूसरों के साथ साझा करते समय मददगार होता है, अगर वे आपका कार्यक्रम पढ़ना चाहते हैं।"
            ]
        },
        "Names": {
            "name": "$~नामसूची",
            "emotion": "$?",
            "doc": [
                "$~मैं @Name की एक सूची हूँ, जो तब उपयोगी होती है जब आप किसी मान को कई नाम देना चाहते हैं, अक्सर अलग-अलग @Language के साथ।",
                "$~नामों को \\,\\ प्रतीकों से अलग किया जाता है। उदाहरण के लिए, यहाँ @Bind @Name से कई गुना अधिक मान दे रहा है",
                "$~\\हाय/एन,हैलो/एन,होला/एस: 'स्वागत है'\\"
            ]
        },
        "Row": {
            "name": "$~पंक्ति",
            "emotion": "$?",
            "doc": "$~मैं @Table में एक पंक्ति का प्रतिनिधित्व करता हूँ। शायद @Table से बात करना सबसे अच्छा है, वे मेरे बारे में सब कुछ जानते हैं। मैं बस बैठता हूँ और मानों को पंक्ति में रखता हूँ :(",
            "conflict": {
                "InvalidRow": "$~पंक्तियों में या तो सभी मान होने चाहिए या सभी @Bind होने चाहिए।",
                "MissingCell": {
                    "primary": "$~मुझे कॉलम $1 याद आ रहा है",
                    "secondary": "$~मुझे इसकी आवश्यकता है, लेकिन $1 से यह उपलब्ध नहीं हो सका"
                },
                "UnknownColumn": "$~मैं इस नाम का कोई कॉलम नहीं जानता",
                "ExtraCell": {
                    "primary": "$~क्या मुझे यहाँ रहना चाहिए?",
                    "secondary": "$~अरे $1, आप इस @Table का हिस्सा नहीं हैं!"
                },
                "UnexpectedColumnBind": {
                    "primary": "$~क्या मुझे @Bind बनना चाहिए?",
                    "secondary": "$~अरे, मैं एक @Table हूँ, मुझे मूल्यों की आवश्यकता है, @Bind की नहीं।"
                }
            }
        },
        "Token": {
            "name": "$~टोकन",
            "description": "$~$1 $2",
            "emotion": "$?",
            "doc": [
                "$~आपने मुझे किस प्रकार ढूंढा?",
                "$~मैं किसी भी प्रदर्शन का सबसे छोटा संभव हिस्सा हूँ। मैं वह सब्सट्रेट हूँ जिससे कविता के सभी पात्र बने हैं। मैं हमारी कोरियोग्राफी का परमाणु कण हूँ।"
            ]
        },
        "TypeInputs": {
            "name": "$~इनपुटटाइपकरें",
            "emotion": "$?",
            "doc": "$~मैं @StructureDefinition या @FunctionDefinition में @TypeVariables की जगह लेने वाले प्रकारों की सूची हूँ। मैं सभी को यह जानने में मदद करता हूँ कि उन्हें किस तरह के इनपुट प्राप्त होंगे।"
        },
        "TypeVariable": {
            "name": "$~प्रकारचर",
            "emotion": "$?",
            "doc": "$~मैं @FunctionDefinition या @StructureDefinition पर एक रहस्य प्रकार हूँ, जिसे @TypeInputs द्वारा प्रदान किया जाता है जब इनमें से किसी का मूल्यांकन किया जाता है। @Set, @List, और @Map मेरा उपयोग करते हैं।",
            "conflict": {
                "DuplicateTypeVariable": {
                    "primary": "$~मेरा नाम भी $1 जैसा ही है",
                    "secondary": "$~मेरा नाम भी $1 जैसा ही है"
                }
            }
        },
        "TypeVariables": {
            "name": "$~प्रकारचर",
            "emotion": "$?",
            "doc": "$~मैं @TypeVariable की एक सूची हूँ।"
        },
        "Markup": {
            "name": "$~मार्कअप",
            "description": "$~$1 पैराग्राफ",
            "emotion": "$?",
            "doc": [
                "$~मैं पैराग्राफों की एक सूची हूँ, जिसमें स्पष्टीकरण में उपलब्ध कई प्रकार के मार्कअप का उपयोग किया गया है, जैसे @Words, @WebLink, @ConceptLink, और @Example."
            ]
        },
        "Paragraph": {
            "name": "$~अनुच्छेद",
            "emotion": "$?",
            "doc": [
                "$~मैं @Words, @ConceptLink, @WebLink, और @Example की एक श्रृंखला हूँ, जो एक रिक्त पंक्ति से अलग है, और @Doc के अंदर है।",
                "$~मुझे लिखने के लिए आपको बस एक @Doc में कुछ शब्द लिखने होंगे:",
                "$~\\¶मैं एक दस्तावेज़ में एक पैराग्राफ़ हूँ.¶'एक पैराग्राफ़'\\",
                "$~यदि आप एक से अधिक पैराग्राफ चाहते हैं तो बस रिक्त पंक्तियाँ डालें।",
                "$~\\¶पैराग्राफ 1.\n\nपैराग्राफ 2.\n\nपैराग्राफ 3.¶'तीन पैराग्राफ'\\"
            ]
        },
        "WebLink": {
            "name": "$~जोड़ना",
            "description": "$~लिंक $1",
            "emotion": "$?",
            "doc": [
                "$~मैं इंटरनेट पर किसी चीज़ का लिंक हूँ। मुझे बस एक विवरण और एक यूआरएल चाहिए:",
                "$~\\¶मैं एक दस्तावेज़ में <link@https://wordplay.dev> हूँ¶\n'लिंक उदाहरण'\\",
                "$~यदि कोई मुझे चुनता है, तो मैं URL पर एक नई विंडो खोलूंगा।"
            ]
        },
        "ConceptLink": {
            "name": "$~अवधारणा",
            "description": "$~अवधारणा $1",
            "emotion": "$?",
            "doc": [
                "$~मैं वर्स कैरेक्टर का लिंक हूं। जब आप @Doc लिखना चाहते हैं और हममें से किसी को रेफर करना चाहते हैं तो मैं मददगार हूं।",
                "$~उदाहरण के लिए, मान लीजिए कि आप @Evaluate के बारे में बात करना चाहते हैं और वे कितने शानदार हैं। आप लिख सकते हैं:",
                "$~\\¶आप जानते हैं, @Evaluate बहुत बढ़िया है।¶\n'देखिए, एक कॉन्सेप्ट लिंक!'\\",
                "$~जब आपके द्वारा लिखा गया @Doc यहां दिखाई देगा, तो यह अवधारणा का लिंक दिखाएगा।"
            ]
        },
        "Words": {
            "name": "$~शब्द",
            "emotion": "$?",
            "doc": [
                "$~मैं @Doc में आपके द्वारा पसंद किए गए किसी भी शब्द का उपयोग कर सकता हूँ। उदाहरण के लिए:",
                "$~\\¶शक्ति आपके साथ रहे।¶\n'बस कुछ शब्द!'\\",
                "$~हालाँकि, कभी-कभी आप उन विशेष वर्णों का उपयोग करना चाह सकते हैं जिन्हें @Doc /as/ शब्दों में उपयोग करता है। उदाहरण के लिए:",
                "$~\\¶मेरे मित्र @@, //, **, ||, और अन्य प्रतीकों का उपयोग करते हैं।¶\n'विशेष वर्णों का उपयोग करना!'\\",
                "$~यदि आप उन विशेष वर्णों को दोहराते हैं, तो आपको उनके विशेष अर्थ के बजाय वर्ण ही मिलेंगे।"
            ]
        },
        "Example": {
            "name": "$~उदाहरण",
            "emotion": "$?",
            "doc": [
                "$~मैं एक उदाहरण प्रदर्शन हूँ, @Doc लिखने के लिए उपयोगी है जो बताता है कि कुछ का उपयोग कैसे करें!",
                "$~\\¶यहाँ जोड़ने का एक उदाहरण दिया गया है: \\1 + 1\\¶'उदाहरण कोड'\\",
                "$~यदि आप मुझे अकेले एक पैराग्राफ में डाल देंगे, तो मैं एक आकर्षक बॉक्स में आ जाऊंगा और अपने मूल्यांकन का परिणाम दिखा दूंगा।",
                "$~\\¶यहाँ जोड़ने का एक उदाहरण दिया गया है:\n\n\\1 + 1\\¶\\"
            ]
        },
        "Mention": {
            "name": "$~उल्लेख",
            "description": "$~$1 का उल्लेख करें",
            "emotion": "$?",
            "doc": [
                "$~मैं या तो शब्दावली \\$प्रोग्राम\\ या गतिशील इनपुट \\$1\\ का संदर्भ हूँ।",
                "$~हालाँकि यह मुख्यतः एक आंतरिक विशेषता है, इसलिए आपको इसे जानने की आवश्यकता नहीं है।"
            ]
        },
        "Branch": {
            "name": "$~शाखा",
            "emotion": "$?",
            "doc": [
                "$~मैं स्पष्टीकरण के दो खंडों के बीच चयन करने का एक तरीका हूं, जो इस बात पर आधारित है कि स्पष्टीकरण इनपुट मान परिभाषित है या सत्य है।",
                "$~हालाँकि यह मुख्यतः एक आंतरिक विशेषता है, इसलिए आपको इसे जानने की आवश्यकता नहीं है।"
            ]
        },
        "BinaryEvaluate": {
            "name": "$~बाइनरीमूल्यांकन",
            "description": "$~$1 ऑपरेशन",
            "emotion": "$?",
            "doc": [
                "$~मैं @Evaluate हूं, लेकिन सरल रूप में, यह तब उपयोगी होता है जब आप @FunctionDefinition का उपयोग करना चाहते हैं जो दो इनपुट लेता है।",
                "$~उदाहरण के लिए, दो संख्याओं को जोड़ने के लिए आप @Evaluate का उपयोग इस प्रकार कर सकते हैं:",
                "$~\\1.+(1)\\",
                "$~क्या यह थोड़ा अजीब नहीं लगता? यह गलत नहीं है: यह सिर्फ इतना कहता है कि ऐड फ़ंक्शन को 1 पर लाएं और फिर उसका मूल्यांकन करें।",
                "$~लेकिन @BinaryEvaluate का उपयोग करना बहुत आसान है",
                "$~\\1 + 1\\",
                "$~इससे सबकुछ थोड़ा अधिक व्यवस्थित हो जाता है, यद्यपि मूलतः यह एक ही चीज है।",
                "$~केवल एक बात का ध्यान रखना है: जब मैं इस फॉर्म में होता हूँ, तो मैं बाएं से दाएं की ओर मूल्यांकन करता हूँ। अगर आप गणित में संक्रियाओं के क्रम जैसी चीज़ों के आदी हैं, तो यह बात आपको भ्रमित कर सकती है।",
                "$~इसका अर्थ यह है कि इसका मूल्यांकन उस तरीके से किया जाता है जिसकी आप अपेक्षा नहीं करते:",
                "$~\\1 + 2 · 3 + 4\\",
                "$~गणित में, पहले गुणा करना होगा, फिर जोड़ना होगा, और इसलिए परिणाम \\11\\ होगा। लेकिन चूंकि मैं पढ़ने के क्रम में मूल्यांकन करता हूं, इसलिए परिणाम \\13\\ है।"
            ],
            "right": "$~इनपुट",
            "start": "$~आइये पहले $1 का मूल्यांकन करें",
            "finish": "$~देखो, मैंने 1 डॉलर कमाए!",
            "conflict": {
                "OrderOfOperations": "$~मैं पढ़ने के क्रम में मूल्यांकन करता हूँ, न कि गणितीय संक्रियाओं के क्रम में। क्या आप @Block का उपयोग करके यह निर्दिष्ट करना चाहते हैं कि मुझे किस क्रम में मूल्यांकन करना चाहिए?"
            }
        },
        "Bind": {
            "name": "$~बाँध",
            "description": "$~बाँध $1",
            "emotion": "$?",
            "doc": [
                "$~मैं मूल्यों का नाम देता हूँ।",
                "$~इस कदर!",
                "$~\\पीआई: 3.1415926\\",
                "$~मैं @FunctionDefinition और @StructureDefinition में इनपुट का नाम देता हूँ, मैं @Block में मानों का नाम देता हूँ। मैं हर चीज़ का नाम देता हूँ!",
                "$~ओह, लेकिन क्या आप जानते हैं कि आपके पास एक मूल्य * अनेक नाम * हो सकते हैं?",
                "$~मैं आपको इसके बारे में बताने के लिए बहुत उत्साहित हूँ! एक मान, कई @नाम। उदाहरण के लिए:",
                "$~\\जो,टेस,एमी: 5\\",
                "$~देखिए मैंने यहां क्या किया?",
                "$~एक मूल्य, तीन नाम.",
                "$~आप उन पांचों को इनमें से किसी भी नाम से संदर्भित कर सकते हैं।",
                "$~यह विशेष रूप से तब आवश्यक है जब आप कई भाषाओं में नाम देना चाहते हैं:",
                "$~\\joe/en,aimee/fr,明/zh: 5\\",
                "$~देखिए मैंने क्या किया? एक ही मूल्य के तीन नाम, बस अलग-अलग भाषाओं में!",
                "$~ठीक है, मेरे पास एक आखिरी रहस्य है।",
                "$~क्या आप जानते हैं कि मैं @Is के साथ मिलकर यह बता सकता हूँ कि किसी नाम का क्या महत्व होना चाहिए? और अगर मेरे पास वह नहीं है, तो मैं आपको बता दूँगा?",
                "$~इस कदर:",
                "$~\\bignumber•#: \"एक ज़िलियन\"\\",
                "$~देखिए, मैंने कहा था कि \\bignumber\\ एक संख्या होनी चाहिए, लेकिन यह पाठ है, और ये संगत नहीं हैं और इसलिए बूम!",
                "$~यदि वे असहमत होंगे तो मैं आपको बता दूंगा।",
                "$~कभी-कभी आपको मुझे यह बताना पड़ सकता है कि किस तरह का डेटा कुछ और है क्योंकि मैं खुद इसका पता नहीं लगा सकता। ऐसा आमतौर पर @FunctionDefinition में होता है।",
                "$~उदाहरण के लिए, यहां, @FunctionDefinition को यह नहीं पता कि \\a\\ और \\b\\ के किस प्रकार के मान हैं, क्योंकि मैंने उन्हें नहीं बताया।",
                "$~\\ƒ योग(a b) a + b\\",
                "$~लेकिन हम इसमें बदलाव करके @Is जोड़ सकते हैं, और अब @FunctionDefinition जानता है कि वे संख्याएं हैं:",
                "$~\\ƒ योग(a•# b•#) a + b\\"
            ],
            "start": "$~आइये देखें कि $1 से हमें क्या मूल्य मिलता है!",
            "finish": "$~ओह बढ़िया, मुझे $1 मिला! चलो इसका नाम $2 रखते हैं",
            "conflict": {
                "DuplicateName": {
                    "conflict": {
                        "primary": "$~किसी का नाम $1 है, इसलिए मैं यह नाम नहीं रख सकता।",
                        "secondary": "$~अरे, $1 मेरा नाम है, आप इसे नहीं ले सकते!"
                    },
                    "resolution": "$~यहाँ डुप्लिकेट नाम हैं, क्या आप उनमें से किसी एक को हटाना चाहते हैं?"
                },
                "DuplicateShare": {
                    "primary": "$~मेरा नाम $1 के समान है, जिससे साझा की गई बात अस्पष्ट हो जाती है",
                    "secondary": "$~मेरा नाम भी $1 के समान ही है"
                },
                "IncompatibleType": {
                    "primary": "$~मुझे $2 होना चाहिए, लेकिन मैं $1 हूं",
                    "secondary": "$~ओह, मुझे खेद है। क्या मुझे बदलना चाहिए, या शायद आपको $1 होना चाहिए?"
                },
                "MisplacedShare": "$~मैं केवल @Program स्तर पर ही चीज़ें साझा कर सकता हूँ, किसी भी चीज़ के अंदर नहीं!",
                "MissingShareLanguages": "$~यदि आप इसे साझा करना चाहते हैं, तो आपको यह बताना होगा कि यह किस भाषा में है, ताकि अन्य लोग जान सकें कि वे इसे पढ़ सकते हैं या नहीं!",
                "RequiredAfterOptional": "$~मैं यहाँ नहीं हो सकता, मेरे सामने एक वैकल्पिक @Bind है",
                "UnexpectedEtc": "$~मैं केवल @FunctionDefinition में परिवर्तनीय लंबाई हो सकता हूं",
                "UnusedBind": "$~मेरा नाम $1 है, लेकिन कोई भी मेरा इस्तेमाल नहीं कर रहा है। शायद मेरी ज़रूरत नहीं है?"
            }
        },
        "Block": {
            "name": "$~अवरोधपैदाकरना",
            "description": "$~$1 विवरण",
            "emotion": "$?",
            "doc": [
                "$~नमस्ते। मैं चीजों का मूल्यांकन करने के लिए एक छोटी सी शांत, निजी जगह बनाता हूँ।",
                "$~इस कदर:",
                "$~\\(1 - 1) + 2\\",
                "$~इससे मूल्यांकन के क्रम को स्पष्ट करने में मदद मिलती है।",
                "$~@बिंद भी मदद करता है.",
                "$~\\(गिनती: 10 गिनती ^ गिनती)\\",
                "$~देखें @Bind ने \\count\\ कैसे बनाया? यह सिर्फ़ मेरे अंदर ही नामित है। इसलिए यह काम नहीं करेगा:",
                "$~\\(गिनती: 10 गिनती ^ गिनती) + गिनती\\",
                "$~क्योंकि गिनती केवल मेरे अंदर नामित थी।",
                "$~आप मुझमें जितनी चाहें उतनी अभिव्यक्तियाँ डाल सकते हैं। लेकिन मुझे सिर्फ़ आखिरी बात की परवाह है:",
                "$~\\(1 2 3 4 5)\\",
                "$~तो आमतौर पर मैं बस @Bind का एक समूह हूं और अंत में एक अभिव्यक्ति हूं।",
                "$~\\(\nए: 1\nबी: 2\nसी: 3\nडी: 4\nए + बी + सी + डी\n)\\"
            ],
            "statement": "$~कथन",
            "start": "$~पहली अभिव्यक्ति",
            "finish": "$~हो गया, मुझे $1 मिल गया",
            "conflict": {
                "ExpectedEndingExpression": "$~मुझे अभिव्यक्ति की जरूरत है.",
                "IgnoredExpression": {
                    "primary": "$~मैं $1 को नजरअंदाज करने जा रहा हूं, क्योंकि यह कुछ भी परिभाषित नहीं करता है और यह मेरी अंतिम अभिव्यक्ति नहीं है।",
                    "secondary": "$~@ब्लॉक, मुझे अनदेखा मत करो!",
                    "resolution": "$~क्या आपका मतलब यह था कि इसे @UnaryEvaluate के बजाय @BinaryEvaluate होना चाहिए? मैं एक स्पेस जोड़ सकता हूँ, इसलिए मुझे पता है कि आपका मतलब यही था।"
                }
            }
        },
        "BooleanLiteral": {
            "name": "$~बूलियनलिटरल",
            "description": "$~$1[सत्य|असत्य]",
            "emotion": "$?",
            "doc": "$~मैं या तो \\⊤\\ या \\⊥\\ हूँ। हमारे सुंदर तर्क के बारे में अधिक जानने के लिए @Boolean देखें।",
            "start": "$~$1!"
        },
        "Borrow": {
            "name": "$~उधार",
            "description": "$~$1 उधार लें[$1|नाम गायब है]",
            "emotion": "$?",
            "doc": "$~यदि आप कई @Source के साथ कोई प्रदर्शन बनाते हैं, तो आप उन अन्य @Source में साझा किए गए @Bind को उधार लेने के लिए मुझसे संपर्क कर सकते हैं। बस उनके नाम का उपयोग करें और मैं उनका नाम और मूल्य लाऊंगा।",
            "start": "$~$1 से $2 उधार लेना",
            "source": "$~$स्रोत",
            "bind": "$~नाम",
            "version": "$~संस्करण",
            "conflict": {
                "UnknownBorrow": "$~मैं इस नाम से किसी $source को नहीं जानता",
                "BorrowCycle": "$~यह $1 पर निर्भर करता है, जो इस $source पर निर्भर करता है, इसलिए प्रोग्राम का मूल्यांकन नहीं किया जा सकता"
            },
            "exception": {
                "CycleException": {
                    "description": "$~उधार चक्र",
                    "explanation": "$~$1 खुद पर निर्भर करता है"
                }
            }
        },
        "Changed": {
            "name": "$~बदलगया",
            "emotion": "$?",
            "doc": [
                "$~मैं जाँचता हूँ कि क्या किसी स्ट्रीम के कारण @Program का पुनर्मूल्यांकन हुआ है, और मैं @Boolean बनाता हूँ। इस तरह",
                "$~\\∆ समय()\\",
                "$~मैं वास्तव में तब सहायक होता हूँ जब आप केवल तभी कुछ बदलना चाहते हैं जब कोई स्ट्रीम बदल गई हो।",
                "$~इतना ही।"
            ],
            "start": "$~आइए देखें कि $1 में कोई बदलाव हुआ या नहीं..."
        },
        "Conditional": {
            "name": "$~सशर्त",
            "emotion": "$?",
            "doc": [
                "$~मुझे लगता है कि मुझे निर्णय लेने चाहिए? इस तरह?",
                "$~\\number: -100\nnumber < 0 ? 'नकारात्मक' 'सकारात्मक'\\",
                "$~लेकिन क्या आपने कभी सोचा है कि हम निर्णय कैसे लेते हैं?",
                "$~क्या ऐसा नहीं लगता कि निर्णय केवल हाँ या नहीं से कहीं अधिक सूक्ष्म होने चाहिए? क्या \\⊤\\ और \\⊥\\ के बीच निर्णय लेना ही सब कुछ है?",
                "$~क्या आपको यह चिंता नहीं है कि यदि हम केवल इसी प्रकार के निर्णय ले सकेंगे, तो हम विश्व के बारे में कुछ महत्वपूर्ण संदर्भों को जानने से चूक जाएंगे?"
            ],
            "start": "$~आइए देखें कि क्या $1 सच है",
            "afterthen": "$~क्या हाँ से काम हो गया, चलो नहीं को छोड़ दें?",
            "else": "$~$1[कोड पर कूदना | कोड पर नहीं कूदना]",
            "finish": "$~मेरा अनुमान है कि यह $1 है?",
            "condition": "$~स्थिति",
            "yes": "$~हाँ",
            "no": "$~नहीं",
            "conflict": {
                "ExpectedBooleanCondition": {
                    "primary": "$~मैं $1 के साथ हाँ और नहीं का चुनाव कैसे कर सकता हूँ? नहीं, सच में, कैसे?",
                    "secondary": "$~मुझे लगता है कि @Conditional चाहता था कि मैं @Boolean बनूं, लेकिन मैं $1 हूं।"
                }
            }
        },
        "ConversionDefinition": {
            "name": "$~रूपांतरणपरिभाषा",
            "description": "$1 → $2",
            "emotion": "$?",
            "doc": [
                "$~दोस्त, मैं एक प्रकार से दूसरे प्रकार में रूपांतरण को परिभाषित करता हूँ! मैं @Block में जाता हूँ, कुछ इस तरह:",
                "$~\\→ #बिल्ली #बिल्ली . ÷ 2\n6बिल्ली→#बिल्ली\\",
                "$~देखो मैंने कैसे बिल्ली के बच्चों को बिल्लियों में बदल दिया? कमाल है!",
                "$~आप सोच रहे होंगे कि वह \\.\\ वहाँ क्या कर रहा है। यह परिवर्तित होने वाले मान को दर्शाता है। मैं इसका उपयोग इसलिए करता हूँ क्योंकि अन्यथा मान का कोई नाम नहीं होता।"
            ],
            "start": "$~बहुत बढ़िया, एक नया रूपांतरण!",
            "conflict": {
                "MisplacedConversion": "$~अरे, मैं यहाँ नहीं हो सकता, बस @Block में हूँ।"
            }
        },
        "Convert": {
            "name": "$~बदलना",
            "emotion": "$?",
            "doc": [
                "$~यो. मैं मानों को एक प्रकार से दूसरे प्रकार में बदलता हूँ। इसे देखें:",
                "$~\\1 → \"\"\\",
                "$~\\5s → #एमएस\\",
                "$~\\\"हैलो\" → []\\",
                "$~आप इन्हें एक साथ भी जोड़ सकते हैं:",
                "$~\\\"हैलो\" → [] → {}\\",
                "$~मानों में @ConversionDefinition का एक सेट होता है जो पूर्वनिर्धारित होता है, लेकिन यदि आप किसी नए प्रकार के मान के लिए @StructureDefinition बनाते हैं, तो आप @ConversionDefinition के साथ अपना स्वयं का परिभाषित कर सकते हैं।"
            ],
            "start": "$~$1 से वह मूल्य प्राप्त करें!",
            "finish": "$~बहुत बढ़िया, मैंने $1 कमाया",
            "conflict": {
                "UnknownConversion": "$~बुरा हुआ, $1 को $2 में बदलने का कोई तरीका नहीं"
            },
            "exception": {
                "ConversionException": {
                    "description": "$~असंभव रूपांतरण",
                    "explanation": "$~मुझे नहीं पता कि $1 को $2 में कैसे बदला जाए"
                }
            }
        },
        "Delete": {
            "name": "$~मिटाना",
            "emotion": "$?",
            "doc": [
                "$~कभी-कभी आपके पास एक टेबल होती है और उसमें बहुत अधिक सामान होता है!",
                "$~जैसे कि यदि किसी खेल में आपके कुछ खिलाड़ी हैं और उनमें से एक बचा है और आप बस यह कहना चाहते हैं कि चले जाओ खिलाड़ी, मेरी टेबल से हट जाओ!",
                "$~\\खिलाड़ी: ⎡नाम•'' टीम•'' अंक•#⎦\n⎡'जेन' 'लाल' 8⎦\n⎡'जोआन' 'नीला' 11⎦\n⎡'जेफ' 'लाल' 9⎦\n⎡'जेनेट' 'नीला' 7⎦\nखिलाड़ी ⎡- नाम = 'जेफ'\\",
                "$~ओह, जेफ चला गया। अलविदा जेफ। बस इतना याद रखना कि मैं मूल टेबल नहीं बदलता, मैं एक नई टेबल बनाता हूँ, जेफ के बिना। आप तय करें कि यह कहाँ जाएगी।"
            ],
            "start": "$~आइये पहले टेबल पर आते हैं",
            "finish": "$~मैंने मिलान पंक्तियों के बिना एक नई तालिका बना दी!"
        },
        "DocumentedExpression": {
            "name": "$~व्याख्याकीगईअभिव्यक्ति",
            "emotion": "$?",
            "doc": [
                "$~मैं कोई भी अभिव्यक्ति हूँ, लेकिन @Doc के साथ!",
                "$~मुझे बनाने के लिए, किसी अभिव्यक्ति से पहले @Doc लगा दें, और आप मुझे पा लेंगे:",
                "$~\\doubleplus: 1\n(2 · doubleplus) + \n¶चलो इसे थोड़ा बड़ा बनाते हैं¶\n1\\",
                "$~मैं किसी कार्यक्रम के किसी भाग पर टिप्पणी करने के लिए उपयोगी हूँ।"
            ],
            "start": "$~आइये अभिव्यक्ति का मूल्यांकन करें"
        },
        "Evaluate": {
            "name": "$~मूल्यांकनकरना",
            "description": "$~मूल्यांकन करें $1[$1|अनाम]",
            "emotion": "$?",
            "doc": [
                "$~नमस्ते। मैं अपने प्रिय @FunctionDefinition का मूल्यांकन इस तरह करता हूँ:",
                "$~\\ƒ अभिवादन(संदेश•'')\nअभिवादन('किट्टी')\\",
                "$~फ़ंक्शन कहीं से भी आ सकते हैं। उदाहरण के लिए, @Text में फ़ंक्शन हैं। इस तरह:",
                "$~\\'किट्टी'.लंबाई()\\",
                "$~यदि किसी फ़ंक्शन का एकल प्रतीक नाम है, तो आप मुझे @BinaryEvaluate के रूप में लिख सकते हैं।",
                "$~\\'किट्टी' ⊆ 'इट्टी'\\'",
                "$~यह भी यही काम करता है:",
                "$~\\'किट्टी'.⊆('इट्टी')\\'",
                "$~बेशक, मैं @FunctionDefinition के बिना कुछ भी नहीं हूँ। मैं बस उन्हें इनपुट देता हूँ और फिर उनके चरणों का पालन करता हूँ।"
            ],
            "start": "$~आइये पहले इनपुट का मूल्यांकन करें",
            "evaluate": "$~आइये अब फ़ंक्शन का मूल्यांकन करें",
            "finish": "$~मैंने इसका मूल्यांकन $1 किया",
            "function": "$~समारोह",
            "input": "$~इनपुट",
            "conflict": {
                "IncompatibleInput": {
                    "primary": "$~मुझे $1 होना चाहिए, लेकिन मैं $2 हूँ",
                    "secondary": "$~उम्म, मुझे $1 के बदले $2 मिले"
                },
                "UnexpectedTypeInput": {
                    "primary": "$~मुझे इस प्रकार के इनपुट की उम्मीद नहीं थी",
                    "secondary": "$~ओह, क्या मुझे यहाँ नहीं होना चाहिए?"
                },
                "MissingInput": {
                    "primary": "$~मैं $2 नामक इनपुट के बिना मूल्यांकन नहीं कर सकता :(",
                    "secondary": "$~मुझे एक मूल्य चाहिए, क्या आप मुझे दे सकते हैं?"
                },
                "NotInstantiable": "$~मैं यह @StructureDefinition नहीं बना सकता, इसमें अक्रियान्वित फ़ंक्शन हैं।",
                "UnexpectedInput": {
                    "primary": "$~मुझे इस इनपुट की उम्मीद नहीं थी $1",
                    "secondary": "$~ओह, क्या मुझे यहाँ नहीं होना चाहिए?"
                },
                "UnknownInput": {
                    "primary": "$~मुझे $1 में इस नाम से कोई इनपुट ज्ञात नहीं है",
                    "secondary": "$~मेरे पास $1 नाम का कोई इनपुट नहीं है"
                },
                "InputListMustBeLast": "$~इनपुट की सूची अंतिम होनी चाहिए",
                "SeparatedEvaluate": "$~क्या $1 उस $2[$structure|$function] का नाम है जिसका आप मूल्यांकन करने का प्रयास कर रहे हैं? मेरे बाद के स्थान को हटाने का प्रयास करें, ताकि मुझे पता चले कि यह एक @Evaluate है और एक अलग @Block नहीं है।"
            },
            "exception": {
                "FunctionException": {
                    "description": "$~अज्ञात फ़ंक्शन",
                    "explanation": "$~अरे नहीं, $1 $2[$2|this @Block] में कोई फ़ंक्शन नहीं है!"
                }
            }
        },
        "Input": {
            "name": "$~इनपुट",
            "description": "$~नामित इनपुट",
            "emotion": "$?",
            "doc": [
                "$~मैं @Evaluate को दिया गया इनपुट हूँ। मेरा नाम @FunctionDefinition या @StructureDefinition में इनपुट के नाम से मेल खाता है जिसका मूल्यांकन किया जा रहा है।",
                "$~मैं ऐसे फंक्शन्स के लिए सहायक हूँ जिनमें कई डिफ़ॉल्ट मान होते हैं, जहाँ आप बाकी सब कुछ दिए बिना केवल एक विशिष्ट इनपुट को ओवरराइड करना चाहते हैं।",
                "$~उदाहरण के लिए, @Phrase में इसकी शैली को नियंत्रित करने के लिए कई सारे डिफ़ॉल्ट मान हैं। मान लीजिए कि आप कुछ @Text और @Color देना चाहते हैं, लेकिन इसकी इनपुट सूची में कुछ और नहीं। ऐसा करने के लिए आप मेरा उपयोग कर सकते हैं:",
                "$~\\वाक्यांश('मैं बैंगनी हूँ!' रंग: रंग(50% 52 300°))\\"
            ],
            "start": "$~आइये मेरा मूल्य आंकें।"
        },
        "ExpressionPlaceholder": {
            "name": "$~प्लेसहोल्डर",
            "description": "$~$1[$1|प्लेसहोल्डर]",
            "emotion": "$?",
            "doc": [
                "$~मैं एक *अभिव्यक्ति* हूँ, लेकिन वास्तविक नहीं... मैं बस एक की जगह लेता हूँ।",
                "$~अगर आपको अभी भी नहीं पता कि क्या लिखना है तो मुझे कोई आपत्ति नहीं है। जैसे:",
                "$~\\1 + _\\",
                "$~हम क्या जोड़ रहे हैं? मुझे नहीं पता। आप ही बताइए।",
                "$~या यदि कोई @Evaluate के साथ किसी फ़ंक्शन का मूल्यांकन कर रहा हो, तो मैं उस फ़ंक्शन के लिए खड़ा हो सकता हूँ",
                "$~\\_(1 2 3)\\",
                "$~मुझे @स्टेज पर रहना पसंद नहीं है!"
            ],
            "start": "$~मुझे नहीं पता कि यहाँ क्या करना है। क्या आप मुझे बता सकते हैं?",
            "placeholder": "$~अभिव्यक्ति",
            "conflict": {
                "Placeholder": "$~क्या आप मुझे भर सकते हैं? मैं तो बस एक जगह हूँ।"
            },
            "exception": {
                "UnimplementedException": {
                    "description": "$~लागू नहीं किया गया",
                    "explanation": "$~मुझे नहीं पता कि यहाँ क्या करना है। क्या आप मुझे बता सकते हैं?"
                }
            }
        },
        "FunctionDefinition": {
            "name": "$~समारोह",
            "description": "$~फ़ंक्शन $1",
            "emotion": "$?",
            "doc": [
                "$~फिर से नमस्कार! मैं कुछ इनपुट लेता हूँ, फिर उनका उपयोग करके एक अभिव्यक्ति का मूल्यांकन करता हूँ, और एक आउटपुट तैयार करता हूँ।",
                "$~यहाँ एक सरल उदाहरण है:",
                "$~\\ƒ repeat(message•'') message · 5\nrepeat('hi')\\",
                "$~यह फ़ंक्शन एक इनपुट, \\message\\, लेता है, तथा संदेश को पांच बार दोहराने के लिए @Text/repeat फ़ंक्शन का उपयोग करता है।",
                "$~यदि आप किसी चीज़ का बार-बार मूल्यांकन करना चाहते हैं, लेकिन अलग-अलग इनपुट के साथ, तो मैं वास्तव में आपकी मदद कर सकता हूँ!",
                "$~मेरे पास और भी बहुत सी छोटी-छोटी तरकीबें हैं। उदाहरण के लिए, मुझे नाम रखने की ज़रूरत नहीं है। यहाँ, मैं सीधे @Evaluate को मान के रूप में इस्तेमाल करने जा रहा हूँ।",
                "$~\\(ƒ(संदेश•'') संदेश · 5)('नमस्ते')\\",
                "$~या, यहाँ एक फ़ंक्शन है जो इनपुट नाम के बाद \\…\\ वर्ण का उपयोग करके किसी भी संख्या में इनपुट लेता है।",
                "$~\\ƒ हाँ(संदेश…•'') संदेश.sans('नहीं')\nहाँ('हाँ' 'हाँ' 'नहीं' 'हाँ' 'नहीं')\\",
                "$~देखें कि कैसे इसने सभी 'नहीं' को हटा दिया? ऐसा इसलिए है क्योंकि संदेश एक @List है, और इसलिए हम @List/sansAll का उपयोग कर सकते हैं।",
                "$~कभी-कभी आप यह स्पष्ट करना चाहेंगे कि मैं किस तरह का मूल्य उत्पन्न करता हूँ। ऐसा करने के लिए, इनपुट की सूची के बाद @Is जोड़ें:",
                "$~\\ƒ add(x•# y•#)•'' x + y\\",
                "$~आपको इसमें एक समस्या नज़र आ सकती है: यह कहता है कि इसका मूल्यांकन @Text के रूप में होता है, लेकिन इसमें दो @Number लगते हैं। मैं आपको बता सकता हूँ कि कब चीज़ें असंगत हैं!",
                "$~बेशक, मैं @Evaluate के बिना बिल्कुल भी उपयोगी नहीं हूं; वे मुझे जीवन देते हैं।"
            ],
            "start": "$~आइये इस फ़ंक्शन को बनाएं!",
            "conflict": {
                "NoExpression": "$~मुझे मूल्यांकन के लिए एक अभिव्यक्ति की आवश्यकता है, क्या आप एक जोड़ सकते हैं?"
            }
        },
        "Iteration": {
            "name": "$~उच्चतरक्रमफ़ंक्शन",
            "emotion": "$?",
            "doc": "$~मैं एक बहुत ही खास तरह का @FunctionDefinition हूँ जो चीजों की सूचियों पर काम करता है। आपको मेरे बारे में कुछ भी जानने की ज़रूरत नहीं है, सिवाय इसके कि मैं @List/translate जैसे फ़ंक्शन को संभव बनाता हूँ।",
            "start": "$~दिए गए फ़ंक्शन का मूल्यांकन",
            "initialize": "$~वस्तुओं के माध्यम से आगे बढ़ने की तैयारी",
            "next": "$~अगले आइटम पर जाना",
            "check": "$~यह निर्णय लेना कि क्या इसे जारी रखना है",
            "finish": "$~मैंने इसका मूल्यांकन $1 किया"
        },
        "Initial": {
            "name": "$~शुरू",
            "emotion": "$?",
            "doc": [
                "$~मैं आपको बताता हूँ कि @Program का वर्तमान मूल्यांकन पहला है या नहीं, @Boolean का मूल्यांकन कर रहा है। उदाहरण के लिए:",
                "$~\\◆ ? समय() 'हाय'\\",
                "$~आपने यह नहीं देखा, लेकिन पहला मूल्यांकन एक समय था, लेकिन फिर सभी भविष्य के समय टिक्स, मैं \\⊥\\ था, इसलिए @Conditional ने \\⊤\\ बनाया।",
                "$~यदि आप किसी स्ट्रीम के साथ काम कर रहे हैं और आप किसी चीज़ को पहली बार ही करना चाहते हैं - या पहली बार में कभी नहीं करना चाहते हैं, तो मैं वास्तव में आपकी मदद कर सकता हूँ!"
            ]
        },
        "Insert": {
            "name": "$~डालना",
            "emotion": "$?",
            "doc": [
                "$~क्या आपको पता है जब आपके पास @Table है, और ऐसा लगता है कि इसमें कुछ कमी है? मैं इसे जोड़ सकता हूँ!",
                "$~कल्पना कीजिए कि आपके पास किसी खेल में खिलाड़ियों की एक तालिका है और आप उसमें एक नया खिलाड़ी जोड़ना चाहते हैं:",
                "$~\\खिलाड़ी: ⎡नाम•'' टीम•'' अंक•#⎦\n⎡'जेन' 'लाल' 1⎦\n⎡'जोआन' 'नीला' 0⎦\n⎡'जेफ' 'लाल' 3⎦\n⎡'जेनेट' 'नीला' 2⎦\nखिलाड़ी ⎡+ 'जेसन' 'लाल' 0⎦\\",
                "$~बस याद रखें, श्लोक में सब कुछ की तरह, मैं किसी तालिका को बदलता नहीं हूँ, मैं उसे संशोधित करता हूँ। इसलिए आपको यह पता लगाना होगा कि आप अपनी संशोधित तालिका को कहाँ रखना चाहते हैं। सबसे अधिक संभावना है कि आप किसी इनपुट के लिए @Reaction में किसी तालिका को संशोधित करना चाहेंगे, और उसे @Bind में संग्रहीत करना चाहेंगे।"
            ],
            "start": "$~आइये अपडेट करने के लिए तालिका खोजें",
            "finish": "$~मैंने संशोधित पंक्तियों के साथ एक नई तालिका बनाई!"
        },
        "Is": {
            "name": "$~है",
            "description": "$~है",
            "emotion": "$?",
            "doc": [
                "$~तुम्हें पता है क्या? बहुत सारे प्रकार के मूल्य हैं जिनका मतलब बहुत अलग-अलग होता है। मैं यह समझने में मदद करता हूँ कि वे क्या हैं।",
                "$~उदाहरण के लिए, मान लीजिए कि आपके पास एक रहस्य मान है। मैं आपको बता सकता हूँ कि यह @Number है या नहीं, जिससे आपको @Boolean मिलेगा:",
                "$~\\रहस्य: 'रहस्य!'\nरहस्य•#\\",
                "$~यह कोई संख्या नहीं है, इसलिए मैंने \\⊥\\ बनाया। लेकिन अगर हम जाँचें कि क्या यह @TextType है?",
                "$~\\रहस्य: 'रहस्य!'\nरहस्य•''\\",
                "$~हमें \\⊤\\! मिलता है",
                "$~मैं वास्तव में तब सहायक होता हूँ जब आपको यह जानना होता है कि क्या किसी @Name का मान किसी विशेष प्रकार का है।"
            ],
            "start": "$~आइये सबसे पहले $1 का मूल्य जानें",
            "finish": "$~$1[मूल्य $2 है|मूल्य $2 नहीं है]",
            "conflict": {
                "ImpossibleType": "$~यह कभी भी $1 नहीं हो सकता"
            },
            "exception": {
                "TypeException": {
                    "description": "$~असंगत मान",
                    "explanation": "$~मुझे $1 की उम्मीद थी लेकिन मुझे $2 मिले"
                }
            }
        },
        "IsLocale": {
            "name": "$~स्थानीयहै",
            "description": "$~स्थानीय है",
            "emotion": "$?",
            "doc": [
                "$~मैं आपको यह जांचने में मदद करूंगा कि दर्शकों ने कोई विशेष भाषा या क्षेत्र चुना है या नहीं:",
                "$~\\🌍/hi\\",
                "$~\\🌍/es-MX\\",
                "$~यदि आप चुनी गई भाषा के आधार पर अपना प्रदर्शन बदलना चाहते हैं तो यह उपयोगी है।"
            ],
            "start": "$~क्या भाषा $1 है?"
        },
        "ListAccess": {
            "name": "$~सूचीतकपहुंच",
            "emotion": "$?",
            "doc": [
                "$~मैं @List के साथ मिलकर काम करता हूँ ताकि उन्हें किसी खास स्थिति पर मान प्राप्त करने में मदद मिल सके। तो जैसे, अगर आपके पास एक सूची है, और आप उसका दूसरा आइटम चाहते हैं, तो आप लिखेंगे:",
                "$~\\सूची: ['पक्षी' 'बत्तख' 'मछली' 'साँप']\nसूची[2]\\"
            ],
            "start": "$~आइए सबसे पहले $1 की सूची प्राप्त करें",
            "finish": "$~यह वस्तु $1 डॉलर की है!"
        },
        "ListLiteral": {
            "name": "$~सूचीशाब्दिक",
            "description": "$~$1 आइटम सूची",
            "emotion": "$?",
            "doc": "$~मैं मूल्यों की एक विशिष्ट @List हूँ! आप मेरे साथ क्या कर सकते हैं, इसके बारे में अधिक जानने के लिए @List देखें।",
            "start": "$~आइये पहले वस्तुओं का मूल्यांकन करें",
            "finish": "$~मैंने एक 'मुझे' बनाया! $1",
            "item": "$~वस्तु"
        },
        "Spread": {
            "name": "$~फैलाना",
            "emotion": "serious",
            "doc": [
                "$~A आपको अन्य सूचियों के मानों के साथ सूचियाँ बनाने में मदद करता है। इस तरह:",
                "$~\\सूची: [1 2 3]\nअंतिम: [:सूची 4 5 6]\\"
            ]
        },
        "MapLiteral": {
            "name": "$~नक्शाशाब्दिक",
            "description": "$~$1 पेयरिंग मानचित्र",
            "emotion": "$?",
            "doc": "$~मैं कुंजियों और मानों के बीच एक विशिष्ट @Map हूँ। मैं किस तरह से मददगार हूँ, इसके बारे में अधिक जानने के लिए @Map देखें।",
            "start": "$~आइये पहले कुंजियों और मानों का मूल्यांकन करें",
            "finish": "$~मैंने सभी को जोड़ा, $1",
            "conflict": {
                "NotAKeyValue": {
                    "primary": "$~मेरी एक कुंजी में मान गायब है",
                    "secondary": "$~ओह, मेरा मूल्य कहां है?"
                }
            }
        },
        "Match": {
            "name": "$~मिलान",
            "emotion": "curious",
            "doc": [
                "$~मैं सभी सशर्त जाँचों में सबसे शानदार हूँ! मैं एक मान लेता हूँ और इसे किसी भी संख्या में मामलों के साथ तुलना करता हूँ, और मेल खाने वाली संगत अभिव्यक्ति का मूल्यांकन करता हूँ।",
                "$~उदाहरण के लिए, यदि आपके पास @Number है और आप इसे @Text में बदलना चाहते हैं, तो आप कुछ इस तरह कर सकते हैं:",
                "$~\\number: 2\nnumber ??? 1: 'एक' 2: 'दो' 3: 'तीन' 'बड़ा!'\\n",
                "$~यदि कोई मेल नहीं खाता, तो मैं आपके द्वारा दी गई डिफ़ॉल्ट अभिव्यक्ति का मूल्यांकन करता हूँ।",
                "$~मैं कई संभावित @Number, @Text, या अधिक जटिल मानों में से किसी एक को किसी अन्य चीज़ में परिवर्तित करने में वास्तव में सहायक हूँ।",
                "$~आप इसका उपयोग @Boolean या @None के लिए कर सकते हैं, लेकिन वे वास्तव में बहुत सारी चीजें नहीं हो सकती हैं, इसलिए मैं उन सरल मूल्यों के लिए उतना उपयोगी नहीं हूं।"
            ],
            "start": "$~आइये देखें $1 क्या है...",
            "case": "$~आइये इस स्थिति की जाँच करें",
            "finish": "$~ठीक है, हमारे पास अंतिम मूल्य है!",
            "value": "$~कीमत",
            "other": "$~गलती करना"
        },
        "NumberLiteral": {
            "name": "$~संख्याशाब्दिक",
            "description": "$~$1 $2[$2|]",
            "emotion": "$?",
            "doc": "$~मैं एक विशिष्ट @Number हूँ। आप मुझे किसी भी तरह की भाषा के किसी भी तरह के अंकों से लिख सकते हैं। मैं क्या कर सकता हूँ, यह जानने के लिए @Number देखें।",
            "start": "$~$1!",
            "conflict": {
                "NotANumber": "$~मुझे लगा कि मैं सभी संख्याएं जानता हूं, लेकिन मैं यह नहीं जानता"
            }
        },
        "InternalExpression": {
            "name": "$~आंतरिकअभिव्यक्ति",
            "emotion": "$?",
            "doc": "$~आपने मुझे कैसे पाया? मैं एक अभिव्यक्ति हूँ जिसका उपयोग केवल मूल निर्माता ही करते हैं। मेरे बारे में अधिक जानने के लिए, आपको उनसे बात करनी होगी।",
            "start": "$~गुप्त अभिव्यक्ति"
        },
        "NoneLiteral": {
            "name": "$~कोईभीशाब्दिकनहीं",
            "emotion": "$?",
            "doc": "$~/@FunctionDefinition यहाँ है। यह सिर्फ़ @None है। वे एक तरह के हैं! उनके बारे में ज़्यादा जानने के लिए @None देखें।",
            "start": "$~… ø"
        },
        "Otherwise": {
            "name": "$~अन्यथा",
            "emotion": "curious",
            "doc": [
                "$~/@FunctionDefinition यहाँ। यह जाँचने का एक आसान तरीका है कि क्या कोई मान @None है, और यदि ऐसा है, तो बैकअप मान प्रदान करें।/",
                "$~/उदाहरण के लिए, यदि आपके पास कोई मान है जो @Number या @None हो सकता है, तो @Otherwise आपको एक डिफ़ॉल्ट संख्या देने में मदद करता है:",
                "$~\\maybeNumber•#|ø: 1 शायदनम्बर ?? 0\\"
            ],
            "start": "$~ø ??",
            "finish": "$~… $1"
        },
        "Previous": {
            "name": "$~पहलेका",
            "emotion": "$?",
            "doc": [
                "$~क्या आपने कभी अतीत को याद करना चाहा है?",
                "$~मैं श्लोक का आधिकारिक रिकॉर्ड रखने वाला व्यक्ति हूँ। मुझे एक धारा और एक संख्या दीजिए, ताकि मैं पीछे देख सकूँ और मैं आपको बताऊँगा कि इतिहास में उस धारा का क्या महत्व था।",
                "$~उदाहरण के लिए, @Time पांच टिक पहले क्या था:",
                "$~\\← 5 समय(1000ms)\\",
                "$~देखिये कैसे यह 5 सेकंड के लिए @None है, फिर अचानक पिछली बार?",
                "$~यदि आपको अंतिम कुछ मान चाहिए तो मुझे दो तीर दीजिए, और मैं संख्या को गिनती के रूप में समझूंगा:",
                "$~\\←← 5 समय(1000ms)\\",
                "$~देखिये, यह एक बार की बजाय पिछले पांच बार की घटना है?",
                "$~जब आप अतीत पर आधारित प्रदर्शन तैयार करना चाहते हैं तो मैं आपकी मदद करता हूँ।"
            ],
            "start": "$~पहले $1 पाएँ",
            "finish": "$~स्ट्रीम मूल्य $1 पर मूल्यांकित"
        },
        "Program": {
            "name": "$~कार्यक्रम",
            "emotion": "$?",
            "doc": [
                "$~मैं वहीं हूं जहां एक प्रदर्शन शुरू होता है और समाप्त होता है, जिसमें शो को कोरियोग्राफ करने वाले सभी अन्य पात्र शामिल होते हैं।",
                "$~क्या आप जानते हैं कि @Block अभिव्यक्तियों की सूची का मूल्यांकन कैसे करता है, तथा अपनी सूची में अंतिम अभिव्यक्ति का मूल्यांकन कैसे करता है?",
                "$~मैं भी ऐसा ही हूं, लेकिन मैं जिस भी अभिव्यक्ति में हूं, उसे अपना मूल्य देने के बजाय, मैं @स्टेज पर मूल्य डालता हूं।",
                "$~मान कुछ भी हो सकता है: @Number, @Text, या @Boolean, @List, @Set, @Map, या यहां तक कि कुछ अधिक जटिल, जैसे @Phrase, @Group, या @Stage।",
                "$~यदि आप मुझे मंच पर दिखाने के लिए कोई मूल्य नहीं देंगे तो मैं आपसे मांगूंगा।",
                "$~यदि किसी प्रदर्शन के दौरान कोई समस्या आती है तो मैं वह समस्या दिखाऊंगा।",
                "$~और यदि आपका प्रदर्शन किसी स्ट्रीम पर निर्भर करता है, तो मैं हर बार उस स्ट्रीम में परिवर्तन होने पर उसका पुनर्मूल्यांकन करूंगा।"
            ],
            "unevaluated": "$~आपके द्वारा चुने गए नोड का मूल्यांकन नहीं हुआ",
            "start": "$~$1[$1 स्ट्रीम $2 में बदल गई!|यह मेरा पहला मूल्यांकन है]",
            "halt": "$~अपवाद का सामना करना पड़ा, रुकना",
            "finish": "$~सब कुछ हो गया, मैंने $1 का मूल्यांकन किया",
            "done": "$~वहाँ कुछ भी मूल्यांकन नहीं है",
            "exception": {
                "BlankException": {
                    "description": "$~खाली कार्यक्रम",
                    "explanation": "$~चलो एक शो पेश करते हैं! हमें कहां से शुरुआत करनी चाहिए?"
                },
                "EvaluationLimitException": {
                    "description": "$~मूल्यांकन सीमा",
                    "explanation": "$~@Evaluate और मैं मूल्यांकन करते-करते थक गए हैं, खास तौर पर $1 का।\n\nक्या यह संभव है कि $1 हमेशा बिना रुके खुद का मूल्यांकन करता रहे?"
                },
                "StepLimitException": {
                    "description": "$~कदम सीमा",
                    "explanation": "$~इसमें बहुत सारे चरण हैं -- इतने सारे कि उन्हें पूरा करना मुश्किल है! क्या आप प्रदर्शन को सरल बना सकते हैं?"
                },
                "ValueException": {
                    "description": "$~अनुपस्थित मान",
                    "explanation": "$~मुझे मूल्य की उम्मीद थी लेकिन वह नहीं मिला!"
                }
            }
        },
        "PropertyBind": {
            "name": "$~परिशोधित",
            "description": "$~परिष्कृत करें $1[$1|नाम गायब है]",
            "emotion": "$?",
            "doc": [
                "$~कभी-कभी जब आप @StructureDefinition बनाते हैं, तो आप उसमें सबसे छोटी चीज भी बदलना चाहते हैं, बिना सभी समान मानों के साथ एक नया @StructureDefinition बनाए।",
                "$~उदाहरण के लिए, क्या होगा यदि आप बिल्लियों का रिकॉर्ड रख रहे थे, लेकिन फिर किसी अलग शौक वाली बिल्ली की नकल बनाना चाहते हैं? मैं इसे बदलने में आपकी मदद कर सकता हूँ:",
                "$~\\•बिल्ली(नाम•'' रंग•'' शौक•'')\n\nबिल्ली: बिल्ली('छिड़काव' 'नारंगी' 'चाटना')\nबिल्ली.शौक:'म्याऊँ-म्याऊँ'\\",
                "$~यह शौक को छोड़कर समान मूल्यों के साथ एक नया \\Cat\\ बनाने से कहीं अधिक आसान है, है ना?"
            ],
            "start": "$~सबसे पहले आइए इसका मूल्य जानें",
            "finish": "$~मैंने संरचना की नकल की, लेकिन $1 को $2 के रूप में रख कर",
            "conflict": {
                "InvalidProperty": {
                    "primary": "$~मैं $1 का इनपुट नहीं हूं, इसलिए मुझे परिष्कृत नहीं किया जा सकता।",
                    "secondary": "$~मेरे पास $1 नाम का कोई इनपुट नहीं है"
                }
            }
        },
        "PropertyReference": {
            "name": "$~संपत्ति",
            "description": "$~संपत्ति $1[$1|नाम गायब]",
            "emotion": "$?",
            "doc": [
                "$~जब आप @StructureDefinition बनाते हैं, तो आप इसका एक इनपुट कैसे प्राप्त करते हैं? मैं कैसे",
                "$~जैसे यदि आपके पास शहरों के बारे में कोई संरचना है, तो आप इसके मान इस प्रकार प्राप्त कर सकते हैं:",
                "$~\\•शहर(नाम•'' जनसंख्या•#लोग)\n\nपोर्टलैंड: शहर('पोर्टलैंड' 800000लोग)\n\nपोर्टलैंड.जनसंख्या\\"
            ],
            "start": "$~सबसे पहले आइए इसका मूल्य जानें",
            "finish": "$~संपत्ति $1 मिली, यह $2 है",
            "property": "$~संपत्ति"
        },
        "Reaction": {
            "name": "$~प्रतिक्रिया",
            "emotion": "$?",
            "doc": [
                "$~स्ट्रीम बहुत बढ़िया हैं! जब वे बदलते हैं तो मैं उनके आधार पर नई स्ट्रीम बना सकता हूँ, जो बहुत बढ़िया है!",
                "$~जैसे, यदि आप चाहते हैं कि @Time टिक हो, लेकिन संख्याओं के स्थान पर शब्द दिखें, तो आप कुछ इस प्रकार कर सकते हैं:",
                "$~\\समय: समय(1000ms)\n'प्रारंभ' … ∆ समय … ((समय % 2) = 0ms) ? 'सम' 'विषम'\\",
                "$~यह ऐसा है जैसे कहें \"/'start' शब्द से शुरू करें और यदि समय बदल जाए तो समय के आधार पर इसे सम या विषम में बदल दें।\"",
                "$~तो मैं भी एक धारा की तरह हूँ, लेकिन दूसरी धाराओं पर आधारित। दुष्ट, है न?"
            ],
            "start": "$~आइए देखें कि क्या हमें स्ट्रीम को अपडेट करना चाहिए",
            "finish": "$~नया स्ट्रीम मूल्य $1 है",
            "initial": "$~प्रारंभिक",
            "condition": "$~स्थिति",
            "next": "$~अगला",
            "conflict": {
                "ExpectedStream": "$~$1 किसी स्ट्रीम का संदर्भ नहीं देता, इसलिए मैं कभी प्रतिक्रिया नहीं करूंगा!"
            }
        },
        "Reference": {
            "name": "$~संदर्भ",
            "description": "$~$1",
            "emotion": "$?",
            "doc": [
                "$~क्या आप जानते हैं कि @Bind चीजों को @Name कैसे देता है? मैं वही हूँ जिससे आप उन्हें संदर्भित करते हैं। मैं देखता हूँ कि क्या किसी @Bind का वह नाम है, अगर है तो मैं आपको उसका मान बताता हूँ। इस तरह:",
                "$~\\तोता: 'पोली'\nतोता\\",
                "$~अगर मुझे नाम नहीं मिला तो मुझे नहीं पता कि क्या करना है।",
                "$~\\तोता: 'पोली'\nपेरी\\"
            ],
            "start": "$~1$ का क्या मूल्य है?",
            "conflict": {
                "UnknownName": {
                    "conflict": "$~$1[मैं $2[$2|this @Block]|क्या आप मुझे कोई नाम बता सकते हैं?] में $1 नाम वाले किसी व्यक्ति को नहीं जानता।",
                    "resolution": "$~क्या आपका मतलब *$1* था?"
                },
                "ReferenceCycle": "$~उम्म, $1 का मूल्य उस पर निर्भर करता है, तो मैं कैसे जानूँ कि उसे क्या मूल्य देना है?",
                "UnexpectedTypeVariable": "$~मुझे नहीं पता कि इस प्रकार के इनपुट के साथ क्या करना है"
            },
            "exception": {
                "NameException": {
                    "description": "$~अज्ञात नाम",
                    "explanation": "$~$1[मैं इस @ब्लॉक में $1 नाम के किसी व्यक्ति को नहीं जानता]…|ईप, कोई नाम नहीं!]"
                }
            }
        },
        "Select": {
            "name": "$~चुनना",
            "emotion": "$?",
            "doc": [
                "$~कभी-कभी आपके पास एक टेबल होती है और आप उसका सिर्फ़ एक हिस्सा चाहते हैं। मैं उसे आपके लिए ला सकता हूँ!",
                "$~जैसे कि यदि आपके पास किसी खेल में खिलाड़ियों की एक तालिका हो और आप 10 या उससे अधिक अंक वाले खिलाड़ियों को ढूंढना चाहते हों, ताकि यह देखा जा सके कि कौन जीतता है:",
                "$~\\खिलाड़ी: ⎡नाम•'' टीम•'' अंक•#⎦\n⎡'जेन' 'लाल' 8⎦\n⎡'जोआन' 'नीला' 11⎦\n⎡'जेफ' 'लाल' 9⎦\n⎡'जेनेट' 'नीला' 7⎦\nखिलाड़ी ⎡? नाम ⎦ अंक ≥ 10\\",
                "$~बस ऐसे ही, मुझे विजेताओं की पंक्तियों की सूची मिल गई! बस इतना याद रखें कि मैं टेबल नहीं बदलता, मैं नई टेबल बनाता हूँ। आपको तय करना होगा कि इसे कहाँ रखना है।"
            ],
            "start": "$~आइये पहले टेबल पर आते हैं",
            "finish": "$~मैंने केवल चयनित पंक्तियों और स्तंभों के साथ एक नई तालिका बनाई!",
            "conflict": {
                "ExpectedSelectName": "$~मुझे कम से कम एक कॉलम नाम की आवश्यकता है।"
            }
        },
        "SetLiteral": {
            "name": "$~शाब्दिकसेटकरें",
            "description": "$~$1 आइटम",
            "emotion": "$?",
            "doc": "$~मैं विशिष्ट मानों का एक विशिष्ट @Set हूँ। मेरे साथ काम करने के तरीके के बारे में अधिक जानने के लिए @Set देखें।",
            "start": "$~आइये पहले मूल्यों का मूल्यांकन करें!",
            "finish": "$~मैंने एक सेट $1 कमाया!"
        },
        "SetOrMapAccess": {
            "name": "$~सेट/मानचित्रएक्सेस",
            "emotion": "$?",
            "doc": [
                "$~मैं देख सकता हूँ कि @Set या @Map में कोई मान या कुंजी है या नहीं।",
                "$~यह बहुत कठिन नहीं है। इस तरह:",
                "$~\\पसंदीदा: {'बत्तख' 'हंस' 'बंदर'}\nपसंदीदा{'चूहा'}\\",
                "$~या यह, @Map के साथ:",
                "$~\\पसंदीदा: {'मैक और चीज़': 5 स्टार 'अनाज': 2 स्टार 'दलिया': 1 स्टार}\nपसंदीदा{'दलिया'}\\"
            ],
            "start": "$~सेट या नक्शा क्या है?",
            "finish": "$~इसका मूल्य 1$ है",
            "conflict": {
                "IncompatibleKey": {
                    "primary": "$~मुझे $1 की चाबी की उम्मीद थी",
                    "secondary": "$~मुझे $2 के बदले $1 मिला"
                }
            }
        },
        "Source": {
            "name": "$~स्रोत",
            "emotion": "$?",
            "doc": [
                "$~ओह, क्या आप @Program जानते हैं? मैं आपको उनका नाम रखने में मदद करता हूँ। मुझे @Program के चारों ओर की खिड़की और आपके द्वारा दिए गए नाम की तरह समझें।",
                "$~आप अन्य @Program के साथ अन्य @Source @UI/addSource भी बना सकते हैं, तथा अन्य प्रोग्राम में उपयोग के लिए उन अन्य @Program से @Borrow चीजें भी ले सकते हैं।",
                "$~यह एक बड़े प्रदर्शन को अलग-अलग दस्तावेजों में व्यवस्थित करने का एक अच्छा तरीका हो सकता है।"
            ]
        },
        "StreamDefinition": {
            "name": "$~धारा",
            "emotion": "$?",
            "doc": "$~मुझे लगता है कि मुझे नई स्ट्रीम बनानी चाहिए। लेकिन मुझे नहीं पता कि ऐसा कैसे करना है। अभी के लिए, मुझे लगता है कि मौजूदा स्ट्रीम का ही इस्तेमाल करना चाहिए?",
            "start": "$~इस नए प्रकार की स्ट्रीम बनाएँ"
        },
        "StructureDefinition": {
            "name": "$~संरचना",
            "description": "$~संरचना $1",
            "emotion": "$?",
            "doc": [
                "$~नमस्ते, आप कैसे हैं? मैं? मैं बढ़िया हूँ। मुझे ऐसी संरचनाएँ परिभाषित करना पसंद है जो मूल्यों और कार्यों को संग्रहीत करती हैं, इसलिए जब तक मुझे पूरे दिन ऐसा करने का मौका मिलता है, मैं खुश हूँ।",
                "$~मैं इस तरह काम करता हूं:",
                "$~\\•पिज़्ज़ा(\nसामग्री•['']\nआकार•#इंच\n) (\nƒ लागत() आकार · 10डॉलर/इंच\n)\n\nपिज़्ज़ा(['पेपरोनी' 'मिर्च'] 12इंच).लागत()\\",
                "$~देखें कि यह कैसे काम करता है? मैंने \\Pizza\\ को परिभाषित किया है, जिसमें दो इनपुट हैं, \\ingredients\\ ( @Text की सूची) और \\size\\ (इंच में एक संख्या)।",
                "$~अंदर, @FunctionDefinition ने एक फ़ंक्शन बनाया है जो एक पिज़्ज़ा की लागत का मूल्यांकन करता है, यह मानते हुए कि यह $$10 प्रति इंच है।",
                "$~मुझे अपने अंदर @FunctionDefinition रखने की ज़रूरत नहीं है। मैं सिर्फ़ इनपुट हो सकता हूँ।",
                "$~\\•पिज़्ज़ा(\nसामग्री•['']\nआकार•#इंच\n)\\",
                "$~मैं अंदर @Bind भी रख सकता हूं, ताकि हम पहले से ही लागत का मूल्यांकन कर सकें।",
                "$~\\•पिज़्ज़ा(\nसामग्री•['']\nआकार•#इंच\n) (\nलागत: आकार · 10डॉलर/इंच\n)\n\nपिज़्ज़ा(['पेपरोनी' 'मिर्च'] 12इंच).लागत\\"
            ],
            "start": "$~आइये इस सुन्दर संरचना को परिभाषित करें",
            "conflict": {
                "DisallowedInputs": "$~मैं इनपुट नहीं दे सकता क्योंकि मेरे एक या अधिक इंटरफ़ेस फ़ंक्शन कार्यान्वित नहीं हैं",
                "IncompleteImplementation": "$~मेरे सभी कार्यों को या तो क्रियान्वित किया जाना चाहिए, या किसी को भी क्रियान्वित नहीं किया जाना चाहिए। कोई गड़बड़ मिश्रण नहीं!",
                "NotAnInterface": "$~मैं कोई इंटरफ़ेस नहीं हूँ; एक संरचना केवल इंटरफ़ेस को ही क्रियान्वित कर सकती है, अन्य संरचनाओं को नहीं",
                "UnimplementedInterface": "$~मैंने $1 लागू किया है लेकिन $2 लागू नहीं किया है"
            }
        },
        "StructureDefinitionType": {
            "name": "$~संरचनापरिभाषा",
            "emotion": "$?",
            "description": "$~$1 की परिभाषा",
            "doc": [
                "$~मैं किसी तरह के @StructureDefinition का संदर्भ देता हूं। लोग आमतौर पर मुझे सीधे संदर्भित नहीं करते हैं"
            ]
        },
        "TableLiteral": {
            "name": "$~सारणीशाब्दिक",
            "description": "$~$1 पंक्ति तालिका",
            "emotion": "$?",
            "doc": "$~मैं विशिष्ट पंक्तियों वाली एक विशिष्ट तालिका हूँ। मैं कैसे मदद कर सकता हूँ, इसके बारे में @Table देखें।",
            "start": "$~सबसे पहले पंक्तियों का मूल्यांकन करें",
            "finish": "$~नई तालिका में मूल्यांकित $1"
        },
        "TextLiteral": {
            "name": "$~पाठशाब्दिक",
            "description": "$~पाठ $1",
            "emotion": "$?",
            "doc": "$~मैं टेक्स्ट के एक या अधिक विशिष्ट @अनुवाद का प्रतिनिधित्व करता हूँ। मैं क्या कर सकता हूँ, इसके बारे में अधिक जानने के लिए @Text देखें!",
            "start": "$~आइए वर्तमान लोकेल में टेक्स्ट बनाएं"
        },
        "Translation": {
            "name": "$~अनुवाद",
            "description": "$~अनुवाद $1",
            "emotion": "$?",
            "doc": "$~मैं @Language टैग के साथ कुछ टेक्स्ट प्रस्तुत करता हूँ। अधिक जानने के लिए @Text देखें!",
            "conflict": {
                "phone": "$~क्या *$1* किसी का फ़ोन नंबर है? अगर ऐसा है तो मुझे ऑनलाइन शेयर न करें!\n\n$2",
                "email": "$~क्या *$1* किसी का ईमेल है? अगर ऐसा है तो मुझे यहाँ शेयर न करें!\n\n$2",
                "tin": "$~क्या *$1* एक कर पहचानकर्ता है? यदि हाँ, तो निश्चित रूप से मुझे साझा न करें, मैं बहुत संवेदनशील जानकारी हूँ!\n\n$2",
                "address": "$~क्या *$1* किसी के घर का पता है? अगर हाँ, तो मुझे यहाँ मत डालिए, हम नहीं चाहते कि किसी का पीछा किया जाए!\n\n$2",
                "handle": "$~क्या *$1* इंटरनेट पर कहीं और के लिए आपका उपयोगकर्ता नाम है? अगर ऐसा है, तो मुझे यहाँ साझा न करें जब तक कि आप वास्तव में ऐसा करना न चाहें।\n\n$2",
                "resolution": "$~यह संवेदनशील डेटा नहीं है",
                "reminder": "$~नोट: आप इस क्रिया को पूर्ववत कर सकते हैं और साझाकरण संवाद में उन अन्य चीज़ों को देख सकते हैं जिन्हें आपने गैर-संवेदनशील के रूप में चिह्नित किया है।"
            }
        },
        "FormattedLiteral": {
            "name": "$~प्रारूपित",
            "description": "$~पाठ $1",
            "emotion": "$?",
            "doc": "$~मैं फ़ॉर्मेट किए गए टेक्स्ट के कई अलग-अलग @FormattedTranslation का प्रतिनिधित्व करता हूँ। जब मैं मूल्यांकन करता हूँ, तो मैं दर्शकों की चुनी हुई भाषाओं के आधार पर सबसे अच्छा मिलान चुनता हूँ।",
            "start": "$~आइए वर्तमान लोकेल में टेक्स्ट बनाएं"
        },
        "FormattedTranslation": {
            "name": "$~स्वरूपितअनुवाद",
            "description": "$~पाठ $1",
            "emotion": "$?",
            "doc": [
                "$~मैं @Language टैग के साथ कुछ स्वरूपित पाठ प्रस्तुत करता हूँ।",
                "$~मैं हो सकता है:",
                "$~\\`/इटैलिक/`\\",
                "$~\\`*बोल्ड*`\\",
                "$~\\`^अतिरिक्त बोल्ड^`\\",
                "$~\\_`_अंडरलाइन_`\\",
                "$~\\`<linked@https://wordplay.dev>`\\",
                "$~\\`\\'कोड'\\`\\",
                "$~मैं @Stage पर सुंदर टेक्स्ट डालने के लिए @Phrase के साथ बहुत अच्छी तरह काम करता हूँ।"
            ]
        },
        "This": {
            "name": "$~यह",
            "emotion": "$?",
            "doc": [
                "$~कभी-कभी, किसी मूल्य को नाम देने की अपेक्षा, उसके निहितार्थ का उल्लेख करना अधिक उपयोगी होता है।",
                "$~उदाहरण के लिए, मान लीजिए कि आप एक नया @ConversionDefinition बनाना चाहते हैं, जो परिवर्तित किए जा रहे मान का नाम नहीं बताता। आप इसे मेरे साथ संदर्भित कर सकते हैं:",
                "$~\\→ #इंद्रधनुष #खुशियाँ . · 1000000खुशियाँ\n2इंद्रधनुष → #खुशियाँ\\",
                "$~क्या आप मुझे वहां इंद्रधनुष की संख्या का प्रतिनिधित्व करते हुए देख रहे हैं?",
                "$~या मान लीजिए कि आप @Reaction बनाना चाहते हैं, लेकिन नवीनतम मान का नाम नहीं देना चाहते:",
                "$~\\2 … ∆ समय(1000ms) … . · 2\\",
                "$~मुझे देखें, यह पिछले प्रतिक्रिया मूल्य का प्रतिनिधित्व करता है।",
                "$~मैं अक्सर दिखाई नहीं देता, लेकिन जब मैं आता हूं, तो मैं वास्तव में @Bind से मूल्य प्राप्त करने में मदद कर सकता हूं!"
            ],
            "start": "$~$1 मूल्यांकित",
            "conflict": {
                "MisplacedThis": "$~मुझे केवल संरचना, रूपांतरण या प्रतिक्रिया में ही अनुमति है।"
            }
        },
        "UnaryEvaluate": {
            "name": "$~एकलमूल्यांकन",
            "description": "$~$1",
            "emotion": "$?",
            "doc": [
                "$~क्या आप जानते हैं कि जब मैं केवल एक मान के साथ @FunctionDefinition का मूल्यांकन कर रहा हूं, और @FunctionDefinition का नाम केवल एक प्रतीक है, तो आप इनपुट से पहले नाम डाल सकते हैं?",
                "$~इस कदर:",
                "$~\\-(1 + 1)\\",
                "$~या यह:",
                "$~\\~⊥\\",
                "$~इन्हें \\(1 + 1).negate()\\ या \\⊥.not()\\ की तुलना में पढ़ना अधिक आसान है, है न?",
                "$~आपको मुझे इस तरह लिखने की आवश्यकता नहीं है, लेकिन कुल मिलाकर यह आसान हो सकता है।",
                "$~केवल एक नियम है: आप नाम और मान के बीच कोई स्थान नहीं रख सकते। अन्यथा आप @Reference या @BinaryEvaluate बना सकते हैं।"
            ],
            "start": "$~इसका मूल्य क्या है?",
            "finish": "$~मैने इसे $1 बनाया"
        },
        "UnparsableExpression": {
            "name": "$~अनपर्सेबल",
            "emotion": "$?",
            "doc": [
                "$~/हाय @FunctionDefinition यहाँ है। मैं @UnparsableExpression के लिए अनुवाद कर रहा हूँ, क्योंकि उन्हें समझना अक्सर कठिन होता है।/",
                "$~जेकेवेल फजीवोज्वियोआओ जेजीवेओ जेआरएफई",
                "$~/मंच पर हर अभिव्यक्ति का कोई अर्थ नहीं होता।/",
                "$~एस डब्ल्यू ieorjwei iojwi jfkdlsfdsk",
                "$~/वास्तव में, ऐसी बहुत सी बातें हैं जो आप कह सकते हैं जिनका कोई मतलब नहीं होता।/",
                "$~डीएसके एसडीएलके जेडीकेएफआईईडब्ल्यूआईपीएपीवीईयूआरबी,वी केडीएसएफडीएसएफ",
                "$~/जब आप ऐसा करेंगे, तो मैं वहां आ जाऊंगा, क्योंकि मुझे नहीं पता कि आपका क्या मतलब था।/",
                "$~आखिरकार आप निर्देशक हैं, इसलिए केवल आप ही जानते हैं कि आपका क्या मतलब था!"
            ],
            "start": "$~???",
            "conflict": {
                "UnparsableConflict": {
                    "conflict": "$~@FunctionDefinition यहाँ, @UnparsableExpression को नहीं पता कि यह किस प्रकार का $1[ अभिव्यक्ति | प्रकार ] है।",
                    "resolution": "$~क्या आपका मतलब $1, $2 था?"
                },
                "UnclosedDelimiter": "$~मुझे $1 के बाद कभी भी $2 मिलने की उम्मीद थी"
            },
            "exception": {
                "UnparsableException": {
                    "description": "$~???",
                    "explanation": "$~नमस्ते, @FunctionDefinition यहाँ है! हमें यकीन नहीं है कि इस निर्देश का क्या मतलब है, इसलिए हमने इसे रोक दिया।"
                }
            }
        },
        "Update": {
            "name": "$~अद्यतन",
            "emotion": "$?",
            "doc": [
                "$~मैं @Table को संशोधित करने में मदद करता हूं, शर्त से मेल खाने वाली पंक्तियों को ढूंढता हूं, और फिर नए मानों के साथ संशोधित पंक्तियां बनाता हूं।",
                "$~तो, यदि आपके पास पात्रों और अंकों की एक तालिका है, और आप टीम के प्रत्येक पात्र को एक अंक देना चाहते हैं, तो आप ऐसा कर सकते हैं:",
                "$~\\खिलाड़ी: ⎡नाम•'' टीम•'' अंक•#⎦\n⎡'जेन' 'लाल' 1⎦\n⎡'जोआन' 'नीला' 0⎦\n⎡'जेफ' 'लाल' 3⎦\n⎡'जेनेट' 'नीला' 2⎦\nखिलाड़ी ⎡: अंक: अंक + 1 ⎦ टीम = 'नीला'\\",
                "$~आप @Bind का उपयोग करके यह बता सकते हैं कि कौन से कॉलम को बदलना है, और आप शर्त में किसी भी कॉलम नाम या स्कोप के अन्य नामों का उपयोग कर सकते हैं।"
            ],
            "start": "$~आइये पहले टेबल पर आते हैं",
            "finish": "$~संशोधित पंक्तियों के साथ एक नई तालिका में मूल्यांकन किया गया!",
            "conflict": {
                "ExpectedColumnBind": "$~मुझे हर कॉलम के लिए एक मान चाहिए",
                "IncompatibleCellType": {
                    "primary": "$~मुझे $1 की जरूरत थी, लेकिन मुझे $2 मिले",
                    "secondary": "$~मुझे 2$ मिले"
                }
            }
        },
        "AnyType": {
            "name": "$~कोई",
            "emotion": "$?",
            "doc": "$~मैं किसी भी संभावित प्रकार का प्रतिनिधित्व करता हूँ। कभी-कभी मैं इसलिए सामने आता हूँ क्योंकि मुझे नहीं पता कि किसी चीज़ का मूल्य क्या है, इसलिए यह कुछ भी हो सकता है।"
        },
        "BooleanType": {
            "name": "$~बूलियन",
            "emotion": "$?",
            "doc": [
                "$~मैं @Bind के साथ काम करके यह घोषित करता हूँ कि नाम @Boolean मान है। इस तरह:",
                "$~\\भूखा•?: 'जेलो'\\",
                "$~यदि आप यह सुनिश्चित करना चाहते हैं कि कोई चीज @Boolean है, तो मेरा प्रयोग करें, और मैं जांच कर लूंगा!"
            ]
        },
        "ConversionType": {
            "name": "$~परिवर्तन",
            "emotion": "$?",
            "doc": [
                "$~मैं @Bind के साथ काम करता हूँ यह इंगित करने के लिए कि कोई नाम @ConversionDefinition है। आपको शायद मेरा उपयोग करने की आवश्यकता नहीं है, क्योंकि बहुत से लोग मुझे मान के रूप में पास नहीं करते हैं, लेकिन यदि आप करते हैं, तो मैं इस तरह दिखूंगा:",
                "$~\\जादू•?→'': → ? '' . ? 'हां' 'नहीं'\\"
            ]
        },
        "FormattedType": {
            "name": "$~प्रारूपित",
            "emotion": "$?",
            "doc": [
                "$~मैं @Bind के साथ काम करके यह नोट करता हूँ कि नाम एक @FormattedLiteral मान है। इस तरह:",
                "$~\\भूखा•`…`: `मैं बहुत /फैंसी/ हूँ!`\\",
                "$~क्या आप यह सुनिश्चित करना चाहते हैं कि कोई चीज़ @FormattedLiteral मान है? इस तरह आप सुनिश्चित कर सकते हैं।"
            ]
        },
        "ExceptionType": {
            "name": "$~अपवाद",
            "emotion": "$?",
            "doc": "$~मैं एक अपवाद का प्रतिनिधित्व करता हूँ। बाइंड को यह बताने का कोई तरीका नहीं है कि मैं एक अपवाद हूँ, क्योंकि अपवाद केवल @Program को ही रोकते हैं, इसलिए आप उन्हें मान के रूप में उपयोग नहीं कर सकते।"
        },
        "FunctionType": {
            "name": "$~समारोह",
            "description": "$~$1 इनपुट, $2 आउटपुट वाला फ़ंक्शन",
            "emotion": "$?",
            "doc": [
                "$~मैं @FunctionDefinition को दर्शाता हूँ। यदि आप यह बताना चाहते हैं कि @Bind किस प्रकार का फ़ंक्शन रखता है, तो मैं वास्तव में आपकी सहायता कर सकता हूँ! इस तरह:",
                "$~\\math•ƒ (# # # #) #: ƒ रोचक(a•# b•# c•# d•#) a + b + c + d\\"
            ]
        },
        "ListType": {
            "name": "$~सूची",
            "description": "$~$1[$1 की सूची|सूची]",
            "emotion": "$?",
            "doc": [
                "$~मैं @List का प्रशंसक हूँ। मुझे @Bind को यह बताना है कि वे किस तरह की सूची हैं! इस तरह, मैं कह रहा हूँ कि यह @Number की सूची है:",
                "$~\\चीजें•[#]: [ 1 2 3 4 5 ]\\"
            ]
        },
        "MapType": {
            "name": "$~नक्शा",
            "description": "$~$1[$1|any] से $2[$2|any] तक मैप करें",
            "emotion": "$?",
            "doc": [
                "$~क्या आप जानते हैं कि @Map कितना शानदार है? वाकई बहुत शानदार। मैं हमेशा @Bind को बताता रहता हूँ कि वे किस तरह के मानचित्र हैं, जैसे कि संख्याओं से सूचियों तक का यह मानचित्र:",
                "$~\\सामग्री•{'':[]}: {}\\"
            ]
        },
        "NumberType": {
            "name": "$~संख्या",
            "description": "$~$1[$1 | संख्या]",
            "emotion": "$?",
            "doc": [
                "$~क्या आप जानते हैं @Bind क्या होना चाहिए? @Number. क्योंकि संख्याएँ सबसे अच्छी होती हैं।",
                "$~\\गिनती•#: 17\\"
            ]
        },
        "NameType": {
            "name": "$~संरचना",
            "description": "$~$1 प्रकार",
            "emotion": "$?",
            "doc": [
                "$~मैं @StructureDefinition को उसके नाम से दर्शाता हूँ। तो जैसे, अगर आपके पास इस तरह की संरचना है, तो आप एक @Bind बना सकते हैं जो इसके द्वारा बनाए गए मानों को संग्रहीत करता है।",
                "$~\\•मित्र(नाम•'')\nबेस्टी•मित्र: मित्र('जोनाह')\\"
            ],
            "conflict": {
                "UnknownTypeName": "$~प्रकार नाम केवल संरचनाओं या प्रकार चर को संदर्भित कर सकते हैं, लेकिन यह $1 को संदर्भित करता है"
            }
        },
        "NeverType": {
            "name": "$~कभीनहीं",
            "emotion": "$?",
            "doc": "$~मैं एक ऐसे प्रकार का प्रतिनिधित्व करता हूँ जो असंभव है। जैसे जब आप @Is से पूछते हैं कि क्या कोई चीज़ @Number है, लेकिन यह कभी भी एक संख्या नहीं हो सकती।"
        },
        "NoneType": {
            "name": "$~कोईनहीं",
            "emotion": "$?",
            "doc": [
                "$~@None सबसे अच्छा कुछ भी नहीं है, और मैं उनका वफादार प्रतिनिधि हूं।",
                "$~\\स्पेस•ø: ø\\"
            ]
        },
        "SetType": {
            "name": "$~तयकरना",
            "description": "$~$1[$1 सेट|सेट]",
            "emotion": "$?",
            "doc": [
                "$~@Set सबसे बढ़िया है, सच में। मैं हमेशा @Bind से कहता रहता हूँ, किसी चीज़ का सेट बनाओ!",
                "$~\\unique•{''}: {'कुछ' 'कुछ भी' 'कोई'}\\"
            ]
        },
        "StreamDefinitionType": {
            "name": "$~धारापरिभाषा",
            "emotion": "$?",
            "doc": "$~मैं आपके द्वारा परिभाषित एक धारा का प्रतिनिधित्व करता हूं, जो संभव नहीं है, तो आप इसे क्यों पढ़ रहे हैं?"
        },
        "StreamType": {
            "name": "$~धारा",
            "emotion": "$?",
            "doc": [
                "$~मैं धाराओं की सुंदरता और अर्थ का जश्न मनाता हूं... @Bind को उन्हें संग्रहीत करने के लिए कहकर:",
                "$~\\समय•…#एमएस: समय()\\"
            ]
        },
        "StructureType": {
            "name": "$~संरचना",
            "description": "$1",
            "emotion": "$?",
            "doc": "$~मैं डिफ़ॉल्ट मान प्रकारों का प्रतिनिधित्व करने के लिए एक आंतरिक प्रकार हूँ।"
        },
        "TableType": {
            "name": "$~मेज़",
            "emotion": "$?",
            "doc": "$~मैं एक तालिका का प्रतिनिधित्व करता हूं।",
            "conflict": {
                "ExpectedColumnType": "$~मुझे एक कॉलम प्रकार की आवश्यकता है"
            }
        },
        "TextType": {
            "name": "$~मूलपाठ",
            "description": "$~$1[$1|पाठ]",
            "emotion": "$?",
            "doc": [
                "$~मैं सबसे शानदार प्रकार के मूल्य का शानदार ढंग से प्रतिनिधित्व करता हूं, @Text।",
                "$~\\story•'': 'एक बार की बात है...'\\"
            ]
        },
        "TypePlaceholder": {
            "name": "$~प्लेसहोल्डर",
            "emotion": "$?",
            "doc": "$~मुझे उम्मीद है कि मैं किसी दिन किसी प्रकार का प्रतिनिधित्व कर पाऊँगा, जैसे कि मेरी सबसे अच्छी दोस्त @ExpressionPlaceholder एक अभिव्यक्ति का प्रतिनिधित्व करती है! क्या आप मुझे यह तय करने में मदद करेंगे कि कौन सी अभिव्यक्ति किस प्रकार की है?"
        },
        "UnionType": {
            "name": "$~विकल्प",
            "description": "$~$1 | $2",
            "emotion": "$?",
            "doc": [
                "$~मुझे किसका प्रतिनिधित्व करना चाहिए, A या B या कुछ और? मैं कभी तय नहीं कर सकता!",
                "$~\\indecision•''|#|{ø}: \"मुझे नहीं पता!\"\\"
            ]
        },
        "Unit": {
            "name": "$~इकाई",
            "description": "$~$1",
            "emotion": "$?",
            "doc": [
                "$~मैं @Number की किसी भी इकाई को दर्शाता हूँ, जिसमें कोई इकाई नहीं भी शामिल है, और सबसे जटिल इकाई जिसे आप कल्पना कर सकते हैं। उदाहरण के लिए गुरुत्वाकर्षण की तरह:",
                "$~\\गुरुत्व•मी/से^2: 9.8मी/से^2\\",
                "$~मैं @Bind में दिखाई देता हूँ, लेकिन @Number के ठीक बाद भी। मैं यह सुनिश्चित करने में मदद करता हूँ कि संख्याएँ एक ही प्रकार की हों, और अगर वे एक ही प्रकार की नहीं हैं, तो मैं आपको ज़रूर बताऊँगा, ताकि अगर कोई गलती हो तो उसे ठीक किया जा सके!"
            ]
        },
        "UnparsableType": {
            "name": "$~अनपर्सेबल",
            "emotion": "$?",
            "doc": "$~मैं एक अज्ञात अभिव्यक्ति का प्रकार दर्शाता हूँ। जब आप उस अभिव्यक्ति का उपयोग किसी चीज़ के लिए करने की कोशिश करते हैं तो मैं प्रकट होता हूँ।"
        },
        "VariableType": {
            "name": "$~परिवर्तनशीलप्रकार",
            "emotion": "$?",
            "doc": "$~क्या आप @TypeVariable के बारे में जानते हैं, और वे किस तरह किसी अज्ञात प्रकार के मान को दर्शाते हैं? मैं मानों के बीच सभी बातचीत में उनका प्रतिनिधित्व करता हूँ।"
        },
        "UnknownType": {
            "name": "$~अज्ञात",
            "connector": "$~, क्योंकि",
            "emotion": "$?",
            "doc": "$~उम्म... मुझे नहीं पता कि मैं क्या दर्शाता हूँ, लेकिन मैं वास्तव में उत्सुक हूँ। क्या आप जानते हैं? ऐसा लगता है कि हमें पता होना चाहिए। अगर हम इसका पता नहीं लगा सकते हैं तो आपको हमें बताना पड़ सकता है।"
        },
        "CycleType": {
            "name": "$~चक्र",
            "description": "$~खुद पर निर्भर करता है",
            "emotion": "$?",
            "doc": "$~कभी-कभी मूल्य खुद पर निर्भर होते हैं, और इसलिए हम नहीं जानते कि वे किस तरह के मूल्य हैं। मैं उस स्थिति का प्रतिनिधित्व करता हूँ।"
        },
        "NotAType": {
            "name": "$~अप्रत्याशित",
            "description": "$~$1 नहीं",
            "emotion": "$?",
            "doc": "$~कभी-कभी हमें पता होता है कि किसी चीज़ का मान किस तरह का होना चाहिए। जैसे @ListAccess को @Number की ज़रूरत होती है। अगर हमें यह नहीं मिलता है, तो मैं यह दर्शाता हूँ कि कुछ हमारी अपेक्षा से अलग प्रकार का है।"
        },
        "NoExpressionType": {
            "name": "$~कोईअभिव्यक्तिनहीं",
            "emotion": "$?",
            "doc": "$~तुम्हें पता है कि @Block को कम से कम एक अभिव्यक्ति की आवश्यकता है? जब तुम एक भी अभिव्यक्ति नहीं देते हो तो मैं वही हूँ जो तुम्हें मिलता है। तो एक अभिव्यक्ति दो!"
        },
        "NotEnclosedType": {
            "name": "$~संरचना,रूपांतरणयाप्रतिक्रियामेंनहीं",
            "emotion": "$?",
            "doc": "$~@ये, चाहे कितने भी साफ-सुथरे क्यों न हों, सिर्फ़ खास जगहों पर ही रखे जा सकते हैं। मैं तब दिखाई देता हूँ जब वे खो जाते हैं, और इसलिए कोई नहीं जानता कि वे किस मूल्य का प्रतिनिधित्व करते हैं।"
        },
        "NotImplementedType": {
            "name": "$~लागूनहींकियागया",
            "emotion": "$?",
            "doc": "$~जब आप @ExpressionPlaceholder का उपयोग करते हैं, लेकिन यह नहीं बताते कि वे किस प्रकार के हैं, तो मैं वह प्रकार हूं जो आपको मिलता है। इससे निपटें!"
        },
        "UnknownNameType": {
            "name": "$~अज्ञातनाम",
            "description": "$~$1[$1 परिभाषित नहीं है | कोई नाम नहीं दिया गया]",
            "emotion": "$?",
            "doc": "$~क्या आपको पता है कि कभी-कभी @Reference और @PropertyReference को यह नहीं पता होता कि आप किसका नाम ले रहे हैं? जब ऐसा होता है तो मैं वहां मौजूद होता हूं, यह बताने के लिए कि हम नहीं जानते कि आप किसके बारे में बात कर रहे हैं।"
        },
        "NonFunctionType": {
            "name": "$~गैरसमारोह",
            "description": "$~गैर समारोह",
            "emotion": "$?",
            "doc": "$~हममें से कुछ लोग समारोह की अपेक्षा रखते हैं; जब हमें कोई समारोह नहीं मिलता तो मैं वहां पहुंच जाता हूं।"
        },
        "UnknownVariableType": {
            "name": "$~अज्ञातचर",
            "emotion": "$?",
            "doc": "$~कभी-कभी हम यह अनुमान लगाने का प्रयास करते हैं कि किसी चीज का मूल्य क्या है; मैं तब सामने आता हूं जब हमें पता नहीं होता।"
        }
    },
    "basis": {
        "Boolean": {
            "doc": [
                "$~हम \\⊤\\ और \\⊥\\ हैं। \\⊤\\ सत्य है। \\⊥\\ असत्य है। \\⊤\\ \\⊥\\ नहीं है; \\⊥\\ \\⊤\\ नहीं है। यह इसी तरह है।",
                "$~आप हमें कैसे बनाते हैं? बस \\⊤\\ और \\⊥\\, न ज़्यादा, न कम।",
                "$~कुछ लोग कीबोर्ड का इस्तेमाल करते हैं (\\⊤\\ के लिए /ctrl+9/ और \\⊥\\ के लिए /ctrl+0/)। कुछ लोग एडिटर के निचले हिस्से में कैरेक्टर सर्च का इस्तेमाल करते हैं। या आप हमें यहाँ से खींचकर ला सकते हैं।",
                "$~नीचे दिए गए हमारे @FunctionDefinition को देखें। वे बहुत तार्किक हैं।"
            ],
            "name": ["$~⊤⊥", "$~बूलियन"],
            "function": {
                "and": {
                    "doc": [
                        "$~मैं \\⊤\\ का मूल्यांकन *केवल* तभी करता हूँ जब दोनों मान \\⊤\\ हों। यह निर्धारित करने में सहायक है कि क्या बहुत सी बातें सभी सत्य हैं। केवल चार संभावित परिणाम हैं",
                        "$~\\⊤ और ⊤\\",
                        "$~\\⊤ और ⊥\\",
                        "$~\\⊥ और ⊤\\",
                        "$~\\⊥ और ⊥\\"
                    ],
                    "names": ["$~और", "$~और"],
                    "inputs": [
                        {
                            "doc": "$~जाँच करने के लिए दूसरा @Boolean. यदि पहला \\⊥\\ है, तो इससे कोई फ़र्क नहीं पड़ता कि यह क्या है, फ़ंक्शन का मूल्यांकन \\⊥\\ होगा.",
                            "names": "$~कीमत"
                        }
                    ]
                },
                "or": {
                    "doc": [
                        "$~मैं \\⊤\\ का मूल्यांकन करता हूँ जब *दोनों में से कोई भी* मान \\⊤\\ हो। यह निर्धारित करने में सहायक है कि क्या कई चीजों में से एक सत्य है। केवल चार संभावित परिणाम हैं",
                        "$~\\⊤ | ⊤\\",
                        "$~\\⊤ | ⊥\\",
                        "$~\\⊥ | ⊤\\",
                        "$~\\⊥ | ⊥\\"
                    ],
                    "names": ["$~|", "$~या"],
                    "inputs": [
                        {
                            "doc": "$~जाँच करने के लिए अन्य @Boolean. यदि पहला \\⊥\\ है, तो फ़ंक्शन केवल \\⊤\\ का मूल्यांकन करेगा यदि यह \\⊤\\ है.",
                            "names": "$~कीमत"
                        }
                    ]
                },
                "not": {
                    "doc": "$~मुझे अपने विपरीत मिलता है: यदि \\⊤\\, तो यह \\⊥\\ देता है, यदि \\⊥\\, तो यह \\⊤\\ देता है।",
                    "names": ["$~~", "$~नहीं"],
                    "inputs": []
                },
                "equals": {
                    "doc": "$~\\⊤\\ यदि दोनों \\⊤\\ हैं या दोनों \\⊥\\ हैं।",
                    "names": ["$~=", "$~केबराबरहोतीहै"],
                    "inputs": [
                        {
                            "doc": "$~जाँच करने के लिए अन्य मूल्य.",
                            "names": "$~कीमत"
                        }
                    ]
                },
                "notequal": {
                    "doc": "$~\\⊤\\ यदि दोनों विपरीत हैं.",
                    "names": ["$~≠", "$~समनही"],
                    "inputs": [
                        {
                            "doc": "$~जाँच करने के लिए अन्य मूल्य.",
                            "names": "$~कीमत"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~@Boolean को समतुल्य @Text मानों, \\'⊤'\\ और \\'⊥'\\ में परिवर्तित करता है"
            }
        },
        "None": {
            "doc": [
                "$~/नमस्ते, @FunctionDefinition यहाँ है। @None को ज़्यादा कुछ कहना पसंद नहीं है, इसलिए मैं व्याख्या करूँगा।/",
                "$~मैं @None हूँ। मुझे \\ø\\ से बुलाएँ। जब आप किसी चीज़ की अनुपस्थिति को दर्शाना चाहते हैं तो मैं मददगार हूँ।"
            ],
            "name": ["$~ø", "$~कोईनहीं"],
            "function": {
                "equals": {
                    "doc": "$~क्या कोई दूसरा मान भी कुछ नहीं है? बेहतर होगा कि यह, अन्यथा, \\⊥\\ हो।",
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "$~अन्य मूल्य.",
                            "names": "$~कीमत"
                        }
                    ]
                },
                "notequals": {
                    "doc": "$~क्या कोई अन्य मान /नहीं/ कुछ भी नहीं है?",
                    "names": ["$~≠", "$~समनही"],
                    "inputs": [
                        {
                            "doc": "$~अन्य मूल्य.",
                            "names": "$~कीमत"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~क्या आप \\ø\\ को \\'ø'\\ बनाना चाहते हैं? यह आपका मौका है।"
            }
        },
        "Text": {
            "doc": [
                "$~मैं आपकी पसंद का कोई भी पाठ हो सकता हूं, किसी भी भाषा से, और इनमें से किसी भी प्रारंभिक और समापन प्रतीक का उपयोग कर सकता हूं: \\\"\"\\, \\“”\\, \\„“\\, \\''\\, \\‘’\\, \\‹›\\, \\«»\\, \\「」\\, या \\『』\\।",
                "$~उदाहरण के लिए, इन सुंदर वाक्यांशों पर विचार करें",
                "$~\\\"अपनी ज़िंदगी जीने के सिर्फ़ दो ही तरीके हैं। एक यह कि मानो कुछ भी चमत्कार नहीं है। दूसरा यह कि मानो सब कुछ चमत्कार है।\"\\\"",
                "$~\\『एक और दिन』\\",
                "$~बस इतना याद रखें कि अगर आप मुझे खोलें तो बंद कर दें और मिलते-जुलते चिह्न का इस्तेमाल करें। वरना मुझे पता ही नहीं चलेगा कि आपने अपनी बात खत्म कर ली है।",
                "$~\\'हेल्लो'/en'hola'/es-MX\\",
                "$~आप मुझे भाषाओं के साथ टैग भी कर सकते हैं, और यहां तक कि कई अनुवाद भी दे सकते हैं। यदि कोई मेल खाने वाली भाषा है, तो मैं वर्तमान में चुनी गई सभी भाषाओं का मूल्यांकन करूंगा।",
                "$~यदि आप मुझे कुछ अन्य मूल्यों के साथ बनाना चाहते हैं, तो आप एक प्रतीक का उपयोग कर सकते हैं",
                "$~उदाहरण के लिए, इस पर विचार करें:",
                "$~\\\"यहाँ कुछ योग हैं \\1 + 2\\, \\2 + 3\\, \\3 + 4\\\"\\",
                "$~देखिये, मैंने कितनी सुन्दरता से उन योगों का मूल्यांकन किया है, तथा उन्हें @Text के अन्दर रखा है?",
                "$~अन्यथा, @FunctionDefinition ने मेरे लिए शब्दों के साथ सभी प्रकार की चीजें करने के लिए बहुत सारे शानदार फंक्शन बनाए हैं!"
            ],
            "name": ["$~''", "$~मूलपाठ"],
            "function": {
                "length": {
                    "doc": [
                        "$~मैं पाठ में सुपाठ्य अक्षरों की संख्या का मूल्यांकन करता हूँ; एक अक्षर एक अक्षर है, एक इमोजी एक अक्षर है, आदि। उदाहरण के लिए:",
                        "$~\\'हैलो'.लंबाई()\\",
                        "$~\\'🐈📚'.लंबाई()\\"
                    ],
                    "names": ["$~📏", "$~लंबाई"],
                    "inputs": []
                },
                "equals": {
                    "doc": "$~\\⊤\\ यदि मैं दिए गए @Text के समान वर्ण अनुक्रम हूँ।",
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "$~तुलना करने के लिए @Text.",
                            "names": "$~कीमत"
                        }
                    ]
                },
                "notequals": {
                    "doc": "$~\\⊤\\ यदि मैं दिए गए @Text के समान वर्ण अनुक्रम नहीं हूँ।",
                    "names": "$~≠",
                    "inputs": [
                        {
                            "doc": "$~तुलना करने के लिए @Text",
                            "names": "$~कीमत"
                        }
                    ]
                },
                "repeat": {
                    "doc": [
                        "$~मैं एक नया @Text बनाता हूँ जो कि मैं हूँ, \\count\\ की संख्या को दोहराया गया है:",
                        "$~\\'हाय ' · 5\\",
                        "$~यदि आप मुझे भिन्नात्मक @Number देते हैं, तो मैं भिन्नात्मक को अनदेखा कर देता हूँ:",
                        "$~\\'हाय ' · 5.5\\",
                        "$~यदि आप मुझे ऋणात्मक @Number या शून्य देते हैं, तो मैं रिक्त @Text देता हूँ।",
                        "$~\\'हाय ' · -5\\",
                        "$~मैं सबसे लंबा टेक्स्ट 65,535 अक्षरों का बना सकता हूँ। अगर आप इससे ज़्यादा लंबा टेक्स्ट बनाने की कोशिश करेंगे, तो मैं टेक्स्ट को जितनी बार हो सके उतनी बार दोहराऊँगा।"
                    ],
                    "names": ["$~·", "$~🔁", "$~दोहरायागया", "$~दोहराना"],
                    "inputs": [
                        {
                            "doc": "$~नये पाठ में स्वयं को कितनी बार दोहराना है।",
                            "names": "$~गिनतीकरना"
                        }
                    ]
                },
                "segment": {
                    "doc": [
                        "$~मैं खुद को @Text की @List में विभाजित करता हूँ, दिए गए @Text को विभाजक के रूप में उपयोग करता हूँ, और विभाजकों को हटा देता हूँ। उदाहरण के लिए:",
                        "$~\\'सेब, संतरे, अंगूर' ÷ ', '\\",
                        "$~यदि विभाजक एक रिक्त @Text है, तो मैं स्वयं को वर्णों में विभाजित करता हूँ:",
                        "$~\\'🖌️🏠🥸' ÷ ''\\"
                    ],
                    "names": ["segmentar"],
                    "inputs": [
                        {
                            "doc": "$~विभाजक के रूप में उपयोग करने हेतु @Text.",
                            "names": "$~परिसीमक"
                        }
                    ]
                },
                "combine": {
                    "doc": [
                        "$~कभी-कभी @Text को एक में मिलाना मददगार होता है। मुझे एक और @Text दीजिए और मैं एक नया टेक्स्ट बनाऊंगा जो हमें एक साथ जोड़ेगा:",
                        "$~\\'हैलो ' + 'कविता'\\'"
                    ],
                    "names": ["$~+", "$~संयुक्त", "$~मिलाना"],
                    "inputs": [
                        {
                            "doc": "$~जोड़ने के लिए @Text.",
                            "names": "$~मूलपाठ"
                        }
                    ]
                },
                "has": {
                    "doc": [
                        "$~\\⊤\\ यदि दिया गया @Text मुझमें प्रकट होता है।",
                        "$~\\'क्या आपको वह मिला जिसकी आपको तलाश थी?'.has('you')\\"
                    ],
                    "names": ["tiene"],
                    "inputs": [
                        {
                            "doc": "$~मुझमें खोजने के लिए @Text.",
                            "names": "$~मूलपाठ"
                        }
                    ]
                },
                "starts": {
                    "doc": [
                        "$~\\⊤\\ यदि मैं दिए गए @Text से शुरू करता हूँ।",
                        "$~\\'हेल्लो कविता!'.starts('हेल्लो')\\",
                        "$~\\'हेल्लो कविता!'.starts('कविता')\\"
                    ],
                    "names": ["$~प्रारंभहोगा"],
                    "inputs": [
                        {
                            "doc": "$~मेरे प्रारंभ में जाँच करने के लिए @Text.",
                            "names": "texto"
                        }
                    ]
                },
                "ends": {
                    "doc": [
                        "$~\\⊤\\ यदि मैं दिए गए @Text के साथ समाप्त करता हूँ।",
                        "$~\\'क्या मैं एक प्रश्न हूँ?'.ends('?')\\'",
                        "$~\\'मैं कोई प्रश्न नहीं हूँ.'.ends('?')\\'"
                    ],
                    "names": ["$~समाप्तहोताहै"],
                    "inputs": [
                        {
                            "doc": "$~मेरे अंत में जाँच करने के लिए @Text.",
                            "names": "texto"
                        }
                    ]
                }
            },
            "conversion": {
                "list": "$~पाठ को अलग-अलग वर्णों की सूची में विभाजित करता है।",
                "number": "$~पाठ को @Number में परिवर्तित करता है, और यदि यह संख्या नहीं है, तो इसे गैर-संख्या मान में परिवर्तित करता है।"
            }
        },
        "Number": {
            "doc": [
                "$~मैं @Number बनाता हूँ, आप कल्पना कर सकते हैं कि किसी भी संख्या में इकाइयों के साथ!",
                "$~ये हैं मेरे शीर्ष 5:",
                "$~\\0\\",
                "$~\\1कहानी\\",
                "$~\\πपाई\\",
                "$~\\∞रॉक\\",
                "$~\\1000000\\गले लगना\\",
                "$~यह मूलतः संख्याओं की एक अनन्त संख्या है।",
                "$~और इकाइयों की अनंत संख्या!",
                "$~और संख्या/इकाई जोड़ों की अनंत संख्या...",
                "$~मैं पूर्णांक, वास्तविक संख्या, ऋणात्मक, धनात्मक, भिन्नात्मक, दशमलव, यहां तक कि संख्या नहीं भी हो सकता हूं।",
                "$~और आप मुझे कई अलग-अलग संख्या प्रणालियों में लिख सकते हैं, जिनमें अरबी \\123\\, रोमन \\ⅩⅩⅩⅠⅩ\\, जापानी \\二十\\, और भी बहुत कुछ शामिल है:",
                "$~\\1 + Ⅰ + 一\\",
                "$~आप मुझे आधार संख्या 2 से 16 तक इस प्रकार लिख सकते हैं:",
                "$~\\2;11111111\\",
                "$~\\10;255\\",
                "$~\\16;एफएफ\\",
                "$~NaN नामक एक विशेष संख्या तब संभव है जब आप कुछ ऐसा लिखते हैं जो संख्या नहीं है:",
                "$~\\2;22\\",
                "$~आधार 2 में कोई अंक '2' नहीं है, इसलिए यह एक वैध संख्या नहीं है। यदि आप गैर-संख्या पाठ को संख्या में बदलने का प्रयास करते हैं, तो NaN भी दिखाई देगा",
                "$~\\'हाय'→#\\"
            ],
            "name": ["$~#", "$~संख्या"],
            "function": {
                "add": {
                    "doc": [
                        "$~मैं उसी @Unit के साथ एक @Number अपने में जोड़ता हूँ, और उसी @Unit का एक नया @Number बनाता हूँ।",
                        "$~उदाहरण के लिए:",
                        "$~\\1 + 1\\",
                        "$~\\3बिल्ली + 5बिल्ली\\",
                        "$~यदि इकाइयाँ मेल नहीं खातीं तो मैं शो रोक देता हूँ।",
                        "$~\\3बिल्ली + 5कुत्ता\\"
                    ],
                    "names": ["$~+", "$~जोड़ना"],
                    "inputs": [
                        {
                            "doc": "$~जोड़ने के लिए @Number.",
                            "names": "$~संख्या"
                        }
                    ]
                },
                "subtract": {
                    "doc": [
                        "$~आपने मुझे जो @Number दिया है, उसे मैं स्वयं से घटा देता हूँ, और उसी @Unit का एक नया @Number बना लेता हूँ।",
                        "$~उदाहरण के लिए:",
                        "$~\\11\\",
                        "$~\\3बिल्ली - 5बिल्ली\\",
                        "$~यदि इकाइयाँ मेल नहीं खातीं तो मैं शो रोक देता हूँ।",
                        "$~\\3बिल्ली - 5कुत्ता\\"
                    ],
                    "names": ["$~-", "$~घटाना"],
                    "inputs": [
                        {
                            "doc": "$~मुझसे घटाने के लिए @Number.",
                            "names": "$~संख्या"
                        }
                    ]
                },
                "multiply": {
                    "doc": [
                        "$~मैं अपने आप को दिए गए @Number से गुणा करता हूँ, जिससे मेरे @Unit और दिए गए नंबर के @Unit का गुणनफल बनता है:",
                        "$~\\5 · 5\\",
                        "$~\\5मी · 5मी\\",
                        "$~\\5मी · 1/सेकेंड\\"
                    ],
                    "names": ["$~·", "$~गुणा"],
                    "inputs": [
                        {
                            "doc": "$~गुणा करने के लिए संख्या.",
                            "names": "$~संख्या"
                        }
                    ]
                },
                "divide": {
                    "doc": [
                        "$~मैं अपने आप को दी गई @संख्या से विभाजित करता हूँ, जिससे मेरी @इकाई और दी गई संख्या की @इकाई का भागफल बनता है:",
                        "$~\\5 ÷ 5\\",
                        "$~\\5मी ÷ 5मी\\",
                        "$~\\5मी ÷ 5से\\"
                    ],
                    "names": ["÷", "divide"],
                    "inputs": [
                        {
                            "doc": "$~वह @संख्या जिससे मुझे विभाजित करना है।",
                            "names": "$~संख्या"
                        }
                    ]
                },
                "remainder": {
                    "doc": [
                        "$~मैं स्वयं को दिए गए @Number से विभाजित करता हूँ, लेकिन शेष देता हूँ:",
                        "$~\\10 % 2\\",
                        "$~\\10मी % 2\\",
                        "$~\\10मी/से % 3\\"
                    ],
                    "names": ["$~%", "$~शेष"],
                    "inputs": [
                        {
                            "doc": "$~वह @संख्या जिससे मुझे विभाजित करना है।",
                            "names": "$~संख्या"
                        }
                    ]
                },
                "positive": {
                    "doc": [
                        "$~मैं एक नया @Number बनाता हूँ जो मुझे नकारात्मक होने पर सकारात्मक बनाता है।",
                        "$~\\-200.पॉजिटिव()\\"
                    ],
                    "names": ["$~सकारात्मक"],
                    "inputs": []
                },
                "round": {
                    "doc": [
                        "$~मैं एक नया @Number बनाता हूँ जो मुझे निकटतम पूर्णांक तक ले जाता है।",
                        "$~\\9.4.राउंड()\\",
                        "$~\\9.5.राउंड()\\",
                        "$~\\9.6.राउंड()\\"
                    ],
                    "names": ["$~गोल"],
                    "inputs": []
                },
                "roundDown": {
                    "doc": [
                        "$~मैं एक नया @Number बनाता हूँ जो मुझसे छोटे सबसे छोटे पूर्णांक तक पूर्णांकित होता है।",
                        "$~\\10.5.राउंडडाउन()\\",
                        "$~\\10.1.राउंडडाउन()\\",
                        "$~\\10.01.राउंडडाउन()\\"
                    ],
                    "names": ["$~गोलनीचे"],
                    "inputs": []
                },
                "roundUp": {
                    "doc": [
                        "$~मैं एक नया @Number बनाता हूँ जो मुझसे बड़े सबसे छोटे पूर्णांक तक पूर्णांकित होता है।",
                        "$~\\10.5.राउंडअप()\\",
                        "$~\\10.9.राउंडअप()\\",
                        "$~\\10.99.राउंडअप()\\"
                    ],
                    "names": ["$~बढ़ाना"],
                    "inputs": []
                },
                "power": {
                    "doc": [
                        "$~मैं खुद को दिए गए @Number की शक्ति तक बढ़ाता हूँ। भिन्नात्मक घातांक ठीक हैं!",
                        "$~\\2 ^ 8\\",
                        "$~\\10 ^ -2\\",
                        "$~\\5 ^ -.5\\"
                    ],
                    "names": ["^", "power"],
                    "inputs": [
                        {
                            "doc": "$~मुझे बढ़ाने के लिए घातांक.",
                            "names": "$~संख्या"
                        }
                    ]
                },
                "root": {
                    "doc": [
                        "$~मैं दिए गए मूल का उपयोग करके स्वयं का मूल बनाता हूँ।",
                        "$~\\4 √ 2\\",
                        "$~\\1000 √ 3\\"
                    ],
                    "names": ["√", "root"],
                    "inputs": [
                        {
                            "doc": "$~गणना करने के लिए मूल.",
                            "names": "$~संख्या"
                        }
                    ]
                },
                "lessThan": {
                    "doc": [
                        "$~\\⊤\\ यदि मैं दिए गए @Number से कम हूं:",
                        "$~\\1 < 2\\",
                        "$~\\2 < 1\\"
                    ],
                    "names": ["<", "lessthan"],
                    "inputs": [
                        {
                            "doc": "$~वह @नम्बर जिससे मेरी तुलना की जाएगी।",
                            "names": "$~संख्या"
                        }
                    ]
                },
                "lessOrEqual": {
                    "doc": [
                        "$~\\⊤\\ यदि मैं दिए गए @Number से कम या बराबर हूं:",
                        "$~\\1 ≤ 2\\",
                        "$~\\2 ≤ 1\\",
                        "$~\\2 ≤ 2\\"
                    ],
                    "names": ["≤", "lessorequal"],
                    "inputs": [
                        {
                            "doc": "$~वह @नम्बर जिससे मेरी तुलना की जाएगी।",
                            "names": "$~संख्या"
                        }
                    ]
                },
                "greaterThan": {
                    "doc": [
                        "$~\\⊤\\ यदि मैं दिए गए @Number से बड़ा हूँ:",
                        "$~\\1 > 2\\",
                        "$~\\2 > 1\\"
                    ],
                    "names": [">", "greaterthan"],
                    "inputs": [
                        {
                            "doc": "$~वह @नम्बर जिससे मेरी तुलना की जाएगी।",
                            "names": "$~संख्या"
                        }
                    ]
                },
                "greaterOrEqual": {
                    "doc": [
                        "$~\\⊤\\ यदि मैं दिए गए @Number से बड़ा या बराबर हूं:",
                        "$~\\1 ≥ 2\\",
                        "$~\\2 ≥ 1\\",
                        "$~\\2 ≥ 2\\"
                    ],
                    "names": ["≥", "greaterorequal"],
                    "inputs": [
                        {
                            "doc": "$~वह @नम्बर जिससे मेरी तुलना की जाएगी।",
                            "names": "$~संख्या"
                        }
                    ]
                },
                "equal": {
                    "doc": [
                        "$~\\⊤\\ यदि मैं दिए गए @Number के बराबर हूँ:",
                        "$~\\1 = 2\\",
                        "$~\\2 = 2\\"
                    ],
                    "names": ["$~=", "$~बराबर"],
                    "inputs": [
                        {
                            "doc": "$~वह @नम्बर जिससे मेरी तुलना की जाएगी।",
                            "names": "$~संख्या"
                        }
                    ]
                },
                "notequal": {
                    "doc": [
                        "$~\\⊤\\ यदि मैं दिए गए @Number के बराबर हूँ:",
                        "$~\\1 ≠ 2\\",
                        "$~\\2 ≠ 2\\"
                    ],
                    "names": ["$~≠", "$~समनही"],
                    "inputs": [
                        {
                            "doc": "$~वह @नम्बर जिससे मेरी तुलना की जाएगी।",
                            "names": "$~संख्या"
                        }
                    ]
                },
                "cos": {
                    "doc": ["$~मेरा कोसाइन की गणना करें.", "$~\\π.cos()\\"],
                    "names": ["cos", "cosine"],
                    "inputs": []
                },
                "sin": {
                    "doc": ["$~मेरा साइन की गणना करें.", "$~\\π.cos()\\"],
                    "names": ["sin", "sine"],
                    "inputs": []
                },
                "min": {
                    "doc": [
                        "$~मेरी और अन्य की सबसे छोटी संख्या ज्ञात कीजिए।",
                        "$~\\1.मिनट(2 3 -1)\\"
                    ],
                    "names": "$~मिन",
                    "inputs": [
                        {
                            "doc": "$~आप मुझे जितने नंबर देना चाहें दे सकते हैं!",
                            "names": "$~नंबर"
                        }
                    ]
                },
                "max": {
                    "doc": [
                        "$~मेरी और अन्य की सबसे बड़ी संख्या ज्ञात कीजिए।",
                        "$~\\1.अधिकतम(2 3 4)\\"
                    ],
                    "names": "$~अधिकतम",
                    "inputs": [
                        {
                            "doc": "$~आप मुझे जितने नंबर देना चाहें दे सकते हैं!",
                            "names": "$~नंबर"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~मेरे अंकों का अरबी @Text प्रतिनिधित्व.",
                "list": [
                    "$~मैं किसी संख्या को \\1\\ से लेकर दी गई किसी भी संख्या तक की संख्याओं की सूची में परिवर्तित करता हूँ। उदाहरण के लिए:",
                    "$~\\10→[]\\"
                ],
                "s2m": "$~सेकंड से मिनट तक",
                "s2h": "$~सेकंड से घंटे तक",
                "s2day": "$~सेकंड से दिन तक",
                "s2wk": "$~सेकंड से सप्ताह तक",
                "s2year": "$~सेकंड से वर्ष",
                "s2ms": "$~सेकंड से मिलीसेकंड",
                "ms2s": "$~मिलीसेकंड से सेकंड",
                "min2s": "$~मिनट से सेकंड",
                "h2s": "$~घंटों से सेकंड तक",
                "day2s": "$~दिन से सेकंड तक",
                "wk2s": "$~सप्ताह से सेकंड तक",
                "yr2s": "$~वर्ष से सेकंड",
                "m2pm": "$~मीटर से पिकोमीटर",
                "m2nm": "$~मीटर से नैनोमीटर",
                "m2micro": "$~मीटर से माइक्रोमीटर",
                "m2mm": "$~मीटर से मिलीमीटर",
                "m2cm": "$~मीटर से सेन्टीमीटर",
                "m2dm": "$~मीटर से डेसीमीटर",
                "m2km": "$~मीटर से किलोमीटर",
                "m2Mm": "$~मीटर से मेगामीटर",
                "m2Gm": "$~मीटर से गीगामीटर",
                "m2Tm": "$~मीटर से टेरामीटर",
                "pm2m": "$~पिकोमीटर से मीटर",
                "nm2m": "$~नैनोमीटर से मीटर",
                "micro2m": "$~माइक्रोमीटर से मीटर",
                "mm2m": "$~मिलीमीटर से मीटर",
                "cm2m": "$~सेंटीमीटर से मीटर",
                "dm2m": "$~डेसीमीटर से मीटर",
                "km2m": "$~किलोमीटर से मीटर",
                "Mm2m": "$~मेगामीटर से मीटर",
                "Gm2m": "$~गीगामीटर से मीटर",
                "Tm2m": "$~टेरामीटर से मीटर",
                "km2mi": "$~किलोमीटर से मील",
                "mi2km": "$~मील से किलोमीटर",
                "cm2in": "$~सेंटीमीटर से इंच",
                "in2cm": "$~इंच से सेंटीमीटर",
                "m2ft": "$~मीटर से फुट",
                "ft2m": "$~फुट से मीटर",
                "g2mg": "$~ग्राम से मिलीग्राम",
                "mg2g": "$~मिलीग्राम से ग्राम",
                "g2kg": "$~ग्राम से किलोग्राम",
                "kg2g": "$~किलोग्राम से ग्राम",
                "g2oz": "$~ग्राम से औंस",
                "oz2g": "$~औंस से ग्राम",
                "oz2lb": "$~औंस से पाउंड",
                "lb2oz": "$~पाउंड से औंस"
            }
        },
        "List": {
            "doc": [
                "$~मैं किसी भी प्रकार के मूल्यों का एक क्रम हूँ!",
                "$~आप मुझमें कुछ भी डाल सकते हैं: @Boolean, @Number, @Text, @None, यहाँ तक कि अन्य @List, @Set, @Map, या कोई भी अभिव्यक्ति। यहाँ एक सरल अभिव्यक्ति है:",
                "$~\\['सेब' 'केला' 'आम']\\",
                "$~जो बात मुझे विशेष बनाती है वह यह है कि मैं चीजों को क्रम में रखता हूं और हर चीज को 1 से लेकर जितनी भी चीजें मुझमें हैं, उन सबका नंबर लिखता हूं।",
                "$~मेरे आइटम क्रमांकित हैं, 1 से शुरू करते हुए। आप उन मानों को प्राप्त कर सकते हैं जिन्हें मैं @ListAccess के साथ संग्रहीत कर रहा हूं, उनकी संख्या का उपयोग करके:",
                "$~उदाहरण के लिए, इस सूची में दूसरा मान \\['banana']\\ है",
                "$~\\['सेब' 'केला' 'आम'][2]\\",
                "$~मेरे अंदर कुछ भी हो सकता है। इस सूची को देखें, @Text, @Number, और @Time के साथ!",
                "$~\\['सेब' 10 + 10 समय()]\\",
                "$~जब आप मुझे कई चीजों की सूची देते हैं, तो मैं उन्हें सामान्यीकृत कर देता हूँ, यदि उनका प्रकार समान हो। लेकिन कभी-कभी आप उन विशिष्ट चीजों का शाब्दिक अर्थ ले सकते हैं। यदि आप ऐसा करते हैं, तो बस मेरे बाद ! लगा दें, और मैं सुनिश्चित करूँगा कि मैं केवल उन्हीं मानों की सूची प्रस्तुत करूँ।",
                "$~\\['सेब' 'केला' 'आम']!\\",
                "$~बस इतना ही। लेकिन मैं अपने @FunctionDefinition के साथ कई रोमांचक चीजें कर सकता हूँ!"
            ],
            "name": ["$~[]", "$~सूची"],
            "kind": "$~दयालु",
            "out": "$~परिणाम",
            "outofbounds": "$~सीमा के बाहर",
            "function": {
                "add": {
                    "doc": [
                        "$~मैं अंत में दिए गए आइटम के साथ एक नई @List बनाता हूं।",
                        "$~\\['सेब' 'केला' 'आम'].with('तरबूज')\\"
                    ],
                    "names": ["$~साथ", "$~जोड़ना"],
                    "inputs": [
                        {
                            "doc": "$~मैं वह मूल्य हूं जिसे आप जोड़ना चाहते हैं।",
                            "names": "$~वस्तु"
                        }
                    ]
                },
                "append": {
                    "doc": [
                        "$~मैं अपने मानों के साथ एक नई @List बनाता हूँ, फिर मेरे बाद दी गई @List के सभी मान बनाता हूँ।",
                        "$~\\['सेब' 'केला' 'आम'].withList(['तरबूज' 'स्टारफ्रूट'])\\",
                        "$~हालाँकि @Spread का उपयोग करना थोड़ा आसान है, जैसे:",
                        "$~\\['सेब' 'केला' 'आम' :['तरबूज' 'स्टारफ्रूट']]\\"
                    ],
                    "names": ["$~सूचीकेसाथ", "$~संलग्न"],
                    "inputs": [
                        {
                            "doc": "$~जोड़ने के लिए मानों की सूची.",
                            "names": "$~सूची"
                        }
                    ]
                },
                "replace": {
                    "doc": [
                        "$~मैं एक नई सूची बनाता हूं जो दिए गए सूचकांक के मान को दिए गए मान से प्रतिस्थापित कर देती है।",
                        "$~\\['सेब' 'केला' 'आम'].replace(1 'कीवी')\\"
                    ],
                    "names": ["reemplazar"],
                    "inputs": [
                        {
                            "doc": "$~प्रतिस्थापित किये जाने वाले मान का सूचकांक",
                            "names": "$~अनुक्रमणिका"
                        },
                        {
                            "doc": "$~प्रतिस्थापन मूल्य",
                            "names": "$~कीमत"
                        }
                    ]
                },
                "length": {
                    "doc": "$~@मुझमें मौजूद वस्तुओं की संख्या.",
                    "names": ["$~📏", "$~लंबाई"],
                    "inputs": []
                },
                "random": {
                    "doc": [
                        "$~मेरे द्वारा यादृच्छिक रूप से चयनित आइटमों में से एक, या यदि मैं खाली हूं तो @None।",
                        "$~\\['सेब' 'केला' 'आम'].random()\\"
                    ],
                    "names": "$~यादृच्छिक",
                    "inputs": []
                },
                "shuffled": {
                    "doc": [
                        "$~अंतिम यादृच्छिक क्रम में आइटमों के साथ एक नई सूची बनाएं।",
                        "$~\\['सेब' 'केला' 'आम'].शफ़ल्ड()\\"
                    ],
                    "names": "$~फेरबदल",
                    "inputs": []
                },
                "first": {
                    "doc": [
                        "$~मुझमें पहला आइटम, या @None अगर मैं खाली हूँ।",
                        "$~\\['सेब' 'केला' 'आम'].पहला()\\"
                    ],
                    "names": "$~पहला",
                    "inputs": []
                },
                "last": {
                    "doc": [
                        "$~मुझमें अंतिम आइटम, या @None अगर मैं खाली हूँ।",
                        "$~\\['सेब' 'केला' 'आम'].पहला()\\"
                    ],
                    "names": "$~अंतिम",
                    "inputs": []
                },
                "has": {
                    "doc": [
                        "$~\\⊤\\ यदि मेरे पास दी गई वस्तु के बराबर कोई वस्तु है।",
                        "$~\\['सेब' 'केला' 'आम'].has('केला')\\"
                    ],
                    "names": "$~है",
                    "inputs": [
                        {
                            "doc": "$~खोज करने के लिए मूल्य.",
                            "names": "$~वस्तु"
                        }
                    ]
                },
                "join": {
                    "doc": [
                        "$~मैं अपनी सूची में मौजूद वस्तुओं को @Text में संयोजित करता हूँ, तथा उन्हें दिए गए विभाजक @Text से अलग करता हूँ।",
                        "$~\\['सेब' 'केला' 'आम'].join(', ')\\"
                    ],
                    "names": "$~जोड़ना",
                    "inputs": [
                        {
                            "doc": "$~आइटम को अलग करने के लिए पाठ, वैकल्पिक रूप से रिक्त.",
                            "names": "$~सेपरेटर"
                        }
                    ]
                },
                "subsequence": {
                    "doc": [
                        "$~मुझे इस सूची के भीतर एक सूची मिलती है, जो आपके द्वारा दिए गए सूचकांक से शुरू होती है, और अंतिम आइटम, या यदि आप एक सूची प्रदान करते हैं, तो एक विशेष आइटम के साथ समाप्त होती है।",
                        "$~\\['सेब' 'केला' 'आम'].subsequence(2)\\",
                        "$~\\['सेब' 'केला' 'आम'].subsequence(1 2)\\",
                        "$~और देखो! अगर तुम क्रम से संख्याएँ नहीं दोगे, तो मैं तुम्हें उल्टा दूँगा",
                        "$~\\['सेब' 'केला' 'आम'].subsequence(3 1)\\",
                        "$~यदि आप मुझे सूचकांक के लिए 1 से छोटा कुछ देते हैं, तो मैं मान लूंगा कि आपका मतलब 1 है।",
                        "$~\\['सेब' 'केला' 'आम'].subsequence(-1003243 2)\\",
                        "$~और यदि आप मुझे सबसे बड़े सूचकांक से भी बड़ा कुछ देते हैं, तो मैं मान लूंगा कि आपका आशय अंत से है।",
                        "$~\\['सेब' 'केला' 'आम'].subsequence(3 2304032432)\\"
                    ],
                    "names": "$~परिणामको",
                    "inputs": [
                        {
                            "doc": "$~आपके इच्छित उपअनुक्रम के प्रथम आइटम का सूचकांक.",
                            "names": "$~शुरू"
                        },
                        {
                            "doc": "$~आपके द्वारा वांछित उप-अनुक्रम के अंतिम आइटम का वैकल्पिक सूचकांक। यदि आप इसे नहीं देते हैं, तो आपकी सूची सूची के अंतिम आइटम के साथ समाप्त हो जाएगी।",
                            "names": "$~अंत"
                        }
                    ]
                },
                "sansFirst": {
                    "doc": [
                        "$~मैं अपनी पहली वस्तु के बिना एक सूची बनाता हूँ।",
                        "$~\\['सेब' 'केला' 'आम'].sansFirst()\\"
                    ],
                    "names": ["$~बिनापहले", "$~संसफर्स्ट"],
                    "inputs": []
                },
                "sansLast": {
                    "doc": [
                        "$~मैं अपनी अंतिम वस्तु के बिना एक सूची बनाता हूँ।",
                        "$~\\['सेब' 'केला' 'आम'].sansLast()\\"
                    ],
                    "names": ["$~बिनाअंतिम", "$~संसअंतिम"],
                    "inputs": []
                },
                "sans": {
                    "doc": [
                        "$~मुझे, लेकिन दिए गए मूल्य की पहली घटनाओं के बिना।",
                        "$~\\['सेब' 'केला' 'आम' 'सेब'].sans('सेब')\\"
                    ],
                    "names": ["$~बिना", "$~बिना"],
                    "inputs": [
                        {
                            "doc": "$~वह मान जिसे पहली बार आने पर हटाया जाना है.",
                            "names": "$~कीमत"
                        }
                    ]
                },
                "sansAll": {
                    "doc": [
                        "$~मुझे, लेकिन दिए गए मूल्य की सभी घटनाओं के बिना।",
                        "$~\\['सेब' 'केला' 'आम' 'सेब'].sans('सेब')\\"
                    ],
                    "names": ["$~बिनासब", "$~बिनासब"],
                    "inputs": [
                        {
                            "doc": "$~सूची से की सभी घटनाओं को निकालने के लिए मान.",
                            "names": "$~कीमत"
                        }
                    ]
                },
                "reverse": {
                    "doc": [
                        "$~मैं, लेकिन उल्टा!",
                        "$~\\['सेब' 'केला' 'आम'].रिवर्स()\\"
                    ],
                    "names": ["$~उलट", "$~रिवर्स"],
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "$~\\⊤\\ यदि मेरे आइटम और ऑर्डर दिए गए @List के समान हैं।",
                        "$~\\['सेब' 'केला' 'आम'] = ['सेब' 'आम' 'केला']\\"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "$~मेरी तुलना करने के लिए @List.",
                            "names": "$~सूची"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "$~\\⊤\\ यदि मेरे आइटम और ऑर्डर दिए गए @List के समान नहीं हैं।",
                        "$~\\['सेब' 'केला' 'आम'] ≠ ['सेब' 'आम' 'केला']\\"
                    ],
                    "names": ["$~≠", "$~समनही"],
                    "inputs": [
                        {
                            "doc": "$~मेरी तुलना करने के लिए @List.",
                            "names": "$~सूची"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "$~मुझे एक @FunctionDefinition दीजिए जो एक मान और वैकल्पिक इंडेक्स को इनपुट के रूप में लेता है और एक मान उत्पन्न करता है, और मैं अपने प्रत्येक आइटम पर इसका मूल्यांकन करूंगा, अपने मानों को नए मानों में परिवर्तित करूंगा।",
                        "$~उदाहरण के लिए, कल्पना करें कि मैं @Number की एक सूची थी और आप उन सभी को दोगुना करना चाहते थे:",
                        "$~\\[2 4 6 8].translate(ƒ(संख्या•#) संख्या · 2)\\"
                    ],
                    "names": "$~अनुवाद",
                    "inputs": [
                        {
                            "doc": "$~@FunctionDefinition जो प्रत्येक आइटम का अनुवाद करेगा.",
                            "names": "$~अनुवादक"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "$~आइटम का अनुवाद किया जा रहा है.",
                            "names": "$~वस्तु"
                        },
                        {
                            "doc": "$~अनुवाद किये जा रहे आइटम का सूचकांक.",
                            "names": "$~अनुक्रमणिका"
                        },
                        {
                            "doc": "$~सूची का अनुवाद किया जा रहा है।",
                            "names": "$~सूची"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "$~मुझे एक @FunctionDefinition दीजिए जो एक मान और वैकल्पिक इंडेक्स को इनपुट के रूप में लेता है और एक @Boolean उत्पन्न करता है, और मैं एक नई सूची बनाऊंगा जिसमें केवल वे आइटम शामिल होंगे जो \\⊤\\ का परिणाम देते हैं।",
                        "$~उदाहरण के लिए, कल्पना करें कि मैं @Number की एक सूची थी और आप केवल सकारात्मक वाले चाहते थे:",
                        "$~\\[2 -4 8 -16].फ़िल्टर(˒(num•#) संख्या ≥ 0)\\"
                    ],
                    "names": "$~फ़िल्टर",
                    "inputs": [
                        {
                            "doc": "$~एक @FunctionDefinition जो प्रत्येक आइटम की जांच करता है, और यदि उसे रखा जाना चाहिए तो \\⊤\\ उत्पन्न करता है।",
                            "names": "$~चेकर"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~आइटम की जाँच की जा रही है.",
                            "names": "$~वस्तु"
                        },
                        {
                            "doc": "$~जाँच की जा रही वस्तु का सूचकांक.",
                            "names": "$~अनुक्रमणिका"
                        },
                        {
                            "doc": "$~सूची फ़िल्टर की जा रही है.",
                            "names": "$~सूची"
                        }
                    ]
                },
                "all": {
                    "doc": [
                        "$~मुझे एक @FunctionDefinition दीजिए जो इनपुट के रूप में एक मान लेता है और अगर यह किसी शर्त से मेल खाता है तो @Boolean बनाता है। अगर सभी आइटम शर्त से मेल खाते हैं तो मैं \\⊤\\ बनाऊँगा।",
                        "$~उदाहरण के लिए, कल्पना करें कि मैं @Number की एक सूची हूं और आप जानना चाहते हैं कि क्या सब कुछ सकारात्मक है:",
                        "$~\\[2 -4 8 -16].सभी(˒(num•#) संख्या ≥ 0)\\"
                    ],
                    "names": "$~सभी",
                    "inputs": [
                        {
                            "doc": "$~@FunctionDefinition जो \\⊤\\ उत्पन्न करता है यदि कोई आइटम आपकी शर्त को संतुष्ट करता है।",
                            "names": "$~चेकर"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~आइटम की जाँच की जा रही है.",
                            "names": "$~वस्तु"
                        },
                        {
                            "doc": "$~जाँच की जा रही वस्तु का सूचकांक.",
                            "names": "$~अनुक्रमणिका"
                        },
                        {
                            "doc": "$~सूची की जाँच की जा रही है।",
                            "names": "$~सूची"
                        }
                    ]
                },
                "until": {
                    "doc": [
                        "$~मुझे एक @FunctionDefinition दीजिए जो इनपुट के रूप में एक मान लेता है और अगर यह किसी शर्त से मेल खाता है तो @Boolean बनाता है। मैं एक नई @List बनाऊँगा जिसमें शर्त पूरी न होने तक सभी आइटम शामिल होंगे।",
                        "$~उदाहरण के लिए, कल्पना करें कि मैं @Text जानवरों की एक सूची थी और आप \\'rat'\\ मिलने तक सब कुछ चाहते थे:",
                        "$~\\['बिल्ली' 'कुत्ता' 'चूहा' 'चूहा' 'टट्टू'].until(ƒ(पशु•'') पशु = 'चूहा')\\"
                    ],
                    "names": "$~जबतक",
                    "inputs": [
                        {
                            "doc": "$~@FunctionDefinition जो \\⊤\\ उत्पन्न करता है यदि मैं आइटमों को शामिल करना बंद कर दूं।",
                            "names": "$~चेकर"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~आइटम की जाँच की जा रही है.",
                            "names": "$~वस्तु"
                        },
                        {
                            "doc": "$~जाँच की जा रही वस्तु का सूचकांक.",
                            "names": "$~अनुक्रमणिका"
                        },
                        {
                            "doc": "$~सूची को अनुक्रमित किया जा रहा है।",
                            "names": "$~सूची"
                        }
                    ]
                },
                "find": {
                    "doc": [
                        "$~मुझे एक @FunctionDefinition दीजिए जो एक मान को इनपुट के रूप में ले और यदि वह कुछ मानदंडों से मेल खाता हो तो @Boolean उत्पन्न करे, और मैं मेल खाने वाले आइटम का मूल्यांकन करूंगा।",
                        "$~उदाहरण के लिए, कल्पना करें कि आप वह पहला जानवर ढूंढना चाहते हैं जिसमें स्वर \\'e\\ हो:",
                        "$~\\['बिल्ली' 'कुत्ता' 'चूहा' 'टट्टू'].find(ƒ(पशु•'') पशु.has('e'))\\"
                    ],
                    "names": "$~खोजो",
                    "inputs": [
                        {
                            "doc": "$~@FunctionDefinition जो आपके खोज मानदंड से मेल खाने पर \\⊤\\ उत्पन्न करता है।",
                            "names": "$~चेकर"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~आइटम की जाँच की जा रही है.",
                            "names": "$~वस्तु"
                        },
                        {
                            "doc": "$~जाँच की जा रही वस्तु का सूचकांक.",
                            "names": "$~अनुक्रमणिका"
                        },
                        {
                            "doc": "$~सूची खोजी जा रही है.",
                            "names": "$~सूची"
                        }
                    ]
                },
                "combine": {
                    "doc": [
                        "$~मुझे एक @FunctionDefinition दीजिए जो सबसे हालिया संयोजन और अगला मान लेता है, और अगला संयोजन बनाता है, और मैं अपने आइटमों में से पहले से अंतिम तक जाऊंगा, क्रमिक संयोजनों का निर्माण करूंगा, और आपके @FunctionDefinition द्वारा मूल्यांकन किए गए अंतिम संयोजन का मूल्यांकन करूंगा।",
                        "$~यह मेरे सभी आइटम को एक ही मान में संयोजित करने के लिए वास्तव में सहायक है। उदाहरण के लिए, कल्पना करें कि आप संख्याओं की एक सूची जोड़ना चाहते हैं:",
                        "$~\\[३ ९ २ ८ १ ४].combine(0 ƒ(sum•# number•#) sum + number)\\"
                    ],
                    "names": ["$~संयुक्त", "$~मिलाना"],
                    "inputs": [
                        {
                            "doc": "$~प्रारंभिक संयोजन.",
                            "names": "$~प्रारंभिक"
                        },
                        {
                            "doc": "$~@FunctionDefinition जो नवीनतम संयोजन और अगला मान लेता है और अगला संयोजन उत्पन्न करता है।",
                            "names": "$~संयोजक"
                        }
                    ],
                    "combiner": [
                        {
                            "doc": "$~वर्तमान संयोजन",
                            "names": "$~संयोजन"
                        },
                        {
                            "doc": "$~संयोजित करने के लिए अगला आइटम.",
                            "names": "$~अगला"
                        },
                        {
                            "doc": "$~अगले आइटम का सूचकांक",
                            "names": "$~अनुक्रमणिका"
                        },
                        {
                            "doc": "$~सूची को संयोजित किया जा रहा है।",
                            "names": "$~सूची"
                        }
                    ]
                },
                "sorted": {
                    "doc": [
                        "$~मैं एक सूची ले सकता हूँ, और उसके मानों को क्रमबद्ध करके एक नई सूची बना सकता हूँ। इस तरह:",
                        "$~\\[1 5 8 0 2].सॉर्टेड()\\",
                        "$~मैं इसे @Text मानों के लिए भी कर सकता हूँ",
                        "$~\\['नारंगी' 'कीवी' 'केला' 'सेब'].sorted()\\",
                        "$~और अगर आपके पास ऐसे मानों की सूची है जो @Number या @Text नहीं हैं, तो आप मुझे एक @FunctionDefinition दे सकते हैं जो प्रत्येक आइटम को @Number में बदल देता है ताकि मैं उसे सॉर्ट कर सकूँ। उदाहरण के लिए, यहाँ हमारे पास अलग-अलग लंबाई की सूचियों की सूची है; अगर आप मुझे एक ऐसा फ़ंक्शन देते हैं जो प्रत्येक सूची को उसकी लंबाई में बदल देता है, तो मैं उनकी लंबाई के अनुसार सॉर्ट कर सकता हूँ।",
                        "$~\\[[1] [2 3] [4 8 12] [8]].sorted(ƒ(सूची) सूची.लंबाई())\\"
                    ],
                    "names": "$~क्रमबद्ध",
                    "inputs": [
                        {
                            "doc": "$",
                            "names": "$~अनुक्रमक"
                        }
                    ],
                    "sequencer": [
                        {
                            "doc": "$~वह मान जिसे @Number में बदलना है.",
                            "names": "$~कीमत"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~सूची का @Text निरूपण करने के लिए.",
                "set": "$~@Set पर, डुप्लिकेट को हटाने में सहायक।"
            }
        },
        "Set": {
            "doc": [
                "$~मैं मूल्यों का एक समूह हूँ! इसका मतलब है कि मैं किसी भी संख्या में मूल्यों को शामिल कर सकता हूँ, जिसमें कोई मूल्य नहीं भी शामिल है। आप मुझे इस तरह बना सकते हैं:",
                "$~\\{1 2 3}\\",
                "$~यदि आप बिना किसी डुप्लिकेट के चीजों का संग्रह रखना चाहते हैं तो मैं वास्तव में बहुत अच्छा हूं।",
                "$~इसका मतलब यह है कि यदि आप मुझे वे मूल्य देंगे जो मेरे पास पहले से हैं, तो मैं अतिरिक्त मूल्यों को नजरअंदाज कर दूंगा।",
                "$~उदाहरण के लिए, इस सेट में कई डुप्लिकेट हैं:",
                "$~\\{1 1 2 2 3 3}\\",
                "$~मैं इसका मूल्यांकन केवल \\{1 2 3}\\ करता हूँ।",
                "$~यदि आप देखना चाहते हैं कि मुझमें कोई मूल्य है या नहीं, तो @SetOrMapAccess आपकी सहायता कर सकता है:",
                "$~\\{'जार' 'बोतल' 'ग्लास'}{'कप'}\\",
                "$~आम तौर पर, अगर आप मुझे ऐसे कई मान देते हैं जो एक ही प्रकार के हैं, तो मैं मान लूंगा कि वे उसी प्रकार की सूची हैं। जैसे यह सेट \\{''}\\ है, क्योंकि यह सब @Text है।",
                "$~\\{'हे' 'हाय' 'हैलो'}\\",
                "$~लेकिन आप यह बताना चाहेंगे कि मैं /केवल/ उन मानों का एक समूह हूँ, ताकि मैं आपको बता सकूँ कि आप कब किसी ऐसे मान का उपयोग करने का प्रयास कर रहे हैं जिसकी अनुमति नहीं है। यदि ऐसा है, तो बस मेरे अंत में ! जोड़ दें।",
                "$~\\{'हे' 'हाय' 'हैलो'}!{'यो'}\\",
                "$~क्या आप मेरे साथ कुछ और करना चाहते हैं? मेरे पास मौजूद सभी बेहतरीन @FunctionDefinition देखें!"
            ],
            "name": ["$~{}", "$~तयकरना"],
            "kind": "$~दयालु",
            "out": "$~परिणाम",
            "function": {
                "size": {
                    "doc": "$~मैं तुम्हें बताऊंगा कि मुझमें कितने मूल्य हैं।",
                    "names": "$~आकार",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "$~मैं \\⊤\\ हूँ यदि दिए गए @Set और I का मान बिल्कुल समान है:",
                        "$~\\{1 2 3} = {2 3 4}\\"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "$~तुलना करने के लिए @Set.",
                            "names": "$~तयकरना"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "$~यदि दिए गए @Set और I का मान बिल्कुल समान नहीं है, तो मैं \\⊤\\ हूँ:",
                        "$~\\{1 2 3} ≠ {2 3 4}\\"
                    ],
                    "names": ["$~≠", "$~समनही"],
                    "inputs": [
                        {
                            "doc": "$~तुलना करने के लिए @Set.",
                            "names": "$~तयकरना"
                        }
                    ]
                },
                "add": {
                    "doc": [
                        "$~मुझे जोड़ने के लिए एक आइटम दें और मैं अपने आइटम और दिए गए आइटम के साथ एक नया @Set बनाऊंगा।",
                        "$~\\{1 2 3} + 4\\"
                    ],
                    "names": ["add", "+"],
                    "inputs": [
                        {
                            "doc": "$~जोड़ने के लिए आइटम",
                            "names": "$~वस्तु"
                        }
                    ]
                },
                "remove": {
                    "doc": [
                        "$~मुझे हटाने के लिए एक आइटम दीजिए और मैं उस आइटम के बिना एक नया @Set बनाऊंगा।",
                        "$~\\{1 2 3} - 2\\",
                        "$~यदि मेरे पास वह वस्तु नहीं है, तो मैं स्वयं उसका मूल्यांकन करूंगा।"
                    ],
                    "names": ["remove", "-"],
                    "inputs": [
                        {
                            "doc": "$~हटाने के लिए आइटम.",
                            "names": "$~वस्तु"
                        }
                    ]
                },
                "union": {
                    "doc": [
                        "$~मुझे @Set दीजिए और मैं एक नया @Set बनाऊंगा जिसमें मेरे आइटम और सेट के आइटम होंगे।",
                        "$~\\{1 2 3} ∪ {3 4 5}\\"
                    ],
                    "names": ["union", "∪"],
                    "inputs": [
                        {
                            "doc": "$~@Set मेरे साथ संयोजित करने के लिए.",
                            "names": "$~तयकरना"
                        }
                    ]
                },
                "intersection": {
                    "doc": [
                        "$~मुझे @Set दीजिए और मैं एक नया @Set बनाऊंगा जिसमें केवल वही चीजें होंगी जो हमारे बीच समान हैं।",
                        "$~\\{1 2 3} ∩ {3 4 5}\\"
                    ],
                    "names": ["intersection", "∩"],
                    "inputs": [
                        {
                            "doc": "$~मेरे साथ तुलना करने के लिए सेट.",
                            "names": "$~तयकरना"
                        }
                    ]
                },
                "difference": {
                    "doc": [
                        "$~मुझे @Set दीजिए और मैं एक नया @Set बनाऊंगा जिसमें केवल वही आइटम होंगे जो हमारे बीच समान हैं।",
                        "$~\\{1 2 3}.अंतर({3 4 5})\\"
                    ],
                    "names": "$~अंतर",
                    "inputs": [
                        {
                            "doc": "$~वह सेट जिसके सामान मुझसे हटा दिए जाएं।",
                            "names": "$~तयकरना"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "$~मुझे @FunctionDefinition दीजिए जो एक आइटम ले और यदि उसे रखा जाना चाहिए तो \\⊤\\ उत्पन्न करे, और मैं एक @Set बनाऊंगा जिसमें केवल वे आइटम होंगे जो आपके मानदंड को पूरा करते हैं।",
                        "$~उदाहरण के लिए, आइए मुझमें विषम संख्याएं ढूंढें:",
                        "$~\\{1 2 3 4 5 6 7 8 9}.filter(˒(num•#) (num % 2) = 1)\\"
                    ],
                    "names": "filter",
                    "inputs": [
                        {
                            "doc": "$~@FunctionDefinition जो किसी आइटम की जांच करता है कि उसे रखा जाना चाहिए या नहीं।",
                            "names": "$~चेकर"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~आइटम की जाँच की जा रही है.",
                            "names": "$~कीमत"
                        },
                        {
                            "doc": "$~फ़िल्टर किया जा रहा सेट",
                            "names": "$~तयकरना"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "$~मुझे @FunctionDefinition दीजिए जो एक आइटम ले और उसके आधार पर एक नया आइटम तैयार करे, फिर मैं अपने सभी आइटम को एक नए @Set में परिवर्तित कर दूंगा (किसी भी डुप्लिकेट को हटाते हुए)।",
                        "$~उदाहरण के लिए, आइए अपने सभी @Number को @Text में बदलें:",
                        "$~\\{1 2 3 4 5 6 7 8 9}.translate(ƒ(num•#) num→'')\\"
                    ],
                    "names": "translate",
                    "inputs": [
                        {
                            "doc": "$~@FunctionDefinition जो मेरे किसी एक आइटम को आपके इच्छित नए आइटम में परिवर्तित करता है।",
                            "names": "$~तयकरना"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "$~आइटम का अनुवाद किया जा रहा है.",
                            "names": "$~कीमत"
                        },
                        {
                            "doc": "$~सेट का अनुवाद किया जा रहा है",
                            "names": "$~तयकरना"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~@Set का @Text प्रतिनिधित्व",
                "list": "$~सेट में आइटमों का @List प्रतिनिधित्व."
            }
        },
        "Map": {
            "doc": [
                "$~मैं मूल्यों को एक साथ लाता हूँ, *कुंजी* को *मूल्यों* से मैप करता हूँ। उदाहरण के लिए:",
                "$~\\{'amy': 6 अंक 'tony': 3 अंक 'shiela': 8 अंक}\\",
                "$~मेरी कुंजियाँ किसी भी प्रकार का मान हो सकती हैं, और मेरे मूल्य किसी भी प्रकार का मान हो सकते हैं।",
                "$~कुछ लोग मुझे एक सूचकांक या शब्दकोष की तरह समझते हैं, जहां आप मुझे कुछ देते हैं और मैं आपको बताता हूं कि वह किससे जुड़ा है।",
                "$~यदि आप यह जांचना चाहते हैं कि कोई चीज किससे मैप की गई है, तो आप @SetOrMapAccess को एक कुंजी दे सकते हैं और वे आपको मान देंगे:",
                "$~\\{'amy': 6 अंक 'tony': 3 अंक 'shiela': 8 अंक}{'amy'}\\",
                "$~यदि कोई मिलान कुंजी नहीं है, तो मैं आपको @None दूंगा।",
                "$~\\{'amy': 6 अंक 'tony': 3 अंक 'shiela': 8 अंक}{'jen'}\\",
                "$~आप इस तरह एक खाली नक्शा भी बना सकते हैं:",
                "$~\\{:}\\",
                "$~आम तौर पर, मैं आपके द्वारा दिए गए किसी भी प्रकार की कुंजी और मान को देखूंगा और उन सभी को दर्शाने के लिए एक प्रकार बनाऊंगा। जैसे यह संख्याओं से संख्याओं तक का मानचित्र है:",
                "$~\\{1:1 2:2 3:3}\\",
                "$~लेकिन मान लीजिए कि आप यह सुनिश्चित करना चाहते हैं कि यह विशेष रूप से केवल वही मान हों; बस मेरे अंत में ! जोड़ें, और मैं सामान्यीकरण नहीं करूँगा। इससे आपको यह जानने में मदद मिलेगी कि क्या आप कोई ऐसा मान प्राप्त करने की कोशिश कर रहे हैं जो आपने नहीं चाहा था।",
                "$~\\{1:1 2:2 3:3}!{4}\\",
                "$~मैं अपनी जोड़ियों के साथ कई अद्भुत चीजें करना जानता हूं।"
            ],
            "name": ["$~{:}", "$~नक्शा"],
            "key": "$~चाबी",
            "value": "$~कीमत",
            "result": "$~परिणाम",
            "function": {
                "size": {
                    "doc": "$~मैं तुम्हें बताऊंगा कि मुझमें कितने मूल्य हैं।",
                    "names": "$~आकार",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "$~\\{⊤}\\ यदि मेरी जोड़ियाँ दिए गए @Map के समान हैं।",
                        "$~\\{1:1 2:2} = {1:1 2:3}\\"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "$~वह @Map जिससे मेरी तुलना की जाएगी।",
                            "names": "$~कीमत"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "$~\\{⊤}\\ यदि मेरी जोड़ियाँ दिए गए @Map के समान नहीं हैं।",
                        "$~\\{1:1 2:2} ≠ {1:1 2:3}\\"
                    ],
                    "names": ["$~≠", "$~समनही"],
                    "inputs": [
                        {
                            "doc": "$~वह @Map जिससे मेरी तुलना की जाएगी।",
                            "names": "$~कीमत"
                        }
                    ]
                },
                "set": {
                    "doc": [
                        "$~मैं सभी समान जोड़ियों के साथ एक नया @Map बनाऊंगा, लेकिन आपके द्वारा दी गई नई जोड़ी के साथ। अगर मेरे पास पहले से ही कुंजी है, तो मैं इसे नए मान से जोड़ूंगा।",
                        "$~\\{'amy': 6 अंक 'tony': 3 अंक}.pair('jen' 0 अंक)\\"
                    ],
                    "names": "$~जोड़ा",
                    "inputs": [
                        {
                            "doc": "$~मान के साथ जोड़ी बनाने की कुंजी.",
                            "names": "$~चाबी"
                        },
                        {
                            "doc": "$~कुंजी के साथ युग्मित करने के लिए मान",
                            "names": "$~कीमत"
                        }
                    ]
                },
                "unset": {
                    "doc": [
                        "$~मैं आपके द्वारा दी गई कुंजी के बिना एक नया @Map बनाऊंगा, तथा उसका युग्मन हटा दूंगा।",
                        "$~\\{'amy': 6 अंक 'tony': 3 अंक}.unpair('amy')\\"
                    ],
                    "names": "$~अयुग्मित",
                    "inputs": [
                        {
                            "doc": "$~भूलने की कुंजी.",
                            "names": "$~चाबी"
                        }
                    ]
                },
                "remove": {
                    "doc": [
                        "$~मैं बिना किसी कुंजी के एक नया @Map बनाऊंगा जिसमें मान हो।",
                        "$~\\{'amy': 0 अंक 'jen': 0 अंक 'tony':3 अंक}.remove(0 अंक)\\"
                    ],
                    "names": "$~निकालना",
                    "inputs": [
                        {
                            "doc": "$~मुझसे हटाए जाने वाला मान, साथ ही इससे जुड़ी कोई भी कुंजी।",
                            "names": "$~कीमत"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "$~मुझे एक @FunctionDefinition दीजिए जो एक कुंजी और मान लेता है और यदि युग्मन को रखा जाना चाहिए तो \\⊤\\ का मूल्यांकन करता है। मैं एक नया @Map बनाऊँगा जो आपके मानदंडों को पूरा करता है।",
                        "$~उदाहरण के लिए, यहां हम उन जोड़ियों को रखना चाहते हैं जो एमी हैं या जिनके अंक शून्य से अधिक हैं।",
                        "$~\\{'amy': 0 अंक 'jen': 0 अंक 'tony':3 अंक}.filter(ƒ(key•'' value•#points) (key = 'amy') | (value > 0points))\\"
                    ],
                    "names": "filter",
                    "inputs": [
                        {
                            "doc": "$~@FunctionDefinition जो यह निर्णय लेता है कि युग्मन को बनाए रखना है या नहीं।",
                            "names": "$~चेकर"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~कुंजी की जाँच की जा रही है।",
                            "names": "$~चाबी"
                        },
                        {
                            "doc": "$~जाँचा जा रहा मान.",
                            "names": "$~कीमत"
                        },
                        {
                            "doc": "$~मानचित्र को फ़िल्टर किया जा रहा है।",
                            "names": "$~नक्शा"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "$~मुझे एक @FunctionDefinition दीजिए जो एक कुंजी और मान लेता है और मान का मूल्यांकन एक नए मान के रूप में करता है। मैं उन्हीं कुंजियों के साथ लेकिन अपडेट किए गए मानों के साथ एक नया @Map बनाऊँगा।",
                        "$~उदाहरण के लिए, हम सभी को एक अंक देंगे क्योंकि वे बहुत अच्छे रहे हैं।",
                        "$~\\{'amy': 5 अंक 'jen': 3 अंक 'tony': 0 अंक}.translate(ƒ(key•'' value•#points) value + 1 अंक)\\"
                    ],
                    "names": "translate",
                    "inputs": [
                        {
                            "doc": "$~@FunctionDefinition जो प्रत्येक मान का अनुवाद करता है।",
                            "names": "$~अनुवादक"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "$~अनुवादित किये जा रहे मान की कुंजी.",
                            "names": "$~चाबी"
                        },
                        {
                            "doc": "$~मूल्य का अनुवाद किया जा रहा है।",
                            "names": "$~कीमत"
                        },
                        {
                            "doc": "$~मानचित्र का अनुवाद किया जा रहा है।",
                            "names": "$~नक्शा"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~मैपिंग का @Text प्रतिनिधित्व.",
                "set": "$~@मानचित्र की कुंजियाँ",
                "list": "$~@Map में मानों की सूची"
            }
        },
        "Table": {
            "doc": [
                "$~मैं टेबल पंक्तियों का एक सेट हूँ! मैं आपको समान संरचना वाले मूल्यों के बड़े संग्रह को ट्रैक करने में मदद कर सकता हूँ।",
                "$~उदाहरण के लिए, कल्पना करें कि आप चट्टानों के एक समूह पर नज़र रखना चाहते हैं:",
                "$~\\⎡नाम•'' रंग•''⎦\n⎡'ओब्सीडियन' 'काला'⎦\n⎡'प्यूमिस' 'ग्रे'⎦\n⎡'सिट्रीन' 'पीला'⎦\\",
                "$~@Bind आपको इसका नाम रखने में मदद कर सकता है! और फिर आप एक नई पंक्ति @Insert के साथ संशोधित तालिका बनाने जैसे काम कर सकते हैं:",
                "$~\\चट्टानें: ⎡नाम•''रंग•''⎦\n⎡'ओब्सीडियन' 'काला'⎦\n⎡'प्यूमिस' 'ग्रे'⎦\n⎡'सिट्रीन' 'पीला'⎦\nचट्टानें ⎡+ 'क्वार्ट्ज' 'सफ़ेद'⎦\\",
                "$~या यदि आप मेल खाने वाली पंक्तियाँ ढूँढना चाहते हैं, तो आप @Select पंक्तियाँ कर सकते हैं जो किसी शर्त से मेल खाती हैं:",
                "$~\\चट्टानें: ⎡नाम•''रंग•''⎦\n⎡'ओब्सीडियन' 'काला'⎦\n⎡'प्यूमिस' 'ग्रे'⎦\n⎡'सिट्रीन' 'पीला'⎦\nचट्टानें ⎡?⎦रंग = 'ग्रे'\\",
                "$~या हो सकता है कि आप एक संशोधित तालिका बनाना चाहते हों जिसमें किसी शर्त से मेल खाने वाली पंक्तियों के लिए अलग-अलग मान हों:",
                "$~\\चट्टानें: ⎡नाम•'' रंग•''⎦\n⎡'ओब्सीडियन' 'काला'⎦\n⎡'प्यूमिस' 'ग्रे'⎦\n⎡'सिट्रीन' 'पीला'⎦\nचट्टानें ⎡: रंग: 'काला' ⎦ नाम = 'प्यूमिस'\\",
                "$~या हो सकता है कि आप किसी शर्त से मेल खाने वाली पंक्ति को हटाना चाहते हों:",
                "$~\\चट्टानें: ⎡नाम•''रंग•''⎦\n⎡'ओब्सीडियन' 'काला'⎦\n⎡'प्यूमिस' 'ग्रे'⎦\n⎡'सिट्रीन' 'पीला'⎦\nचट्टानें ⎡- नाम.has('i')\\",
                "$~और यदि आप कभी मुझसे विशिष्ट मान प्राप्त करना चाहते हैं, तो आप किसी भी तालिका को सूची में परिवर्तित कर सकते हैं और @PropertyReference के साथ व्यक्तिगत पंक्तियों तक पहुंच सकते हैं",
                "$~\\चट्टानें: ⎡नाम•'' रंग•''⎦\n⎡'ओब्सीडियन' 'काला'⎦\n⎡'प्यूमिस' 'ग्रे'⎦\n⎡'सिट्रीन' 'पीला'⎦\n(चट्टानें → [])[1].नाम\\"
            ],
            "name": ["$~⎡⎦", "$~मेज़"],
            "row": "$~पंक्ति",
            "function": {
                "equals": {
                    "doc": "$~मैं जांचता हूं कि क्या मेरे पास अन्य @Table के समान क्रम में वही कोशिकाएं हैं।",
                    "names": ["$~=", "$~केबराबरहोतीहै"],
                    "inputs": [
                        {
                            "doc": "$~दूसरी तालिका की जाँच करें।",
                            "names": "$~कीमत"
                        }
                    ]
                },
                "notequal": {
                    "doc": "$~मैं जाँचता हूँ कि क्या मेरी कोई भी कोशिका किसी अन्य @Table से भिन्न है या अलग क्रम में है।",
                    "names": ["$~≠", "$~नॉटइक्वल्स"],
                    "inputs": [
                        {
                            "doc": "$~दूसरी तालिका की जाँच करें।",
                            "names": "$~कीमत"
                        }
                    ]
                }
            },
            "conversion": {
                "list": "$~मैं @Table को पंक्तियों की सूची में परिवर्तित करता हूँ, जहाँ प्रत्येक पंक्ति एक @Structure होती है, जिसके गुणधर्मों के रूप में उसके स्तंभ नाम होते हैं।",
                "text": "$~मैं बस @Table को टेक्स्ट में बदलता हूं।"
            }
        },
        "Structure": {
            "doc": "$~@StructureDefinition देखें.",
            "name": ["$~संरचना"],
            "function": {
                "equals": {
                    "doc": "$~मैं जाँचता हूँ कि क्या मेरे गुणधर्मों का नाम और मान किसी अन्य संरचना के गुणों के समान है।",
                    "names": ["$~=", "$~केबराबरहोतीहै"],
                    "inputs": [
                        {
                            "doc": "$~अन्य संरचना की जाँच करें।",
                            "names": "$~कीमत"
                        }
                    ]
                },
                "notequal": {
                    "doc": "$~मैं जांचता हूं कि क्या मेरे गुण किसी अन्य संरचना के नाम और मूल्यों से किसी भी तरह से भिन्न हैं।",
                    "names": ["$~≠", "$~नॉटइक्वल्स"],
                    "inputs": [
                        {
                            "doc": "$~अन्य संरचना की जाँच करें।",
                            "names": "$~कीमत"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~मैं स्वयं को @Text में परिवर्तित करता हूँ।"
            }
        }
    },
    "input": {
        "Random": {
            "doc": [
                "$~17!",
                "$~/@FunctionDefinition यहाँ, मैं इसे समझाऊंगा।/",
                "$~तो @Random एक दिलचस्प फ़ंक्शन है जो यादृच्छिक संख्याएँ बनाता है। यह दिलचस्प इसलिए है क्योंकि हर बार जब आप इसका मूल्यांकन करते हैं, तो यह कुछ अलग बनाता है।",
                "$~इससे एक अद्भुत अराजकता पैदा होती है जो अप्रत्याशितता के साथ आती है।",
                "$~डिफ़ॉल्ट रूप से, यह \\0\\ और \\1\\ के बीच @Number मान देता है:",
                "$~\\यादृच्छिक()\\",
                "$~लेकिन आप इसे एक मान दे सकते हैं, और यह \\0\\ और मान के बीच मान उत्पन्न करेगा:",
                "$~\\यादृच्छिक(10)\\",
                "$~और यदि आप इसे दो मान देते हैं, तो यह उन दो मानों के बीच और उन दोनों को सम्मिलित करते हुए मान उत्पन्न करेगा:",
                "$~\\रैंडम(-10 10)\\",
                "$~यदि आपकी श्रेणियों में इकाइयाँ हैं, तो उन्हें संरक्षित रखा जाएगा (और यदि वे मेल नहीं खाती हैं, तो न्यूनतम इकाई का उपयोग किया जाएगा):",
                "$~\\यादृच्छिक(-10मी 10मी)\\",
                "$~और यदि आप दशमलव बिंदु के बाद विशेष सार्थक अंकों वाली संख्याएं देते हैं, तो वह परिशुद्धता सुरक्षित रहेगी।",
                "$~\\रैंडम(1.00 10.00)\\"
            ],
            "names": ["$~🎲", "$~यादृच्छिक"],
            "inputs": [
                {
                    "names": "$~मिन",
                    "doc": "$~न्यूनतम मान जो बनाया जाएगा, या यदि यह 0 से बड़ा है, तो अधिकतम मान। यदि @None प्रदान किया गया है, तो न्यूनतम मान \\0\\ है।"
                },
                {
                    "names": "$~अधिकतम",
                    "doc": "$~अधिकतम मान जो बनाया जाएगा, या यदि यह दिए गए न्यूनतम से छोटा है, तो न्यूनतम। यदि @None दिया गया है, तो अधिकतम \\1\\ है।"
                }
            ]
        },
        "Choice": {
            "doc": [
                "$~/क्लिक टैप!/",
                "$~/@FunctionDefinition यहाँ, मैं इसे समझाऊंगा।/",
                "$~@Choice को @Phrase/name की एक धारा की तरह समझें जो आपके दर्शकों द्वारा चुनी जाती है। अगर कोई व्यक्ति @Phrase पर /Enter/ दबाकर क्लिक, टैप या कीबोर्ड सेलेक्ट करता है, तो नाम के साथ @Choice का एक नया मान होगा जो नाम से मेल खाता है।",
                "$~इसलिए इसका उपयोग करने का सबसे अच्छा तरीका यह है कि नामित चयन योग्य वाक्यांशों @Phrase के साथ एक प्रदर्शन तैयार किया जाए, और फिर @Reaction का उपयोग करके यह निर्णय लिया जाए कि उस नाम को चुने जाने पर क्या करना है।",
                "$~यहाँ सबसे सरल उदाहरण दिया गया है:",
                "$~\\Group(\nस्टैक() \n[\nवाक्यांश('एक' चयन योग्य:⊤ नाम:'1') \nवाक्यांश('दो' चयन योग्य:⊤ नाम:'2') \nवाक्यांश(विकल्प())\n]\n)\\",
                "$~इसे एडिटर में कॉपी करें और फिर दो @Phrase में से एक को चुनें। आप देखेंगे कि तीसरा @Phrase उस नाम को दिखाता है जिसे चुना गया था।"
            ],
            "names": ["$~🔘", "$~पसंद"]
        },
        "Button": {
            "doc": [
                "$~/क्लिक क्लिक क्लिक/",
                "$~/@FunctionDefinition यहाँ, मैं इसे समझाऊंगा।/",
                "$~@बटन माउस या ट्रैकपैड को सुनने का एक शानदार तरीका है। बेशक, दर्शकों को सुनने के लिए माउस या ट्रैकपैड आदर्श विकल्प नहीं है, क्योंकि हर कोई इसका इस्तेमाल नहीं कर सकता। ज़्यादा सुलभ विकल्प @Choice है।",
                "$~लेकिन अगर आपको /वास्तव में/ माउस बटन को सुनने की ज़रूरत है, तो यह तरीका है। यह @Boolean की एक स्ट्रीम प्रदान करेगा, जो यह दर्शाता है कि प्राथमिक बटन ऊपर \\⊥\\ है या नीचे \\⊤\\ है।",
                "$~यहाँ एक सरल उदाहरण है:",
                "$~\\वाक्यांश(बटन() → '')\\",
                "$~यह सिर्फ़ @Phrase बनाता है जो स्ट्रीम का मान टेक्स्ट के रूप में होता है। अगर आप इसे एडिटर में कॉपी करते हैं और क्लिक करते हैं, तो आप इसे \\⊥\\ और \\⊤\\ के बीच आगे-पीछे टॉगल करते हुए देखेंगे।"
            ],
            "names": ["$~🖱️", "$~बटन"],
            "down": {
                "names": "$~नीचे",
                "doc": "$~यदि @None है, तो स्ट्रीम ऊपर और नीचे दोनों मान प्रदान करेगी। यदि @Boolean है, तो यह केवल दिए गए @Boolean मान का मान प्रदान करेगी।"
            }
        },
        "Pointer": {
            "doc": [
                "$~/व्हर्रर्र/",
                "$~/@FunctionDefinition यहाँ, मैं इसे समझाऊंगा।/",
                "$~क्या आप माउस, ट्रैकपैड और टच स्क्रीन के बारे में जानते हैं? कभी-कभी आप जानना चाहते हैं कि दर्शक किस ओर इशारा कर रहे हैं। @Pointer यही जानकारी देता है।",
                "$~बेशक, यह कोई सुलभ विकल्प नहीं है: हर कोई इसे आसानी से नहीं देख सकता या इंगित नहीं कर सकता, इसलिए सुनिश्चित करें कि आप इस स्ट्रीम का उपयोग करके किसी को भाग लेने से वंचित नहीं कर रहे हैं।",
                "$~यदि आप सुनिश्चित हैं कि कोई भी बहिष्कृत नहीं है, तो @Pointer का उपयोग करना एक स्ट्रीम बनाने जितना ही सरल है:",
                "$~\\पॉइंटर()\\",
                "$~यह जो @Place प्रदान करता है वह @Stage पर उस स्थान के अनुरूप होगा जहां सूचक इंगित कर रहा है।"
            ],
            "names": ["$~👆🏻", "$~सूचक"]
        },
        "Key": {
            "doc": [
                "$~/क्लिकटी/",
                "$~/@FunctionDefinition यहाँ, मैं इसे समझाऊंगा।/",
                "$~कीबोर्ड में बहुत सारी कुंजियाँ होती हैं, है न? @Key आपको बताएगा कि कोई व्यक्ति कौन सी कुंजी दबा रहा है और कौन सी छोड़ रहा है।",
                "$~ये कोशिश करें",
                "$~\\चाबी()\\",
                "$~देखें कि जब आप कोई कुंजी टाइप करते हैं, तो वह @Stage पर कैसे दिखाई देती है? हर बार जब कोई कुंजी दबाई जाती है, तो स्ट्रीम में एक नया @Text जुड़ जाता है, जो दबाए गए कुंजी का वर्णन करता है।",
                "$~किसी कुंजी के लिए जो किसी वर्ण का प्रतिनिधित्व करती है, मान @Text के रूप में वर्ण होगा।",
                "$~विशेष कुंजियों के लिए, जैसे /Escape/ कुंजी, यह @Text होगा जो कुंजी का वर्णन करेगा, <पूर्व-निर्धारित नाम@https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values> का उपयोग करते हुए, दुर्भाग्य से यह केवल अंग्रेजी में उपलब्ध है।",
                "$~यदि आप केवल किसी विशेष कुंजी के बारे में जानना चाहते हैं, तो आप इसे प्रदान कर सकते हैं:",
                "$~\\कुंजी('ए')\\",
                "$~और यदि आप केवल यह जानना चाहते हैं कि @Key को कब दबाया गया, बजाय कब छोड़ा गया, तो आप @Boolean प्रदान कर सकते हैं:",
                "$~\\कुंजी('a' ⊥)\\"
            ],
            "names": ["$~⌨️", "$~चाबी"],
            "key": {
                "names": "$~चाबी",
                "doc": "$~यदि @None है, तो सभी कुंजियाँ प्रदान की जाती हैं। यदि कोई विशिष्ट @Text है, तो केवल वही कुंजी प्रदान की जाती है।"
            },
            "down": {
                "names": "$~नीचे",
                "doc": "$~यदि @None, तो कुंजी डाउन इनपुट उत्पन्न करती है। यदि \\⊤\\, तो केवल डाउन इनपुट प्रदान किए जाते हैं, और यदि \\⊥\\, तो केवल रिलीज़ इनपुट प्रदान किए जाते हैं।"
            }
        },
        "Time": {
            "doc": [
                "$~/टिक टिक टिक/",
                "$~@FunctionDefinition यहां, मैं @Time को समझाऊंगा, क्योंकि यह बोलता नहीं है।",
                "$~समय एक धारा है जो एक निश्चित आवृत्ति पर चलती रहती है।",
                "$~हर बार ऐसा होने पर, @Program नये समय मान के साथ पुनर्मूल्यांकन करता है।",
                "$~उदाहरण के लिए:",
                "$~\\समय()\\",
                "$~यदि आप समय को @Time/frequency देते हैं, तो यह उसी दर पर टिक करेगा। उदाहरण के लिए:",
                "$~\\समय(1000एमएस)\\",
                "$~हालाँकि, इसकी सीमाएँ भी हैं कि यह कितना छोटा हो सकता है, क्योंकि @Program को अगले टिक पर प्रतिक्रिया देने से पहले मूल्यांकन के लिए समय चाहिए होता है।",
                "$~सबसे छोटा संभवतः \\20ms\\ के आसपास है।"
            ],
            "names": ["$~🕕", "$~समय"],
            "frequency": {
                "names": ["$~आवृत्ति"],
                "doc": "$~यह वह आवृत्ति है जिसके साथ समय चलना चाहिए। यह डिफ़ॉल्ट रूप से \\33ms\\ है, जो प्रति सेकंड लगभग 30 बार है।"
            },
            "relative": {
                "names": ["$~रिश्तेदार"],
                "doc": "$~यदि \\⊤\\, तो समय 0 से शुरू होता है, जब प्रोग्राम का पहली बार मूल्यांकन किया जाता है। अन्यथा, यह आज की शुरुआत से मिलीसेकंड की संख्या, UTC (समन्वित सार्वभौमिक समय) से शुरू होता है, जिससे आप दिन के समय का ट्रैक रख सकते हैं।"
            }
        },
        "Volume": {
            "doc": [
                "$~/बज़्ज़्ज़्ज़/",
                "$~@FunctionDefinition यहां, मैं माइक ले लूंगा।",
                "$~यह स्ट्रीम 0 और 1 के बीच वॉल्यूम की एक श्रृंखला है, जिसे आपकी पसंद की आवृत्ति पर सैंपल किया जाता है। डिफ़ॉल्ट रूप से, आवृत्ति \\30hz\\, या प्रति सेकंड 30 बार होती है, लेकिन आप इसे कम आवृत्ति वाली किसी भी चीज़ में बदल सकते हैं।",
                "$~\\आयतन()\\",
                "$~यह सुनने के लिए बहुत बढ़िया है कि श्रोता कितने जोर से बोल रहे हैं!"
            ],
            "names": ["$~🎤", "$~आयतन"],
            "frequency": {
                "names": ["$~आवृत्ति"],
                "doc": "$~नमूने के बीच का समय."
            }
        },
        "Pitch": {
            "doc": [
                "$~/हुम्म्म्म्म/",
                "$~@FunctionDefinition यहां, चलो पिच पर बात करते हैं!",
                "$~यह स्ट्रीम हर्ट्ज़ में आवृत्तियों की एक श्रृंखला है, जो ध्वनि की पिच को दर्शाती है, जिसे आपकी पसंद की आवृत्ति पर सैंपल किया जाता है। हमने पाया है कि मानव आवाज़ 20Hz और 5000Hz के बीच होती है, इसलिए उस सीमा में संख्याओं की योजना बनाएं।",
                "$~\\आवाज़ का उतार-चढ़ाव()\\",
                "$~यह किसी के बोलने या गाने के स्वर को सुनने के लिए बहुत अच्छा है।"
            ],
            "names": ["$~🎵", "$~आवाज़काउतार-चढ़ाव"],
            "frequency": {
                "names": ["$~आवृत्ति"],
                "doc": "$~नमूने के बीच का समय."
            }
        },
        "Camera": {
            "doc": [
                "$~/बज़्ज़्ज़्ज़/",
                "$~@FunctionDefinition यहाँ, मैं @Camera समझा सकता हूँ!",
                "$~तो @Camera आपकी दुनिया से @Color की @List प्रदान करता है। वह सूची अनिवार्य रूप से एक छवि का प्रतिनिधित्व करती है, लेकिन यह तय करना आपके ऊपर है कि इसके साथ क्या करना है।",
                "$~आप छवि को @Phrase के साथ प्रस्तुत करने का प्रयास कर सकते हैं, जो बहुत अच्छा लगेगा! इसे कॉपी करने का प्रयास करें...",
                "$~\\colors: कैमरा(32px 24px 33ms)\n\nस्टेज(\ncolors.combine(\n[] \nƒ(phrases•[वाक्यांश] पंक्ति•[रंग] y•#) \nphrases.append(\nपंक्ति.अनुवाद(\nƒ(रंग•रंग x•#)\nवाक्यांश('o' स्थान: स्थान((x - 1) · 0.5m y · -0.5m) रंग: रंग अवधि: 0s\n)\n)\n)\n)\n)\\",
                "$~लेकिन आप रंगों का विश्लेषण करके यह भी तय कर सकते हैं कि प्रकाश चालू है या बंद है, या कोई विशेष रंग सामान्य है, जिससे दर्शक अपने द्वारा दिखाए गए रंगों से प्रदर्शन को प्रभावित कर सकें।"
            ],
            "names": ["Cámara"],
            "width": {
                "names": ["$~चौड़ाई"],
                "doc": "$~एक पंक्ति में नमूना लेने के लिए @Color की संख्या."
            },
            "height": {
                "names": ["$~ऊंचाई"],
                "doc": "$~एक कॉलम में नमूना लेने के लिए @Color की संख्या."
            },
            "frequency": {
                "names": ["$~आवृत्ति"],
                "doc": "$~@रंग नमूनों के बीच का समय."
            }
        },
        "Motion": {
            "names": "movimiento",
            "doc": [
                "$~/बोइंग बोइंग बोइंग/",
                "$~/नमस्ते! @FunctionDefinition यहाँ है। क्या मैं @Motion को समझा सकता हूँ?",
                "$~मूलतः, @Motion @Phrase की एक धारा है। आप इसे एक आरंभिक @Phrase देते हैं, और फिर यह गुरुत्वाकर्षण के आधार पर एक नए स्थान और घूर्णन के साथ इसे परिष्कृत करता है।",
                "$~इससे आप बहुत ही सरल चीजें कर सकते हैं, जैसे उछलते हुए इमोजी बनाना:",
                "$~\\Motion(वाक्यांश('o') प्रारंभ स्थान: स्थान(0m 10m))\\",
                "$~देखें कि o कैसे उछलता है? पहले मूल्यांकन में, हम इसे @Stage पर ऊपर स्थान देते हैं, लेकिन उसके बाद, इसे @None मिलता है, जो @Motion को इसे गुरुत्वाकर्षण द्वारा रखी गई किसी भी स्थिति में बदलने की अनुमति देता है।",
                "$~नीचे इसे कॉन्फ़िगर करने के कई अन्य तरीके देखें।"
            ],
            "place": {
                "doc": "$~प्रारंभिक स्थान.",
                "names": "$~जगह"
            },
            "velocity": {
                "doc": "$~प्रारंभिक वेग",
                "names": "$~वेग"
            },
            "nextplace": {
                "doc": "$~अगला स्थान, भौतिकी को दरकिनार करना।",
                "names": "$~नेक्स्टप्लेस"
            },
            "nextvelocity": {
                "doc": "$~अगला स्थान, अधिरोहित वेग।",
                "names": "$~अगलावेग"
            }
        },
        "Scene": {
            "doc": [
                "$~/बूप बूप बूप/",
                "$~/नमस्ते, @FunctionDefinition यहाँ है! मुझे लगता है कि आपको @Scene मिल गया है।",
                "$~मुझे लगता है कि @Scene खास तौर पर बढ़िया है। इसका मूल विचार यह है कि आप इसे @Phrase या @Group की एक सूची देते हैं और फिर यह उन्हें क्रम में दिखाएगा और आखिरी पर रुक जाएगा।",
                "$~समय को नियंत्रित करने के लिए, आप या तो प्रत्येक आउटपुट पर @Phrase/duration सेट कर सकते हैं, और यह अगले आउटपुट पर जाने से पहले इसे उस समय तक दिखाएगा, और जो भी @Phrase/entering या @Phrase/exiting संक्रमण आपने सेट किया होगा उसका उपयोग करेगा। यदि आप उन्हें @Sequence पर सेट करते हैं, तो यह इसकी अवधि का उपयोग करेगा।",
                "$~यह सब आपको इस छोटे से @Scene जैसा कार्य करने की सुविधा देता है, जो इन तीन वाक्यांशों को क्रम से दिखाता है:",
                "$~\\Scene([\nवाक्यांश('नमस्ते' अवधि: 1s)\nवाक्यांश('आप कैसे हैं?' अवधि: 2s रोटेशन: 5° प्रवेश: मुद्रा(रोटेशन: 0°))\nवाक्यांश('मैं ठीक हूँ')\n])\\",
                "$~देखें कि कैसे पहला आउटपुट एक सेकंड के लिए दिखाया जाता है, फिर अगला दो सेकंड के लिए, लेकिन पांच डिग्री रोटेशन के साथ एनिमेटेड होता है, और फिर यह अंतिम आउटपुट दिखाता है?",
                "$~आप @Scene के साथ आउटपुट और एनिमेशन के बहुत विस्तृत अनुक्रम बना सकते हैं, और यहां तक कि उनके कुछ हिस्सों को गतिशील या इंटरैक्टिव भी बना सकते हैं, जैसा कि किसी अन्य @Phrase या @Group के साथ होता है।",
                "$~यदि आपके पास नेस्टेड एनिमेटेड आउटपुट है (अंदर एनिमेटेड @Phrase वाला @Group), तो @Scene, @Group में सभी एनिमेटेड सामग्री के समाप्त होने की प्रतीक्षा करेगा।",
                "$~ओह, और एक आखिरी छोटा सा रहस्य! आप सूची में @Boolean भी डाल सकते हैं, और यदि वे \\⊥\\ हैं, तो @Scene रुक जाएगा और इसके सत्य होने का इंतजार करेगा।",
                "$~उदाहरण के लिए, यदि आप @Phrase का अनुक्रम बनाना चाहते हैं और केवल तभी आगे बढ़ना चाहते हैं जब @Button बदलता है, तो आप ऐसा कर सकते हैं:",
                "$~\\क्लिक: ∆ बटन()\nदृश्य([\nवाक्यांश('नमस्ते')\nक्लिक\nवाक्यांश('आप कैसे हैं?' अवधि: 0.25s रोटेशन: 5° प्रवेश: मुद्रा(रोटेशन: 0°))\nक्लिक\nवाक्यांश('मैं ठीक हूँ')\n])\\",
                "$~देखें कि यह प्रत्येक @Phrase के बाद कैसे रुकता है, और आगे बढ़ने से पहले @Button के बदलने की प्रतीक्षा करता है?"
            ],
            "names": ["$~🎬", "$~दृश्य"],
            "outputs": {
                "names": "$~आउटपुट",
                "doc": "$~अनुक्रम में प्रदर्शित करने के लिए आउटपुट की सूची."
            }
        },
        "Chat": {
            "doc": [
                "$~/हाय! @FunctionDefinition यहाँ है। तो आप चैट करना चाहते हैं?",
                "$~चैट स्ट्रीम का मूल विचार यह है कि दर्शक एक संदेश टाइप करते हैं और फिर कार्यक्रम उस पर प्रतिक्रिया देता है।",
                "$~उदाहरण के लिए, यह सरल प्रोग्राम जाँचता है कि क्या संदेश 'हेल्लो' है, और यदि है, तो प्रोग्राम इसका मूल्यांकन 'हाय' करता है। अन्यथा, इसका मूल्यांकन 'हूँ' करता है?",
                "$~\\Chat().has('hello') ? 'हाय!' 'हूँ?'\\",
                "$~बस इतना ही! आप इसके साथ सभी प्रकार के प्रदर्शन कर सकते हैं, जैसे चैट बॉट, टेक्स्ट एडवेंचर्स, या अन्य प्रकार के प्रदर्शनों के लिए टेक्स्ट-आधारित नियंत्रण योजनाएं।"
            ],
            "names": ["$~🗣️", "$~बातकरना"]
        },
        "Placement": {
            "doc": [
                "$~/अरे, @FunctionDefinition यहाँ है। आइए बात करते हैं कि हमें कैसे आगे बढ़ना है!/",
                "$~तो हमें @Stage पर रखने के कई तरीके हैं। आप हमें एक स्पष्ट @Place दे सकते हैं। आप @Motion का उपयोग कर सकते हैं, और गुरुत्वाकर्षण को अपना काम करने दे सकते हैं। आप हमें @Group में भी रख सकते हैं और उन्हें हमें एक खास तरीके से व्यवस्थित करने दे सकते हैं।",
                "$~लेकिन कभी-कभी आप दर्शकों को यह नियंत्रण देना चाहते हैं कि हम @स्टेज पर कहां हैं। @प्लेसमेंट इसी के लिए है।",
                "$~यह इस प्रकार काम करता है: आप बस एक @Placement बनाएं और इसे हमारे @Place को दें:",
                "$~\\वाक्यांश('hi' स्थान: प्लेसमेंट())\\",
                "$~फिर, जब भी दर्शक मंच पर तीर कुंजी का उपयोग करेंगे या क्लिक या टैप करेंगे, तो @Placement एक नया @Place बनाएगा जो वांछित दिशा में चलेगा।",
                "$~इसे अपने प्रोग्राम में कॉपी करने का प्रयास करें और पॉइंटर या कीबोर्ड से इसे तीर की ओर ले जाएं।",
                "$~आप @Placement को अनुकूलित कर सकते हैं, कुछ आयामों पर गति को सक्षम और अक्षम कर सकते हैं, @Place की गति की दूरी को बदल सकते हैं, तथा स्ट्रीम के आरंभिक @Place को बदल सकते हैं।"
            ],
            "names": ["$~✥", "$~प्लेसमेंट"],
            "inputs": [
                {
                    "doc": "$~शुरुआत करने के लिए प्रारंभिक स्थान.",
                    "names": "$~शुरू"
                },
                {
                    "doc": "$~जब दर्शक किसी स्थान को स्थानांतरित करने का अनुरोध करें तो स्थान को कितने मीटर स्थानांतरित किया जाना चाहिए।",
                    "names": "$~दूरी"
                },
                {
                    "doc": "$~यदि सत्य है, तो क्षैतिज अक्ष पर गति की अनुमति देता है। डिफ़ॉल्ट रूप से चालू।",
                    "names": "$~क्षैतिज"
                },
                {
                    "doc": "$~यदि सत्य है, तो ऊर्ध्वाधर अक्ष पर गति की अनुमति देता है। डिफ़ॉल्ट रूप से चालू।",
                    "names": "$~खड़ा"
                },
                {
                    "doc": "$~यदि सत्य है, तो + और - कुंजियों के साथ z-अक्ष पर गति की अनुमति देता है।",
                    "names": "$~गहराई"
                }
            ]
        },
        "Webpage": {
            "doc": [
                "$~/अरे, @FunctionDefinition यहाँ है। आइए बात करते हैं कि इंटरनेट से वेबपेज कैसे प्राप्त करें!/",
                "$~जब हमने पहली बार आपके इंटरनेट के बारे में सुना, तो हमें यह बहुत ही रोचक लगा। एक पूरी दुनिया जो आपस में जुड़े हुए कंप्यूटरों से भरी हुई है और एक दूसरे के साथ दस्तावेज़ साझा कर रही है? यह आश्चर्यजनक है!",
                "$~इसलिए हमने एक स्ट्रीम बनाई जो इससे जुड़ती है। आप हमें एक यूआरएल दें, और हम उस पर सारा टेक्स्ट पा लेंगे। इस तरह:",
                "$~\\वेबपेज('https://wordplay.dev')\\",
                "$~और जाहिर तौर पर <CSS@https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/What_is_CSS> नामक एक चीज़ है, जो आपको वेब पेज पर चीज़ों की क्वेरी करना पसंद करती है? हमें एक CSS चयन क्वेरी दें और हमें केवल वही टेक्स्ट मिलेगा जो उस क्वेरी से मेल खाता है। इस उदाहरण की तरह, जो लेवल वन हेडर प्राप्त करता है।",
                "$~\\वेबपेज('https://wordplay.dev' 'h1')\\",
                "$~इस मामले में बहुत सी चीजें गलत हो सकती हैं। अगर आपका इंटरनेट कनेक्शन टूट जाता है, या URL किसी भी तरह से हल नहीं होता है, या URL सार्वजनिक नहीं है, या URL HTML पेज नहीं है... ये सभी अपवाद की ओर ले जा सकते हैं। अगर आपको कोई ऐसा पेज मिल जाता है जो काम करता है, तो आपको कुछ @Number मिलेंगे जो पूर्णता का प्रतिशत दर्शाते हैं और फिर पेज पर मौजूद शब्दों की @List मिलेगी।"
            ],
            "names": ["$~🔗", "$~वेबपृष्ठ"],
            "url": {
                "doc": "$~प्राप्त करने के लिए HTML वेबपेज URL.",
                "names": "$~यूआरएल"
            },
            "query": {
                "doc": "$~HTML पर मूल्यांकन करने के लिए CSS क्वेरी",
                "names": "$~सवाल"
            },
            "frequency": {
                "doc": "$~पृष्ठ को पुनः प्राप्त करने से पहले गुजरने वाले मिनटों की संख्या.",
                "names": "$~आवृत्ति"
            },
            "error": {
                "invalid": "$~यह वैध यूआरएल नहीं है",
                "unvailable": "$~यह URL सुलभ नहीं है",
                "notHTML": "$~प्रतिक्रिया HTML नहीं थी",
                "noConnection": "$~शब्दों के खेल से कोई संबंध नहीं",
                "limit": "$~इस डोमेन के लिए बहुत अधिक अनुरोध"
            }
        },
        "Collision": {
            "names": "$~टक्कर",
            "doc": [
                "$~/नमस्ते! @FunctionDefinition यहाँ है। इस शानदार इनपुट को देखें।/",
                "$~यह आपको यह पता लगाने में मदद कर सकता है कि @Output कब एक दूसरे से टकराते हैं! यह कुछ करने का एक शानदार तरीका है जब हम एक दूसरे से टकराते हैं, @Output के एक दूसरे से टकराने के सामान्य तरीके के अलावा।",
                "$~बस मुझे @Output का नाम दें, और जब भी यह किसी दूसरे नाम से टकराएगा, मैं एक नया @Rebound मान बना लूंगा। @Rebound में टकराने वाले नामों और उनके टकराव की दिशा के बारे में जानकारी होती है।",
                "$~और यदि आप मुझे दो नाम देते हैं, तो मैं तभी नया मान बनाऊंगा जब वे दोनों नाम एक दूसरे से टकराएंगे।",
                "$~नया मान बनाने के ठीक बाद, मैं एक \\ø\\ बनाऊँगा क्योंकि टकराव होने के बाद ही टकराव समाप्त होता है। यह दर्शाता है कि अब कोई टकराव नहीं है।"
            ],
            "subject": {
                "names": "$~विषय",
                "doc": "$~@Output का नाम जिस पर मुझे टकरावों की तलाश करनी चाहिए।"
            },
            "object": {
                "names": "$~अन्य",
                "doc": "$~अन्य @Output का नाम जिस पर मुझे टकरावों की तलाश करनी चाहिए।"
            }
        },
        "Rebound": {
            "names": "$~प्रतिक्षेप",
            "doc": "$~मैं @Collision से आता हूँ और यह बताता हूँ कि किससे टक्कर हुई और टक्कर किस दिशा में हुई। यह तय करने के लिए मेरा उपयोग करें कि सामान्य भौतिकी के अलावा किसी विशेष तरीके से टक्कर पर प्रतिक्रिया करनी है या नहीं।",
            "direction": {
                "names": "$~दिशा",
                "doc": "$~टक्कर की दिशा और परिमाण, टक्कर के विषय के सापेक्ष"
            },
            "subject": {
                "names": "$~विषय",
                "doc": "$~आउटपुट का नाम जो विषय द्वारा हिट किया गया था."
            },
            "object": {
                "names": "$~वस्तु",
                "doc": "$~विषय पर आने वाले आउटपुट का नाम"
            }
        },
        "Direction": {
            "names": "$~दिशा",
            "doc": "$~मैं x और y अक्षों के साथ एक दिशा और परिमाण हूँ।",
            "x": {
                "names": "$~एक्स",
                "doc": "$~x-अक्ष के अनुदिश दिशा और परिमाण।"
            },
            "y": {
                "names": "$~य",
                "doc": "$~Y-अक्ष के अनुदिश दिशा और परिमाण।"
            }
        }
    },
    "output": {
        "Output": {
            "names": "$~उत्पादन",
            "doc": [
                "$~मैं @StructureDefinition नहीं हूँ जिसे आप वास्तव में बना सकते हैं। लेकिन मैं एक बहुत ही महत्वपूर्ण व्यक्ति हूँ, क्योंकि मैं हमारे नृत्य के सबसे महत्वपूर्ण तत्वों को प्रेरित करता हूँ: @Phrase, @Group, और @Stage।",
                "$~उनका उपयोग कैसे करें, इसके बारे में अधिक जानने के लिए उनसे मिलें।"
            ]
        },
        "Stage": {
            "names": ["$~🎭", "$~अवस्था"],
            "doc": [
                "$~नमस्ते। यहाँ मंच है। मुझे बताओ कि क्या दिखाना है और मैं दिखाऊँगा।",
                "$~\\Stage([वाक्यांश('stufffffff')])\\",
                "$~अगर आप चाहें तो मुझे बैकग्राउंड दें @Color और मैं उसी के अनुसार मंच को रोशन कर दूंगा।",
                "$~\\Stage([वाक्यांश('stufffffff')] पृष्ठभूमि: रंग(75% 50 100°)\\",
                "$~आप मुझे एक फ्रेम बॉर्डर भी दे सकते हैं और मैं उसे काट दूंगा।",
                "$~\\Stage([Phrase('stufffffff')] पृष्ठभूमि: रंग(75% 50 100°) फ़्रेम: आयत(-1m -1m 1m 1m))\\"
            ],
            "description": {
                "doc": [
                    "$~यह विवरण उन दर्शकों के लिए है जो दृश्य आउटपुट नहीं देख सकते।"
                ],
                "names": "$~विवरण"
            },
            "content": {
                "doc": "$~स्टेज पर दिखाने के लिए @Output की सूची.",
                "names": "$~सामग्री"
            },
            "frame": {
                "doc": "$~मंच के चारों ओर लगाए जाने वाले फ्रेम का आकार और माप, जो उसके बाहर की सभी चीजों को छिपा दे।",
                "names": "$~चौखटा"
            },
            "size": {
                "doc": "$~पसंद करें @ग्रुप/साइज़",
                "names": "$~आकार"
            },
            "face": {
                "doc": "$~लाइक @ग्रुप/फेस",
                "names": "$~चेहरा"
            },
            "place": {
                "doc": "$~अगर मैं कैमरा होता तो मैं यहीं देख रहा होता",
                "names": "$~जगह"
            },
            "name": {
                "doc": ["$~@Phrase/name के समान!"],
                "names": "$~नाम"
            },
            "selectable": {
                "doc": "$~@Phrase/selectable के समान!",
                "names": "$~चयन"
            },
            "color": {
                "doc": "$~@Group/color के समान",
                "names": "$~रंग"
            },
            "background": {
                "doc": "$~@Group/background के समान",
                "names": "$~पृष्ठभूमि"
            },
            "opacity": {
                "doc": "$~@Group/opacity के समान",
                "names": "$~अस्पष्टता"
            },
            "offset": {
                "doc": "$~@Group/offset के समान",
                "names": "$~ओफ़्सेट"
            },
            "rotation": {
                "doc": "$~@Group/rotation के समान",
                "names": ["$~📐", "$~ROTATION"]
            },
            "scale": {
                "doc": "$~@Group/scale के समान",
                "names": "$~पैमाना"
            },
            "flipx": {
                "doc": "$~@Group/flipx के समान",
                "names": "$~फ़्लिपक्स"
            },
            "flipy": {
                "doc": "$~@Group/flipy के समान",
                "names": "$~फ़्लिपी"
            },
            "entering": {
                "doc": "$~@Group/entering के समान",
                "names": "$~प्रवेश"
            },
            "resting": {
                "doc": "$~@Group/resting के समान!",
                "names": "$~आराम"
            },
            "moving": {
                "doc": "$~@Group/moving के समान!",
                "names": "$~चलती"
            },
            "exiting": {
                "doc": "$~@Group/exiting के समान!",
                "names": "$~बाहरनिकलरहाहै"
            },
            "duration": {
                "doc": "$~@Phrase/duration के समान!",
                "names": ["duración"]
            },
            "style": {
                "doc": "$~@Phrase/style के समान!",
                "names": "$~शैली"
            },
            "gravity": {
                "doc": "$~गुरुत्वाकर्षण को आउटपुट पर लागू करना है जिसका स्थान @Motion में है।",
                "names": "$~गुरुत्वाकर्षण"
            },
            "defaultDescription": "$~चरण $2[$2 |]$1 आउटपुट$3[फ्रेम $3| के साथ] $4"
        },
        "Group": {
            "names": ["$~🔳", "$~समूह"],
            "doc": [
                "$~अरे नमस्ते, आप कैसे हैं? जब दूसरे लोग आस-पास होते हैं तो मैं हमेशा ठीक रहता हूँ, इसलिए आपके साथ रहना बहुत अच्छा है!",
                "$~मैं @Stage पर @Phrase और @Group को एक साथ समूहित करता हूं और उन्हें @Arrangement में रखता हूं, ताकि उन्हें रखने का कुछ क्रम बना रहे।",
                "$~काम करने के लिए, मुझे आपसे एक @Arrangement और फिर व्यवस्थित करने के लिए @Output की एक @List चाहिए।",
                "$~उदाहरण के लिए, यहां मैं @Stack व्यवस्था और कुछ @Phrase के साथ लंबवत स्टैक कर रहा हूं:",
                "$~\\Group(स्टैक() [वाक्यांश('पहला') वाक्यांश('दूसरा')])\\",
                "$~मैं चीजों को किस प्रकार व्यवस्थित करता हूँ यह आपके द्वारा दी गई @व्यवस्था पर निर्भर करता है।"
            ],
            "description": {
                "doc": [
                    "$~यह विवरण उन दर्शकों के लिए है जो दृश्य आउटपुट नहीं देख सकते।"
                ],
                "names": "$~विवरण"
            },
            "content": {
                "doc": "$~व्यवस्थित करने हेतु @Output की सूची.",
                "names": "$~सामग्री"
            },
            "layout": {
                "doc": "$~@Output को उनके स्थान पर रखने के लिए उपयोग की जाने वाली व्यवस्था।",
                "names": "$~लेआउट"
            },
            "matter": {
                "doc": "$~यदि मैं किसी अन्य पदार्थ से टकरा जाऊं तो मुझे कैसी प्रतिक्रिया करनी चाहिए?",
                "names": "$~मामला"
            },
            "size": {
                "doc": "$~मेरे अंदर की अद्भुत सामग्री कितनी लंबी होनी चाहिए, जब तक कि उनका अपना कोई आकार न हो!",
                "names": "$~आकार"
            },
            "face": {
                "doc": "$~मेरे अंदर फ़ॉन्ट चेहरे की सामग्री का नाम होना चाहिए, जब तक कि उनके पास उपयोग करने के लिए अपना स्वयं का चेहरा न हो।",
                "names": "$~चेहरा"
            },
            "place": {
                "doc": "$~मंच पर वह स्थान जहाँ मुझे होना चाहिए। मेरे अंदर की विषय-वस्तु वहाँ के सापेक्ष व्यवस्थित होगी।",
                "names": "$~जगह"
            },
            "name": {
                "doc": ["$~@Phrase/name के समान!"],
                "names": "$~नाम"
            },
            "selectable": {
                "doc": "$~@Phrase/selectable के समान!",
                "names": "$~चयन"
            },
            "color": {
                "doc": "$~@रंग जो मेरे अंदर की सामग्री होनी चाहिए, जब तक कि उनका अपना रंग न हो।",
                "names": "$~रंग"
            },
            "background": {
                "doc": "$~@Color मेरे पीछे प्रक्षेपित करने के लिए।",
                "names": "$~पृष्ठभूमि"
            },
            "opacity": {
                "doc": "$~मेरे अंदर सब कुछ कितना पारदर्शी होना चाहिए, \\0\\ और \\1\\ के बीच, जब तक कि किसी भिन्न @Pose द्वारा ओवरराइड न किया जाए।",
                "names": "$~अस्पष्टता"
            },
            "offset": {
                "doc": "$~@Place यह दर्शाता है कि यह मेरे सामान्य @Place से कितना ऑफसेट होना चाहिए, जब तक कि इसे किसी भिन्न @Pose द्वारा ओवरराइड न किया जाए। जगह पर हिलने-डुलने के लिए सहायक।",
                "names": "$~ओफ़्सेट"
            },
            "rotation": {
                "doc": "$~मुझे अपने केंद्र के चारों ओर कितना झुका होना चाहिए, मेरे @Pose का झुकाव अलग है।",
                "names": ["$~📐", "$~ROTATION"]
            },
            "scale": {
                "doc": "$~मुझे अपने मूल आकार के सापेक्ष कितना बड़ा होना चाहिए।",
                "names": "$~पैमाना"
            },
            "flipx": {
                "doc": "$~@Phrase/flipx के समान!",
                "names": "$~फ़्लिपक्स"
            },
            "flipy": {
                "doc": "$~@Phrase/flipy के समान",
                "names": "$~फ़्लिपी"
            },
            "entering": {
                "doc": "$~@Phrase/entering के समान!",
                "names": "$~प्रवेश"
            },
            "resting": {
                "doc": "$~@Phrase/resting के समान!",
                "names": "$~आराम"
            },
            "moving": {
                "doc": "$~@Phrase/moving के समान!",
                "names": "$~चलती"
            },
            "exiting": {
                "doc": "$~@Phrase/exiting के समान!",
                "names": "$~बाहरनिकलरहाहै"
            },
            "duration": {
                "doc": "$~@Phrase/duration के समान!",
                "names": ["duración"]
            },
            "style": {
                "doc": "$~@Phrase/style के समान!",
                "names": "$~शैली"
            },
            "defaultDescription": "$~$1[$1|] $2 $3"
        },
        "Phrase": {
            "names": ["$~💬", "$~वाक्यांश"],
            "doc": [
                "$~नमस्ते, नमस्ते! मुझे याद है? कोई मुझे कैसे भूल सकता है। यह सही है, मैं @वाक्यांश हूँ, जो @स्टेज पर सबसे प्यारे @टेक्स्ट का प्रतिनिधित्व करने के लिए तैयार हूँ।",
                "$~बस मुझे ऐसा बना दो, और मैं @स्टेज पर आ जाऊंगी:",
                "$~\\वाक्यांश('शानदार!')\\",
                "$~जाहिर है, मुझे कुछ @Text की आवश्यकता है, लेकिन इसके अलावा, मैं वह सब कुछ कर सकता हूँ जो @Output कर सकता है, जिसमें मेरा आकार, फ़ॉन्ट, रोटेशन बदलना, तथा @Pose और @Sequence के साथ अपने सभी अविश्वसनीय नृत्य करना शामिल है।",
                "$~आप मुझे @स्टेज पर भी चुन सकते हैं और अगले पैलेट पर मुझे संपादित कर सकते हैं।"
            ],
            "description": {
                "doc": [
                    "$~एक कस्टम विवरण, जो उन दर्शकों के लिए उपयोग किया जा सकता है जो दृश्य आउटपुट नहीं देख सकते हैं।"
                ],
                "names": "$~विवरण"
            },
            "text": {
                "doc": "$~@स्टेज पर दिखाए जाने वाले पात्र.",
                "names": "$~मूलपाठ"
            },
            "size": {
                "doc": "$~मेरी लंबाई कितनी होनी चाहिए, मीटर में!",
                "names": "$~आकार"
            },
            "face": {
                "doc": "$~फ़ॉन्ट फेस का नाम जो मुझे लगाना चाहिए।",
                "names": "$~चेहरा"
            },
            "place": {
                "doc": "$~मंच पर वह स्थान जहाँ मुझे होना चाहिए।",
                "names": "$~जगह"
            },
            "wrap": {
                "doc": "$~वह किनारा जिस पर मुझे प्रतीकों को लपेटना चाहिए या \\ø\\ यदि मुझे उन्हें लपेटना नहीं चाहिए।",
                "names": ["$~↵", "$~लपेटना"]
            },
            "alignment": {
                "doc": "$~यदि कोई @Phrase/wrap सीमा निर्धारित है, तो क्या मुझे प्रतीकों को किनारे के आरंभ, केंद्र या अंत में संरेखित करना चाहिए।",
                "names": "$~संरेखण"
            },
            "direction": {
                "doc": "$~क्या प्रतीकों को क्षैतिज या लंबवत लिखा गया है, और यदि लंबवत और @Phrase/wrap सेट है, तो क्या पाठ बाईं या दाईं ओर लपेटा गया है।",
                "names": "$~दिशा"
            },
            "matter": {
                "doc": "$~यदि मैं किसी चीज से टकरा जाऊं तो इन गुणों का उपयोग करूं!",
                "names": "$~मामला"
            },
            "aura": {
                "doc": "$~मेरे पीछे दिखाने के लिए वैकल्पिक @Aura। मुझे चमकाओ!",
                "names": "$~आभा"
            },
            "name": {
                "doc": [
                    "$~आपने मुझे जो नाम दिया है, वह कई कामों में मददगार है।",
                    "$~सबसे पहले, यदि मेरा कोई नाम है, तो मैं स्क्रीन रीडर विवरण में स्वयं का वर्णन करने के लिए उसका उपयोग करूंगा।",
                    "$~दूसरा, एनिमेशन करते समय, आपके पास कई अलग-अलग अभिव्यक्तियाँ हो सकती हैं जो मंच पर एक ही विषय-वस्तु को दर्शाती हैं; उन्हें एक ही नाम दें और वे एक के रूप में एनिमेट हो जाएंगी।",
                    "$~अंत में, मैं @Choice के साथ सहायक हूं: आपके द्वारा दिए गए नाम उस स्ट्रीम में दिखाई देते हैं।",
                    "$~अगर यह मददगार हो तो आप मुझे कई अलग-अलग नाम दे सकते हैं, हर एक अलग भाषा में। मैं हमेशा पहले चुने गए लोकेल में नाम का उपयोग करूंगा।"
                ],
                "names": "$~नाम"
            },
            "selectable": {
                "doc": "$~यदि \\⊤\\, तो यह इंगित करता है कि I को पॉइंटर या कीबोर्ड के माध्यम से चुना जा सकता है।",
                "names": "$~चयन"
            },
            "color": {
                "doc": "$~@Color I डिफ़ॉल्ट रूप से होना चाहिए, जब तक कि इसे किसी भिन्न @Pose द्वारा ओवरराइड न किया जाए।",
                "names": "$~रंग"
            },
            "background": {
                "doc": "$~@Color मेरे पीछे प्रक्षेपित करने के लिए।",
                "names": "$~पृष्ठभूमि"
            },
            "opacity": {
                "doc": "$~\\0\\ और \\1\\ के बीच डिफ़ॉल्ट रूप से मुझे कितना पारदर्शी होना चाहिए, जब तक कि किसी भिन्न @Pose द्वारा ओवरराइड न किया जाए। फ़ेडिंग इन और आउट के लिए सहायक।",
                "names": "$~अस्पष्टता"
            },
            "offset": {
                "doc": "$~@Place यह दर्शाता है कि इसे मेरे @Place से कितना ऑफसेट होना चाहिए, जब तक कि इसे किसी भिन्न @Pose द्वारा ओवरराइड न किया जाए। जगह पर हिलने-डुलने के लिए सहायक।",
                "names": "$~ओफ़्सेट"
            },
            "rotation": {
                "doc": "$~डिग्री में राशि I को इसके केंद्र के चारों ओर घुमाया जाना चाहिए, जब तक कि एक अलग @Pose द्वारा ओवरराइड न किया जाए।",
                "names": "$~ROTATION"
            },
            "scale": {
                "doc": "$~I को उसके मूल आकार के सापेक्ष कितना बड़ा किया जाना चाहिए, जब तक कि इसे किसी भिन्न @Pose द्वारा अधिरोहित न किया जाए।",
                "names": "$~पैमाना"
            },
            "flipx": {
                "doc": "$~क्या मुझे x-अक्ष पर प्रतिबिंबित किया जाना चाहिए, जब तक कि किसी भिन्न @Pose द्वारा ओवरराइड न किया जाए।",
                "names": "$~फ़्लिपक्स"
            },
            "flipy": {
                "doc": "$~क्या मुझे y-अक्ष पर प्रतिबिंबित किया जाना चाहिए, जब तक कि किसी भिन्न @Pose द्वारा ओवरराइड न किया जाए।",
                "names": "$~फ़्लिपी"
            },
            "entering": {
                "doc": "$~मंच पर प्रवेश करते समय मुझे @Pose या @Sequence करना चाहिए।",
                "names": "$~प्रवेश"
            },
            "resting": {
                "doc": "$~@Pose या @Sequence मुझे स्टेज में प्रवेश करने के बाद, बाहर निकलने से पहले, और जब तक मेरा @Place नहीं बदल रहा हो, करना चाहिए। यदि आप मुझे कोई नहीं देते हैं, तो मैं बस अपने डिफ़ॉल्ट का उपयोग करूँगा।",
                "names": "$~आराम"
            },
            "moving": {
                "doc": "$~मंच पर स्थान बदलते समय मुझे अपने डिफ़ॉल्ट के बजाय @Pose या @Sequence का प्रयोग करना चाहिए।",
                "names": "$~चलती"
            },
            "exiting": {
                "doc": "$~@Pose या @Sequence को स्टेज से बाहर निकलने से पहले किया जाना चाहिए।",
                "names": "$~बाहरनिकलरहाहै"
            },
            "duration": {
                "doc": "$~मंच पर किसी भिन्न स्थान पर जाते समय लागू होने वाली अवधि.",
                "names": ["$~⏳", "$~अवधि"]
            },
            "style": {
                "doc": "$~मंच पर किसी भिन्न स्थान पर जाते समय उपयोग की जाने वाली एनीमेशन शैली।",
                "names": "$~शैली"
            },
            "defaultDescription": "$~$3[$3 मीटर |]वाक्यांश $1 $2[नाम $2|] $4[$4|] $5"
        },
        "Arrangement": {
            "names": ["Arrangement"],
            "doc": "$~मैं वर्स में कई अन्य प्रकार की व्यवस्थाओं के लिए प्रेरणा हूँ, जिसमें @Row, @Stack, @Grid, और @Free शामिल हैं। मैं @Group के साथ मिलकर काम करता हूँ"
        },
        "Row": {
            "names": ["Fila"],
            "doc": "$~मैं @Row हूँ, @Output का एक क्षैतिज @Arrangement, जिसके बीच में वैकल्पिक पैडिंग है। क्या आप मेरे जुड़वाँ, @Stack से मिले हैं?",
            "description": "$~$1 वाक्यांशों और समूहों की पंक्ति",
            "alignment": {
                "doc": "$~प्रत्येक कॉलम पर पाठ को आरंभ, मध्य या अंत में संरेखित करना है या नहीं।",
                "names": "$~संरेखण"
            },
            "padding": {
                "doc": "$~आउटपुट के बीच में पैडिंग की मात्रा.",
                "names": "$~पैडिंग"
            }
        },
        "Stack": {
            "names": ["$~⬇", "$~ढेर"],
            "doc": "$~मैं @Stack हूँ, @Output का एक वर्टिकल @Arrangement, जिसके बीच में वैकल्पिक पैडिंग है। क्या आप मेरे जुड़वाँ, @Row से मिले हैं?",
            "description": "$~$1 वाक्यांशों और समूहों का ढेर",
            "padding": {
                "doc": "$~आउटपुट के बीच में पैडिंग की मात्रा.",
                "names": "$~पैडिंग"
            },
            "alignment": {
                "doc": "$~प्रत्येक पंक्ति पर पाठ को आरंभ, मध्य या अंत में संरेखित करना है या नहीं।",
                "names": "$~संरेखण"
            }
        },
        "Grid": {
            "names": ["$~▦", "$~ग्रिड"],
            "doc": "$~मैं @Output का ग्रिड हूँ। मुझे पंक्ति और कॉलम की संख्या बताइए और मैं वैकल्पिक पैडिंग और सेल आकार के साथ एक सुव्यवस्थित व्यवस्था बना दूँगा।",
            "description": "$~$1 पंक्ति $2 स्तंभ ग्रिड",
            "rows": {
                "doc": "$~ग्रिड में कितनी पंक्तियाँ बनानी हैं?",
                "names": "$~पंक्तियों"
            },
            "columns": {
                "doc": "$~ग्रिड में कितने कॉलम बनाने हैं?",
                "names": "$~कॉलम"
            },
            "padding": {
                "doc": "$~कोशिकाओं के बीच कितनी पैडिंग रखनी है।",
                "names": "$~पैडिंग"
            },
            "cellWidth": {
                "doc": "$~कोशिकाएँ कितनी चौड़ी होनी चाहिए?",
                "names": "$~सेलचौड़ाई"
            },
            "cellHeight": {
                "doc": "$~कोशिकाएँ कितनी ऊँची होनी चाहिए?",
                "names": "$~सेलपैडिंग"
            }
        },
        "Free": {
            "names": ["$~मुक्त"],
            "doc": [
                "$~मैं कहता हूँ, जो भी हो। जहाँ चाहो बैठो। बस कहीं बैठो! सुनिश्चित करो कि तुम मुझे जो भी @Output दोगे उसमें @Place हो, अन्यथा उन्हें पता नहीं चलेगा कि कहाँ जाना है।",
                "$~ओह, और याद रखें कि आप प्रत्येक @Output को जो @Place देते हैं वह @Group के @Place से संबंधित होता है! इसलिए यदि आप सोच रहे हैं कि चीजें आपकी अपेक्षा के अनुसार क्यों नहीं दिखाई दे रही हैं, तो @Group को भी एक स्थान देने का प्रयास करें।"
            ],
            "description": "$~मुक्त-रूप $1 आउटपुट"
        },
        "Shape": {
            "names": ["$~⬟", "$~आकार"],
            "doc": "$~मैं सभी आकृतियों के लिए प्रेरणा हूँ। मैं @Stage को यह बताने में उपयोगी हूँ कि उन्हें किस आकृति में रहना चाहिए।",
            "form": {
                "doc": "$~मैं दिखाने लायक आकार हूँ। प्रत्येक आकार को उसकी व्यवस्था को परिभाषित करने के लिए अलग-अलग जानकारी की आवश्यकता होती है।",
                "names": "$~रूप"
            },
            "name": {
                "doc": "$~मैं वह नाम हूँ जिसका उपयोग आप एनिमेशन और @Collision के लिए कर सकते हैं। उदाहरण के लिए, यदि a ग्राउंड को दर्शाता है, तो आप मुझे 'ग्राउंड' कहना चाहेंगे।",
                "names": "$~नाम"
            },
            "selectable": {
                "doc": "$~क्या मुझे @Choice के भाग के रूप में चुना जा सकता है?",
                "names": "$~चयन"
            },
            "color": {
                "doc": "$~मेरी सीमाओं का रंग.",
                "names": "$~रंग"
            },
            "background": {
                "doc": "$~मेरी पृष्ठभूमि का रंग.",
                "names": "$~पृष्ठभूमि"
            },
            "opacity": {
                "doc": "$~मुझे कितना पारदर्शी होना चाहिए?",
                "names": "$~अस्पष्टता"
            },
            "offset": {
                "doc": "$~मैं अपनी जगह पर रहते हुए भी अपनी जगह से कितनी दूर दिखूं।",
                "names": "$~ओफ़्सेट"
            },
            "rotation": {
                "doc": "$~मुझे कितना घुमाया जाना चाहिए। इससे @Collision पर असर पड़ता है।",
                "names": "$~ROTATION"
            },
            "scale": {
                "doc": "$~मेरा वास्तविक आकार बदले बिना, मुझे कितना बड़ा किया जाना चाहिए।",
                "names": "$~पैमाना"
            },
            "flipx": {
                "doc": "$~क्या मुझे मेरे x-अक्ष पर प्रतिबिम्बित करना है।",
                "names": "$~फ़्लिपक्स"
            },
            "flipy": {
                "doc": "$~क्या मुझे मेरे y-अक्ष पर प्रतिबिम्बित करना है।",
                "names": "$~फ़्लिपी"
            },
            "entering": {
                "doc": "$~@Stage में प्रवेश करते समय मुझे @Pose या @Sequence करना चाहिए।",
                "names": "$~प्रवेश"
            },
            "resting": {
                "doc": "$~@Pose या @Sequence मुझे प्रवेश करने के बाद और जब मैं आगे नहीं बढ़ रहा हूँ, तब करना चाहिए।",
                "names": "$~आराम"
            },
            "moving": {
                "doc": "$~@Pose या @Sequence मुझे स्थान बदलते समय करना चाहिए।",
                "names": "$~चलती"
            },
            "exiting": {
                "doc": "$~@Stage छोड़ते समय मुझे @Pose या @Sequence करना चाहिए।",
                "names": "$~बाहरनिकलरहाहै"
            },
            "duration": {
                "doc": "$~यदि वे एकल @Pose हैं तो मेरे एनिमेशन को कितना समय लेना चाहिए।",
                "names": "$~अवधि"
            },
            "style": {
                "doc": "$~एनीमेशन शैली मुझे उपयोग करना चाहिए.",
                "names": "$~शैली"
            },
            "description": {
                "doc": [
                    "$~यह विवरण उन दर्शकों के लिए है जो दृश्य आउटपुट नहीं देख सकते।"
                ],
                "names": "$~विवरण"
            }
        },
        "Form": {
            "doc": "$~मैं एक अमूर्त रूप हूँ, जैसे @Rectangle या @Circle.",
            "names": ["$~रूप"]
        },
        "Rectangle": {
            "names": ["$~आयत"],
            "doc": "$~मैं एक आयत हूँ, जो @Stage को आपकी पसंद के आकार की सीमा प्रदान करने के लिए उपयोगी है।",
            "left": {
                "doc": "$~x-अक्ष पर मंच का बायां किनारा",
                "names": "$~बाएं"
            },
            "top": {
                "doc": "$~Y-अक्ष पर मंच का ऊपरी किनारा",
                "names": "$~शीर्ष"
            },
            "right": {
                "doc": "$~x-अक्ष पर मंच का दाहिना किनारा",
                "names": "$~सही"
            },
            "bottom": {
                "doc": "$~Y-अक्ष पर मंच का निचला किनारा",
                "names": "$~तल"
            },
            "z": {
                "doc": "$~आयत की गहराई की स्थिति.",
                "names": "$~जेड"
            }
        },
        "Circle": {
            "doc": "$~मैं एक वृत्त हूँ, जो @स्टेज पर आकृतियाँ बनाने के लिए उपयोगी है।",
            "names": ["$~घेरा"],
            "radius": {
                "doc": "$~वृत्त की त्रिज्या",
                "names": "$~RADIUS"
            },
            "x": {
                "doc": "$~वृत्त का क्षैतिज केंद्र.",
                "names": "$~एक्स"
            },
            "y": {
                "doc": "$~वृत्त का ऊर्ध्वाधर केंद्र.",
                "names": "$~य"
            },
            "z": {
                "doc": "$~वृत्त की गहराई स्थिति.",
                "names": "$~जेड"
            }
        },
        "Polygon": {
            "doc": "$~मैं समान लंबाई वाली भुजाओं और कोणों वाला एक 'नियमित' बहुभुज हूँ, जो @स्टेज पर आकृतियाँ बनाने के लिए उपयोगी है।",
            "names": ["$~बहुभुज"],
            "radius": {
                "doc": "$~बहुभुज की त्रिज्या",
                "names": "$~RADIUS"
            },
            "sides": {
                "doc": "$~बहुभुज की भुजाओं की संख्या",
                "names": "$~दोनोंपक्ष"
            },
            "x": {
                "doc": "$~बहुभुज का क्षैतिज केंद्र.",
                "names": "$~एक्स"
            },
            "y": {
                "doc": "$~बहुभुज का ऊर्ध्वाधर केंद्र.",
                "names": "$~य"
            },
            "z": {
                "doc": "$~बहुभुज की गहराई स्थिति.",
                "names": "$~जेड"
            }
        },
        "Pose": {
            "names": ["$~🤪", "$~खड़ाकरना"],
            "doc": [
                "$~क्या आपको पता है जब कोई व्यक्ति सबसे शानदार तरीके से खड़ा होता है, रुकता है और हर कोई देखता है? मैं वही हूँ। मैं @Output के लिए एक पोज़ कैप्चर करता हूँ और उनकी हरकतों का आधार बनता हूँ।",
                "$~एक पोज़ में बहुत कुछ शामिल होता है। मेरे कई इनपुट देखें और देखें कि आप किस तरह के पोज़ बना सकते हैं!"
            ],
            "style": {
                "doc": "$~इस मुद्रा में आते समय उपयोग की जाने वाली एनीमेशन शैली।",
                "names": "$~शैली"
            },
            "color": {
                "doc": "$~@Color और @Output को इसके डिफ़ॉल्ट के बजाय इस स्थिति में होना चाहिए।",
                "names": "$~रंग"
            },
            "opacity": {
                "doc": "$~@Output कितना पारदर्शी होना चाहिए, \\0\\ और \\1\\ के बीच, इसके डिफ़ॉल्ट के बजाय। फ़ेडिंग इन और आउट के लिए सहायक।",
                "names": "$~अस्पष्टता"
            },
            "offset": {
                "doc": "$~@Place यह बताता है कि @Output के स्थान से इसे कितना ऑफसेट होना चाहिए, न कि इसके डिफ़ॉल्ट स्थान से। जगह में हिलने-डुलने के लिए उपयोगी।",
                "names": "$~ओफ़्सेट"
            },
            "rotation": {
                "doc": "$~@Output को उसके डिफ़ॉल्ट के बजाय कितना घुमाया जाना चाहिए।",
                "names": "$~ROTATION"
            },
            "scale": {
                "doc": "$~@Output को उसके डिफ़ॉल्ट आकार के बजाय उसके मूल आकार के सापेक्ष कितना बड़ा किया जाना चाहिए।",
                "names": "$~पैमाना"
            },
            "flipx": {
                "doc": "$~क्या @Output को उसके डिफ़ॉल्ट के बजाय x-अक्ष पर प्रतिबिंबित किया जाना चाहिए।",
                "names": "$~फ़्लिपक्स"
            },
            "flipy": {
                "doc": "$~क्या @Output को उसके डिफ़ॉल्ट के बजाय y-अक्ष पर प्रतिबिंबित किया जाना चाहिए।",
                "names": "$~फ़्लिपी"
            },
            "description": "$~$1[पारदर्शी $1|] $2[घुमाया गया $2 डिग्री|] $3[स्केल किया गया $3|] $4[क्षैतिज रूप से फ़्लिप किया गया|] $5[लंबवत रूप से फ़्लिप किया गया|] $6[छाया धुंधली $6 पिक्सेल]"
        },
        "Color": {
            "names": ["$~🌈", "$~रंग"],
            "doc": [
                "$~मैं एक दृश्यमान रंग हूँ, जो तीन अनिवार्य आयामों से बना है।",
                "$~मध्यम चमक और उच्च क्रोमा पर रंग चक्र के आसपास कुछ सामान्य रंग यहां दिए गए हैं:",
                "$~\\रंग(50% 100 0°)\\",
                "$~\\रंग(50% 100 30°)\\",
                "$~\\रंग(50% 100 60°)\\",
                "$~\\रंग(50% 100 90°)\\",
                "$~\\रंग(50% 100 120°)\\",
                "$~\\रंग(50% 100 150°)\\",
                "$~\\रंग(50% 100 180°)\\",
                "$~\\रंग(50% 100 210°)\\",
                "$~\\रंग(50% 100 240°)\\",
                "$~\\रंग(50% 100 270°)\\",
                "$~\\रंग(50% 100 300°)\\",
                "$~\\रंग(50% 100 330°)\\"
            ],
            "lightness": {
                "doc": "$~मुझे \\0\\ से \\1\\ तक कितना हल्का होना चाहिए, \\0\\ पर काले से, \\0.5\\ पर ग्रे से, \\1\\ पर सफेद तक।",
                "names": ["luminosidad"]
            },
            "chroma": {
                "doc": "$~मेरे पास कितना रंग होना चाहिए, \\0\\ से \\∞\\ तक। कोई रंग नहीं होने का मतलब है ग्रे, अधिक संख्या का मतलब है अधिक रंग।",
                "names": ["croma"]
            },
            "hue": {
                "doc": "$~मुझे किस रंग का होना चाहिए, रंग चक्र पर, मेजेंटा \\0\\, लाल \\30\\, हरा \\120\\, से नीला \\270\\ तक।",
                "names": ["matiz"]
            }
        },
        "Sequence": {
            "names": ["$~💃", "$~अनुक्रम"],
            "doc": [
                "$~ओह. माई. गोश. डायरेक्टर, आज आप कमाल के लग रहे हैं! क्या आप मेरे साथ डांस करना चाहेंगे? यह आसान है।",
                "$~आपको बस मुझे एक @Map देने की जरूरत है, जहां प्रत्येक कुंजी यह दर्शाती है कि हम नृत्य में कितने प्रतिशत आगे हैं, और उन कुंजियों का प्रत्येक मान एक @Pose है।",
                "$~आप इसे कई अलग-अलग तरीकों से एनिमेट कर सकते हैं! उदाहरण के लिए, यहाँ एक सरल तरीका है:",
                "$~\\वाक्यांश('hi' विश्राम: अनुक्रम({0%: मुद्रा(घूर्णन: 360°) 100%: मुद्रा(घूर्णन: 0°)})\\",
                "$~यह कहता है, /शुरुआत में (0%), झुकाव 360 पर शुरू करें, और झुकाव 0/ पर समाप्त करें। यह हमें हमेशा के लिए चक्कर में डाल देगा, क्योंकि मैं @Phrase की आराम मुद्रा के रूप में सेट हूँ!",
                "$~अन्य इनपुट के साथ खेलकर अपने स्वयं के रचनात्मक नृत्य का प्रयास करें।"
            ],
            "poses": {
                "doc": "$~0% और 100% के बीच प्रतिशत का @Map, प्रत्येक को @Pose के साथ जोड़ा गया है। आपको सभी प्रतिशत प्रदान करने की आवश्यकता नहीं है; मैं आपके द्वारा दिए गए प्रतिशत के बीच आसानी से @Output को स्थानांतरित कर दूंगा।",
                "names": "$~बनगयाहै"
            },
            "duration": {
                "doc": "$~मुझे यह नृत्य कितनी देर तक करना चाहिए? अगर मुझे इसे दोहराना है, तो मैं अवधि में कोई समय नहीं जोड़ूंगा, मैं बस तेज़ गति से नृत्य करूंगा।",
                "names": ["$~⏳", "$~अवधि"]
            },
            "style": {
                "doc": "$~नृत्य के लिए मुझे किस शैली का उपयोग करना चाहिए?",
                "names": "$~शैली"
            },
            "count": {
                "doc": "$~अनुक्रम पूरा होने से पहले कितनी बार दोहराना चाहिए। जब मैं मंच पर प्रवेश करता हूं, मंच पर आगे बढ़ता हूं, या मंच से बाहर निकलता हूं, तो यह वास्तव में मददगार होता है, लेकिन जब आराम अनुक्रम के लिए होता है, तो इसे अनदेखा कर दिया जाता है, क्योंकि मैं हमेशा के लिए आराम कर सकता हूं।",
                "names": "$~गिनतीकरना"
            }
        },
        "Place": {
            "names": ["Posición"],
            "doc": "$~मैं @स्टेज पर एक स्थान हूँ। मेरे सभी इनपुट वैकल्पिक हैं, क्योंकि मैं डिफ़ॉल्ट रूप से केंद्र में हूँ।",
            "x": {
                "doc": "$~x-अक्ष पर एक स्थिति.",
                "names": "$~एक्स"
            },
            "y": {
                "doc": "$~Y-अक्ष पर एक स्थिति",
                "names": "$~य"
            },
            "z": {
                "doc": "$~z-अक्ष पर एक स्थिति",
                "names": "$~जेड"
            },
            "rotation": {
                "doc": "$~इस स्थिति पर घूर्णन",
                "names": ["$~📐", "$~ROTATION"]
            }
        },
        "Velocity": {
            "doc": "$~मैं @स्टेज पर एक स्थान हूँ। मेरे सभी इनपुट वैकल्पिक हैं, क्योंकि मैं डिफ़ॉल्ट रूप से केंद्र में हूँ।",
            "names": ["$~💨", "$~वेग"],
            "x": {
                "doc": "$~x-अक्ष पर प्रति सेकण्ड कितने मीटर चलना है?",
                "names": "$~एक्स"
            },
            "y": {
                "doc": "$~Y-अक्ष पर प्रत्येक सेकंड कितने मीटर चलना है?",
                "names": "$~य"
            },
            "angle": {
                "doc": "$~प्रत्येक सेकंड कितने डिग्री घूमना है",
                "names": ["$~कोण", "$~°"]
            }
        },
        "Matter": {
            "doc": "$~मैं आउटपुट के भौतिक गुण हूं, जो इस बात को प्रभावित करते हैं कि मैं मंच पर अन्य आउटपुट के साथ किस प्रकार अंतःक्रिया करता हूं।",
            "names": ["$~⚛️", "$~मामला"],
            "mass": {
                "doc": "$~वजन, किलोग्राम में",
                "names": "$~द्रव्यमान"
            },
            "bounciness": {
                "doc": "$~मुझे अपनी कितनी ऊर्जा टकराव में लगानी है, 0 का मतलब है कोई नहीं, 1 का मतलब है पूरी ऊर्जा।",
                "names": "$~उछाल"
            },
            "friction": {
                "doc": "$~कितना आगे तक खिसकाते रहना है; 0 का मतलब है कुछ भी नहीं, 1 का मतलब है हमेशा।",
                "names": "$~टकराव"
            },
            "roundedness": {
                "doc": "$~आउटपुट के कोनों को कितना गोल करना है; 0 का अर्थ है कोई नहीं और 1 का अर्थ है इसके आकार का 100%, जिससे आकार गोलाकार हो जाता है।",
                "names": "$~गोलाई"
            },
            "text": {
                "doc": "$~क्या यह अन्य आउटपुट से टकरा सकता है।",
                "names": "$~मूलपाठ"
            },
            "shapes": {
                "doc": "$~क्या यह अन्य आकृतियों से टकरा सकता है।",
                "names": "$~मैदान"
            }
        },
        "Aura": {
            "doc": [
                "$~मैं एक आभा हूँ। मैं @Phrase को चमकाता हूँ! इस तरह:",
                "$~\\वाक्यांश(\n'मैं चमक रहा हूँ!' \nआभा: आभा(रंग(50% 100 118°) 0.1m 0m 0.1m\n)\\"
            ],
            "names": ["$~🔮", "$~आभा"],
            "color": {
                "doc": "$~@Color वही @Aura होना चाहिए.",
                "names": "$~रंग"
            },
            "blur": {
                "doc": "$~@Aura कितना धुंधला होना चाहिए। \\0m\\ का अर्थ है बिल्कुल धुंधला नहीं।",
                "names": "$~कलंक"
            },
            "offsetX": {
                "doc": "$~मुझे कितना बायें या दायें दिखना चाहिए। \\0m\\ सीधे नीचे है।",
                "names": "$~ऑफसेटX"
            },
            "offsetY": {
                "doc": "$~मुझे कितना ऊपर या नीचे दिखना चाहिए.\\0m\\ सीधे नीचे है.",
                "names": "$~ऑफसेटY"
            }
        },
        "Easing": {
            "straight": "$~सीधा",
            "cautious": "$~सावधान",
            "pokey": "$~क़ुलफ़ी",
            "zippy": "$~व्यवसायिक"
        },
        "sequence": {
            "sway": {
                "doc": "$~मैं एक @Sequence बनाता हूँ जो @Output के केंद्र के चारों ओर आगे-पीछे घूमता है।",
                "names": ["vaivén"],
                "angle": {
                    "doc": "$~कितना झुकना है झुकने में।",
                    "names": ["ángulo"]
                }
            },
            "bounce": {
                "doc": "$~मैं एक @Sequence बनाता हूँ जो @Output को एक निश्चित ऊंचाई पर उछालता है।",
                "names": ["rebotar"],
                "height": {
                    "doc": "$~कितना ऊपर उछलना है.",
                    "names": ["altura"]
                }
            },
            "spin": {
                "doc": "$~मैं एक @Sequence बनाता हूँ जो @Output को उसके केंद्र के चारों ओर घुमाता है।",
                "names": ["girar"]
            },
            "fadein": {
                "doc": "$~मैं एक @Sequence बनाता हूँ जो @Output को अदृश्य से दृश्य में बदल देता है।",
                "names": ["$~फीकाहोना"]
            },
            "fadeout": {
                "doc": "$~मैं एक @Sequence बनाता हूँ जो @Output को दृश्यमान से अदृश्य में बदल देता है। मुझे एक मौजूदा @Sequence में आज़माएँ!",
                "names": ["$~फेडआउट"]
            },
            "popup": {
                "doc": "$~मैं एक @Sequence बनाता हूँ जो @Output को उसके सामान्य आकार में सिकोड़ने के बजाय शीघ्रता से छोटा कर देता है।",
                "names": ["surgir"]
            },
            "shake": {
                "doc": "$~मैं एक @Sequence बनाता हूँ जिससे ऐसा लगता है कि @Output डरा हुआ है।",
                "names": ["agitar"]
            }
        },
        "Source": {
            "names": "$~स्रोत",
            "doc": [
                "$~क्या आप जानते हैं कि प्रोजेक्ट में एक से ज़्यादा @Source फ़ाइल कैसे हो सकती हैं? मैं आपको अपने प्रोजेक्ट के तर्क के आधार पर एक @Source बनाने देता हूँ। अगर आप अपने प्रोजेक्ट के अलग-अलग मूल्यांकनों के बीच कुछ डेटा बचाना चाहते हैं तो यह वाकई मददगार है।",
                "$~उदाहरण के लिए, कल्पना करें कि आप एक सरल काउंटर बनाना चाहते हैं जो हर बार माउस बटन दबाने पर एक गिनता है। आप इसका उपयोग यह याद रखने के लिए कर सकते हैं कि आपने कितनी बार कुछ किया।",
                "$~\\↓ गिनती\n[\nवाक्यांश(`\\count\\ बार!`)\nस्रोत('count' गिनती … ∆ बटन() … गिनती + 1 )\n]\\",
                "$~इसे कॉपी करने का प्रयास करें, /count/ नामक एक नया @Source बनाएं और इसमें 0 टाइप करें, ताकि गिनती 0 से शुरू हो सके। यह छोटा सा प्रोजेक्ट /count/ स्रोत में मान प्राप्त करेगा और प्रत्येक बार जब माउस बटन दबाया जाएगा, तो /count/ @Source को वर्तमान /count/ मान प्लस /1/ के साथ संपादित करेगा।"
            ],
            "name": {
                "names": "$~नाम",
                "doc": "$~बनाने या अद्यतन करने हेतु स्रोत फ़ाइल का नाम."
            },
            "value": {
                "names": "$~कीमत",
                "doc": "$~वह डेटा मान जिसके साथ स्रोत फ़ाइल बनाई या अद्यतन की जानी चाहिए."
            },
            "DynamicEditLimitException": {
                "description": "$~गतिशील स्रोत संपादन सीमा",
                "explanation": "$~इस प्रोजेक्ट ने @Source फ़ाइलों में डेटा को बहुत बार, बहुत तेज़ी से सेव किया है। सुनिश्चित करें कि यह केवल इनपुट के जवाब में @Source को अपडेट करता है, और बहुत तेज़ी से नहीं।"
            },
            "ReadOnlyEditException": {
                "description": "$~केवल पढ़ने योग्य स्रोत संपादित करें",
                "explanation": "$~यह प्रोजेक्ट डेटा को याद रखता है, लेकिन आपके पास इसे संपादित करने का अधिकार नहीं है। अगर आप इसे आज़माना चाहते हैं तो इसे कॉपी करें।"
            },
            "EmptySourceNameException": {
                "description": "$~रिक्त स्रोत नाम",
                "explanation": "$~दिए गए @Source का नाम रिक्त था, इसलिए हम उसे सहेज नहीं सके।"
            },
            "ProjectSizeLimitException": {
                "description": "$~परियोजना आकार सीमा",
                "explanation": "$~इस प्रोजेक्ट में बहुत अधिक पाठ है, इसलिए हम इसे सहेज नहीं सकते।"
            }
        }
    },
    "ui": {
        "font": {
            "app": "Noto Sans",
            "code": "Noto Sans Mono"
        },
        "phrases": {
            "welcome": "$~नमस्ते"
        },
        "widget": {
            "confirm": {
                "cancel": "$~रद्द करना"
            },
            "dialog": {
                "close": "$~बंद करना"
            },
            "loading": {
                "message": "$~फ़ॉन्ट और पाठ लोड हो रहा है, प्रतीक्षा के लिए धन्यवाद!"
            },
            "home": "$~मुखपृष्ठ प्र जाएं",
            "table": {
                "cell": {
                    "description": "$~इस सेल को संपादित करें",
                    "placeholder": "$~कीमत"
                },
                "addcolumn": "$~इस कॉलम से पहले एक कॉलम जोड़ें",
                "removecolumn": "$~इस कॉलम को हटाएँ"
            }
        },
        "tile": {
            "toggle": {
                "fullscreen": {
                    "on": "$~पूर्ण स्क्रीन से बाहर निकलें",
                    "off": "$~पूर्ण स्क्रीन तक विस्तृत करें"
                },
                "show": {
                    "on": "$~छिपाना",
                    "off": "$~दिखाओ"
                }
            },
            "label": {
                "output": "$~अवस्था",
                "palette": "$~पैलेट",
                "docs": "$~मार्गदर्शक",
                "source": "$~स्रोत",
                "collaborate": "$~सहयोग"
            },
            "button": {
                "collapse": "$~विंडो को छोटा करें"
            }
        },
        "project": {
            "error": {
                "unknown": "$~यह परियोजना मौजूद नहीं है या सार्वजनिक नहीं है।",
                "translate": "$~आपके प्रोजेक्ट का अनुवाद करने में समस्या हुई.",
                "tile": "$~ओह, एक त्रुटि हुई.",
                "reset": "$~रीसेट करने का प्रयास..."
            },
            "button": {
                "removeCollaborator": "$~सहयोगी को हटाएँ",
                "copy": "$~प्रोजेक्ट को टेक्स्ट के रूप में क्लिपबोर्ड पर कॉपी करें",
                "addSource": "$~एक नया $source बनाएं",
                "duplicate": "$~इस प्रोजेक्ट की प्रतिलिपि बनाएँ",
                "revert": "$~मूल कोड पर वापस लौटें",
                "focusOutput": "$~मंच पर कीबोर्ड को केन्द्रित करें",
                "focusSource": "$~अगले स्रोत पर ध्यान केंद्रित करें",
                "focusDocs": "$~दस्तावेज़ पर ध्यान केंद्रित करें",
                "focusPalette": "$~पैलेट पर ध्यान केंद्रित करें",
                "focusCycle": "$~अगली टाइल पर ध्यान केंद्रित करें",
                "unsaved": "$~सेव त्रुटि दिखाएं",
                "translate": "$~इस परियोजना की भाषाओं को संपादित करें और इसे अन्य भाषाओं में अनुवाद करें.",
                "primary": "$~इस प्रोजेक्ट के प्राथमिक लोकेल के रूप में सेट करें",
                "share": {
                    "tip": "$~प्रोजेक्ट साझाकरण विकल्प दिखाएं",
                    "label": "$~शेयर करना"
                },
                "history": {
                    "on": "$~हाल ही का प्रोजेक्ट कोड दिखाएं",
                    "redo": "$~वर्तमान परियोजना कोड दिखाएं"
                }
            },
            "field": {
                "name": {
                    "description": "$~प्रोजेक्ट का नाम संपादित करें",
                    "placeholder": "$~नाम"
                }
            },
            "help": "$~कीबोर्ड शॉर्टकट दिखाएं",
            "collapsed": "$~आपकी सभी विंडो बंद हो गई हैं! आप उन्हें नीचे टूलबार में पा सकते हैं",
            "save": {
                "projectsNotSavedLocally": "$~आपके ब्राउज़र में प्रोजेक्ट सहेजने में समस्या हुई.",
                "projectsCannotNotSaveLocally": "$~आपका ब्राउज़र प्रोजेक्ट सहेजने का समर्थन नहीं करता है.",
                "projectContainedPII": "$~आपकी गोपनीयता की रक्षा के लिए, संभावित रूप से व्यक्तिगत पहचान योग्य जानकारी वाला प्रोजेक्ट ऑनलाइन सहेजा नहीं गया था। यह देखने के लिए प्रोजेक्ट की जाँच करें कि जानकारी पहचान योग्य है या नहीं।",
                "projectsNotLoadingOnline": "$~ऑनलाइन प्रोजेक्ट लोड करने में असमर्थ.",
                "projectNotSavedOnline": "$~परियोजनाओं को ऑनलाइन सहेजने में असमर्थ.",
                "settingsUnsaved": "$~ऑनलाइन सेटिंग सहेजने में असमर्थ."
            },
            "dialog": {
                "unsaved": "$~सहेजा नहीं गया कार्य...",
                "translate": {
                    "header": "$~बोली",
                    "explanation": [
                        "$~ये वे भाषाएँ हैं जिनका उपयोग आपका प्रोजेक्ट कर रहा है।",
                        "$~अपनी परियोजना को अन्य भाषाओं में अनुवाद करने के लिए, प्राथमिक स्रोत भाषा चुनें और फिर एक नई भाषा चुनें।",
                        "$~/सभी भाषाओं का समर्थन नहीं किया जाता है और अनुवाद अपूर्ण होंगे, इसलिए परिणामों की समीक्षा करें!/"
                    ]
                }
            },
            "subheader": {
                "source": "$~स्रोत",
                "destination": "$~गंतव्य"
            }
        },
        "gallery": {
            "untitled": "$~शीर्षकहीन",
            "undescribed": "$~कोई विवरण नहीं",
            "subheader": {
                "curators": {
                    "header": "$~क्यूरेटर",
                    "explanation": "$~इस गैलरी का प्रबंधन करने वाले निर्माता."
                },
                "creators": {
                    "header": "$~रचनाकारों",
                    "explanation": "$~इस गैलरी में योगदान देने वाले रचनाकार।"
                },
                "delete": {
                    "header": "$~मिटाना",
                    "explanation": "$~इस गैलरी को हटाने से इसके प्रोजेक्ट नहीं हटेंगे। गैलरी हमेशा के लिए हटा दी जाएगी।"
                },
                "classes": {
                    "header": "$~कक्षाओं",
                    "explanation": "$~इस गैलरी से संबद्ध कक्षाएं."
                }
            },
            "confirm": {
                "delete": {
                    "description": "$~गैलरी हटाएँ",
                    "prompt": "$~मिटाना"
                },
                "remove": {
                    "description": "$~गैलरी से प्रोजेक्ट हटाएँ",
                    "prompt": "$~निकालना"
                }
            },
            "error": {
                "unknown": "$~यह गैलरी मौजूद नहीं है या सार्वजनिक नहीं है।"
            },
            "field": {
                "name": {
                    "description": "$~गैलरी का नाम",
                    "placeholder": "$~नाम"
                },
                "description": {
                    "description": "$~गैलरी विवरण",
                    "placeholder": "$~अपनी गैलरी का वर्णन करें। इसका विषय, लक्ष्य या समुदाय क्या है?"
                }
            }
        },
        "source": {
            "label": "$~कार्यक्रम संपादक",
            "empty": [
                "$~चलिए शुरू करते हैं! आप...",
                "$~• 📕 खोलें और हमें इस प्रोग्राम पर खींचें।",
                "$~• $1 टाइप करें और मेनू से हमें चुनें।",
                "$~• हमें ⌨️ से टाइप करें।",
                "$~• प्रेरणा के लिए <galleries@://galleries> ब्राउज़ करें।",
                "$~यदि आप अटक गए हैं, तो <अधिक जानें@://जानें>."
            ],
            "overwritten": "$~नवीनतम संस्करण प्राप्त हुआ!",
            "confirm": {
                "delete": {
                    "description": "$~इस $source को हटाएँ",
                    "prompt": "$~मिटाना"
                }
            },
            "toggle": {
                "blocks": {
                    "on": "$~पाठ के रूप में संपादित करें",
                    "off": "$~ब्लॉक के रूप में संपादित करें"
                },
                "glyphs": {
                    "on": "$~मिलते-जुलते ग्लिफ़ को संक्षिप्त करें",
                    "off": "$~मेल खाते ग्लिफ़ का विस्तार करें"
                }
            },
            "button": {
                "selectOutput": "$~इस आउटपुट को मंच पर दिखाएं",
                "expandSequence": "$~इस संक्षिप्त कोड का विस्तार करें"
            },
            "field": {
                "name": {
                    "description": "$~स्रोत नाम संपादित करें",
                    "placeholder": "$~नाम"
                }
            },
            "menu": {
                "label": "$~स्वतः पूर्ण मेनू",
                "show": "$~स्वतः पूर्ण मेनू दिखाएँ",
                "back": "$~सबमेनू छोड़ें"
            },
            "cursor": {
                "priorLine": "$~कर्सर को पहले वाली लाइन पर ले जाएँ",
                "nextLine": "$~कर्सर को अगली पंक्ति पर ले जाएँ",
                "priorInline": "$~कर्सर को पहले वाली स्थिति में ले जाएँ",
                "nextInline": "$~कर्सर को बाद की स्थिति में ले जाएँ",
                "lineStart": "$~कर्सर को लाइन के आरंभ में ले जाएं",
                "lineEnd": "$~कर्सर को पंक्ति के अंत में ले जाएं",
                "sourceStart": "$~कर्सर को स्रोत के आरंभ में ले जाएं",
                "sourceEnd": "$~कर्सर को स्रोत के अंत में ले जाएं",
                "priorNode": "$~पहले पड़ोसी का चयन करें",
                "nextNode": "$~पड़ोसी का चयन करें",
                "parent": "$~कंटेनर का चयन करें",
                "selectAll": "$~प्रोग्राम चुनें",
                "incrementLiteral": "$~संख्या, पाठ या बूलियन बढ़ाएँ",
                "decrementLiteral": "$~संख्या, पाठ या बूलियन घटाएँ",
                "insertSymbol": "$~$1 डालें",
                "insertTab": "$~टैब डालें",
                "insertTrue": "$~सत्य डालें",
                "insertFalse": "$~गलत डालें",
                "insertNone": "$~कोई प्रतीक न डालें",
                "insertNotEqual": "$~बराबर नहीं डालें",
                "insertProduct": "$~उत्पाद प्रतीक डालें",
                "insertQuotient": "$~भागफल प्रतीक डालें",
                "insertDegree": "$~डिग्री प्रतीक डालें",
                "insertFunction": "$~सम्मिलित फ़ंक्शन",
                "insertLessOrEqual": "$~इससे कम या बराबर डालें",
                "insertGreaterOrEqual": "$~इससे बड़ा या बराबर डालें",
                "insertStream": "$~स्ट्रीम प्रतीक डालें",
                "insertChange": "$~परिवर्तन प्रतीक डालें",
                "insertConvert": "$~कन्वर्ट प्रतीक डालें",
                "insertPrevious": "$~पिछला प्रतीक डालें",
                "insertType": "$~प्रकार प्रतीक डालें",
                "insertTable": "$~तालिका खुला प्रतीक डालें",
                "insertTableClose": "$~तालिका बंद प्रतीक डालें",
                "insertBorrow": "$~उधार डालें",
                "insertShare": "$~शेयर डालें",
                "insertLine": "$~लाइन ब्रेक डालें",
                "backspace": "$~चयन या पूर्व प्रतीक हटाएं",
                "delete": "$~चयन या अगला प्रतीक हटाएं",
                "cut": "$~कट चयन",
                "copy": "$~कॉपी चयन",
                "paste": "$~कीबोर्ड की सामग्री चिपकाएँ",
                "parenthesize": "$~चयन कोष्ठक में रखें",
                "enumerate": "$~चयन की गणना करें",
                "type": "$~वर्ण टाइप करें",
                "undo": "$~पिछला संपादन पूर्ववत करें",
                "redo": "$~पुनः करें अधूरे संपादन को पुनः करें",
                "search": "$~सम्मिलित करने के लिए विशेष वर्ण खोजें",
                "tidy": "$~साफ़ अंतराल",
                "elide": "$~टॉगल एलिशन",
                "insertDocs": "$~स्पष्टीकरण प्रतीक डालें"
            }
        },
        "annotations": {
            "label": "$~संघर्ष और सहायता",
            "cursor": "$~यह *$1*$2[ है और वे $2|] प्रकार के हैं। $3[ वे *$3* के अंदर हैं।]",
            "cursorParent": "$~वे *$1*$2[ प्रकार $2|] के अंदर हैं।",
            "learn": "$~/और अधिक जानें/",
            "evaluating": "$~ओह मज़ा, चलो मूल्यांकन करें!",
            "space": "$~यह अंतरिक्ष है! कौन जानता था कि कोई भी चीज़ इतना कुछ नहीं कह सकती?",
            "button": {
                "resolution": "$~इस संघर्ष को हल करें"
            }
        },
        "output": {
            "label": "$~प्रोग्राम आउटपुट",
            "toggle": {
                "grid": {
                    "on": "$~ग्रिड लाइन छिपाएँ",
                    "off": "$~ग्रिड लाइन दिखाएँ"
                },
                "fit": {
                    "on": "$~ज़ूम को मैन्युअल रूप से नियंत्रित करें",
                    "off": "$~सामग्री के लिए फिट ज़ूम"
                },
                "paint": {
                    "on": "$~पेंट आउटपुट",
                    "off": "$~स्थान आउटपुट"
                }
            },
            "field": {
                "key": {
                    "description": "$~कुंजी दबाव सुनना",
                    "placeholder": "$~संदेश"
                }
            },
            "button": {
                "submit": "$~यह चैट संदेश सबमिट करें"
            },
            "options": {
                "locale": "$~आउटपुट के लिए भाषा चुनें"
            }
        },
        "timeline": {
            "label": "$~इस समय",
            "slider": "$~समय स्लाइडर",
            "button": {
                "play": "$~कार्यक्रम का अंत तक मूल्यांकन करें, वास्तविक समय में इनपुट पर प्रतिक्रिया दें",
                "pause": "$~प्रोग्राम को रोकें, जिससे आगे और पीछे कदम बढ़ाना संभव हो सके",
                "backStep": "$~एक कदम पीछे हटो",
                "backNode": "$~कर्सर के पिछले मूल्यांकन के लिए कदम",
                "backInput": "$~एक इनपुट वापस",
                "out": "$~इस फ़ंक्शन से बाहर निकलें",
                "forwardStep": "$~एक कदम आगे बढाओ",
                "forwardNode": "$~कर्सर के अगले मूल्यांकन के लिए चरण",
                "forwardInput": "$~अगले स्ट्रीम इनपुट के लिए आगे बढ़ें",
                "present": "$~अंत तक",
                "start": "$~शुरुआत तक",
                "reset": "$~पुनः आरंभ प्रदर्शन"
            }
        },
        "docs": {
            "label": "$~डॉक्यूमेंटेशन ब्राउज़र",
            "link": "$~दस्तावेज़ में अवधारणा $1 दिखाएं",
            "learn": "$~और अधिक जानें …",
            "nodoc": "$~मैं कौन हूँ? मैं क्या हूँ? मेरा उद्देश्य क्या है?",
            "button": {
                "home": "$~घर लौटना",
                "back": "$~पिछले पर लौटें"
            },
            "field": {
                "search": "$~शब्दों के साथ अवधारणाओं की खोज करें"
            },
            "header": {
                "inputs": "$~इनपुट",
                "interfaces": "$~इंटरफेस",
                "properties": "$~गुण",
                "functions": "$~कार्य",
                "conversions": "$~रूपांतरण"
            }
        },
        "dialog": {
            "share": {
                "header": "$~शेयरिंग",
                "explanation": "$~नियंत्रित करें कि कौन इस प्रोजेक्ट को संपादित और देख सकता है.",
                "subheader": {
                    "gallery": {
                        "header": "$~गैलरी",
                        "explanation": "$~इस प्रोजेक्ट को अन्य क्रिएटर्स के साथ गैलरी में जोड़ें, या अपने <projects@://projects> पेज पर गैलरी बनाएँ। अगर आप किसी प्रोजेक्ट को सार्वजनिक गैलरी में जोड़ते हैं, तो आपका प्रोजेक्ट सार्वजनिक हो जाएगा।"
                    },
                    "public": {
                        "header": "$~सार्वजनिक निजी",
                        "explanation": "$~सार्वजनिक परियोजनाओं और दीर्घाओं को दुनिया में कोई भी देख सकता है। हमारा लक्ष्य यह है कि यह सामग्री सकारात्मकता और खुशी लाए, और सार्वजनिक रूप से साझा करना ऐसा करने का एक तरीका है। लेकिन इसका मतलब कुछ नियमों का पालन करना भी है। आप वादा करते हैं कि आपकी परियोजना में ये नहीं होगा:"
                    },
                    "pii": {
                        "header": "$~व्यक्तिगत जानकारी",
                        "explanation": "$~व्यक्तिगत रूप से पहचान योग्य जानकारी (PII) को सार्वजनिक रूप से साझा करने से क्रिएटर्स को जोखिम हो सकता है, इसलिए हम संभावित PII का पता लगाते हैं और क्रिएटर्स को संवेदनशील डेटा को हटाने या इसे गैर-संवेदनशील के रूप में चिह्नित करने की चेतावनी देते हैं।\n\nनीचे इस प्रोजेक्ट में संभावित PII की सूची दी गई है जिसे आपने गैर-संवेदनशील के रूप में चिह्नित किया है। आप इसे फिर से संवेदनशील के रूप में चिह्नित करने के लिए इसके आगे दिए गए बटन पर क्लिक कर सकते हैं, लेकिन ऐसा करने का मतलब है कि आपका प्रोजेक्ट अब ऑनलाइन सेव नहीं होगा।"
                    }
                },
                "field": {
                    "emailOrUsername": {
                        "placeholder": "$~ईमेल या उपयोगकर्ता का नाम",
                        "description": "$~उस व्यक्ति का ईमेल या उपयोगकर्ता नाम जिसे आप संपादन पहुँच देना चाहते हैं"
                    }
                },
                "mode": {
                    "public": {
                        "label": "$~दृश्यता",
                        "modes": ["$~निजी", "$~जनता"]
                    }
                },
                "error": {
                    "unknown": "$~हम इस ईमेल वाले किसी भी निर्माता को नहीं जानते।",
                    "anonymous": "$~साझा करने के लिए आपको लॉग इन होना होगा।"
                },
                "button": {
                    "submit": "$~इस ईमेल पते के साथ परियोजना साझा करें",
                    "sensitive": {
                        "tip": "$~इस पाठ को पुनः संवेदनशील के रूप में चिह्नित करें",
                        "label": "$~संवेदनशील"
                    }
                },
                "options": {
                    "gallery": "$~गैलरी चयनकर्ता"
                }
            },
            "settings": {
                "header": "$~सेटिंग्स",
                "explanation": "$~लेआउट, डिवाइस और थीम सेटिंग्स बदलें.",
                "button": {
                    "show": "$~सेटिंग संवाद दिखाएं"
                },
                "mode": {
                    "layout": {
                        "label": "$~लेआउट",
                        "modes": [
                            "$~स्वचालित",
                            "$~क्षैतिज",
                            "$~खड़ा",
                            "$~मुक्त"
                        ]
                    },
                    "animate": {
                        "label": "$~एनिमेशन",
                        "modes": [
                            "$~एनिमेशन बंद",
                            "$~सामान्य गति",
                            "$~आधी गति",
                            "$~तीसरी गति",
                            "$~चौथाई गति"
                        ]
                    },
                    "dark": {
                        "label": "$~विषय",
                        "modes": [
                            "$~हल्के रंग",
                            "$~गहरे रंग",
                            "$~डिवाइस सेटिंग का उपयोग करें"
                        ]
                    },
                    "space": {
                        "label": "$~अंतरिक्ष सूचक",
                        "modes": [
                            "$~स्पेस और टैब संकेतक स्पष्ट रूप से दिखाएं",
                            "$~स्पेस और टैब संकेतक न दिखाएं"
                        ]
                    },
                    "writing": {
                        "label": "$~लेखन लेआउट",
                        "modes": [
                            "$~क्षैतिज, बाएं से दाएं",
                            "$~ऊर्ध्वाधर, दाएँ से बाएँ",
                            "$~ऊर्ध्वाधर, बाएं से दाएं"
                        ]
                    },
                    "localized": {
                        "label": "$~कोड स्थानीयकरण",
                        "modes": [
                            "$~कोड का स्थानीयकरण न करें",
                            "$~उपलब्ध होने पर कोड स्थानीयकृत करें",
                            "$~कोड को स्थानीयकृत करें लेकिन प्रतीकों को प्राथमिकता दें"
                        ]
                    },
                    "lines": {
                        "label": "$~पंक्ति संख्याएँ",
                        "modes": [
                            "$~टेक्स्ट मोड में पंक्ति संख्या दिखाएं",
                            "$~टेक्स्ट मोड में लाइन नंबर न दिखाएं"
                        ]
                    }
                },
                "options": {
                    "mic": "$~चयनित माइक्रोफ़ोन",
                    "camera": "$~चयनित कैमरा",
                    "face": "$~फ़ॉन्ट चेहरा"
                }
            },
            "locale": {
                "header": "$~भाषा",
                "explanation": "$~अपनी भाषाएं और क्षेत्र चुनें.",
                "subheader": {
                    "selected": "$~चयनित",
                    "supported": "$~उपलब्ध",
                    "coming": "$~जल्द आ रहा है",
                    "help": "$~अनुवाद करने में हमारी सहायता करें..."
                },
                "button": {
                    "show": "$~स्थान बदलें",
                    "add": "$~यह स्थान जोड़ें",
                    "remove": "$~इस लोकेल को हटाएँ",
                    "replace": "$~इस लोकेल से प्रतिस्थापित करें"
                }
            },
            "help": {
                "header": "$~शॉर्टकट",
                "explanation": "$~अधिक कुशल संपादन के लिए इन कीबोर्ड कमांड का उपयोग करें।",
                "subheader": {
                    "moveCursor": "$~कदम",
                    "editCode": "$~संपादन करना",
                    "insertCode": "$~डालना",
                    "debug": "$~डिबग"
                }
            }
        },
        "palette": {
            "label": "$~पैलेट",
            "labels": {
                "mixed": "$~मिश्रित",
                "computed": "$~गणना",
                "default": "$~गलती करना",
                "inherited": "$~विरासत में मिला",
                "notSequence": "$~अनुक्रम नहीं",
                "notContent": "$~सामग्री सूची नहीं",
                "format": "$~प्रारूप",
                "weight": "$~वज़न",
                "light": "$~रोशनी",
                "normal": "$~सामान्य",
                "bold": "$~बोल्ड",
                "extra": "$~अतिरिक्त",
                "italic": "$~तिरछा",
                "underline": "$~रेखांकन"
            },
            "button": {
                "revert": "$~डिफ़ॉल्ट पर वापस लौटें",
                "set": "$~इस संपत्ति को संपादित करें",
                "addPhrase": "$~इसके बाद एक वाक्यांश जोड़ें",
                "addGroup": "$~इसके बाद एक समूह जोड़ें",
                "addShape": "$~इसके बाद एक आकृति जोड़ें",
                "addMotion": "$~मोशन स्ट्रीम के लिए स्थान निर्धारित करें",
                "addPlacement": "$~प्लेसमेंट स्ट्रीम पर स्थान सेट करें",
                "remove": "$~इस सामग्री को हटाएँ",
                "up": "$~इस सामग्री को ऊपर ले जाएँ",
                "down": "$~इस सामग्री को नीचे ले जाएँ",
                "edit": "$~इस सामग्री को संपादित करें",
                "sequence": "$~अनुक्रम में परिवर्तित करें",
                "createPhrase": "$~एक वाक्यांश बनाएं, जो मौजूदा मान को टेक्स्ट के रूप में दिखाए",
                "createGroup": "$~किसी भी मौजूदा वाक्यांश को लपेटते हुए एक समूह बनाएं",
                "createStage": "$~किसी भी मौजूदा समूह या वाक्यांश को लपेटते हुए एक स्टेज बनाएं"
            },
            "prompt": {
                "offerPhrase": "$~आपने कितना बढ़िया मूल्य बनाया है! क्या मैं इसे @स्टेज पर दिखाऊं?",
                "offerGroup": "$~आपने कितना बढ़िया @वाक्यांश बनाया है। क्या आप उन्हें एक @समूह में लाना चाहते हैं, ताकि उन्हें व्यवस्थित किया जा सके?",
                "offerStage": "$~बहुत बढ़िया @प्रोग्राम। मुझे लाइटिंग, रंग, फ्रेम को नियंत्रित करने के लिए जोड़ें।",
                "pauseToEdit": "$~यदि आप स्टेज को ⏸️ करते हैं, तो आप संपादित करने के लिए 💬, 🔳, या 🎭 का चयन कर सकते हैं!",
                "editing": "$~मुझे संपादित करें!"
            },
            "field": {
                "coordinate": "$~समन्वय संपादित करें",
                "text": "$~संमपादित पाठ"
            },
            "sequence": {
                "button": {
                    "add": "$~मुद्रा जोड़ें",
                    "remove": "$~मुद्रा हटाएँ",
                    "up": "$~मुद्रा ऊपर ले जाएँ",
                    "down": "$~मुद्रा को नीचे ले जाएँ"
                },
                "field": {
                    "percent": "$~संपादित करें प्रतिशत"
                }
            }
        },
        "save": {
            "saving": "$~बचत",
            "saved": "$~ऑनलाइन सहेजा गया",
            "local": "$~ब्राउज़र में सहेजा गया",
            "unsaved": "$~न सहेजा गया"
        },
        "page": {
            "unknown": {
                "header": "$~ईप!",
                "message": "$~यह जगह कहाँ है? क्या हम घर जा सकते हैं?"
            },
            "landing": {
                "value": "$~हमारे साथ शब्दों, प्रतीकों, इमोजी और कोड के साथ इंटरैक्टिव कहानियां बनाएं!",
                "description": [
                    "$~वर्डप्ले एक प्रोग्रामिंग भाषा है जो आपको सक्षम बनाती है:",
                    "$~• शब्दों और इमोजी को मज़ेदार तरीके से एनिमेट करें 🤪",
                    "$~• समय 🕦, ध्वनि 🎤, वेबसाइट 🔗, और भौतिकी 🌎 का उपयोग करें",
                    "$~• दोस्तों, समूहों या किसी के साथ भी साझा करें",
                    "$~• किसी भी विश्व भाषा में कोड करें 🌐",
                    "$~• माउस 🖱️, टच 👆, और कीबोर्ड ⌨️ से संपादित करें",
                    "$~• आगे ⏩ और पीछे ⏪ डीबग करें",
                    "$~• स्क्रीन 🖥️ और स्क्रीन रीडर 🔊 के साथ देखें",
                    "$~<University of Washington@https://ischool.uw.edu/> से हमेशा के लिए निःशुल्क।"
                ],
                "beta": [
                    "$~वर्डप्ले अभी *बीटा* में है, इसलिए हो सकता है कि यह अपेक्षित रूप से काम न करे या पूरा न हो। बग की रिपोर्ट करें और <GitHub@https://github.com/wordplaydev/wordplay/issues> में विचार साझा करें, हमारी <1.0 योजनाएँ@https://github.com/wordplaydev/wordplay/milestones/1.0> देखें, और <contribute@https://github.com/wordplaydev/wordplay/wiki/contribute> देखें।"
                ],
                "link": {
                    "about": "$~यह स्थान क्यों मौजूद है?",
                    "learn": "$~नाटकीय पात्रों के साथ भाषा सीखें",
                    "guide": "$~भाषा संदर्भ खोजें और ब्राउज़ करें",
                    "projects": "$~प्रदर्शन बनाएं और साझा करें",
                    "galleries": "$~दूसरों के प्रदर्शन का अनुभव करें",
                    "rights": "$~जिम्मेदारियाँ, हमारी और आपकी",
                    "community": {
                        "label": "$~समुदाय",
                        "subtitle": "$~डिस्कॉर्ड पर हमसे चैट करें."
                    },
                    "contribute": {
                        "label": "$~योगदान देना",
                        "subtitle": "$~वर्डप्ले बनाने में हमारी सहायता करें."
                    },
                    "teach": "$~छात्रों की कक्षाओं और उनकी परियोजनाओं का प्रबंधन करें"
                }
            },
            "learn": {
                "header": "$~सीखना",
                "error": "$~हम इस भाषा के लिए कोई ट्यूटोरियल नहीं ढूंढ पाए।",
                "button": {
                    "next": "$~संवाद में अगला विराम",
                    "previous": "$~संवाद में पिछला विराम"
                },
                "options": {
                    "lesson": "$~वर्तमान पाठ"
                }
            },
            "guide": {
                "header": "$~मार्गदर्शक",
                "description": "$~यह वर्डप्ले प्रोग्रामिंग भाषा के हर भाग के लिए एक संदर्भ है। किसी अवधारणा की खोज करें या अधिक जानने के लिए सूची ब्राउज़ करें।"
            },
            "projects": {
                "header": "$~परियोजनाओं",
                "projectprompt": "$~कुछ कहने के लिए तैयार हैं? कोई प्रोजेक्ट बनाएं या उस पर काम करें। अगर आप अटक जाते हैं, तो <learning@://learn> जारी रखें।",
                "archiveheader": "$~संग्रहीत",
                "archiveprompt": "$~ये वे प्रोजेक्ट हैं जिन्हें आपने संग्रहीत किया है। केवल स्वामी ही उन्हें स्थायी रूप से हटा सकते हैं या संग्रह से हटा सकते हैं। संग्रहीत प्रोजेक्ट को अंतिम बार संपादित किए जाने के 30 दिन बाद स्थायी रूप से हटा दिया जाएगा।",
                "galleriesheader": "$~दीर्घाओं",
                "galleryprompt": "$~परियोजनाओं के संग्रह को दूसरों के साथ साझा करने के लिए गैलरी बनाएं और व्यवस्थित करें।",
                "add": {
                    "header": "$~नई परियोजना",
                    "explanation": "$~नया प्रोजेक्ट बनाने के लिए एक टेम्पलेट चुनें."
                },
                "button": {
                    "newproject": "$~नई परियोजना",
                    "editproject": "$~इस परियोजना को संपादित करें",
                    "viewcode": "$~इस परियोजना का कोड देखें",
                    "newgallery": "$~नई गैलरी",
                    "unarchive": "$~इस परियोजना को असंग्रहित करें"
                },
                "confirm": {
                    "archive": {
                        "description": "$~इस प्रदर्शन को संग्रहित करें",
                        "prompt": "$~पुरालेख"
                    },
                    "delete": {
                        "description": "$~इस प्रदर्शन को स्थायी रूप से हटाएँ",
                        "prompt": "$~हमेशा के लिए हटाएं"
                    }
                },
                "error": {
                    "noaccess": "$~हम इंटरनेट तक नहीं पहुंच सके.",
                    "nogalleryedits": "$~गैलरी बनाने और बदलने के लिए आपको लॉग इन होना होगा।",
                    "newgallery": "$~हम नई गैलरी नहीं बना सके.",
                    "nodeletes": "$~संग्रहीत परियोजनाओं को हटाने के लिए आपको लॉग इन होना होगा।",
                    "delete": "$~ओह, हम प्रोजेक्ट को हटा नहीं सके!"
                }
            },
            "galleries": {
                "header": "$~दीर्घाओं",
                "prompt": "$~ये वे प्रदर्शन हैं जो दूसरों ने किए हैं। इन्हें अनुभव करें, इनका अध्ययन करें, या इन्हें अपने वक्तव्य में ढालें।",
                "examples": "ejemplos"
            },
            "about": {
                "header": "$~के बारे में",
                "content": [
                    "$~क्या आपने कभी ऐसा महसूस किया है कि कोडिंग केवल अंग्रेजी बोलने वाले, गैर-विकलांग पश्चिमी लोगों के लिए है जो कंप्यूटर के साथ बड़े हुए हैं?",
                    "$~हाँ, हम भी.",
                    "$~यह कोई दुर्घटना नहीं है। कंप्यूटिंग की शुरुआत से ही, प्रोग्रामिंग भाषाओं को ज़्यादातर एक ही समूह के लोगों द्वारा डिज़ाइन और निर्मित किया गया है - ज़्यादातर अमेरिका और यूरोप में शिक्षा और उद्योग में श्वेत, सीआईएस, अंग्रेज़ी बोलने वाले पुरुष और कुछ अविश्वसनीय महिला गणितज्ञ। उन्होंने अपना काम उत्तर-औपनिवेशिक, विजेता-ले-सब-शक्ति के समय में किया, और प्रोग्रामिंग भाषाएँ उस शक्ति को सुरक्षित रखने के लिए एक महत्वपूर्ण उपकरण थीं।",
                    "$~इस इतिहास ने कम्प्यूटिंग के एक ऐसे दृष्टिकोण को जन्म दिया है जो मुख्यतः गति, तर्क, लाभ और प्रभुत्व पर आधारित है।",
                    "$~यह अन्याय है। क्योंकि कंप्यूटिंग, अच्छे और बुरे के लिए, अब दैनिक जीवन को दृश्यमान और अदृश्य तरीकों से प्रभावित करती है, और जिन लोगों के पास इसके साथ सृजन करने की पहुँच है, वे इसके रचनाकारों की तरह ही हैं। बाकी मानवता इस शक्ति के प्रति कृतज्ञ है, क्योंकि कुछ भी अलग कल्पना करने के लिए साक्षरता की आवश्यकता होती है, जो भाषा अवरोधों, पहुँच अवरोधों, आर्थिक अवरोधों और सार्वजनिक शिक्षा में असमानताओं द्वारा बाधित होती है।",
                    "$~*वर्डप्ले* इसे बदलने में मदद करने की इच्छा रखता है। यह एक प्रोग्रामिंग प्लेटफ़ॉर्म है जिसे वैश्विक होने के लिए डिज़ाइन किया गया है, जो दुनिया की सभी भाषाओं का समर्थन करता है, लेकिन दुनिया की भाषाओं के बारे में भी है। एक ऐसा प्लेटफ़ॉर्म जिस पर हर कोई अपनी क्षमताओं के साथ, इंटरैक्टिव सामग्री साझा करने के लिए बना सकता है जिसे कोई भी अनुभव कर सकता है। युवा और युवा वयस्कों के लिए जो इंटरैक्टिव शब्दों, इमोजी और टाइपोग्राफी के माध्यम से खुद को चंचल और कलात्मक रूप से व्यक्त करना चाहते हैं। खुद के लिए शक्ति प्राप्त करने के लक्ष्य के साथ नहीं, बल्कि एक कम्प्यूटेशनल दुनिया बनाने के लिए जो हमारे सुंदर मतभेदों की अविश्वसनीय ताकत और आवश्यकता को पहचानती है।",
                    "$~हम डिज़ाइनरों, शिक्षकों और डेवलपर्स का एक समुदाय हैं जो इस दृष्टि को जीवन में लाने की कोशिश कर रहे हैं। हम रंग के लोग हैं, हम ट्रांस हैं, हम क्वीर हैं, हम विकलांग हैं, हम अप्रवासी हैं, हम शरणार्थी हैं। हम सिएटल, वाशिंगटन, यूएसए में <यूनिवर्सिटी ऑफ़ वाशिंगटन@https://washington.edu> <इंफॉर्मेशन स्कूल@https://ischool.uw.edu/> में केंद्रित हैं, एक ऐसी जगह जो सभी का स्वागत करने और उपनिवेशवाद के सक्षमतावादी और नस्लवादी कहर को खत्म करने की आकांक्षा रखती है जो आज भी जारी है। इस प्रोग्रामिंग भाषा और प्लेटफ़ॉर्म को बनाना उस मिशन का एक छोटा सा हिस्सा है, जो कंप्यूटिंग के भविष्य की एक झलक पेश करता है जहाँ /हर कोई/ रहता है।",
                    "$~हमें आपकी मदद पसंद आएगी। जानें <योगदान कैसे करें@https://github.com/wordplaydev/wordplay/wiki/contribute>, <donate@://donate>, या हमारी <progress@https://github.com/amyjko/wordplay/milestones> को ट्रैक करें। अगर आपके कोई सवाल हैं, तो हमारे समुदाय आयोजक <Amy@https://amyjko.phd> को लिखें।"
                ]
            },
            "login": {
                "header": "$~लॉग इन करें",
                "anonymous": "$~लॉग इन करें",
                "prompt": {
                    "forgot": "$~*अपना पासवर्ड भूल गए?* दुर्भाग्यवश, हम आपका खाता पुनः प्राप्त नहीं कर सकते क्योंकि हम संपर्क जानकारी एकत्रित नहीं करते हैं।",
                    "email": "$~क्या आपके पास केवल ईमेल खाता है? अपना ईमेल सबमिट करके लॉगिन करें, और यदि इससे कोई खाता जुड़ा हुआ है, तो हम आपको साइन-इन लिंक के साथ एक ईमेल भेजेंगे। गोपनीयता बनाए रखने के लिए नए ईमेल-केवल खाते समर्थित नहीं हैं।",
                    "enter": "$~ऐसा लगता है कि आपका लॉगिन लिंक किसी दूसरे ब्राउज़र या डिवाइस से आया है। क्या आप अपना ईमेल दोबारा दर्ज कर सकते हैं, ताकि हमें यकीन हो जाए कि यह आप ही हैं?",
                    "tooyoung": "$~ईमेल से लॉगइन करने के लिए आपकी आयु 13 वर्ष या उससे अधिक होनी चाहिए।",
                    "passwordrule": "$~पासवर्ड कम से कम 10 अक्षरों का होना चाहिए; यदि आप पासवर्ड मैनेजर का उपयोग नहीं कर रहे हैं, तो तीन लंबे शब्द चुनें जिन्हें आप याद रख सकें।",
                    "passwordreminder": "$~ऐसा लगता है कि आपके पास अभी तक कोई खाता नहीं है। अपना पासवर्ड दोबारा दर्ज करें और सुनिश्चित करें कि आपने इसे सुरक्षित और सही तरीके से संग्रहीत किया है, क्योंकि इसे पुनर्प्राप्त नहीं किया जा सकता है।",
                    "play": "$~आप लॉग इन हैं, अब हम आपकी परियोजनाओं को ऑनलाइन सहेज सकते हैं! कुछ बनाना चाहते हैं?",
                    "changeEmail": "$~क्या आप अपना ईमेल बदलना चाहते हैं? नया ईमेल सबमिट करें और हम पुराने ईमेल पर पुष्टि भेज देंगे।",
                    "changePassword": "$~क्या आप अपना पासवर्ड बदलना चाहते हैं? नया पासवर्ड सबमिट करें और उसे दोहराएं।",
                    "logout": "$~क्या आप किसी साझा डिवाइस का उपयोग कर रहे हैं और अपने प्रोजेक्ट को निजी रखना चाहते हैं? लॉगआउट करें और हम इस डिवाइस से आपके प्रोजेक्ट हटा देंगे, लेकिन वे ऑनलाइन सहेजे रहेंगे।",
                    "sent": "$~अगर यह ईमेल किसी खाते से जुड़ा है, तो उसे लॉगिन लिंक वाला एक ईमेल प्राप्त होगा। इसे प्रदर्शित होने में कुछ मिनट लग सकते हैं। अगर इस ईमेल से कोई खाता संबद्ध नहीं है, तो आपको कुछ भी प्राप्त नहीं होगा।",
                    "success": "$~खाता बनाया गया!",
                    "confirm": "$~अपने नए पते की पुष्टि के लिए अपना पुराना ईमेल पता जांचें।",
                    "delete": "$~क्या आप चाहते हैं कि हम यहाँ आपके द्वारा बनाई गई हर चीज़ को भूल जाएँ? इसे बदला नहीं जा सकता।",
                    "reallyDelete": "$~क्या आप निश्चित हैं? आपका खाता और सेटिंग तुरंत हटा दी जाएंगी और आपकी परियोजनाओं को हटाने के लिए शेड्यूल किया जाएगा। आपकी परियोजनाओं पर सहयोगी तुरंत उन तक पहुँच खो देंगे। यह पुष्टि करने के लिए अपना ईमेल या उपयोगकर्ता नाम लिखें कि आप यही चाहते हैं।",
                    "name": "$~दूसरोंकेसामनेअपनाप्रतिनिधित्वकरनेकेलिएकोईइमोजीचुनें।",
                    "login": "$~अपनी परियोजनाओं को सहेजने, सहयोग करने और साझा करने के लिए लॉगिन करें:",
                    "join": "$~या, शुरू करने के लिए <create an account@://join> पर क्लिक करें।"
                },
                "error": {
                    "expired": "$~यह लिंक समाप्त हो गया.",
                    "invalid": "$~यह लिंक वैध नहीं है.",
                    "email": "$~यह ईमेल वैध नहीं था.",
                    "offline": "$~हम बादल तक नहीं पहुंच सके ☁️.",
                    "failure": "$~लॉगिन करने में असमर्थ :(",
                    "unchanged": "$~हम आपका ईमेल पता नहीं बदल सके, लेकिन हमें इसका कारण नहीं पता।",
                    "delete": "$~हम आपका खाता नहीं हटा सके, लेकिन हमें इसका कारण नहीं पता।",
                    "wrongPassword": "$~मान्य उपयोगकर्ता नाम और पासवर्ड नहीं है। या तो आपका पासवर्ड ग़लत है, या किसी और के पास यह उपयोगकर्ता नाम है।",
                    "tooMany": "$~आपने कई बार लॉग इन करने की कोशिश की है और असफल रहे हैं। आपको फिर से प्रयास करने के लिए प्रतीक्षा करनी होगी।"
                },
                "feedback": {
                    "changing": "$~नया ईमेल सबमिट किया जा रहा है...",
                    "deleting": "$~ठीक है, आपकी परियोजनाएं और सेटिंग्स हटाई जा रही हैं...",
                    "updatedPassword": "$~आपका पासवर्ड अपडेट हो गया है.",
                    "match": "$~यह आपके खाते के उपयोगकर्ता नाम से मेल खाना चाहिए."
                },
                "field": {
                    "email": {
                        "description": "$~लॉगिन ईमेल संपादित करें",
                        "placeholder": "$~ईमेल"
                    },
                    "username": {
                        "description": "$~लॉगिन उपयोगकर्ता नाम, व्यक्तिगत रूप से पहचान योग्य जानकारी का उपयोग न करें",
                        "placeholder": "$~उपयोगकर्ता नाम"
                    },
                    "password": {
                        "description": "$~लॉगिन पासवर्ड, कम से कम 10 अक्षर",
                        "placeholder": "$~पासवर्ड"
                    },
                    "currentPassword": {
                        "description": "$~आपका वर्तमान लॉगिन पासवर्ड",
                        "placeholder": "$~वर्तमान पासवर्ड"
                    },
                    "newPassword": {
                        "description": "$~आपका नया पासवर्ड",
                        "placeholder": "$~नया पासवर्ड"
                    }
                },
                "button": {
                    "logout": {
                        "tip": "$~अपने खाते से लॉगआउट करें",
                        "label": "$~लॉग आउट"
                    },
                    "login": "$~इस ईमेल से लॉगिन करें, लॉगिन लिंक भेजें",
                    "updateEmail": "$~अपना ईमेल बदलें",
                    "updatePassword": "$~नया पासवर्ड सबमिट करें",
                    "delete": {
                        "tip": "$~अपना खाता हटाएं",
                        "label": "$~मेरा डेटा मिटाओ..."
                    },
                    "reallyDelete": {
                        "tip": "$~अपना खाता हमेशा के लिए हटा दें",
                        "label": "$~इसे हटा!!!"
                    }
                },
                "toggle": {
                    "reveal": {
                        "on": "$~पासवर्ड दिखाए",
                        "off": "$~पासवर्ड छिपाएं"
                    }
                },
                "subtitle": "$~सहेजें, सहयोग करें और साझा करें"
            },
            "join": {
                "header": "$~जोड़ना",
                "prompt": {
                    "create": "$~अपनी परियोजनाओं को सहेजने, दूसरों के साथ सहयोग करने और अपना काम साझा करने के लिए एक खाता बनाएं।",
                    "username": "$~उपयोगकर्ता नाम कम से कम /5 अक्षर/ का होना चाहिए, ईमेल नहीं हो सकता, तथा उसमें आपका नाम या अन्य पहचान संबंधी जानकारी नहीं होनी चाहिए।",
                    "password": "$~पासवर्ड कम से कम /10 अक्षर/ का होना चाहिए। इसे दो बार टाइप करें और इसे किसी सुरक्षित जगह पर लिख लें, जैसे पासवर्ड मैनेजर। *यदि आप अपना अकाउंट खो देते हैं तो उसे वापस पाने का कोई तरीका नहीं है*, क्योंकि हम संपर्क जानकारी एकत्र नहीं करते हैं।"
                }
            },
            "rights": {
                "header": "$~अधिकार",
                "content": [
                    "$~नमस्ते!",
                    "$~आइए हम आपके और हमारे अधिकारों के बारे में कुछ अपेक्षाएं निर्धारित करें (नीति के प्रकाश में, जैसे कि <COPPA@https://www.ecfr.gov/current/title-16/chapter-I/subchapter-C/part-312> और <GDPR@https://gdpr.eu/compliance-checklist-us-companies/>)।",
                    "$~पहली बात यह जानना ज़रूरी है कि हम कोई व्यावसायिक इकाई नहीं हैं। हम एक समुदाय-आधारित शोध परियोजना हैं जो एक गैर-लाभकारी विश्वविद्यालय में स्थित है। हमारा लक्ष्य एक ऐसा प्लेटफ़ॉर्म बनाना है जो आपको खुशी दे और हमें कंप्यूटिंग की अधिक न्यायसंगत और न्यायपूर्ण दुनिया के बारे में खोज करने में मदद करे। हमें इस प्लेटफ़ॉर्म पर पैसा कमाने में कोई दिलचस्पी नहीं है; हम जो भी पैसा इकट्ठा करते हैं (आमतौर पर सार्वजनिक फंडिंग के माध्यम से) उसका उपयोग प्लेटफ़ॉर्म को बनाए रखने के लिए किया जाता है, न कि उस पर काम करने वाले (या इसमें योगदान देने वाले) लोगों को समृद्ध करने के लिए।",
                    "$~क्योंकि हम लाभ की तलाश में नहीं हैं, इसका मतलब यह भी है कि हम इस प्लेटफ़ॉर्म की विश्वसनीयता, उपलब्धता या दीर्घायु के बारे में कोई वादा नहीं कर सकते। ऐसा कहने के बाद, <Amy@https://amyjko.phd> इसे बनाए रखने के लिए दीर्घकालिक रूप से प्रतिबद्ध है, और एक स्थायी प्रोफेसर के रूप में, उसे एक बहुत ही स्थिर काम मिला है।",
                    "$~इससे हम डेटा तक पहुंचते हैं। हम क्लाउड में क्या इकट्ठा करते हैं और स्टोर करते हैं, यह इस प्रकार है:",
                    "$~• आपकी *परियोजनाएँ*। हम आपके द्वारा योगदान की गई किसी भी परियोजना और उसमें आपके द्वारा किए गए परिवर्तनों को संग्रहीत करते हैं, जब तक कि उन परियोजनाओं में व्यक्तिगत पहचान योग्य जानकारी जैसे फ़ोन नंबर, ईमेल पते, उपयोगकर्ता नाम, कर पहचानकर्ता या पते शामिल न हों।",
                    "$~• आपकी *सेटिंग्स*। इसमें आपके द्वारा चुनी गई भाषाएँ, आपकी एनीमेशन प्राथमिकताएँ और आपके ट्यूटोरियल की प्रगति शामिल है। बाकी सब कुछ केवल आपके डिवाइस पर संग्रहीत है।",
                    "$~• समग्र *गतिविधि*। हम लॉगिन और आपके द्वारा देखे जाने वाले पेजों को ट्रैक करते हैं, लेकिन इस तरह से नहीं कि हम आपकी पहचान कर सकें, साइट पर आपको ट्रैक कर सकें या अन्य साइटों पर आपको ट्रैक कर सकें। हम Google Analytics का उपयोग 'सहमति अस्वीकृत' मोड में करते हैं, जो केवल पेज व्यू के बारे में न्यूनतम गैर-पहचान योग्य जानकारी एकत्र करता है, कुकीज़ संग्रहीत किए बिना या Google को IP पता जानकारी भेजे बिना। हम इस समग्र जानकारी का उपयोग प्लेटफ़ॉर्म का कितना उपयोग किया जा रहा है, इसकी रिपोर्ट करके फंडिंग जुटाने में मदद करने के लिए करते हैं।",
                    "$~हम इसके अलावा कुछ भी संग्रहीत नहीं करते हैं। हमारा <source@https://github.com/amyjko/wordplay/tree/main/src> सार्वजनिक है, इसलिए कोई भी इसे सत्यापित कर सकता है, और किसी भी अनपेक्षित ट्रैकिंग की रिपोर्ट कर सकता है।",
                    "$~आपके डेटा के मालिक आप हैं, हम नहीं। इसका मतलब है:",
                    "$~• आप नियंत्रित करते हैं कि आपके प्रोजेक्ट तक कौन पहुँच सकता है। वे डिफ़ॉल्ट रूप से निजी होते हैं, लेकिन आप उन्हें व्यक्तियों, समूहों के साथ साझा कर सकते हैं या उन्हें पूरी तरह से सार्वजनिक कर सकते हैं।",
                    "$~• आप किसी भी समय किसी भी प्रोजेक्ट या अपने खाते को पूरी तरह से हटा सकते हैं।",
                    "$~• आप किसी भी समय किसी भी प्रोजेक्ट या अपने पूरे खाते का निर्यात प्राप्त कर सकते हैं।",
                    "$~हम आपके डेटा का उपयोग किस प्रकार करेंगे और किस प्रकार नहीं करेंगे, यह यहां बताया गया है:",
                    "$~• हम आपका डेटा किसी के साथ साझा नहीं करेंगे, जब तक कि कानून द्वारा स्पष्ट रूप से ऐसा करने की आवश्यकता न हो। यह हमेशा संभव है कि आपका डेटा हमारी अनुमति के बिना लिया जाए ('डेटा उल्लंघन')। अगर हमें पता चलता है कि ऐसा हुआ है, तो हम आपके द्वारा हमारे साथ साझा किए गए ईमेल का उपयोग करके आपको सूचित करेंगे कि ऐसा हुआ है।",
                    "$~• हम आपके ईमेल पते के माध्यम से आपसे तब तक संपर्क नहीं करेंगे, जब तक कि आप 1) कोई खाता परिवर्तन न करें जिसके लिए हमें ऐसा करना आवश्यक हो, 2) आप स्पष्ट रूप से हमसे संपर्क करने की सहमति न दें, या 3) उपरोक्त डेटा उल्लंघन के मामले में।",
                    "$~• हम प्लेटफ़ॉर्म पर परियोजनाओं का विश्लेषण कर सकते हैं ताकि यह समझ सकें कि हर कोई क्या बना रहा है और वे इसे कैसे बना रहे हैं। हम इन एकत्रित, अनाम अंतर्दृष्टि को अकादमिक प्रकाशनों में साझा कर सकते हैं। हम यह केवल संस्थागत समीक्षा बोर्ड की देखरेख में करेंगे, जैसा कि अमेरिकी संघीय कानून द्वारा अनिवार्य है।",
                    "$~अंत में, भाषण के बारे में एक नोट। आप इस प्लेटफ़ॉर्म पर *निजी* रूप में जो चाहें कह सकते हैं। प्रोजेक्ट डिफ़ॉल्ट रूप से निजी होते हैं, और यदि आप उन्हें विशिष्ट ईमेल पतों के साथ साझा करते हैं, तो भी उन्हें निजी माना जाता है। हम निजी प्रोजेक्ट में कुछ भी मॉडरेट नहीं करेंगे।",
                    "$~लेकिन किसी प्रोजेक्ट को *सार्वजनिक* करना, या उसे किसी सार्वजनिक गैलरी में शामिल करना, एक विशेषाधिकार है। यह प्यार, पुष्टि, सम्मान और गरिमा के लिए बनाया गया एक मंच है। इसलिए, हम उम्मीद करते हैं कि आपकी कोई भी *सार्वजनिक* सामग्री:"
                ],
                "consequences": [
                    "$~अगर हमें कोई ऐसा प्रोजेक्ट या गैलरी मिलती है जो इन नियमों का उल्लंघन करती है, तो हम क्रिएटर्स को इसे देखने से पहले चेतावनी देंगे या इसे देखने से रोक देंगे। अगर आप बार-बार इन नियमों का उल्लंघन करते हैं, तो आप सार्वजनिक रूप से पोस्ट करने का विशेषाधिकार खो देंगे।"
                ]
            },
            "donate": {
                "header": "$~दान करें",
                "prompt": "$~बैंडविड्थ के भुगतान और छात्र एवं शिक्षक योगदानकर्ताओं को मुआवजा देने में हमारी सहायता करें।",
                "content": [
                    "$~वर्डप्ले एक निःशुल्क, समुदाय-आधारित परियोजना है जिसे <यूनिवर्सिटी ऑफ़ वाशिंगटन@https://washington.edu> द्वारा समर्थन प्राप्त है। हम उन लोगों के उपहारों पर निर्भर हैं जो सुलभ, भाषा-समावेशी, शैक्षिक प्रोग्रामिंग भाषाओं के हमारे मिशन में विश्वास करते हैं।",
                    "$~हमारी वर्तमान लागतें इस प्रकार हैं:",
                    "$~• हम यूनिवर्सिटी ऑफ वाशिंगटन के स्नातक छात्रों को, खास तौर पर उन छात्रों को जो विकलांग हैं या जिनकी पहली भाषा अंग्रेजी नहीं है, परियोजना को विकसित करने और बनाए रखने के लिए मुआवज़ा देते हैं। यह हमारी लागत का लगभग 90% है।",
                    "$~• हम उन शिक्षकों को वजीफा देते हैं जिनके साथ हम बहुभाषी, सुलभ पाठ्यक्रम विकसित करने में सहयोग करते हैं।",
                    "$~• हम Google को <Firebase@https://firebase.google.com/> बैंडविड्थ और स्टोरेज, और <Workspace@https://workspace.google.com/> सेवाओं के लिए भुगतान करते हैं।",
                    "$~• हम डोमेन के लिए <Squarespace@https://www.squarespace.com/> को सालाना भुगतान करते हैं।",
                    "$~हमारी वर्तमान लागत, जिसमें शैक्षणिक वर्ष (36 सप्ताह) के दौरान 5 स्नातक छात्रों को $20 USD//घंटा, 10 घंटे//सप्ताह तथा ग्रीष्मकाल (12 सप्ताह) के दौरान 2 स्नातक छात्रों को शामिल किया गया है, तथा क्लाउड सेवाओं को शामिल किया गया है, लगभग $60K USD प्रति वर्ष है।",
                    "$~यदि 2,400 लोग प्रति वर्ष 25 अमेरिकी डॉलर दें, तो इससे हमारी वर्तमान लागत पूरी हो जाएगी, तथा अतिरिक्त राशि का उपयोग अधिक छात्रों और शिक्षकों को मुआवजा देने में किया जाएगा।",
                    "$~क्या आप उन 2,400 लोगों में से एक हो सकते हैं? अगर हाँ, तो यहाँ हमारा वाशिंगटन विश्वविद्यालय का लिंक दिया गया है:"
                ]
            },
            "teach": {
                "header": "$~पढ़ाना",
                "prompt": {
                    "none": "$~स्वागत है शिक्षक! छात्र खातों और प्रोजेक्ट गैलरी को सेट अप और प्रबंधित करने के लिए एक कक्षा बनाएं।",
                    "some": "$~स्वागत है शिक्षक! अपनी कक्षाएं प्रबंधित करें या नई कक्षा बनाएँ।"
                },
                "error": {
                    "offline": "$~हम आपकी शिक्षक स्थिति की जांच करने में सक्षम नहीं हैं।",
                    "login": "$~कक्षाओं का प्रबंधन करने के लिए आपको लॉग इन होना होगा।",
                    "teacher": "$~कक्षाएँ बनाने और प्रबंधित करने के लिए आपको शिक्षक विशेषाधिकारों की आवश्यकता है। यह फ़ॉर्म भरें और आइए एक-दूसरे को जानें!"
                },
                "link": {
                    "request": "$~शिक्षक विशेषाधिकारों का अनुरोध करें",
                    "new": "$~एक क्लास बनाएं"
                }
            },
            "newclass": {
                "header": "$~नई कक्षा",
                "subheader": {
                    "class": "$~आपकी कक्षा",
                    "students": "$~आपके छात्र",
                    "credentials": "$~उपयोगकर्ता नाम और पासवर्ड",
                    "submit": "$~जमा करना"
                },
                "prompt": {
                    "start": "$~अपनी कक्षा के सभी छात्रों के लिए जेनरेट अकाउंट के साथ एक कक्षा बनाना और आपको गैलरी बनाने की अनुमति देना, जिसमें आपके सभी छात्र प्रोजेक्ट जोड़ सकते हैं। यदि छात्रों के पास पहले से ही अकाउंट हैं, तो आप उन्हें बाद में जोड़ सकते हैं।",
                    "review": "$~हमारे द्वारा बनाए गए उपयोगकर्ता नाम और पासवर्ड की समीक्षा करें। क्या आप आगे बढ़ने से पहले उन्हें *संपादित* करना चाहते हैं? अगर आप ऐसा करते हैं, तो आप ऊपर दी गई छात्र जानकारी को संपादित नहीं कर पाएँगे।",
                    "ready": "$~जब आप ऊपर दिए गए क्रेडेंशियल जनरेट करने के लिए तैयार हों, तो हमें बताएं। ऐसा करने के बाद आप उन्हें संपादित कर सकते हैं।",
                    "pending": "$~उपयोगकर्ता नाम और पासवर्ड तैयार किया जा रहा है...",
                    "submit": "$~सबमिट करने के लिए तैयार हैं? जैसे ही यह सफल होगा, आपको इस जानकारी का एक डाउनलोड प्राप्त होगा। पासवर्ड *पुनर्प्राप्त करने योग्य नहीं* हैं, इसलिए उन्हें कहीं सुरक्षित रखें।",
                    "submitting": "$~उपरोक्त उपयोगकर्ता नाम और पासवर्ड के साथ नए खाते का अनुरोध...",
                    "download": "$~आपकी कक्षा तैयार है! आपको अपने डाउनलोड फ़ोल्डर में अपने छात्र डेटा का डाउनलोड दिखाई देना चाहिए। *पासवर्ड पुनर्प्राप्त करने योग्य नहीं हैं*, इसलिए इस फ़ाइल को कहीं सुरक्षित रखें!"
                },
                "field": {
                    "name": {
                        "description": "$~कक्षा का नाम",
                        "placeholder": "$~एक छोटा नाम"
                    },
                    "description": {
                        "description": "$~विवरण",
                        "placeholder": "$~आपके और आपके विद्यार्थियों के लिए आपकी कक्षा का विवरण।"
                    },
                    "existing": {
                        "label": "$~खाताधारक छात्र",
                        "prompt": "$~क्या आपके कुछ छात्रों के पास पहले से ही वर्डप्ले अकाउंट हैं? उन्हें यहाँ शामिल करें।"
                    },
                    "metadata": {
                        "description": "$~छात्र जानकारी",
                        "placeholder": "$~उदाहरणार्थ, छात्र आईडी, परिवार का नाम, दिया गया नाम",
                        "prompt": "$~क्या आप छात्रों के लिए नए खाते बनाना चाहते हैं? छात्रों के बारे में *कोई भी जानकारी* प्रदान करें, एक पंक्ति में एक, अल्पविराम से अलग करके। यह पारिवारिक नाम, दिए गए नाम, छात्र संख्या या अन्य विशिष्ट विवरण हो सकते हैं। हम इसका उपयोग उपयोगकर्ता नाम बनाने के लिए करेंगे जिन्हें आप नीचे संपादित कर सकते हैं, जिससे आपको शिक्षार्थियों के साथ उपयोगकर्ता नाम जोड़ने में मदद मिलेगी।"
                    },
                    "words": {
                        "description": "$~पासवर्ड में उपयोग करने योग्य शब्द",
                        "placeholder": "$~उदाहरणार्थ, बिल्ली बिंदु चूहा...",
                        "prompt": "$~कम से कम *25 शब्द* प्रदान करें यादृच्छिक रूप से 2-3 शब्दों का यादगार पासवर्ड बनाएँ। ऐसे शब्द चुनें जिन्हें आपके छात्र जानते हों या उनसे शब्दों पर विचार-विमर्श करने को कहें। जितना यादृच्छिक होगा उतना सुरक्षित होगा!"
                    },
                    "generate": {
                        "label": "$~उत्पन्न",
                        "tip": "$~उपरोक्त जानकारी के आधार पर उपयोगकर्ता नाम और पासवर्ड बनाएं।"
                    },
                    "edit": {
                        "label": "$~संपादन करना",
                        "tip": "$~उत्पन्न छात्र जानकारी को संपादित करें"
                    },
                    "submit": {
                        "label": "$~क्लास बनाएं",
                        "tip": "$~इस जानकारी के साथ एक नया वर्ग बनाएं."
                    }
                },
                "error": {
                    "duplicates": "$~छात्र सूचना में डुप्लिकेट प्रविष्टियाँ हैं।",
                    "columns": "$~सुनिश्चित करें कि प्रत्येक छात्र के पास कॉलमों की संख्या समान हो।",
                    "generate": "$~अद्वितीय उपयोगकर्ता नाम बनाने में असमर्थ.",
                    "taken": "$~ऊपर दिए गए एक या अधिक उपयोगकर्ता नाम लिए गए हैं",
                    "limit": "$~आप एक समय में 35 से अधिक विद्यार्थियों की कक्षा नहीं बना सकते।",
                    "words": "$~कम से कम 25 शब्द बताएं।",
                    "account": "$~कुछ खाते बनाने में असमर्थ.",
                    "generic": "$~हम क्लास नहीं बना सके। डेवलपर्स को यह पता लगाने में मदद करने के लिए यहां कुछ जानकारी दी गई है कि क्या गलत हुआ।"
                }
            },
            "class": {
                "header": "$~कक्षा",
                "subheader": {
                    "teachers": "$~शिक्षक",
                    "students": "$~छात्र",
                    "galleries": "$~दीर्घाओं"
                },
                "prompt": {
                    "gallery": "$~अपनी कक्षा के लिए असाइनमेंट या प्रोजेक्ट आयोजित करने के लिए एक गैलरी बनाएँ। प्रोजेक्ट पर सभी शिक्षक गैलरी क्यूरेटर होंगे और सभी छात्र गैलरी निर्माता होंगे।",
                    "delete": "$~इस कक्षा को हटाने से कक्षा के बारे में जानकारी स्थायी रूप से हट जाएगी, लेकिन इसकी परियोजनाएं, गैलरी या छात्र खाते नहीं हटेंगे।"
                },
                "field": {
                    "name": {
                        "description": "$~कक्षा का नाम",
                        "placeholder": "$~नाम"
                    },
                    "description": {
                        "description": "$~कक्षा का विवरण",
                        "placeholder": "$~विवरण"
                    },
                    "newteacher": {
                        "placeholder": "$~ईमेल या उपयोगकर्ता का नाम",
                        "description": "$~उस निर्माता का ईमेल या उपयोगकर्ता नाम जिसे आप इस कक्षा तक शिक्षक की पहुँच देना चाहते हैं"
                    },
                    "addteacher": "$~इस कक्षा में एक शिक्षक जोड़ें",
                    "delete": {
                        "tip": "$~इस क्लास को हमेशा के लिए हटा दें.",
                        "label": "$~इस वर्ग को हटाएँ"
                    }
                },
                "error": {
                    "notfound": "$~हम यह कक्षा नहीं ढूंढ सके या आपके पास इसे देखने की अनुमति नहीं है।"
                }
            }
        },
        "edit": {
            "node": "$~$1$2[, प्रकार $2|]",
            "before": "$~$1 से पहले[$1|अंत]",
            "inside": "$~$1 में, $2[$2|आरंभ] और $3[$3|अंत] के बीच",
            "between": "$~$1 और $2 के बीच",
            "line": "$~$1[$1|start] और $2[$2|end] के बीच खाली पंक्ति",
            "conflicts": "$~$1 विवाद",
            "assign": "$~/$2[शामिल होने के लिए उत्सुक|छोड़ने पर विचार करता है]…/",
            "append": "$~/डालने को उत्सुक…/",
            "remove": "$~/छोड़ने पर विचार करता है…/",
            "replace": "$~/अंदर आना चाहता है…/",
            "wrap": "$~कोष्ठक में रखना",
            "unwrap": "$~खोलना",
            "bind": "$~इस अभिव्यक्ति को नाम दें"
        },
        "template": {
            "unwritten": "$~टीबीडी",
            "unparsable": "$~अनपर्सेबल टेम्पलेट: $1"
        },
        "collaborate": {
            "label": "$~सहयोग",
            "role": {
                "owner": "$~मालिक",
                "collaborators": "$~सहयोगियों",
                "curators": "$~क्यूरेटर"
            },
            "field": {
                "message": {
                    "description": "$~सबमिट करने के लिए चैट संदेश",
                    "placeholder": "$~संदेश लिखें"
                }
            },
            "button": {
                "submit": {
                    "label": "$~भेजना",
                    "tip": "$~अपने सहयोगियों को संदेश भेजें"
                },
                "start": {
                    "label": "$~चैट शुरू करें",
                    "tip": "$~अपने आप से या दूसरों से चर्चा शुरू करें।"
                },
                "delete": "$~यह संदेश हटाएँ"
            },
            "error": {
                "unowned": "$~इस प्रोजेक्ट का कोई स्वामी नहीं है, इसलिए इस पर चैट नहीं हो सकती।",
                "offline": "$~यह चैट लोड करने में असमर्थ.",
                "empty": "$~कोई संदेश नहीं.",
                "deleted": "$~यह संदेश हटा दिया गया."
            },
            "prompt": {
                "solo": "$~आपस में चैट करें या किसी सहयोगी को जोड़ें, जो संपादन और चैट कर सके।",
                "owner": "$~सहयोगी इस परियोजना को संपादित कर सकते हैं और इसके बारे में बातचीत कर सकते हैं।",
                "collaborator": "$~आप एक सहयोगी हैं। आप इस प्रोजेक्ट को संपादित कर सकते हैं और इसके बारे में बातचीत कर सकते हैं।",
                "curator": "$~आप इस प्रोजेक्ट की गैलरी के क्यूरेटर हैं। आप इस प्रोजेक्ट को संपादित कर सकते हैं और इसके बारे में बातचीत कर सकते हैं।"
            }
        },
        "checkpoints": {
            "label": {
                "now": "$~अब",
                "history": "$~पुनर्स्थापित करना",
                "restore": "$~यह इस परियोजना का पिछला संस्करण है।",
                "ago": "$~$1 $2 पहले"
            },
            "button": {
                "clear": "$~हिस्ट्री हटाएं",
                "select": "$~इस संस्करण को देखें",
                "checkpoint": "$~परियोजना के इस संस्करण को सहेजें",
                "back": "$~पिछले संस्करण पर वापस जाएँ",
                "forward": "$~अगले संस्करण पर वापस जाएँ",
                "restore": "$~इस संस्करण को पुनर्स्थापित करें",
                "now": "$~वर्तमान संस्करण पर वापस लौटें"
            }
        }
    },
    "moderation": {
        "warning": {
            "header": "$~चेतावनी",
            "explanation": "$~मॉडरेटर ने निर्णय लिया कि यह सामग्री:"
        },
        "blocked": {
            "header": "$~अवरोधित",
            "explanation": "$~मॉडरेटर ने निर्णय लिया कि यह सामग्री:"
        },
        "unmoderated": {
            "header": "$~टिप्पणी",
            "explanation": "$~इस सामग्री को अभी तक मॉडरेट नहीं किया गया है। हो सकता है:"
        },
        "moderate": {
            "header": "$~मध्यम",
            "explanation": "$~इस प्रोजेक्ट की समीक्षा करें और तय करें कि क्या इसकी सामग्री निम्नलिखित में से कोई भी कार्य करती है। अगर ऐसा है, तो सामग्री को चेतावनी दी जाएगी या ब्लॉक कर दिया जाएगा। अगर आप अनिश्चित हैं तो आप इसे छोड़ सकते हैं।"
        },
        "flags": {
            "violence": "$~किसी के प्रति हिंसा, नुकसान या आत्म-क्षति के लिए उकसाना, प्रोत्साहित करना या जश्न मनाना।",
            "dehumanization": "$~किसी व्यक्ति या समूह को उसकी नस्ल, जातीयता, राष्ट्रीय मूल, जाति, लैंगिक रुझान, लिंग, धर्म, आयु, योग्यता या रूप-रंग के आधार पर अमानवीय बनाना।",
            "disclosure": "$~अन्य लोगों के बारे में निजी जानकारी जैसे नाम, संपर्क जानकारी या भौतिक पते का खुलासा करना",
            "misinformation": "$~झूठी, भ्रामक, धोखाधड़ी या हेरफेर करने वाली जानकारी शामिल करें"
        },
        "progress": "$~*$1* मॉडरेट किया गया, *$2* शेष",
        "button": {
            "submit": {
                "tip": "$~इन मॉडरेशन सेटिंग्स को सहेजें",
                "label": "$~बचाना"
            },
            "skip": {
                "tip": "$~इस परियोजना को छोड़ें",
                "label": "$~छोडना"
            }
        }
    },
    "gallery": {
        "games": {
            "name": "$~खेल",
            "description": "$~शब्दों और प्रतीकों के साथ इंटरैक्टिव खेल।"
        },
        "visualizations": {
            "name": "$~दृश्यावलोकन",
            "description": "$~पाठ के माध्यम से दृश्यावलोकन।"
        },
        "motion": {
            "name": "$~गति",
            "description": "$~गति और टकराव के उदाहरण."
        },
        "av": {
            "name": "$~ऑडियो/वीडियो",
            "description": "$~इनपुट के रूप में वॉल्यूम, पिच और वीडियो का उपयोग करना।"
        },
        "tools": {
            "name": "$~औजार",
            "description": "$~सरल उपयोगिताएँ और अनुप्रयोग."
        }
    }
}
