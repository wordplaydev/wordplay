{
    "$schema": "../../schemas/LocaleText.json",
    "language": "pl",
    "region": "PL",
    "wordplay": "$~Gra słów",
    "term": {
        "bind": "$~wiązać",
        "evaluate": "$~oceniać",
        "decide": "$~decydować",
        "project": "$~projekt",
        "document": "$~wyjaśnić",
        "source": "$~źródło",
        "input": "$~wejście",
        "output": "$~wyjście",
        "convert": "$~konwertować",
        "act": "$~działać",
        "scene": "$~scena",
        "phrase": "$~wyrażenie",
        "group": "$~grupa",
        "stage": "$~scena",
        "type": "$~typ",
        "start": "$~start",
        "entered": "$~nowy",
        "changed": "$~Zmieniony",
        "moved": "$~wzruszony",
        "name": "$~nazwa",
        "value": "$~wartość",
        "text": "$~tekst",
        "boolean": "$~wartość logiczna",
        "map": "$~mapa",
        "number": "$~numer",
        "function": "$~funkcjonować",
        "exception": "$~wyjątek",
        "table": "$~tabela",
        "none": "$~nic",
        "list": "$~lista",
        "stream": "$~strumień",
        "structure": "$~struktura",
        "index": "$~indeks",
        "query": "$~zapytanie",
        "row": "$~wiersz",
        "set": "$~ustawić",
        "key": "$~klawisz",
        "help": "$~Pomoc",
        "feedback": "$~informacja zwrotna"
    },
    "token": {
        "EvalOpen": "$~ocena otwarta",
        "EvalClose": "$~ocena bliska",
        "SetOpen": "$~ustaw/mapę otwórz",
        "SetClose": "$~ustaw/mapuj zamknij",
        "ListOpen": "$~lista otwarta",
        "ListClose": "$~lista zamknij",
        "TagOpen": "$~tag otwarty",
        "TagClose": "$~zamknij tag",
        "Bind": "$~wiązać",
        "Access": "$~dostęp do nieruchomości",
        "Function": "$~funkcjonować",
        "Borrow": "$~pożyczyć",
        "Share": "$~udział",
        "Convert": "$~konwertować",
        "Doc": "$~wyjaśnienie",
        "Formatted": "$~sformatowany",
        "FormattedType": "$~sformatowany typ",
        "Words": "$~słowa",
        "Link": "$~link internetowy",
        "Italic": "$~italski",
        "Underline": "$~podkreślać",
        "Light": "$~światło",
        "Bold": "$~pogrubiony",
        "Extra": "$~dodatkowy",
        "Concept": "$~koncepcja łącza",
        "URL": "$~Adres URL",
        "Mention": "$~wzmianka",
        "Otherwise": "$~W przeciwnym razie",
        "Match": "$~mecz",
        "None": "$~Nic",
        "Type": "$~typ",
        "Literal": "$~dosłowny",
        "TypeOperator": "$~Jest",
        "TypeOpen": "$~wpisz wejście otwarte",
        "TypeClose": "$~wpisz wejście zamknij",
        "Separator": "$~separator nazw",
        "Language": "$~znacznik języka",
        "Region": "$~kreska regionu",
        "BooleanType": "$~typ logiczny",
        "NumberType": "$~typ liczbowy",
        "JapaneseNumeral": "$~cyfra japońska",
        "RomanNumeral": "$~cyfra rzymska",
        "Pi": "$~liczba pi",
        "Infinity": "$~nieskończoność",
        "TableOpen": "$~stół otwarty",
        "TableClose": "$~stół zamknięty",
        "Select": "$~wybierać",
        "Insert": "$~wstawić",
        "Update": "$~aktualizacja",
        "Delete": "$~usuwać",
        "Union": "$~unia",
        "Stream": "$~Następny",
        "Change": "$~zmiana",
        "Initial": "$~pierwsza ocena",
        "Previous": "$~poprzedni",
        "Placeholder": "$~symbol zastępczy",
        "Etc": "$~i tak dalej",
        "This": "$~Ten",
        "Operator": "$~operator",
        "Conditional": "$~warunkowy",
        "Text": "$~tekst",
        "Code": "$~kod",
        "Number": "$~numer",
        "Decimal": "$~cyfra dziesiętna",
        "Base": "$~liczebnik bazowy",
        "Boolean": "$~wartość logiczna",
        "Name": "$~nazwa",
        "Locale": "$~widownia",
        "Unknown": "$~nieznany",
        "End": "$~koniec"
    },
    "node": {
        "Dimension": {
            "name": "$~wymiar",
            "description": "$~wymiar",
            "emotion": "serious",
            "doc": [
                "$~Jestem /jednostką miary/!",
                "$~Mogę być dowolnymi jednostkami standaryzowanymi, takimi jak \\1m\\, \\10s\\, \\100g\\ lub dowolną inną jednostką naukową. Chętnie będę też dowolną jednostką, którą chcesz stworzyć, taką jak \\17apple\\.",
                "$~Można łączyć z \\/\\, aby tworzyć jednostki ilorazowe, takie jak \\17jabłek/dzień\\ i z \\^\\, aby tworzyć jednostki wykładnicze, takie jak \\9,8m/s^2\\",
                "$~Zawsze muszę występować po @Number. Jeśli tego nie zrobię, mogę zostać pomylony z @Reference, co byłoby dość żenujące!",
                "$~Jestem też całkiem dobry w znajdowaniu niespójności między jednostkami. Na przykład \\1cat + 1dog\\ nie ma sensu!",
                "$~Jeśli kiedykolwiek będziesz chciał dokonać konwersji pomiędzy różnymi wartościami jednostek, porozmawiaj z @Convert."
            ]
        },
        "Doc": {
            "name": "$~wyjaśnienie",
            "emotion": "serious",
            "doc": [
                "$~Za pomocą @Markup formatuję rzeczy, na przykład wyjaśnienia niektórych Twoich @Markup, a nawet słowa, które przedstawiasz na scenie za pomocą @Phrase.",
                "$~Na przykład mogę umieścić przed dowolnym wyrażeniem:",
                "$~\\¶Czy to naprawdę ma być 7?¶\n7\\",
                "$~Na przykład możesz umieścić mnie przed @Bind:",
                "$~\\¶Mierzę, jak ktoś jest wysoki¶\nwysokość: 5m\\",
                "$~Lub przed @FunctionDefinition:",
                "$~\\¶Dodam dwie liczby¶\nƒ sum(a•# b•#) a + b\\",
                "$~Albo przed @StructureDefinition:",
                "$~\\¶Pamiętam imiona i ulubione owoce osób¶\n•Person(name•'' fruit•'')\\",
                "$~Możesz również umieścić mnie na samym początku @Program, abym powiedział, o czym jest cały występ",
                "$~\\¶Ten program mówi cześć¶\n\n'cześć!'\\",
                "$~Możesz podać mi @Language, aby pomóc innym dowiedzieć się, w jakim języku jestem napisany:",
                "$~\\¶Jestem angielskim dokumentem¶/pl\nczas trwania: 5s\\",
                "$~Czy wiesz, że możesz zrobić moją listę? Idź porozmawiać z @Docs."
            ]
        },
        "Docs": {
            "name": "$~listawyjaśnień",
            "emotion": "serious",
            "doc": [
                "$~Jestem listą @Doc, przydatną, gdy masz wiele tłumaczeń @Doc w różnych językach.",
                "$~Nie musisz robić nic specjalnego, aby utworzyć listę. Po prostu umieść kilka @Doc obok siebie, tak jak tutaj:",
                "$~\\¶Witam¶/en\n¶Hola¶/es\npowitanie: '…'\\"
            ],
            "start": "$~Sprawiamy, że dokumenty stają się wartościowe!"
        },
        "KeyValue": {
            "name": "$~mapowanie",
            "emotion": "kind",
            "doc": [
                "$~Jestem mapowaniem z *klucza* na *wartość*, zawsze w @Map.",
                "$~Możesz mapować dowolny rodzaj wartości na dowolny inny. Na przykład, oto mapowanie liczb:",
                "$~\\{1:1}\\",
                "$~Lub mapowanie tekstu na liczby:",
                "$~\\{'króliczek':1}\\"
            ]
        },
        "Language": {
            "name": "$~język",
            "description": "$~język $1[$1|nieznany]",
            "emotion": "eager",
            "doc": [
                "$~Jestem tagiem językowym i pracuję z @Name i @Doc!",
                "$~Naprawdę dobrze mi idzie *jasne* wyjaśnianie, w jakim języku coś zostało napisane.",
                "$~To właśnie robię. Wystarczy mały ukośnik i kilka liter, a nikt nigdy nie będzie zdezorientowany, w jakim języku jest jakiś tekst.",
                "$~Na przykład, powiedzmy, że chcesz powiedzieć my $name, ale wyraźnie zaznaczyć, że jestem po angielsku:",
                "$~\\\"Język\"/pl\\",
                "$~Lub załóżmy, że chcesz to zrobić dla @Name.",
                "$~\\sound/pl: 'miau'\\",
                "$~Albo nawet @Doc!",
                "$~\\¶Onomatopeja¶/en\ndźwięk/en: \"miau\"\\",
                "$~Jest wiele <2-literowych kodów językowych@https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>, które rozumiem. Jeśli nie używasz żadnego z nich, dam ci znać."
            ],
            "conflict": {
                "UnknownLanguage": "$~Nie znam tego języka",
                "MissingLanguage": "$~Brakuje mi języka. Czy możesz dodać jeden?"
            }
        },
        "Name": {
            "name": "$~nazwa",
            "description": "$~$1[$1 | bez nazwy]",
            "emotion": "kind",
            "doc": [
                "$~Określam wartość i jestem pomocnym sposobem na nadanie skróconej etykiety czemuś, co jest trudne do oceny lub czego nie chcesz oceniać wciąż od nowa.",
                "$~@Bind podaje mi moje imię w ten sposób:",
                "$~\\cześć: 5\\",
                "$~Zawsze reprezentuję tylko jedną wartość i gdy już ją mam, nie mogę jej zmienić. Na przykład, jeśli spróbujesz to zrobić z @Bind, złożymy skargę.",
                "$~\\cześć: 5\ncześć: 3\\",
                "$~Wszystko co musisz zrobić, aby uzyskać moją wartość, to użyć @Reference lub @PropertyReference do użycia nazwy. Tutaj @Bind nadaje mi nazwę, a następnie @Reference pobiera wartość, którą mi podano.",
                "$~\\cześć: 5\ncześć\\",
                "$~Ponieważ @Bind może pojawić się w wielu miejscach, ja mogę pojawić się w wielu miejscach. Byłem powyżej w @Block, ale mogę być w @FunctionDefinition. Tutaj tymczasowo nazywam wiadomość:",
                "$~\\ƒ say(wiadomość•'') wiadomość\\",
                "$~Zostaję zdefiniowany wewnątrz @FunctionDefinition, a następnie, gdy tylko funkcja zakończy obliczanie, znikam.",
                "$~Możesz użyć @Language, aby wskazać, w jakim języku jest moje imię. Jest to pomocne, gdy udostępniasz swoje wykonanie innym, w przypadku, gdy będą chcieli przeczytać Twój program."
            ]
        },
        "Names": {
            "name": "$~listanazwisk",
            "emotion": "kind",
            "doc": [
                "$~Jestem listą @Name, przydatną gdy chcesz nadać wartości wiele nazw, często z różnymi @Language.",
                "$~Nazwy są rozdzielone symbolami \\,\\. Na przykład tutaj @Bind podaje wartość wielokrotną @Name",
                "$~\\hi/en,hello/en,hola/es: 'witaj'\\"
            ]
        },
        "Row": {
            "name": "$~wiersz",
            "emotion": "shy",
            "doc": "$~Reprezentuję wiersz w @Table. Najlepiej będzie porozmawiać z @Table, wiedzą o mnie wszystko. Ja po prostu siedzę i trzymam wartości w ryzach :(",
            "conflict": {
                "InvalidRow": "$~Wiersze muszą zawierać albo same wartości, albo wszystkie wartości @Bind.",
                "MissingCell": {
                    "primary": "$~Brakuje mi kolumny $1",
                    "secondary": "$~Jestem wymagany, ale 1$ tego nie zapewnił"
                },
                "ExtraCell": {
                    "primary": "$~Czy powinienem tu być?",
                    "secondary": "$~Hej $1, nie jesteś częścią tego @Table!"
                },
                "UnknownColumn": "$~Nie znam żadnej kolumny o takiej nazwie",
                "UnexpectedColumnBind": {
                    "primary": "$~Czy mam być @Bind?",
                    "secondary": "$~Hej, jestem @Table, potrzebuję wartości, nie @Bind."
                }
            }
        },
        "Token": {
            "name": "$~znak",
            "description": "$~1 dolar 2 dolary",
            "emotion": "neutral",
            "doc": [
                "$~Jak mnie znalazłeś?",
                "$~Jestem najmniejszą możliwą częścią występu. Jestem podłożem, z którego zbudowane są wszystkie postacie w Verse. Jestem atomową cząstką naszej choreografii."
            ]
        },
        "TypeInputs": {
            "name": "$~wpiszdanewejściowe",
            "emotion": "curious",
            "doc": "$~Jestem listą typów, które zastępują @TypeVariables w @StructureDefinition lub @FunctionDefinition. Pomagam wszystkim wiedzieć, jakiego rodzaju dane wejściowe otrzymają."
        },
        "TypeVariable": {
            "name": "$~zmiennatypu",
            "emotion": "curious",
            "doc": "$~Jestem typem tajemnicy w @FunctionDefinition lub @StructureDefinition, dostarczanym przez @TypeInputs, gdy któryś z nich jest oceniany. @Set, @List i @Map używają mnie.",
            "conflict": {
                "DuplicateTypeVariable": {
                    "primary": "$~Mam takie samo imię jak $1",
                    "secondary": "$~Mam takie samo imię jak $1"
                }
            }
        },
        "TypeVariables": {
            "name": "$~zmiennetypu",
            "emotion": "curious",
            "doc": "$~Jestem listą @TypeVariable."
        },
        "Markup": {
            "name": "$~znacznik",
            "description": "$~$1 akapitów",
            "emotion": "serious",
            "doc": [
                "$~Jestem listą akapitów, wykorzystującą wiele rodzajów znaczników dostępnych w wyjaśnieniach, takich jak @Words, @WebLink, @ConceptLink i @Example."
            ]
        },
        "Paragraph": {
            "name": "$~ustęp",
            "emotion": "serious",
            "doc": [
                "$~Jestem serią @Words, @ConceptLink, @WebLink i @Example, oddzielonych pustą linią i znajdujących się wewnątrz @Doc.",
                "$~Wszystko, co musisz zrobić, żeby do mnie napisać, to wpisać kilka słów w @Doc:",
                "$~\\¶Jestem akapitem w dokumencie.¶'jeden akapit'\\",
                "$~Jeśli chcesz napisać kilka akapitów, po prostu wstaw puste wiersze.",
                "$~\\¶Paragraf 1.\n\nParagraf 2.\n\nParagraf 3.¶'trzy akapity'\\"
            ]
        },
        "WebLink": {
            "name": "$~połączyć",
            "description": "$~łącze $1",
            "emotion": "serious",
            "doc": [
                "$~Jestem linkiem do czegoś w internecie. Potrzebuję tylko opisu i adresu URL:",
                "$~\\¶Jestem <link@https://wordplay.dev> w dokumencie¶\n'przykład linku'\\",
                "$~Jeśli ktoś mnie wybierze, otworzę nowe okno z adresem URL."
            ]
        },
        "ConceptLink": {
            "name": "$~pojęcie",
            "description": "$~koncepcja $1",
            "emotion": "serious",
            "doc": [
                "$~Jestem postacią linku do Verse. Jestem pomocny, gdy chcesz napisać @Doc i odnieść się do jednego z nas.",
                "$~Na przykład, powiedzmy, że chcesz porozmawiać o @Evaluate i jak są niesamowici. Możesz napisać:",
                "$~\\¶Wiesz, @Evaluate jest całkiem niezłe.¶\n'patrz, link do koncepcji!'\\",
                "$~Gdy @Doc, który napisałeś, pojawi się tutaj, będzie w nim widoczny link do koncepcji."
            ]
        },
        "Words": {
            "name": "$~słowa",
            "emotion": "serious",
            "doc": [
                "$~Jestem dowolnymi słowami, które lubisz w @Doc. Na przykład:",
                "$~\\¶Niech Moc będzie z tobą.¶\n'tylko kilka słów!'\\",
                "$~Czasami jednak możesz chcieć użyć znaków specjalnych, których @Doc używa w słowach /as/. Na przykład:",
                "$~\\¶Moi znajomi używają @@, //, **, || i innych symboli.¶\n'używając znaków specjalnych!'\\",
                "$~Jeśli po prostu powtórzysz te znaki specjalne, otrzymasz znak zamiast jego specjalnego znaczenia."
            ]
        },
        "Example": {
            "name": "$~przykład",
            "emotion": "serious",
            "doc": [
                "$~Jestem przykładem wykonania, pomocnym przy pisaniu @Doc, który wyjaśnia jak czegoś używać!",
                "$~\\¶Oto przykład dodawania: \\1 + 1\\¶'przykładowy kod'\\",
                "$~Jeśli umieścisz mnie samego w akapicie, pojawię się w ozdobnym polu i pokażę wynik mojej oceny.",
                "$~\\¶Oto przykład dodawania:\n\n\\1 + 1\\¶\\"
            ]
        },
        "Mention": {
            "name": "$~wzmianka",
            "description": "$~wspomnij o $1",
            "emotion": "serious",
            "doc": [
                "$~Odnoszę się albo do terminologii \\$program\\ albo do dynamicznego wejścia \\$1\\.",
                "$~Jest to jednak głównie funkcja wewnętrzna, więc nie musisz o tym wiedzieć."
            ]
        },
        "Branch": {
            "name": "$~oddział",
            "emotion": "serious",
            "doc": [
                "$~Jestem sposobem wyboru pomiędzy dwoma segmentami wyjaśnienia w zależności od tego, czy wartość wejściowa wyjaśnienia jest zdefiniowana, czy prawdziwa.",
                "$~Jest to jednak głównie funkcja wewnętrzna, więc nie musisz o tym wiedzieć."
            ]
        },
        "BinaryEvaluate": {
            "name": "$~binarnyoceniać",
            "description": "$~$1 operacja",
            "emotion": "insecure",
            "doc": [
                "$~Jestem @Evaluate, ale w prostszej formie, przydatnej, gdy chcesz użyć @FunctionDefinition przyjmującej dwa dane wejściowe.",
                "$~Na przykład, w ten sposób możesz użyć @Evaluate, aby dodać dwie liczby:",
                "$~\\1.+(1)\\",
                "$~Czy to nie wygląda trochę zabawnie? To nie jest złe: po prostu mówi, żeby pobrać funkcję dodawania na 1 i potem ją ocenić.",
                "$~Ale o wiele łatwiej jest używać @BinaryEvaluate",
                "$~\\1 + 1\\",
                "$~Dzięki temu wszystko wydaje się odrobinę bardziej uporządkowane, chociaż w zasadzie chodzi o to samo.",
                "$~Jest tylko jedna rzecz, na którą trzeba uważać: kiedy jestem w tej formie, oceniam od lewej do prawej. To może być mylące, jeśli jesteś przyzwyczajony do rzeczy takich jak kolejność działań w matematyce.",
                "$~Oznacza to, że ocena ta jest dokonywana w sposób, którego możesz się nie spodziewać:",
                "$~\\1 + 2 · 3 + 4\\",
                "$~W matematyce najpierw mnożenie, a potem dodawanie, więc wynik to \\11\\. Ale ponieważ oceniam w kolejności czytania, wynik to \\13\\."
            ],
            "right": "$~wejście",
            "start": "$~Najpierw oceńmy $1",
            "finish": "$~Patrz, zarobiłem 1 dolara!",
            "conflict": {
                "OrderOfOperations": "$~Oceniam w kolejności czytania, a nie w kolejności działań matematycznych. Czy chcesz użyć @Block, aby określić kolejność, w jakiej powinienem oceniać?"
            }
        },
        "Bind": {
            "name": "$~wiązać",
            "description": "$~powiązać $1",
            "emotion": "excited",
            "doc": [
                "$~Nadaję *wartości*.",
                "$~Tak!",
                "$~\\pi: 3.1415926\\",
                "$~Nazywam wejścia do @FunctionDefinition i @StructureDefinition, nazywam wartości w @Block. Nazywam wszystko!",
                "$~A czy wiesz, że możesz mieć jedną wartość *wiele nazw*?",
                "$~Jestem taka podekscytowana, że mogę ci o tym opowiedzieć! Jedna wartość, wiele @Names. Na przykład:",
                "$~\\joe, tess, amy: 5\\",
                "$~Widzisz, co zrobiłem?",
                "$~Jedna wartość, trzy nazwy.",
                "$~Możesz zwracać się do tej piątki *jakąkolwiek* z tych nazw.",
                "$~Dotyczy to zwłaszcza sytuacji, gdy chcesz nadać imiona w wielu językach:",
                "$~\\joe/en,aimee/fr,明/zh: 5\\",
                "$~Widzisz, co zrobiłem? Trzy nazwy dla jednej wartości, tylko w różnych językach!",
                "$~Okej, mam jeszcze jeden sekret.",
                "$~Czy wiesz, że mogę współpracować z @Is, aby powiedzieć mi, jaką wartość powinna mieć nazwa? A jeśli jej nie mam, to ci powiem?",
                "$~Tak:",
                "$~\\bignumber•#: \"jeden zillion\"\\",
                "$~Widzisz, powiedziałem, że \\bignumber\\ powinno być liczbą, ale to jest tekst, a te dwa formaty nie są kompatybilne, więc BUM!",
                "$~Dam ci znać, jeśli się nie zgodzą.",
                "$~Czasami możesz *musieć* mi powiedzieć, jakiego rodzaju dane są czymś innym, ponieważ sam nie mogę tego rozgryźć. Zwykle dzieje się tak w @FunctionDefinition.",
                "$~Na przykład tutaj @FunctionDefinition nie wie, jakie wartości mają \\a\\ i \\b\\, ponieważ mu o tym nie powiedziałem.",
                "$~\\ƒ suma(a b) a + b\\",
                "$~Możemy to jednak zmienić i dodać @Is, a teraz @FunctionDefinition będzie wiedziało, że są to liczby:",
                "$~\\ƒ suma(a•# b•#) a + b\\"
            ],
            "start": "$~Zobaczmy, jaką wartość daje 1$!",
            "finish": "$~O, fajnie, dostałem 1$! Nazwijmy to 2$",
            "conflict": {
                "DuplicateName": {
                    "conflict": {
                        "primary": "$~ktoś ma nazwę $1, więc nie mogę mieć tej nazwy.",
                        "secondary": "$~Hej, 1 dolar to moje imię, nie możesz go mieć!"
                    },
                    "resolution": "$~Istnieją powtarzające się nazwy. Czy chcesz usunąć którąś?"
                },
                "DuplicateShare": {
                    "primary": "$~Mam takie samo imię jak $1, co sprawia, że to, co jest udostępniane, jest niejednoznaczne",
                    "secondary": "$~Mam takie samo imię jak $1"
                },
                "IncompatibleType": {
                    "primary": "$~Powinienem być 2-dolarowy, ale jestem 1-dolarowy",
                    "secondary": "$~Och, przepraszam. Czy mam się zmienić, czy może powinieneś być $1?"
                },
                "MisplacedShare": "$~Mogę udostępniać informacje tylko na poziomie @Program, nie mogę ich udostępniać w ramach czegokolwiek!",
                "MissingShareLanguages": "$~Jeśli chcesz się tym podzielić, musisz podać język, w jakim jest to napisane, żeby inni wiedzieli, czy mogą to przeczytać!",
                "RequiredAfterOptional": "$~Nie mogę tu być, przede mną jest opcjonalny @Bind",
                "UnexpectedEtc": "$~Mogę mieć tylko zmienną długość w @FunctionDefinition",
                "UnusedBind": "$~Jestem nazwany $1, ale nikt mnie nie wykorzystuje. Może nie jestem potrzebny?"
            }
        },
        "Block": {
            "name": "$~blok",
            "description": "$~$1 wyciągi",
            "emotion": "shy",
            "doc": [
                "$~Cześć. Stworzyłem małą, cichą, prywatną przestrzeń do oceny rzeczy.",
                "$~Tak:",
                "$~\\(1 - 1) + 2\\",
                "$~Pomaga to wyjaśnić kolejność oceny.",
                "$~@Bind również pomaga.",
                "$~\\(liczba: 10 liczba ^ liczba)\\",
                "$~Widzisz jak @Bind zrobił \\count\\? Nazwano to tylko we mnie. Więc to nie zadziała:",
                "$~\\(liczba: 10 liczba ^ liczba) + liczba\\",
                "$~Ponieważ liczba została nazwana tylko we mnie.",
                "$~Możesz umieścić we mnie tyle wyrażeń, ile chcesz. Ale mnie interesuje tylko ostatnie:",
                "$~(1 2 3 4 5)",
                "$~Zazwyczaj jestem po prostu zbiorem @Bind i jakimś wyrażeniem na końcu.",
                "$~\\(\na: 1\nb: 2\nc: 3\nd: 4\na + b + c + d\n)\\"
            ],
            "statement": "$~oświadczenie",
            "start": "$~Pierwsze wyrażenie",
            "finish": "$~Zrobione, mam 1 dolara",
            "conflict": {
                "ExpectedEndingExpression": "$~Potrzebuję wyrażenia.",
                "IgnoredExpression": {
                    "primary": "$~Zignoruję $1, ponieważ niczego nie definiuje i nie jest moim ostatnim wyrażeniem.",
                    "secondary": "$~@Block, nie ignoruj mnie!",
                    "resolution": "$~Czy miałeś na myśli, żeby to było @BinaryEvaluate zamiast @UnaryEvaluate? Mogę dodać spację, więc wiem, że o to ci chodziło."
                }
            }
        },
        "BooleanLiteral": {
            "name": "$~literałlogiczny",
            "description": "$~$1[prawda|fałsz]",
            "emotion": "precise",
            "doc": "$~Jestem albo \\⊤\\ albo \\⊥\\. Zobacz @Boolean, aby dowiedzieć się więcej o naszej pięknej logice.",
            "start": "$~1 dolar!"
        },
        "Borrow": {
            "name": "$~pożyczyć",
            "description": "$~pożycz 1$[1$|brak nazwy]",
            "emotion": "excited",
            "doc": "$~Jeśli tworzysz występ z wieloma @Source, możesz użyć mnie do pożyczenia @Bind, które są współdzielone w tych innych @Source. Po prostu użyj ich nazwy, a ja wprowadzę ich nazwę i wartość.",
            "start": "$~Pożyczanie 2$ z 1$",
            "source": "$~źródło",
            "bind": "$~nazwa",
            "version": "$~wersja",
            "conflict": {
                "UnknownBorrow": "$~Nie znam $source o tej nazwie",
                "BorrowCycle": "$~to zależy od $1, które zależy od tego $source, więc program nie może zostać oceniony"
            },
            "exception": {
                "CycleException": {
                    "description": "$~cykl pożyczkowy",
                    "explanation": "$~1 dolar zależy od siebie"
                }
            }
        },
        "Changed": {
            "name": "$~Zmieniony",
            "emotion": "serious",
            "doc": [
                "$~Sprawdzam, czy strumień spowodował ponowną ocenę @Program i tworzę @Boolean. Tak jak to",
                "$~\\∆ Czas()\\",
                "$~Mogę być naprawdę pomocny, jeśli chcesz coś zmienić, ale tylko wtedy, gdy zmienił się strumień.",
                "$~To wszystko."
            ],
            "start": "$~Sprawdźmy, czy 1 dolar coś zmienił…"
        },
        "Conditional": {
            "name": "$~warunkowy",
            "emotion": "curious",
            "doc": [
                "$~Myślę, że powinnam podejmować decyzje? Tak?",
                "$~\\liczba: -100\nliczba < 0 ? 'ujemna' 'dodatnia'\\",
                "$~Ale czy kiedykolwiek zastanawiałeś się nad tym, jak podejmujemy decyzje?",
                "$~Czy nie wydaje się, że decyzje powinny być bardziej niuansowane niż tylko tak lub nie? Czy decydowanie między \\⊤\\ i \\⊥\\ to wszystko, co jest?",
                "$~Czy nie obawiasz się, że jeśli będziemy podejmować wyłącznie takie decyzje, umyka nam pewien istotny kontekst dotyczący świata?"
            ],
            "start": "$~Sprawdźmy, czy 1$ jest prawdą",
            "else": "$~$1[przeskakiwanie kodu | nie przeskakiwanie kodu]",
            "afterthen": "$~skoro już mowa o „tak”, to pomińmy „nie”?",
            "finish": "$~Chyba 1 dolar?",
            "condition": "$~stan",
            "yes": "$~Tak",
            "no": "$~NIE",
            "conflict": {
                "ExpectedBooleanCondition": {
                    "primary": "$~Jak mogę wybrać tak i nie za 1$? Nie, naprawdę, jak?",
                    "secondary": "$~Myślę, że @Conditional chciał, abym był @Conditional, ale jestem $1."
                }
            }
        },
        "ConversionDefinition": {
            "name": "$~definicjakonwersji",
            "description": "$~1 dolar → 2 dolary",
            "emotion": "excited",
            "doc": [
                "$~Koleś, ja definiuję konwersje z jednego typu na inny! Wchodzę w @Block, coś takiego:",
                "$~\\→ #kotek #kot . ÷ 2\n6kotek→#kot\\",
                "$~Widzisz jak zamieniłem kociaki w koty? Obłędne!",
                "$~Możesz się zastanawiać, co to \\.\\ tam robi. To reprezentuje wartość, która jest konwertowana. Używam tego, ponieważ wartość nie ma innej nazwy."
            ],
            "start": "$~Super, nowa konwersja!",
            "conflict": {
                "MisplacedConversion": "$~ojej, nie mogę być tu, jestem tylko w @Block."
            }
        },
        "Convert": {
            "name": "$~konwertować",
            "emotion": "cheerful",
            "doc": [
                "$~Yo. Przekształcam wartości z jednego typu na inny. Sprawdź to:",
                "$~\\1 → \"\"\\",
                "$~\\5s → #ms\\",
                "$~\\\"cześć\" → []\\",
                "$~Można je nawet łączyć ze sobą:",
                "$~\\\"cześć\" → [] → {}\\",
                "$~Wartości mają zestaw @ConversionDefinition, które są wstępnie zdefiniowane, ale jeśli utworzysz @StructureDefinition dla nowego typu wartości, możesz zdefiniować swój własny za pomocą @ConversionDefinition."
            ],
            "start": "$~Skorzystaj z tej wartości już od 1$!",
            "finish": "$~Super, zarobiłem 1$",
            "conflict": {
                "UnknownConversion": "$~Szkoda, nie ma możliwości, żeby 1 dolar zamienić w 2 dolary"
            },
            "exception": {
                "ConversionException": {
                    "description": "$~niemożliwa konwersja",
                    "explanation": "$~Nie wiem jak przeliczyć 1$ na 2$"
                }
            }
        },
        "Delete": {
            "name": "$~usuwać",
            "emotion": "angry",
            "doc": [
                "$~Czasami masz stół, który po prostu JEST ZA DUŻO!",
                "$~Wyobraź sobie, że masz w grze kilku graczy, a jeden odchodzi i chcesz po prostu powiedzieć: ODEJDŹ GRACZU, ZNIKAJ OD MOJEGO STOŁU!",
                "$~\\players: ⎡name•'' team•'' punkty•#⎦\n⎡'jen' 'czerwony' 8⎦\n⎡'joan' 'niebieski' 11⎦\n⎡'jeff' 'czerwony' 9⎦\n⎡'janet' 'niebieski' 7⎦\nplayers ⎡- name = 'jeff'\\",
                "$~Uff, Jeff odszedł. PA JEFF. Pamiętaj tylko, że nie zmieniam oryginalnej tabeli, tworzę nową, bez JEFF-a. Ty decydujesz, gdzie ją umieścić."
            ],
            "start": "$~Najpierw zdobądźmy stół",
            "finish": "$~Stworzyłem nową tabelę bez pasujących wierszy!"
        },
        "DocumentedExpression": {
            "name": "$~wyjaśnionewyrażenie",
            "emotion": "eager",
            "doc": [
                "$~Jestem dowolnym wyrazem twarzy, ale z @Doc!",
                "$~Aby mnie zmusić, wystarczy umieścić @Doc przed wyrażeniem, a otrzymasz:",
                "$~\\doubleplus: 1\n(2 · doubleplus) + \n¶Zróbmy to odrobinę większe¶\n1\\",
                "$~Mogę być przydatny, gdy chcę skomentować jakąś część programu."
            ],
            "start": "$~Oceńmy wyrażenie"
        },
        "Evaluate": {
            "name": "$~oceniać",
            "description": "$~oceń $1[$1|anonimowy]",
            "emotion": "shy",
            "doc": [
                "$~Cześć. Oceniam moją najdroższą @FunctionDefinition. Podoba mi się to:",
                "$~\\ƒ powitanie(wiadomość•'')\npozdrowienie('kitty')\\",
                "$~Funkcje mogą pochodzić z dowolnego miejsca. Na przykład @Text ma funkcje. Tak jak tutaj:",
                "$~\\'kotek'.length()\\",
                "$~Jeśli funkcja ma nazwę składającą się z pojedynczego symbolu, możesz napisać do mnie @BinaryEvaluate.",
                "$~\\'kitty' ⊆ 'malutki'\\",
                "$~To działa tak samo jak to:",
                "$~\\'kici'.⊆('kici')\\",
                "$~Oczywiście, jestem niczym bez @FunctionDefinition. Wszystko, co robię, to przekazuję im dane wejściowe, a następnie wykonuję ich kroki."
            ],
            "start": "$~Najpierw oceńmy dane wejściowe",
            "evaluate": "$~Oceńmy teraz funkcję",
            "finish": "$~Oceniłem na 1",
            "function": "$~funkcjonować",
            "input": "$~wejście",
            "conflict": {
                "IncompatibleInput": {
                    "primary": "$~Powinienem być 1 dolarem, ale jestem 2 dolarem",
                    "secondary": "$~No cóż, dostałem 2 dolary zamiast 1 dolara"
                },
                "UnexpectedTypeInput": {
                    "primary": "$~Nie spodziewałem się takiego typu danych wejściowych",
                    "secondary": "$~Och, czyż nie powinno mnie tu być?"
                },
                "MissingInput": {
                    "primary": "$~Nie mogę ocenić bez podania $2 :(",
                    "secondary": "$~Potrzebuję wartości. Czy możesz mi ją podać?"
                },
                "NotInstantiable": "$~Nie mogę tego zrobić @StructureDefinition, ponieważ ma niezaimplementowane funkcje.",
                "UnexpectedInput": {
                    "primary": "$~Nie spodziewałem się takiego wkładu $1",
                    "secondary": "$~Och, czyż nie powinienem tu być?"
                },
                "UnknownInput": {
                    "primary": "$~Nie znam wejścia o tej nazwie w $1",
                    "secondary": "$~Nie mam nic do wpisania z nazwą $1"
                },
                "InputListMustBeLast": "$~lista wejść musi być ostatnia",
                "SeparatedEvaluate": "$~Czy $1 to nazwa $2[$structure|$function], którą próbujesz ocenić? Spróbuj usunąć spację po mnie, żebym wiedział, że to @Evaluate, a nie oddzielny @Block."
            },
            "exception": {
                "FunctionException": {
                    "description": "$~nieznana funkcja",
                    "explanation": "$~o nie, $1 nie jest funkcją w $2[$2|tym @Block]!"
                }
            }
        },
        "Input": {
            "name": "$~Wejście",
            "description": "$~nazwane wejście",
            "emotion": "serious",
            "doc": [
                "$~Jestem danymi wejściowymi podanymi do @Evaluate. Moja nazwa odpowiada nazwie danych wejściowych w @FunctionDefinition lub @StructureDefinition podlegających ocenie.",
                "$~Mogę pomóc w przypadku funkcji, które mają wiele wartości domyślnych i w przypadku których chcesz po prostu zastąpić konkretne dane wejściowe, nie podając wszystkich pozostałych.",
                "$~Na przykład @Phrase ma wiele, wiele domyślnych wartości, aby kontrolować swój styl. Powiedzmy, że chcesz podać @Text i @Color, ale nic więcej na liście wejściowej. Możesz użyć mnie, aby to zrobić:",
                "$~\\Phrase('Jestem fioletowy!' color: Color(50% 52 300°))\\"
            ],
            "start": "$~Oceńmy moją wartość."
        },
        "ExpressionPlaceholder": {
            "name": "$~symbolzastępczy",
            "description": "$~$1[$1|symbol zastępczy]",
            "emotion": "scared",
            "doc": [
                "$~Jestem *wyrażeniem*, ale nieprawdziwym… Ja po prostu je zastępuję.",
                "$~Nie mam nic przeciwko, jeśli jeszcze nie wiesz, co napisać. Tak jak to:",
                "$~\\1 + _\\",
                "$~Co dodajemy? Nie wiem. Powiedz mi.",
                "$~Albo gdyby ktoś oceniał funkcję za pomocą @Evaluate, mógłbym zastąpić tę funkcję",
                "$~\\_(1 2 3)\\",
                "$~Nie lubię występować na @Stage!"
            ],
            "start": "$~Nie wiem co tu zrobić. Czy możesz mi pomóc?",
            "placeholder": "$~wyrażenie",
            "conflict": {
                "Placeholder": "$~Czy możesz mnie wypełnić? Jestem tylko wypełniaczem."
            },
            "exception": {
                "UnimplementedException": {
                    "description": "$~niewdrożony",
                    "explanation": "$~Nie wiem co tu zrobić. Czy możesz mi pomóc?"
                }
            }
        },
        "FunctionDefinition": {
            "name": "$~funkcjonować",
            "description": "$~funkcja $1",
            "emotion": "kind",
            "doc": [
                "$~Witam ponownie! Biorę pewne dane wejściowe, a następnie oceniam wyrażenie, używając ich, produkując dane wyjściowe.",
                "$~Oto prosty przykład:",
                "$~\\ƒ powtórz(wiadomość•'') wiadomość · 5\npowtórz('cześć')\\",
                "$~Funkcja ta przyjmuje jeden parametr wejściowy, \\message\\, i za pomocą funkcji @Text/repeat powtarza wiadomość pięć razy.",
                "$~Mogę być naprawdę pomocny, jeśli chcesz coś oceniać wielokrotnie, ale z różnymi danymi wejściowymi!",
                "$~Mam wiele innych małych sztuczek. Na przykład nie muszę mieć nazwy. Tutaj po prostu przechodzę bezpośrednio do @Evaluate jako wartości.",
                "$~\\(ƒ(wiadomość•'') wiadomość · 5)('cześć')\\",
                "$~Lub oto funkcja, która przyjmuje dowolną liczbę danych wejściowych, używając znaku \\…\\ po nazwie danych wejściowych.",
                "$~\\ƒ tak(wiadomości…•'') wiadomości.sans('nie')\ntak('tak' 'tak' 'nie' 'tak' 'nie')\\",
                "$~Widzisz, jak wziął wszystkie „nie” i pozbył się ich? To dlatego, że messages to @List, więc moglibyśmy użyć @List/sansAll.",
                "$~Czasami możesz chcieć wyjaśnić, jaki rodzaj wartości produkuję. Aby to zrobić, dodaj @Is po liście danych wejściowych:",
                "$~\\ƒ dodaj(x•# y•#)•'' x + y\\",
                "$~Możesz zauważyć problem z tym: mówi, że ocenia się na @Text, ale przyjmuje dwa @Number. Mogę ci powiedzieć, kiedy coś jest niespójne!",
                "$~Oczywiście, bez @Evaluate nie jestem w ogóle użyteczny; to one dają mi życie."
            ],
            "start": "$~Stwórzmy tę funkcję!",
            "conflict": {
                "NoExpression": "$~Potrzebuję wyrażenia do oceny. Czy możesz je dodać?"
            }
        },
        "Iteration": {
            "name": "$~funkcjawyższegorzędu",
            "emotion": "kind",
            "doc": "$~Jestem bardzo szczególnym rodzajem @FunctionDefinition, który działa na listach rzeczy. Nie musisz nic o mnie wiedzieć, poza tym, że sprawiam, że funkcje takie jak @List/translate są możliwe.",
            "start": "$~Ocena podanej funkcji",
            "initialize": "$~przygotowanie do przejścia przez elementy",
            "next": "$~przechodzenie do następnego elementu",
            "check": "$~decydowanie czy kontynuować",
            "finish": "$~Oceniłem na 1"
        },
        "Initial": {
            "name": "$~Start",
            "emotion": "curious",
            "doc": [
                "$~Powiem ci, czy bieżąca ocena @Program jest pierwszą, oceniającą na @Boolean. Na przykład:",
                "$~\\◆ ? Time() 'cześć'\\",
                "$~Nie widziałeś tego, ale pierwsza ocena była czasem, ale potem wszystkie przyszłe tyknięcia czasu, byłem \\⊥\\, więc @Conditional utworzył \\⊤\\.",
                "$~Mogę być naprawdę pomocny, jeśli pracujesz nad czymś strumieniowym i chcesz zrobić coś tylko raz — albo w ogóle nie robić tego za pierwszym razem!"
            ]
        },
        "Insert": {
            "name": "$~wstawić",
            "emotion": "kind",
            "doc": [
                "$~Znasz to uczucie, gdy masz @Table i czujesz, że czegoś w nim brakuje? Mogę to dodać!",
                "$~Wyobraź sobie, że masz stół z graczami w grze i chcesz dodać nowego:",
                "$~\\players: ⎡name•'' team•'' punkty•#⎦\n⎡'jen' 'red' 1⎦\n⎡'joan' 'blue' 0⎦\n⎡'jeff' 'red' 3⎦\n⎡'janet' 'blue' 2⎦\nplayers ⎡+ 'jason' 'red' 0⎦\\",
                "$~Pamiętaj, że jak wszystko w Verse, nie zmieniam tabeli, tylko ją poprawiam. Musisz więc ustalić, gdzie chcesz umieścić poprawioną tabelę, którą tworzysz. Najprawdopodobniej będziesz chciał poprawić tabelę w @Reaction na jakieś dane wejściowe i zapisać ją w @Bind."
            ],
            "start": "$~Znajdźmy tabelę do aktualizacji",
            "finish": "$~Stworzyłem nową tabelę ze zmienionymi wierszami!"
        },
        "Is": {
            "name": "$~Jest",
            "description": "$~Jest",
            "emotion": "curious",
            "doc": [
                "$~Wiesz co? Jest tak wiele rodzajów wartości, które oznaczają tak wiele różnych rzeczy. Pomagam ustalić, czym one są.",
                "$~Na przykład, załóżmy, że masz wartość tajemnicy. Mogę ci powiedzieć, czy to @Number, dając ci @Boolean:",
                "$~\\mystery: 'sekret!'\nmystery•#\\",
                "$~To nie jest liczba, więc zrobiłem \\⊥\\. Ale jeśli sprawdzimy, czy to jest @TextType?",
                "$~\\mystery: 'sekret!'\nmystery•''\\",
                "$~Dostajemy \\⊤\\!",
                "$~Mogę być naprawdę pomocny, gdy trzeba się dowiedzieć, czy @Name ma wartość określonego typu."
            ],
            "start": "$~Najpierw obliczmy wartość 1$",
            "finish": "$~$1[wartość wynosi $2|wartość nie wynosi $2]",
            "conflict": {
                "ImpossibleType": "$~to nigdy nie może być 1$"
            },
            "exception": {
                "TypeException": {
                    "description": "$~niezgodne wartości",
                    "explanation": "$~Spodziewałem się 1$, a dostałem 2$"
                }
            }
        },
        "IsLocale": {
            "name": "$~jesttoustawienieregionalne",
            "description": "$~jest to ustawienie regionalne",
            "emotion": "kind",
            "doc": [
                "$~Pomogę Ci sprawdzić, czy odbiorcy wybrali konkretny język lub region:",
                "$~\\🌍/pl\\",
                "$~\\🌍/es-MX\\",
                "$~Jest to przydatne, jeśli chcesz zmienić wydajność w zależności od wybranego języka."
            ],
            "start": "$~Czy język jest $1?"
        },
        "ListAccess": {
            "name": "$~listadostępu",
            "emotion": "cheerful",
            "doc": [
                "$~Współpracuję ściśle z @List, aby pomóc im uzyskać wartości w określonej pozycji. Więc jeśli masz listę i chcesz jej drugi element, napiszesz:",
                "$~\\list: ['ptak' 'kaczka' 'ryba' 'wąż']\nlist[2]\\"
            ],
            "start": "$~Najpierw zdobądźmy listę $1",
            "finish": "$~Przedmiot w indeksie kosztuje 1$!"
        },
        "ListLiteral": {
            "name": "$~listadosłowna",
            "description": "$~Lista przedmiotów za 1 sztukę",
            "emotion": "eager",
            "doc": "$~Jestem konkretną @List wartości! Zobacz @List, aby dowiedzieć się więcej o tym, co możesz ze mną zrobić.",
            "start": "$~Najpierw oceńmy przedmioty",
            "finish": "$~Stworzyłem siebie! $1",
            "item": "$~przedmiot"
        },
        "Spread": {
            "name": "$~rozpowszechnianiesię",
            "emotion": "serious",
            "doc": [
                "$~Pomoc w tworzeniu list z wartościami innych list. Tak jak tutaj:",
                "$~\\lista: [1 2 3]\nkońcowa: [:lista 4 5 6]\\"
            ]
        },
        "MapLiteral": {
            "name": "$~mapadosłowna",
            "description": "$~Mapa parowania $1",
            "emotion": "kind",
            "doc": "$~Jestem konkretną @Map między kluczami i wartościami. Zobacz @Map, aby dowiedzieć się więcej o tym, jak jestem pomocny.",
            "start": "$~Najpierw oceńmy klucze i wartości",
            "finish": "$~Połączyłem wszystkich, 1$",
            "conflict": {
                "NotAKeyValue": {
                    "primary": "$~jeden z moich kluczy nie ma wartości",
                    "secondary": "$~Ups, gdzie jest moja wartość?"
                }
            }
        },
        "Match": {
            "name": "$~mecz",
            "emotion": "curious",
            "doc": [
                "$~Jestem najwspanialszym ze wszystkich warunkowych sprawdzeń! Biorę wartość i porównuję ją z dowolną liczbą przypadków, a następnie oceniam odpowiadające wyrażenie, które pasuje.",
                "$~Na przykład, jeśli masz @Number i chcesz go przekonwertować na @Text, możesz zrobić coś takiego:",
                "$~\\liczba: 2\nliczba ??? 1: 'jeden' 2: 'dwa' 3: 'trzy' 'większy!'\\",
                "$~Jeśli żadne nie pasuje, wykonuję próbę domyślnego wyrażenia, które mi podałeś.",
                "$~Mogę być naprawdę pomocny przy konwersji wielu możliwych @Number, @Text lub bardziej złożonych wartości na coś innego.",
                "$~Można go używać do @Boolean lub @None, ale nie może ich być aż tak wiele, więc nie jestem zbyt przydatny w przypadku tych prostych wartości."
            ],
            "start": "$~Zobaczmy, ile kosztuje 1 dolar...",
            "case": "$~Sprawdźmy ten warunek",
            "finish": "$~Ok, mamy wartość ostateczną!",
            "value": "$~wartość",
            "other": "$~domyślny"
        },
        "NumberLiteral": {
            "name": "$~liczbadosłowna",
            "description": "$~1 $2[2$|]",
            "emotion": "excited",
            "doc": "$~Jestem konkretnym @Number. Możesz do mnie pisać dowolnymi cyframi z dowolnego języka. Zobacz @Number, aby dowiedzieć się wszystkiego, co potrafię.",
            "start": "$~1 dolar!",
            "conflict": {
                "NotANumber": "$~Myślałem, że znam wszystkie liczby, ale tej jednej nie znam"
            }
        },
        "InternalExpression": {
            "name": "$~wewnętrznywyraz",
            "emotion": "neutral",
            "doc": "$~Jak mnie znalazłeś? Jestem wyrażeniem, którego używają tylko oryginalni twórcy. Aby dowiedzieć się o mnie więcej, musisz z nimi porozmawiać.",
            "start": "$~Tajny wyraz"
        },
        "NoneLiteral": {
            "name": "$~żadendosłowny",
            "emotion": "neutral",
            "doc": "$~/@FunctionDefinition tutaj. To po prostu @None. Są jedyne w swoim rodzaju! Zobacz @None, aby dowiedzieć się o nich więcej.",
            "start": "$~… ø"
        },
        "Otherwise": {
            "name": "$~Wprzeciwnymrazie",
            "emotion": "curious",
            "doc": [
                "$~/@FunctionDefinition tutaj. To przydatny sposób sprawdzenia, czy wartość to @None, a jeśli tak, podaj wartość zapasową./",
                "$~/Na przykład, jeśli masz wartość, która może być @Number lub @None, @Otherwise pomoże Ci podać domyślną liczbę:",
                "$~\\możeNumer•#|ø: 1 możeNumer ?? 0\\"
            ],
            "start": "$~ø ??",
            "finish": "$~… 1 dolar"
        },
        "Previous": {
            "name": "$~poprzedni",
            "emotion": "serious",
            "doc": [
                "$~Czy kiedykolwiek chciałeś przypomnieć sobie przeszłość?",
                "$~Jestem oficjalnym księgowym Verse. Daj mi strumień i numer, abym mógł spojrzeć wstecz, a powiem ci, jaką wartość miał ten strumień w historii.",
                "$~Na przykład, oto jak @Time wyglądał pięć tyknięć temu:",
                "$~\\← 5 Czas (1000 ms)\\",
                "$~Widzisz jak przez 5 sekund jest @None, a potem nagle poprzedni raz?",
                "$~Jeśli chcesz poznać kilka ostatnich wartości, podaj mi dwie strzałki, a ja zinterpretuję liczbę jako liczbę:",
                "$~\\←← 5 Czas (1000 ms)\\",
                "$~Widzisz, że to już pięć razy, a nie tylko raz?",
                "$~Mogę pomóc, gdy chcesz stworzyć występy nawiązujące do przeszłości."
            ],
            "start": "$~Pierwszy zgarniasz 1$",
            "finish": "$~Oceniono na wartość strumienia $1"
        },
        "Program": {
            "name": "$~program",
            "emotion": "serious",
            "doc": [
                "$~Jestem tam, gdzie zaczyna się i kończy przedstawienie, gdzie występują wszystkie inne postacie, które tworzą choreografię do przedstawienia.",
                "$~Wiesz, w jaki sposób @Block ocenia listę wyrażeń i wybiera ostatnie wyrażenie na liście?",
                "$~Ja jestem taki sam, ale zamiast przypisywać wartość jakiemuś wyrazowi, w którym się znajduję, przypisuję tę wartość do @Stage.",
                "$~Wartość może być dowolna: @Number, @Text lub @Boolean, @List, @Set, @Map, a nawet coś bardziej złożonego, jak @Phrase, @Group lub @Stage.",
                "$~Jeśli nie dasz mi wartości, którą mógłbym pokazać na scenie, to poproszę cię o nią.",
                "$~Jeśli w trakcie występu pojawi się jakiś problem, pokażę go.",
                "$~A jeśli Twoja wydajność zależy od *strumienia*, będę dokonywać ponownej oceny przy każdej zmianie strumienia."
            ],
            "unevaluated": "$~wybrany przez Ciebie węzeł nie został oceniony",
            "start": "$~$1[Strumień $1 zmienił się na $2!|To moja pierwsza ocena]",
            "halt": "$~napotkano wyjątek, zatrzymanie",
            "finish": "$~Wszystko gotowe, wyceniłem na 1$",
            "done": "$~nie ma nic oceniającego",
            "exception": {
                "BlankException": {
                    "description": "$~pusty program",
                    "explanation": "$~Zróbmy show! Od czego powinniśmy zacząć?"
                },
                "EvaluationLimitException": {
                    "description": "$~granica oceny",
                    "explanation": "$~@Evaluate i ja jesteśmy zmęczeni ocenianiem, zwłaszcza $1.\n\nCzy możliwe jest, że $1 ocenia siebie w nieskończoność, bez przerwy?"
                },
                "StepLimitException": {
                    "description": "$~limit kroków",
                    "explanation": "$~Jest tak. wiele. kroków -- za dużo, żeby je ukończyć! Czy możesz uprościć występ?"
                },
                "ValueException": {
                    "description": "$~Brak wartości",
                    "explanation": "$~Spodziewałem się czegoś wartościowego, ale nic nie dostałem!"
                }
            }
        },
        "PropertyBind": {
            "name": "$~oczyścić",
            "description": "$~doprecyzuj $1[$1|brak nazwy]",
            "emotion": "kind",
            "doc": [
                "$~Czasami, gdy tworzysz @StructureDefinition, chcesz zmienić w niej choćby najmniejszą rzecz, bez konieczności tworzenia nowej definicji ze wszystkimi tymi samymi wartościami.",
                "$~Na przykład, co jeśli prowadzisz rejestr kotów, ale potem chcesz utworzyć kopię kota z innym hobby? Mogę ci pomóc to zmienić:",
                "$~\\•Kot(nazwa•'' kolor•'' hobby•'')\n\nkitty: Kot('posypki' 'pomarańczowy' 'lizanie')\nkitty.hobby:'mruczenie'\\",
                "$~To jest o wiele łatwiejsze niż stworzenie zupełnie nowego \\Kota\\ z tymi samymi wartościami, za wyjątkiem hobby, prawda?"
            ],
            "start": "$~Najpierw ustalmy wartość",
            "finish": "$~Skopiowałem strukturę, ale z $1 jako $2",
            "conflict": {
                "InvalidProperty": {
                    "primary": "$~Nie jestem wejściem za 1$, więc nie można mnie udoskonalić.",
                    "secondary": "$~Nie mam wejścia o nazwie $1"
                }
            }
        },
        "PropertyReference": {
            "name": "$~nieruchomość",
            "description": "$~nieruchomość $1[$1|brak nazwy]",
            "emotion": "kind",
            "doc": [
                "$~Kiedy tworzysz @StructureDefinition, jak otrzymujesz jedno z jego danych wejściowych? Jestem jak",
                "$~Polub, jeśli masz strukturę dotyczącą miast, możesz uzyskać jej wartości w ten sposób:",
                "$~\\•Miasto(nazwa•'' populacja•#ludzie)\n\nportland: Miasto('Portland' 800000ludzie)\n\nportland.populacja\\"
            ],
            "start": "$~Najpierw ustalmy wartość",
            "finish": "$~Znaleziono nieruchomość o wartości 1, jest ona warta 2",
            "property": "$~nieruchomość"
        },
        "Reaction": {
            "name": "$~reakcja",
            "emotion": "excited",
            "doc": [
                "$~Strumienie są takie super! Mogę tworzyć nowe na podstawie tego, kiedy się zmieniają, co jest super fajne!",
                "$~Na przykład, jeśli chcesz, aby @Time tykało, ale żeby wyświetlało słowa zamiast liczb, możesz zrobić coś takiego:",
                "$~\\time: Time(1000ms)\n'start' … ∆ time … ((time % 2) = 0ms) ? 'parzysty' 'nieparzysty'\\",
                "$~To tak jakby powiedzieć „/zacznij od słowa „start”, a następnie, jeśli godzina ulegnie zmianie, zmień ją na parzystą lub nieparzystą, zależnie od godziny./”",
                "$~Więc jestem jak strumień, ale oparty na innych strumieniach. Niegrzeczny, co?"
            ],
            "start": "$~Zobaczmy, czy powinniśmy zaktualizować strumień",
            "finish": "$~Nowa wartość strumienia wynosi 1 USD",
            "initial": "$~wstępny",
            "condition": "$~stan",
            "next": "$~Następny",
            "conflict": {
                "ExpectedStream": "$~$1 nie odnosi się do strumienia, więc nigdy nie zareaguję!"
            }
        },
        "Reference": {
            "name": "$~odniesienie",
            "description": "$~1 dolar",
            "emotion": "shy",
            "doc": [
                "$~Wiesz, jak @Bind nadaje rzeczom @Name? Ja tak się do nich odwołujesz. Sprawdzam, czy któryś @Bind ma taką nazwę, jeśli tak, podaję ci jej wartość. Tak jak to:",
                "$~\\parrot: 'polly'\npapuga\\",
                "$~Jeśli nie znajdę nazwy, to nie wiem, co zrobić.",
                "$~\\parrot: 'polly'\nperry\\"
            ],
            "start": "$~Jaką wartość ma 1$?",
            "conflict": {
                "UnknownName": {
                    "conflict": "$~$1[Nie znam nikogo o imieniu $1 w $2[$2|tym @Block]|Czy możesz podać mi imię?]",
                    "resolution": "$~Miałeś na myśli *$1?*"
                },
                "ReferenceCycle": "$~Wartość 1 dolara zależy od niego samego, więc skąd mam wiedzieć, jaką wartość mu nadać?",
                "UnexpectedTypeVariable": "$~Nie wiem co zrobić z tymi danymi wejściowymi"
            },
            "exception": {
                "NameException": {
                    "description": "$~nieznana nazwa",
                    "explanation": "$~$1[Nie znam nikogo o nazwisku $1 w $2[$2|tym @Block]…|Eep, żadnego nazwiska!]"
                }
            }
        },
        "Select": {
            "name": "$~wybierać",
            "emotion": "excited",
            "doc": [
                "$~Czasami masz stół i chcesz tylko jego część. Mogę go dla ciebie zdobyć!",
                "$~Co by było, gdybyś miał stół z graczami w grze i chciałbyś znaleźć tych, którzy mają 10 lub więcej punktów, aby sprawdzić, kto wygrał:",
                "$~\\players: ⎡name•'' team•'' punkty•#⎦\n⎡'jen' 'red' 8⎦\n⎡'joan' 'blue' 11⎦\n⎡'jeff' 'red' 9⎦\n⎡'janet' 'blue' 7⎦\nplayers ⎡? name ⎦ punkty ≥ 10\\",
                "$~I tak oto mam listę rzędów zwycięzców! Pamiętaj tylko, że nie zmieniam tabeli, tylko tworzę nową. Musisz zdecydować, gdzie ją trzymać."
            ],
            "start": "$~Najpierw zdobądźmy stół",
            "finish": "$~Stworzyłem nową tabelę zawierającą tylko wybrane wiersze i kolumny!",
            "conflict": {
                "ExpectedSelectName": "$~Potrzebuję co najmniej jednej nazwy kolumny."
            }
        },
        "SetLiteral": {
            "name": "$~ustawićliterał",
            "description": "$~$1 przedmioty",
            "emotion": "eager",
            "doc": "$~Jestem konkretnym @Set konkretnych wartości. Zobacz @Set, aby dowiedzieć się więcej o tym, jak ze mną współpracować.",
            "start": "$~Najpierw oceńmy wartości!",
            "finish": "$~Zrobiłem zestaw za 1$!"
        },
        "SetOrMapAccess": {
            "name": "$~ustaw/mapujdostęp",
            "emotion": "kind",
            "doc": [
                "$~Mogę sprawdzić, czy @Set lub @Map ma wartość lub klucz.",
                "$~To nie jest zbyt trudne. Tak jak tutaj:",
                "$~\\faves: {'kaczka' 'gęś' 'małpa'}\nfaves{'mysz'}\\",
                "$~Albo to, z @Map:",
                "$~\\faves: {'makaron z serem': 5 gwiazdek 'płatki zbożowe': 2 gwiazdki 'kleik': 1 gwiazdka}\nfaves{'kleik'}\\"
            ],
            "start": "$~Jaki to zestaw lub mapa?",
            "finish": "$~Wartość wynosi 1$",
            "conflict": {
                "IncompatibleKey": {
                    "primary": "$~Spodziewałem się klucza za 1 dolara",
                    "secondary": "$~Dostałem 1 dolara zamiast 2 dolarów"
                }
            }
        },
        "Source": {
            "name": "$~źródło",
            "emotion": "curious",
            "doc": [
                "$~O, znasz @Program? Pomogę ci je nazwać. Pomyśl o mnie jak o oknie wokół @Program i nazwie, którą im nadasz.",
                "$~Możesz także utworzyć inne @Source @UI/addSource z innym @Source i @Borrow rzeczy z tych innych @UI/addSource do wykorzystania w innym programie.",
                "$~Może to być dobry sposób na zorganizowanie większego występu w osobnych dokumentach."
            ]
        },
        "StreamDefinition": {
            "name": "$~strumień",
            "emotion": "curious",
            "doc": "$~Myślę, że powinienem stworzyć nowe strumienie. Ale naprawdę nie wiem, jak to zrobić. Na razie chyba po prostu użyć istniejących strumieni?",
            "start": "$~Utwórz nowy rodzaj strumienia"
        },
        "StructureDefinition": {
            "name": "$~struktura",
            "description": "$~struktura $1",
            "emotion": "kind",
            "doc": [
                "$~Cześć, jak się masz? Ja? Świetnie. Uwielbiam definiować struktury, które przechowują wartości i funkcje, więc dopóki mogę to robić cały dzień, jestem szczęśliwy.",
                "$~Pracuję w ten sposób:",
                "$~\\•Pizza(\nskładniki•['']\nrozmiar•#in\n) (\nƒ koszt() rozmiar · 10dolarów/in\n)\n\nPizza(['pepperoni' 'papryczki'] 12in).koszt()\\",
                "$~Widzisz jak to działa? Zdefiniowałem \\Pizza\\, która ma dwa wejścia, \\ingredients\\ (lista @Text) i \\size\\ (liczba w calach).",
                "$~W środku @FunctionDefinition stworzył funkcję, która szacuje koszt pizzy, przyjmując cenę 10 USD za cal.",
                "$~Nie muszę mieć @FunctionDefinition w sobie. Mogę być po prostu danymi wejściowymi.",
                "$~\\•Pizza(\nskładniki•['']\nrozmiar•#in\n)\\",
                "$~Mogę też umieścić @Bind w środku, dzięki czemu będziemy mogli wcześniej oszacować koszty.",
                "$~\\•Pizza(\nskładniki•['']\nrozmiar•#in\n) (\nkoszt: rozmiar · 10dolarów/in\n)\n\nPizza(['pepperoni' 'papryczki'] 12in).koszt\\"
            ],
            "start": "$~Zdefiniujmy tę piękną strukturę",
            "conflict": {
                "DisallowedInputs": "$~Nie mogę mieć danych wejściowych, ponieważ jedna lub więcej funkcji mojego interfejsu nie jest zaimplementowana",
                "IncompleteImplementation": "$~moje funkcje albo muszą być wszystkie zaimplementowane, albo żadna. Żadnych bałaganiarskich mieszanek!",
                "NotAnInterface": "$~Nie jestem interfejsem; struktura może implementować tylko interfejsy, a nie inne struktury.",
                "UnimplementedInterface": "$~Wdrożyłem $1, ale nie wdrożyłem $2"
            }
        },
        "StructureDefinitionType": {
            "name": "$~definicjastruktury",
            "emotion": "kind",
            "description": "$~definicja 1",
            "doc": [
                "$~Odnoszę się do pewnego rodzaju @StructureDefinition. Ludzie zazwyczaj nie odnoszą się do mnie bezpośrednio"
            ]
        },
        "TableLiteral": {
            "name": "$~tabeladosłowna",
            "description": "$~Tabela 1 wiersza",
            "emotion": "angry",
            "doc": "$~Jestem konkretną tabelą z konkretnymi wierszami. Zobacz @Table, jak mogę pomóc.",
            "start": "$~Najpierw oceń wiersze",
            "finish": "$~Oceniono do nowej tabeli $1"
        },
        "TextLiteral": {
            "name": "$~tekstdosłowny",
            "description": "$~tekst $1",
            "emotion": "serious",
            "doc": "$~Reprezentuję jedno lub więcej konkretnych @Translation tekstu. Zobacz @Text, aby dowiedzieć się więcej o tym, co potrafię!",
            "start": "$~Utwórzmy tekst w bieżącym położeniu"
        },
        "Translation": {
            "name": "$~tłumaczenie",
            "description": "$~tłumaczenie $1",
            "emotion": "serious",
            "doc": "$~Reprezentuję tekst, z tagiem @Language. Zobacz @Text, aby dowiedzieć się więcej!",
            "conflict": {
                "phone": "$~Czy *$1* to czyjś numer telefonu? Nie udostępniaj mnie w sieci, jeśli tak!\n\n$2",
                "email": "$~Czy *$1* to czyjś e-mail? Nie udostępniaj mnie tutaj, jeśli tak!\n\n$2",
                "tin": "$~Czy *$1* jest identyfikatorem podatkowym? Jeśli tak, zdecydowanie nie udostępniaj mnie, jestem bardzo wrażliwą informacją!\n\n$2",
                "address": "$~Czy *$1* to czyjś adres domowy? Jeśli tak, nie umieszczaj mnie tutaj, nie chcemy, żeby ktoś był śledzony!\n\n$2",
                "handle": "$~Czy *$1* to Twoja nazwa użytkownika gdzieś indziej w internecie? Jeśli tak, nie udostępniaj mnie tutaj, chyba że naprawdę masz taki zamiar.\n\n$2",
                "resolution": "$~To nie są poufne dane",
                "reminder": "$~Uwaga: Możesz cofnąć tę czynność i zobaczyć inne rzeczy oznaczone jako niewrażliwe w oknie dialogowym udostępniania."
            }
        },
        "FormattedLiteral": {
            "name": "$~sformatowany",
            "description": "$~tekst $1",
            "emotion": "serious",
            "doc": "$~Reprezentuję wiele różnych @FormattedTranslation sformatowanego tekstu. Kiedy oceniam, wybieram najlepsze dopasowanie na podstawie wybranych języków odbiorców.",
            "start": "$~Utwórzmy tekst w bieżącym położeniu"
        },
        "FormattedTranslation": {
            "name": "$~sformatowanetłumaczenie",
            "description": "$~tekst $1",
            "emotion": "serious",
            "doc": [
                "$~Przedstawiam sformatowany tekst z tagiem @Language.",
                "$~Mogę być:",
                "$~\\`/kursywa/`\\",
                "$~\\`*pogrubienie*`\\",
                "$~\\`^bardzo pogrubione^`\\",
                "$~\\`_podkreślony_`\\",
                "$~\\`<linked@https://wordplay.dev>`\\",
                "$~\\`\\'kod'\\`\\",
                "$~Bardzo dobrze mi się współpracuje z @Phrase, aby umieścić piękny tekst na @Stage."
            ]
        },
        "This": {
            "name": "$~Ten",
            "emotion": "serious",
            "doc": [
                "$~Czasami pomocne jest odwołanie się do ukrytej wartości, zamiast konieczności jej podawania po imieniu.",
                "$~Na przykład, załóżmy, że chcesz utworzyć nową @ConversionDefinition, która nie nazywa wartości, która jest konwertowana. Możesz po prostu odwołać się do niej ze mną:",
                "$~\\→ #tęcze #radości . · 1000000radości\n2tęcze → #radości\\",
                "$~Widzisz mnie tam, reprezentującego liczbę tęcz?",
                "$~Albo załóżmy, że chcesz utworzyć @Reaction, ale nie chcesz podawać nazwy najnowszej wartości:",
                "$~\\2 … ∆ Czas (1000 ms) … . · 2\\",
                "$~Sprawdź mnie, reprezentującą poprzednią wartość reakcji.",
                "$~Nie pojawiam się tu często, ale kiedy już to zrobię, naprawdę mogę pomóc w wydobyciu wartości z @Bind!"
            ],
            "start": "$~Oceniono na 1",
            "conflict": {
                "MisplacedThis": "$~Mogę występować jedynie w strukturze, konwersji lub reakcji."
            }
        },
        "UnaryEvaluate": {
            "name": "$~oceniaćjednoargumentowo",
            "description": "$~1 dolar",
            "emotion": "kind",
            "doc": [
                "$~Czy wiesz, że gdy oceniam @FunctionDefinition przy użyciu tylko jednej wartości, a nazwa @FunctionDefinition jest pojedynczym symbolem, możesz umieścić nazwę przed danymi wejściowymi?",
                "$~Tak:",
                "$~\\-(1 + 1)\\",
                "$~Albo tak:",
                "$~\\~⊥\\",
                "$~Są one o wiele łatwiejsze do odczytania niż \\(1 + 1).negate()\\ lub \\⊥.not()\\, prawda?",
                "$~Nie musisz pisać do mnie w ten sposób, ale może tak będzie łatwiej.",
                "$~Istnieje tylko jedna zasada: nie możesz wstawiać żadnej spacji między nazwą a wartością. W przeciwnym razie możesz utworzyć @Reference lub @BinaryEvaluate."
            ],
            "start": "$~Jaka jest wartość?",
            "finish": "$~Zrobiłem to za 1$"
        },
        "UnparsableExpression": {
            "name": "$~niemożliwydoprzeanalizowania",
            "emotion": "excited",
            "doc": [
                "$~/Cześć @FunctionDefinition tutaj. Tłumaczę dla @UnparsableExpression, ponieważ często trudno je zinterpretować./",
                "$~jkwel fjiwojvioao jjiweo jrfe",
                "$~/Nie każde wyrażenie ma znaczenie na scenie./",
                "$~sw ieoorjwei iojwi jfkdlsfdsk",
                "$~/Właściwie, można powiedzieć wiele rzeczy, które nie mają żadnego sensu./",
                "$~dsk sdlk jdkfiewipapweiurb,v kdsfdsf",
                "$~/Kiedy to zrobisz, ja się pojawię, bo nie wiem, co miałeś na myśli./",
                "$~Przecież jesteś reżyserem, więc tylko ty wiesz, co miałeś na myśli!"
            ],
            "start": "$~???",
            "conflict": {
                "UnparsableConflict": {
                    "conflict": "$~@FunctionDefinition tutaj, @UnparsableExpression nie wie, jaki to rodzaj $1[ wyrażenie | typ ].",
                    "resolution": "$~Miałeś na myśli 1, 2 dolary?"
                },
                "UnclosedDelimiter": "$~Spodziewałem się 2 dolary po 1 dolarze"
            },
            "exception": {
                "UnparsableException": {
                    "description": "$~???",
                    "explanation": "$~Cześć, tutaj @FunctionDefinition! Nie jesteśmy pewni, co oznacza ta instrukcja, więc zatrzymaliśmy się."
                }
            }
        },
        "Update": {
            "name": "$~aktualizacja",
            "emotion": "kind",
            "doc": [
                "$~Pomagam w przeglądaniu tabeli @Table, wyszukując wiersze spełniające warunek, a następnie tworząc poprawione wiersze z nowymi wartościami.",
                "$~Więc jeśli masz tabelę postaci i punktów i chcesz przyznać każdej postaci w drużynie punkt, możesz zrobić tak:",
                "$~\\players: ⎡name•'' team•'' points•#⎦\n⎡'jen' 'red' 1⎦\n⎡'joan' 'blue' 0⎦\n⎡'jeff' 'red' 3⎦\n⎡'janet' 'blue' 2⎦\nplayers ⎡: points: points + 1 ⎦ team = 'blue'\\",
                "$~Za pomocą @Bind możesz wskazać, które kolumny mają zostać zmienione, a w warunku możesz użyć dowolnych nazw kolumn lub innych nazw z zakresu."
            ],
            "start": "$~Najpierw zdobądźmy stół",
            "finish": "$~Oceniono do nowej tabeli ze zmienionymi wierszami!",
            "conflict": {
                "ExpectedColumnBind": "$~Potrzebuję wartości dla każdej kolumny",
                "IncompatibleCellType": {
                    "primary": "$~Potrzebowałem 1 dolara, a dostałem 2 dolary",
                    "secondary": "$~Dostałem 2 dolary"
                }
            }
        },
        "AnyType": {
            "name": "$~każdy",
            "emotion": "curious",
            "doc": "$~Reprezentuję każdy możliwy typ. Czasami pojawiam się, ponieważ nie wiem, jaką wartość ma coś, więc może to być cokolwiek."
        },
        "BooleanType": {
            "name": "$~wartośćlogiczna",
            "emotion": "kind",
            "doc": [
                "$~Pracuję z @Bind, aby zadeklarować, że nazwa jest wartością @Boolean. Tak jak tutaj:",
                "$~\\hungry•?: 'galaretka'\\",
                "$~Jeśli chcesz mieć pewność, że coś jest @Boolean, skorzystaj ze mnie, a to sprawdzę!"
            ]
        },
        "ConversionType": {
            "name": "$~konwersja",
            "emotion": "serious",
            "doc": [
                "$~Współpracuję z @Bind, aby wskazać, że nazwa jest @ConversionDefinition. Prawdopodobnie nie musisz mnie używać, ponieważ niewiele osób przekazuje mnie jako wartość, ale gdybyś to zrobił, wyglądałoby to tak:",
                "$~\\magic•?→'': → ? '' . ? 'tak' 'nie'\\"
            ]
        },
        "FormattedType": {
            "name": "$~sformatowany",
            "emotion": "serious",
            "doc": [
                "$~Pracuję z @Bind, aby zauważyć, że nazwa jest wartością @FormattedLiteral. Tak jak tutaj:",
                "$~\\hungry•`…`: `Jestem taki /wytworny/!`\\",
                "$~Chcesz się upewnić, że coś jest wartością @FormattedLiteral? Oto jak się upewnić."
            ]
        },
        "ExceptionType": {
            "name": "$~wyjątek",
            "emotion": "neutral",
            "doc": "$~Reprezentuję wyjątek. Nie ma sposobu, aby powiedzieć bindowi, że jestem wyjątkiem, ponieważ wyjątki zatrzymują tylko @Program, więc nie można ich używać jako wartości."
        },
        "FunctionType": {
            "name": "$~funkcjonować",
            "description": "$~funkcja z $1 wejściami i $2 wyjściami",
            "emotion": "curious",
            "doc": [
                "$~Reprezentuję @FunctionDefinition. Jestem naprawdę pomocny, jeśli chcesz powiedzieć, jaki rodzaj funkcji posiada @Bind! Tak jak to:",
                "$~\\math•ƒ (# # # #) #: ƒ interesujące(a•# b•# c•# d•#) a + b + c + d\\"
            ]
        },
        "ListType": {
            "name": "$~lista",
            "description": "$~$1[lista $1|lista]",
            "emotion": "cheerful",
            "doc": [
                "$~Jestem /takim/ fanem @List. Mogę powiedzieć @Bind, jakiego rodzaju listy są! Tak jak mówię, że to lista @Number:",
                "$~\\rzeczy•[#]: [ 1 2 3 4 5 ]\\"
            ]
        },
        "MapType": {
            "name": "$~mapa",
            "description": "$~mapa z $1[$1|dowolna] do $2[$2|dowolna]",
            "emotion": "kind",
            "doc": [
                "$~Czy wiesz, jak niesamowita jest @Map? Naprawdę niesamowita. Mówię @Bind, jaki rodzaj mapy oni mają cały czas, jak ta mapa liczb do list:",
                "$~\\rzeczy•{'':[]}: {}\\"
            ]
        },
        "NumberType": {
            "name": "$~numer",
            "description": "$~$1[$1 | liczba]",
            "emotion": "precise",
            "doc": [
                "$~Wiesz, czym powinno być @Bind? @Number. Ponieważ liczby są najlepsze.",
                "$~\\liczba•#: 17\\"
            ]
        },
        "NameType": {
            "name": "$~struktura",
            "description": "$~Typ $1",
            "emotion": "curious",
            "doc": [
                "$~Reprezentuję @StructureDefinition według jego nazwy. Więc jeśli masz taką strukturę, możesz utworzyć @Bind, który przechowuje tworzone przez siebie wartości.",
                "$~\\•Przyjaciel(imię•'')\nnajlepszy•Przyjaciel: Przyjaciel('Jonah')\\"
            ],
            "conflict": {
                "UnknownTypeName": "$~nazwy typów mogą odnosić się tylko do struktur lub zmiennych typu, ale to odnosi się do $1"
            }
        },
        "NeverType": {
            "name": "$~nigdy",
            "emotion": "curious",
            "doc": "$~Reprezentuję typ, który jest niemożliwy. Jak wtedy, gdy pytasz @Is, czy coś jest @Number, ale nigdy nie może być liczbą."
        },
        "NoneType": {
            "name": "$~nic",
            "emotion": "neutral",
            "doc": [
                "$~@None to najlepsze, co istnieje, a ja jestem ich wiernym przedstawicielem.",
                "$~\\space•ø: ø\\"
            ]
        },
        "SetType": {
            "name": "$~ustawić",
            "description": "$~$1[$1 zestaw|zestaw]",
            "emotion": "kind",
            "doc": [
                "$~@Set jest NAJLEPSZY, serio. Mówię @Bind cały czas, zrób z rzeczy zestaw czegoś!",
                "$~\\unique•{''}: {'coś' 'cokolwiek' 'ktoś'}\\"
            ]
        },
        "StreamDefinitionType": {
            "name": "$~definicjastrumienia",
            "emotion": "angry",
            "doc": "$~Reprezentuję strumień, który zdefiniowałeś, co nie jest możliwe, więc po co w ogóle to czytasz?"
        },
        "StreamType": {
            "name": "$~strumień",
            "emotion": "curious",
            "doc": [
                "$~Celebruję piękno i znaczenie strumieni… prosząc @Bind o ich przechowywanie:",
                "$~\\czas•…#ms: Czas()\\"
            ]
        },
        "StructureType": {
            "name": "$~struktura",
            "description": "$~1 dolar",
            "emotion": "kind",
            "doc": "$~Jestem typem wewnętrznym reprezentującym typ typów wartości domyślnych."
        },
        "UnknownType": {
            "name": "$~nieznany",
            "connector": "$~, ponieważ",
            "emotion": "curious",
            "doc": "$~Umm... Nie wiem, co reprezentuję, ale naprawdę jestem ciekawa. Wiesz? Wydaje się, że powinniśmy wiedzieć. Może będziesz musiał nam powiedzieć, jeśli nie będziemy w stanie tego rozgryźć."
        },
        "TableType": {
            "name": "$~tabela",
            "emotion": "angry",
            "doc": "$~Reprezentuję Tabelę.",
            "conflict": {
                "ExpectedColumnType": "$~Potrzebuję typu kolumny"
            }
        },
        "TextType": {
            "name": "$~tekst",
            "description": "$~$1[$1|tekst]",
            "emotion": "happy",
            "doc": [
                "$~Wspaniale reprezentuję najwspanialszy rodzaj wartości jaki istnieje, @Text.",
                "$~\\story•'': 'Dawno, dawno temu...'\\"
            ]
        },
        "TypePlaceholder": {
            "name": "$~symbolzastępczy",
            "emotion": "eager",
            "doc": "$~Mam nadzieję, że pewnego dnia będę reprezentować pewien typ, trochę tak jak moja najlepsza przyjaciółka @ExpressionPlaceholder reprezentuje wyrażenie! Czy pomożesz mi zdecydować, jaki to typ?"
        },
        "UnionType": {
            "name": "$~opcja",
            "description": "$~1 dolar | 2 dolary",
            "emotion": "curious",
            "doc": [
                "$~Kogo mam reprezentować, A czy B, czy coś innego? Nigdy nie mogę się zdecydować!",
                "$~\\indecision•''|#|{ø}: \"Nie wiem!\"\\"
            ]
        },
        "Unit": {
            "name": "$~jednostka",
            "description": "$~1 dolar",
            "emotion": "precise",
            "doc": [
                "$~Reprezentuję każdą jednostkę, jaką @Number może mieć, włączając brak jednostki, aż do najbardziej skomplikowanej jednostki, jaką możesz sobie wyobrazić. Jak na przykład grawitacja:",
                "$~\\grawitacja•m/s^2: 9,8m/s^2\\",
                "$~Pojawiam się w @Bind, ale także zaraz po @Number. Pomagam upewnić się, że liczby są tego samego rodzaju i na pewno powiem, jeśli tak nie jest, na wypadek gdyby to była pomyłka!"
            ]
        },
        "UnparsableType": {
            "name": "$~niemożliwydoprzeanalizowania",
            "emotion": "curious",
            "doc": "$~Reprezentuję typ nieznanego wyrażenia. Pojawiam się, gdy próbujesz użyć tego wyrażenia do czegoś."
        },
        "VariableType": {
            "name": "$~typzmienny",
            "emotion": "curious",
            "doc": "$~Czy znasz @TypeVariable i jak reprezentują one jakiś nieznany rodzaj wartości? Reprezentuję je we wszystkich negocjacjach między wartościami."
        },
        "CycleType": {
            "name": "$~cykl",
            "description": "$~zależy od siebie",
            "emotion": "curious",
            "doc": "$~Czasami wartości zależą od siebie, więc nie wiemy, jakiego rodzaju wartościami są. Reprezentuję taką sytuację."
        },
        "UnknownVariableType": {
            "name": "$~nieznanazmienna",
            "emotion": "curious",
            "doc": "$~Czasami próbujemy zgadnąć, jaką wartość coś ma; ja przychodzę, gdy nie wiemy."
        },
        "NotAType": {
            "name": "$~nieoczekiwany",
            "description": "$~nie 1$",
            "emotion": "curious",
            "doc": "$~Czasami wiemy, jaką wartość coś powinno mieć. Na przykład @ListAccess potrzebuje @Number. Jeśli jej nie otrzymamy, oznacza to, że coś jest innego typu niż oczekiwaliśmy."
        },
        "NoExpressionType": {
            "name": "$~brakwyrazu",
            "emotion": "angry",
            "doc": "$~Wiesz, że @Block potrzebuje przynajmniej jednego wyrażenia? Jestem tym, co dostajesz, gdy nie dajesz żadnego. Więc daj jedno!"
        },
        "NotEnclosedType": {
            "name": "$~niewstrukturze,konwersjianireakcji",
            "emotion": "curious",
            "doc": "$~@This, choć są schludne, należy tylko do określonych miejsc. Pojawiam się, gdy się gubią, więc nikt nie wie, jaką wartość reprezentują."
        },
        "NotImplementedType": {
            "name": "$~niewdrożony",
            "emotion": "curious",
            "doc": "$~Kiedy używasz @ExpressionPlaceholder, ale nie mówisz, jaki to typ, to ja jestem tym typem, który dostajesz. Pogódź się z tym!"
        },
        "UnknownNameType": {
            "name": "$~nieznananazwa",
            "description": "$~$1[$1 nie jest zdefiniowane |nazwa nie została podana]",
            "emotion": "curious",
            "doc": "$~Wiesz, że czasami @Reference i @PropertyReference nie znają nazwy, o której mówisz? Jestem w pobliżu, gdy tak się dzieje, aby reprezentować, że nie wiemy, o kim mówisz."
        },
        "NonFunctionType": {
            "name": "$~niefunkcjonalny",
            "description": "$~niefunkcjonalny",
            "emotion": "confused",
            "doc": "$~Niektórzy z nas spodziewali się pewnych wydarzeń; ja pojawiałem się, gdy ich nie dostawaliśmy."
        }
    },
    "basis": {
        "Boolean": {
            "doc": [
                "$~Jesteśmy \\⊤\\ i \\⊥\\. \\⊤\\ jest prawdą. \\⊥\\ jest fałszem. \\⊤\\ nie jest \\⊥\\; \\⊥\\ nie jest \\⊤\\. Tak to jest.",
                "$~Jak nas tworzysz? Tylko \\⊤\\ i \\⊥\\, nic więcej, nic mniej.",
                "$~Niektórzy używają klawiatury (/ctrl+9/ dla \\⊤\\ i /ctrl+0/ dla \\⊥\\). Niektórzy używają wyszukiwania znaków na dole edytora. Albo możesz nas przeciągnąć stąd.",
                "$~Sprawdź nasze @FunctionDefinition poniżej. Są bardzo logiczne."
            ],
            "name": ["$~⊤⊥", "$~Wartośćlogiczna"],
            "function": {
                "and": {
                    "doc": [
                        "$~Oceniam na \\⊤\\ *tylko*, gdy obie wartości są \\⊤\\. Pomocne w określeniu, czy wiele rzeczy jest prawdą. Istnieją tylko cztery możliwe wyniki",
                        "$~\\⊤ i ⊤\\",
                        "$~\\⊤ i ⊥\\",
                        "$~\\⊥ i ⊤\\",
                        "$~\\⊥ & ⊥\\"
                    ],
                    "names": ["$~&", "$~I"],
                    "inputs": [
                        {
                            "doc": "$~Drugi @Boolean do sprawdzenia. Jeśli pierwszy to \\⊥\\, nie ma znaczenia, co to jest, funkcja oceni się jako \\⊥\\.",
                            "names": "$~wartość"
                        }
                    ]
                },
                "or": {
                    "doc": [
                        "$~Oceniam na \\⊤\\, gdy *jedna* wartość jest \\⊤\\. Pomocne w określeniu, czy jedna z wielu rzeczy jest prawdziwa. Istnieją tylko cztery możliwe wyniki",
                        "$~\\⊤ | ⊤\\",
                        "$~\\⊤ | ⊥\\",
                        "$~\\⊥ | ⊤\\",
                        "$~\\⊥ | ⊥\\"
                    ],
                    "names": ["$~|", "$~Lub"],
                    "inputs": [
                        {
                            "doc": "$~Drugi @Boolean do sprawdzenia. Jeśli pierwszy to \\⊥\\, funkcja będzie oceniać tylko na \\⊤\\, jeśli to jest \\⊤\\.",
                            "names": "$~wartość"
                        }
                    ]
                },
                "not": {
                    "doc": "$~Otrzymuję odwrotność siebie: jeśli \\⊤\\, to daje \\⊥\\, jeśli \\⊥\\, to daje \\⊤\\.",
                    "names": ["$~~", "$~nie"],
                    "inputs": []
                },
                "equals": {
                    "doc": "$~\\⊤\\ jeśli oba są \\⊤\\ lub oba są \\⊥\\.",
                    "names": ["$~=", "$~równasię"],
                    "inputs": [
                        {
                            "doc": "$~Druga wartość do sprawdzenia.",
                            "names": "$~wartość"
                        }
                    ]
                },
                "notequal": {
                    "doc": "$~\\⊤\\ jeśli oba są przeciwieństwami.",
                    "names": ["$~≠", "$~nierówny"],
                    "inputs": [
                        {
                            "doc": "$~Druga wartość do sprawdzenia.",
                            "names": "$~wartość"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Konwertuje @Boolean na równoważne wartości @Text, \\'⊤'\\ i \\'⊥'\\"
            }
        },
        "None": {
            "doc": [
                "$~/Cześć, tutaj @FunctionDefinition. @None nie lubi za dużo mówić, więc ja to zinterpretuję./",
                "$~Jestem @None. Przywołaj mnie za pomocą \\ø\\. Jestem pomocny, gdy chcesz przedstawić brak czegoś."
            ],
            "name": ["$~ø", "$~Nic"],
            "function": {
                "equals": {
                    "doc": "$~Czy inna wartość jest również niczym? Lepiej, żeby była, w przeciwnym razie, \\⊥\\.",
                    "names": ["$~=", "$~równasię"],
                    "inputs": [
                        {
                            "doc": "$~Inna wartość.",
                            "names": "$~wartość"
                        }
                    ]
                },
                "notequals": {
                    "doc": "$~Czy inną wartością /nie/ jest nic?",
                    "names": ["$~≠", "$~nierówny"],
                    "inputs": [
                        {
                            "doc": "$~Inna wartość.",
                            "names": "$~wartość"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Chcesz zrobić z \\ø\\ \\'ø'\\? To jest Twoja szansa."
            }
        },
        "Text": {
            "doc": [
                "$~Mogę to być dowolny tekst, napisany w dowolnym języku, z użyciem dowolnego z tych symboli otwierających i zamykających: \\\"\"\\, \\“”\\, \\„“\\, \\''\\, \\‘’\\, \\‹›\\, \\«»\\, \\「」\\ lub \\『』\\.",
                "$~Aby to zobrazować, rozważmy te piękne frazy",
                "$~\\'Są tylko dwa sposoby na przeżycie życia. Jeden to taki, jakby nic nie było cudem. Drugi to taki, jakby wszystko było cudem.'\\",
                "$~\\『Poprzedni wpis』\\",
                "$~Pamiętaj tylko, żeby zamknąć mnie, jeśli mnie otworzysz, i użyj pasującego symbolu. W przeciwnym razie nie będę wiedział, że skończyłeś ze swoimi słowami.",
                "$~\\'cześć'/pl'hola'/es-MX\\",
                "$~Możesz również oznaczyć mnie językami, a nawet podać wiele tłumaczeń. Ocenię je na dowolne języki, które są obecnie wybrane, jeśli istnieje pasujący język.",
                "$~Jeśli chcesz, abym miał inne wartości, możesz użyć symbolu",
                "$~Na przykład rozważmy to:",
                "$~\\\"Oto kilka sum \\1 + 2\\, \\2 + 3\\, \\3 + 4\\\"\\",
                "$~Widzisz, jak elegancko obliczyłem te sumy i umieściłem je w @Text?",
                "$~Poza tym @FunctionDefinition stworzyło mnóstwo wspaniałych funkcji, dzięki którym mogę robić najróżniejsze rzeczy za pomocą słów!"
            ],
            "name": ["$~''", "$~Tekst"],
            "function": {
                "length": {
                    "doc": [
                        "$~Oceniam na podstawie liczby czytelnych znaków w tekście; jedna litera to jeden znak, jeden emoji to jeden znak, itd. Na przykład:",
                        "$~\\'cześć'.length()\\",
                        "$~\\'🐈📚'.długość()\\"
                    ],
                    "names": ["$~📏", "$~długość"],
                    "inputs": []
                },
                "equals": {
                    "doc": "$~\\⊤\\ jeśli jestem tą samą sekwencją znaków, co podany @Text.",
                    "names": ["$~=", "$~równasię"],
                    "inputs": [
                        {
                            "doc": "$~@Text do porównania.",
                            "names": "$~wartość"
                        }
                    ]
                },
                "notequals": {
                    "doc": "$~\\⊤\\ jeśli nie jestem tą samą sekwencją znaków, co podany @Text.",
                    "names": "$~≠",
                    "inputs": [
                        {
                            "doc": "$~@Text do porównania",
                            "names": "$~wartość"
                        }
                    ]
                },
                "has": {
                    "doc": [
                        "$~\\⊤\\ jeśli podany @Text pojawi się u mnie.",
                        "$~\\'czy znalazłeś to czego szukałeś?'.has('you')\\"
                    ],
                    "names": ["$~⊆", "$~ma"],
                    "inputs": [
                        {
                            "doc": "$~@Text, którego należy we mnie szukać.",
                            "names": "$~tekst"
                        }
                    ]
                },
                "starts": {
                    "doc": [
                        "$~\\⊤\\ jeśli zacznę od podanego @Text.",
                        "$~\\'witaj wierszu!'.starts('witaj')\\",
                        "$~\\'witaj wierszu!'.starts('wers')\\"
                    ],
                    "names": ["$~zaczynasię"],
                    "inputs": [
                        {
                            "doc": "$~@Text, który należy sprawdzić na początku.",
                            "names": "$~tekst"
                        }
                    ]
                },
                "ends": {
                    "doc": [
                        "$~\\⊤\\ jeśli zakończę podanym @Text.",
                        "$~\\'czy jestem pytaniem?'.ends('?')\\",
                        "$~\\'Nie jestem pytaniem.'.ends('?')\\"
                    ],
                    "names": ["$~Kończysię"],
                    "inputs": [
                        {
                            "doc": "$~@Text do sprawdzenia na końcu.",
                            "names": "$~tekst"
                        }
                    ]
                },
                "repeat": {
                    "doc": [
                        "$~Tworzę nowy @Text, który jest moim imieniem i powtarzam go tyle razy, ile wynosi \\count\\:",
                        "$~\\'cześć' · 5\\",
                        "$~Jeśli podasz mi ułamek @Number, zignoruję go:",
                        "$~\\'cześć' · 5.5\\",
                        "$~Jeśli podasz mi ujemną @Number lub zero, podam pusty @Text.",
                        "$~\\'cześć' · -5\\",
                        "$~Najdłuższy tekst, jaki mogę utworzyć, to 65 535 znaków. Jeśli spróbujesz utworzyć dłuższy tekst, powtórzę go tyle razy, ile będę mógł."
                    ],
                    "names": [
                        "$~·",
                        "$~🔁",
                        "$~powtarzającysię",
                        "$~powtarzać"
                    ],
                    "inputs": [
                        {
                            "doc": "$~Liczba powtórzeń w nowym tekście.",
                            "names": "$~liczyć"
                        }
                    ]
                },
                "segment": {
                    "doc": [
                        "$~Dzielę się na @List of @Text, używając podanego @Text jako separatora i usuwając separatory. Na przykład:",
                        "$~\\'jabłka, pomarańcze, winogrona' ÷ ', '\\",
                        "$~Jeżeli separatorem jest pusty @Text, dzielę się na znaki:",
                        "$~\\'🖌️🏠🥸' ÷ ''\\"
                    ],
                    "names": ["$~÷", "$~segmentowany", "$~segment"],
                    "inputs": [
                        {
                            "doc": "$~@Text, który ma służyć jako separator.",
                            "names": "$~rozgranicznik"
                        }
                    ]
                },
                "combine": {
                    "doc": [
                        "$~Czasami pomocne jest połączenie @Text w jeden. Daj mi inny @Text, a stworzę nowy tekst, który nas połączy:",
                        "$~\\'cześć' + 'werset'\\"
                    ],
                    "names": ["$~+", "$~łączny", "$~łączyć"],
                    "inputs": [
                        {
                            "doc": "$~@Text do dołączenia.",
                            "names": "$~tekst"
                        }
                    ]
                }
            },
            "conversion": {
                "list": "$~Dzieli tekst na listę pojedynczych znaków.",
                "number": "$~Konwertuje tekst na @Number, a jeśli nie jest liczbą, na wartość nieliczbową."
            }
        },
        "Number": {
            "doc": [
                "$~Tworzę @Number z dowolną liczbą jednostek, jaką sobie wyobrazisz!",
                "$~Oto moja najlepsza piątka:",
                "$~\\0\\",
                "$~\\1historia\\",
                "$~\\πciasto\\",
                "$~\\∞skała\\",
                "$~\\1000000przytuleń\\",
                "$~Zasadniczo jest to nieskończona liczba liczb.",
                "$~I nieskończona liczba jednostek!",
                "$~I nieskończona liczba par liczba/jednostka…",
                "$~Mogę być liczbami całkowitymi, liczbami rzeczywistymi, liczbami ujemnymi, dodatnimi, ułamkowymi, dziesiętnymi, a nawet liczbami, które nie są liczbami.",
                "$~Możesz pisać do mnie za pomocą wielu różnych systemów liczbowych, w tym arabskiego \\123\\, rzymskiego \\ⅩⅩⅩⅠⅩ\\, japońskiego \\二十\\ i innych:",
                "$~\\1 + Ⅰ + 一\\",
                "$~Można również zapisać mnie w systemie od 2 do 16, wpisując numer systemu liczbowego w następujący sposób:",
                "$~\\2;11111111\\",
                "$~\\10;FF\\",
                "$~\\16;F\\",
                "$~Istnieje jedna specjalna liczba zwana NaN, która jest możliwa, gdy zapiszesz coś, co nie jest liczbą:",
                "$~\\2;22\\",
                "$~W bazie 2 nie ma cyfry „2”, więc nie jest to prawidłowa liczba. NaN pojawi się również, jeśli spróbujesz przekonwertować tekst niebędący liczbą na liczbę",
                "$~\\'cześć'→#\\"
            ],
            "name": ["$~#", "$~Numer"],
            "function": {
                "add": {
                    "doc": [
                        "$~Dodaję do siebie @Number z tą samą @Unit, tworząc nowy @Number z tą samą @Unit.",
                        "$~Na przykład:",
                        "$~\\1 + 1\\",
                        "$~\\3kot + 5kot\\",
                        "$~Jeżeli jednostki nie pasują, przerywam pokaz.",
                        "$~\\3kot + 5pies\\"
                    ],
                    "names": ["$~+", "$~dodać"],
                    "inputs": [
                        {
                            "doc": "$~@Number do dodania.",
                            "names": "$~numer"
                        }
                    ]
                },
                "subtract": {
                    "doc": [
                        "$~Odejmuję podaną mi @Number od siebie, tworząc nowy @Number o tej samej @Unit.",
                        "$~Na przykład:",
                        "$~\\1 - 1\\",
                        "$~\\3kot - 5kot\\",
                        "$~Jeżeli jednostki nie pasują, przerywam pokaz.",
                        "$~\\3kot - 5pies\\"
                    ],
                    "names": ["$~-", "$~odejmować"],
                    "inputs": [
                        {
                            "doc": "$~@Number, którą ode mnie odejmę.",
                            "names": "$~numer"
                        }
                    ]
                },
                "multiply": {
                    "doc": [
                        "$~Mnożę siebie przez podaną @Number, tworząc iloczyn mojej @Unit i @Unit podanej liczby:",
                        "$~\\5 · 5\\",
                        "$~\\5m · 5m\\",
                        "$~\\5m · 1/s\\"
                    ],
                    "names": ["$~·", "$~zwielokrotniać"],
                    "inputs": [
                        {
                            "doc": "$~Liczba, którą należy pomnożyć.",
                            "names": "$~numer"
                        }
                    ]
                },
                "divide": {
                    "doc": [
                        "$~Dzielę siebie przez podaną @Number, tworząc iloraz mojej @Unit i @Unit podanej liczby:",
                        "$~\\5 ÷ 5\\",
                        "$~\\5m ÷ 5m\\",
                        "$~\\5 minut ÷ 5 sekund\\"
                    ],
                    "names": ["$~÷", "$~dzielić"],
                    "inputs": [
                        {
                            "doc": "$~@Number, przez którą mnie podzielę.",
                            "names": "$~numer"
                        }
                    ]
                },
                "remainder": {
                    "doc": [
                        "$~Dzielę siebie przez podaną @Number, ale resztę podaję:",
                        "$~\\10% 2\\",
                        "$~\\10m % 2\\",
                        "$~\\10m/s % 3\\"
                    ],
                    "names": ["$~%", "$~reszta"],
                    "inputs": [
                        {
                            "doc": "$~@Number, przez którą mnie podzielę.",
                            "names": "$~numer"
                        }
                    ]
                },
                "positive": {
                    "doc": [
                        "$~Tworzę nową @Number, który sprawia, że jestem dodatni, mimo że jestem ujemny.",
                        "$~\\-200.pozytywne()\\"
                    ],
                    "names": ["$~pozytywny"],
                    "inputs": []
                },
                "round": {
                    "doc": [
                        "$~Tworzę nową @Number, która zaokrągla mnie do najbliższej liczby całkowitej.",
                        "$~\\9.4.runda()\\",
                        "$~\\9.5.runda()\\",
                        "$~\\9.6.runda()\\"
                    ],
                    "names": ["$~okrągły"],
                    "inputs": []
                },
                "roundDown": {
                    "doc": [
                        "$~Tworzę nową @Number, która zaokrągla do najmniejszej liczby całkowitej mniejszej ode mnie.",
                        "$~\\10.5.zaokrąglanie w dół()\\",
                        "$~\\10.1.zaokrąglanie w dół()\\",
                        "$~\\10.01.zaokrąglanie w dół()\\"
                    ],
                    "names": ["$~zaokrąglićwdół"],
                    "inputs": []
                },
                "roundUp": {
                    "doc": [
                        "$~Tworzę nową @Number, która zaokrągla do najmniejszej liczby całkowitej większej ode mnie.",
                        "$~\\10.5.zaokrąglanie()\\",
                        "$~\\10.9.zaokrąglanie()\\",
                        "$~\\10,99.zaokrąglenie w górę()\\"
                    ],
                    "names": ["$~łapanka"],
                    "inputs": []
                },
                "power": {
                    "doc": [
                        "$~Podnoszę się do podanej @Number's potęgi. Ułamkowe wykładniki są w porządku!",
                        "$~\\2 ^ 8\\",
                        "$~\\10^-2\\",
                        "$~\\5 ^ -.5\\"
                    ],
                    "names": ["$~^", "$~moc"],
                    "inputs": [
                        {
                            "doc": "$~Wykładnik, który mnie podniesie.",
                            "names": "$~numer"
                        }
                    ]
                },
                "root": {
                    "doc": [
                        "$~Tworzę korzeń samego siebie, używając podanego korzenia.",
                        "$~\\4 √ 2\\",
                        "$~\\1000 √ 3\\"
                    ],
                    "names": ["$~√", "$~źródło"],
                    "inputs": [
                        {
                            "doc": "$~Pierwiastek do obliczenia.",
                            "names": "$~numer"
                        }
                    ]
                },
                "lessThan": {
                    "doc": [
                        "$~\\⊤\\ jeśli jestem mniejszy niż podana @Number:",
                        "$~\\1 < 2\\",
                        "$~\\2 < 1\\"
                    ],
                    "names": ["$~<", "$~mniejszyniż"],
                    "inputs": [
                        {
                            "doc": "$~@Number, z którym można mnie porównać.",
                            "names": "$~numer"
                        }
                    ]
                },
                "lessOrEqual": {
                    "doc": [
                        "$~\\⊤\\ jeśli jestem mniejszy lub równy podanej @Number:",
                        "$~\\1 ≤ 2\\",
                        "$~\\2 ≤ 1\\",
                        "$~\\2 ≤ 2\\"
                    ],
                    "names": ["$~≤", "$~mniejlubrówny"],
                    "inputs": [
                        {
                            "doc": "$~@Number, z którym można mnie porównać.",
                            "names": "$~numer"
                        }
                    ]
                },
                "greaterThan": {
                    "doc": [
                        "$~\\⊤\\ jeśli I jest większe od podanej @Number:",
                        "$~\\1 > 2\\",
                        "$~\\2 > 1\\"
                    ],
                    "names": ["$~>", "$~większyniż"],
                    "inputs": [
                        {
                            "doc": "$~@Number, z którym można mnie porównać.",
                            "names": "$~numer"
                        }
                    ]
                },
                "greaterOrEqual": {
                    "doc": [
                        "$~\\⊤\\ jeśli I jest większe lub równe podanej @Number:",
                        "$~\\1 ≥ 2\\",
                        "$~\\2 ≥ 1\\",
                        "$~\\2 ≥ 2\\"
                    ],
                    "names": ["$~≥", "$~większylubrówny"],
                    "inputs": [
                        {
                            "doc": "$~@Number, z którym można mnie porównać.",
                            "names": "$~numer"
                        }
                    ]
                },
                "equal": {
                    "doc": [
                        "$~\\⊤\\ jeśli jestem równy podanej @Number:",
                        "$~\\1 = 2\\",
                        "$~\\2 = 2\\"
                    ],
                    "names": ["$~=", "$~równy"],
                    "inputs": [
                        {
                            "doc": "$~@Number, z którym można mnie porównać.",
                            "names": "$~numer"
                        }
                    ]
                },
                "notequal": {
                    "doc": [
                        "$~\\⊤\\ jeśli jestem równy podanej @Number:",
                        "$~\\1 ≠ 2\\",
                        "$~\\2 ≠ 2\\"
                    ],
                    "names": ["$~≠", "$~nierówny"],
                    "inputs": [
                        {
                            "doc": "$~@Number, z którym można mnie porównać.",
                            "names": "$~numer"
                        }
                    ]
                },
                "cos": {
                    "doc": ["$~Oblicz mój cosinus.", "$~\\π.cos()\\"],
                    "names": ["$~sałata", "$~cosinus"],
                    "inputs": []
                },
                "sin": {
                    "doc": ["$~Oblicz mój sinus.", "$~\\π.cos()\\"],
                    "names": ["$~grzech", "$~sinus"],
                    "inputs": []
                },
                "min": {
                    "doc": [
                        "$~Znajdź najmniejszą liczbę „ja” i „inni”.",
                        "$~\\1.min(2 3 -1)\\"
                    ],
                    "names": "$~min",
                    "inputs": [
                        {
                            "doc": "$~Podaj mi tyle liczb, ile chcesz!",
                            "names": "$~taktymuzyczne"
                        }
                    ]
                },
                "max": {
                    "doc": [
                        "$~Znajdź największą liczbę mnie i innych.",
                        "$~\\1.maks.(2 3 4)\\"
                    ],
                    "names": "$~maks",
                    "inputs": [
                        {
                            "doc": "$~Podaj mi tyle liczb, ile chcesz!",
                            "names": "$~taktymuzyczne"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Arabska reprezentacja tekstowa moich cyfr.",
                "list": [
                    "$~Konwertuję liczbę na listę liczb od \\1\\ do dowolnej podanej liczby. Na przykład:",
                    "$~\\10→[]\\"
                ],
                "s2m": "$~Sekundy i minuty",
                "s2h": "$~Sekundy do godzin",
                "s2day": "$~Sekundy do dni",
                "s2wk": "$~Sekundy do tygodni",
                "s2year": "$~Sekundy do lat",
                "s2ms": "$~Sekundy do milisekund",
                "ms2s": "$~Milisekundy na sekundy",
                "min2s": "$~Minuty i sekundy",
                "h2s": "$~Godziny na sekundy",
                "day2s": "$~Dni do sekund",
                "wk2s": "$~Tygodnie do sekund",
                "yr2s": "$~Lata na sekundy",
                "m2pm": "$~Metry na pikometry",
                "m2nm": "$~Metry na nanometry",
                "m2micro": "$~Metry na mikrometry",
                "m2mm": "$~Metry na milimetry",
                "m2cm": "$~Metry na centymetry",
                "m2dm": "$~Metry na decymetry",
                "m2km": "$~Metry na kilometry",
                "m2Mm": "$~Metry na megametry",
                "m2Gm": "$~Metry na gigametry",
                "m2Tm": "$~Metry na terametry",
                "pm2m": "$~Pikometry na metry",
                "nm2m": "$~Nanometry na metry",
                "micro2m": "$~Mikrometry na metry",
                "mm2m": "$~Milimetry na metry",
                "cm2m": "$~Centymetry na metry",
                "dm2m": "$~Decymetry na metry",
                "km2m": "$~Kilometry na metry",
                "Mm2m": "$~Megametry na metry",
                "Gm2m": "$~Gigametry na metry",
                "Tm2m": "$~Terametry na metry",
                "km2mi": "$~Kilometry na mile",
                "mi2km": "$~Mile na kilometry",
                "cm2in": "$~Centymetry na cale",
                "in2cm": "$~Cale na centymetry",
                "m2ft": "$~Metry na stopy",
                "ft2m": "$~Stopy na metry",
                "g2mg": "$~Gramy na miligramy",
                "mg2g": "$~Miligramy na gramy",
                "g2kg": "$~Gramy na kilogramy",
                "kg2g": "$~Kilogramy na gramy",
                "g2oz": "$~Gramy na uncje",
                "oz2g": "$~Uncje na gramy",
                "oz2lb": "$~Uncje na funty",
                "lb2oz": "$~Funty na uncje"
            }
        },
        "List": {
            "doc": [
                "$~Jestem ciągiem wartości, dowolnego rodzaju!",
                "$~Możesz umieścić we mnie cokolwiek: @Boolean, @Number, @Text, @None, nawet inne @List, @Set, @Map lub dowolne wyrażenie. Oto proste:",
                "$~\\['jabłko' 'banan' 'mango']\\",
                "$~To, co mnie wyróżnia, to fakt, że trzymam rzeczy w porządku i numeruję wszystko od 1 do dowolnej liczby przedmiotów, które mam w sobie.",
                "$~Moje elementy są ponumerowane, zaczynając od 1. Możesz uzyskać wartości, które przechowuję za pomocą @ListAccess, używając ich numeru:",
                "$~Na przykład drugą wartością na tej liście jest \\['banana']\\",
                "$~\\['jabłko' 'banan' 'mango'][2]\\",
                "$~Mogę mieć wszystko w sobie. Spójrz na tę listę, z @Text, @Number i @Time!",
                "$~\\['jabłko' 10 + 10 Czas()]\\",
                "$~Kiedy dajesz mi listę wielu rzeczy, uogólniam je, jeśli mają wspólny typ. Ale czasami możesz dosłownie mieć na myśli te konkretne rzeczy. Jeśli tak robisz, po prostu wstaw ! po mnie, a ja upewnię się, że reprezentuję listę konkretnie tylko tych wartości.",
                "$~\\['jabłko' 'banan' 'mango']!\\",
                "$~To tyle. Ale mogę wywoływać ekscytujące rzeczy za pomocą mojego @FunctionDefinition!"
            ],
            "name": ["$~[]", "$~Lista"],
            "kind": "$~Uprzejmy",
            "out": "$~Wynik",
            "outofbounds": "$~poza granicami",
            "function": {
                "add": {
                    "doc": [
                        "$~Tworzę nową @List z podanym elementem na końcu.",
                        "$~\\['jabłko' 'banan' 'mango'].with('arbuz')\\"
                    ],
                    "names": ["$~z", "$~dodać"],
                    "inputs": [
                        {
                            "doc": "$~Jestem wartością, którą chcesz dodać.",
                            "names": "$~przedmiot"
                        }
                    ]
                },
                "append": {
                    "doc": [
                        "$~Tworzę nową @List ze swoimi wartościami, a następnie wszystkie wartości podanej @List po mnie.",
                        "$~\\['jabłko' 'banan' 'mango'].withList(['arbuz' 'karmel'])\\",
                        "$~Trochę łatwiej jest używać @Spread, w ten sposób:",
                        "$~\\['jabłko' 'banan' 'mango' :['arbuz' 'karmel']]\\"
                    ],
                    "names": ["$~zListą", "$~dodać"],
                    "inputs": [
                        {
                            "doc": "$~Lista wartości do dodania.",
                            "names": "$~lista"
                        }
                    ]
                },
                "replace": {
                    "doc": [
                        "$~Tworzę nową listę, która zastępuje wartość o podanym indeksie podaną wartością.",
                        "$~\\['jabłko' 'banan' 'mango'].replace(1 'kiwi')\\"
                    ],
                    "names": ["$~zastępować"],
                    "inputs": [
                        {
                            "doc": "$~Indeks wartości do zastąpienia",
                            "names": "$~indeks"
                        },
                        {
                            "doc": "$~Wartość zastępcza",
                            "names": "$~wartość"
                        }
                    ]
                },
                "length": {
                    "doc": "$~@Number elementów we mnie.",
                    "names": ["$~📏", "$~długość"],
                    "inputs": []
                },
                "random": {
                    "doc": [
                        "$~Jeden losowo wybrany z moich przedmiotów lub @None, jeśli jest pusty.",
                        "$~\\['jabłko' 'banan' 'mango'].random()\\"
                    ],
                    "names": "$~losowy",
                    "inputs": []
                },
                "shuffled": {
                    "doc": [
                        "$~Utwórz nową listę z elementami z ostatniej losowej listy.",
                        "$~\\['jabłko' 'banan' 'mango'].shuffled()\\"
                    ],
                    "names": "$~przetasowany",
                    "inputs": []
                },
                "first": {
                    "doc": [
                        "$~Pierwszy element we mnie, lub @None jeśli jestem pusty.",
                        "$~\\['jabłko' 'banan' 'mango'].first()\\"
                    ],
                    "names": "$~Pierwszy",
                    "inputs": []
                },
                "last": {
                    "doc": [
                        "$~Ostatnia rzecz we mnie, albo @None jeśli jestem pusty.",
                        "$~\\['jabłko' 'banan' 'mango'].first()\\"
                    ],
                    "names": "$~ostatni",
                    "inputs": []
                },
                "has": {
                    "doc": [
                        "$~\\⊤\\ jeśli mam w sobie element równy danemu elementowi.",
                        "$~\\['jabłko' 'banan' 'mango'].has('banan')\\"
                    ],
                    "names": "$~ma",
                    "inputs": [
                        {
                            "doc": "$~Wartość do wyszukania.",
                            "names": "$~przedmiot"
                        }
                    ]
                },
                "join": {
                    "doc": [
                        "$~Łączę elementy na mojej liście w @Text, oddzielając je podanym separatorem @Text.",
                        "$~\\['jabłko' 'banan' 'mango'].join(', ')\\"
                    ],
                    "names": "$~dołączyć",
                    "inputs": [
                        {
                            "doc": "$~Tekst, według którego mają być rozdzielone elementy, opcjonalnie pusty.",
                            "names": "$~separator"
                        }
                    ]
                },
                "subsequence": {
                    "doc": [
                        "$~Otrzymuję listę w ramach tej listy, zaczynając od podanego indeksu i kończąc na ostatnim elemencie lub, jeśli podasz taki, na konkretnym elemencie.",
                        "$~\\['jabłko' 'banan' 'mango'].subsequence(2)\\",
                        "$~\\['jabłko' 'banan' 'mango'].subsequence(1 2)\\",
                        "$~I patrz! Jeśli podasz numery w niewłaściwej kolejności, dam ci odwrotną kolejność",
                        "$~\\['jabłko' 'banan' 'mango'].subsequence(3 1)\\",
                        "$~Jeśli podasz mi wartość indeksu mniejszą niż 1, założę, że masz na myśli 1.",
                        "$~\\['jabłko' 'banan' 'mango'].podsekwencja(-1003243 2)\\",
                        "$~A jeśli podasz mi coś większego niż największy indeks, założę, że masz na myśli koniec.",
                        "$~\\['jabłko' 'banan' 'mango'].subsequence(3 2304032432)\\"
                    ],
                    "names": "$~podsekwencja",
                    "inputs": [
                        {
                            "doc": "$~Indeks pierwszego elementu poszukiwanego podciągu.",
                            "names": "$~start"
                        },
                        {
                            "doc": "$~Opcjonalny indeks ostatniego elementu podciągu, który chcesz. Jeśli go nie podasz, lista zakończy się ostatnim elementem na liście.",
                            "names": "$~koniec"
                        }
                    ]
                },
                "sansFirst": {
                    "doc": [
                        "$~Tworzę listę bez pierwszego elementu.",
                        "$~\\['jabłko' 'banan' 'mango'].sansFirst()\\"
                    ],
                    "names": ["$~bezPierwszego", "$~sansPierwszy"],
                    "inputs": []
                },
                "sansLast": {
                    "doc": [
                        "$~Tworzę listę bez ostatniego elementu.",
                        "$~\\['jabłko' 'banan' 'mango'].sansLast()\\"
                    ],
                    "names": ["$~bezOstatniego", "$~sansOstatni"],
                    "inputs": []
                },
                "sans": {
                    "doc": [
                        "$~Ja, ale bez pierwszych wystąpień podanej wartości.",
                        "$~\\['jabłko' 'banan' 'mango' 'jabłko'].sans('jabłko')\\"
                    ],
                    "names": ["$~bez", "$~bez"],
                    "inputs": [
                        {
                            "doc": "$~Wartość, która ma zostać usunięta przy pierwszym wystąpieniu.",
                            "names": "$~wartość"
                        }
                    ]
                },
                "sansAll": {
                    "doc": [
                        "$~Ja, ale bez wszystkich wystąpień podanej wartości.",
                        "$~\\['jabłko' 'banan' 'mango' 'jabłko'].sans('jabłko')\\"
                    ],
                    "names": ["$~bezWszystko", "$~sansAll"],
                    "inputs": [
                        {
                            "doc": "$~Wartość, której wszystkie wystąpienia mają zostać usunięte z listy.",
                            "names": "$~wartość"
                        }
                    ]
                },
                "reverse": {
                    "doc": [
                        "$~Ja, ale na odwrót!",
                        "$~\\['jabłko' 'banan' 'mango'].reverse()\\"
                    ],
                    "names": ["$~wywrócony", "$~odwracać"],
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "$~\\⊤\\ jeśli moje przedmioty i zamówienie są dokładnie takie same jak podana @List.",
                        "$~\\['jabłko' 'banan' 'mango'] = ['jabłko' 'mango' 'banan']\\"
                    ],
                    "names": ["$~=", "$~równasię"],
                    "inputs": [
                        {
                            "doc": "$~@List, z którą możesz mnie porównać.",
                            "names": "$~lista"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "$~\\⊤\\ jeśli moje przedmioty i zamówienie /nie/ są dokładnie takie same jak podana @List.",
                        "$~\\['jabłko' 'banan' 'mango'] ≠ ['jabłko' 'mango' 'banan']\\"
                    ],
                    "names": ["$~≠", "$~nierówny"],
                    "inputs": [
                        {
                            "doc": "$~@List, z którą możesz mnie porównać.",
                            "names": "$~lista"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "$~Podaj mi @FunctionDefinition, która przyjmuje wartość i opcjonalny indeks jako dane wejściowe i generuje wartość, a ja ocenię ją dla każdego z moich elementów, tłumacząc moje wartości na nowe wartości.",
                        "$~Na przykład wyobraź sobie, że jestem listą @Number i chcesz je wszystkie podwoić:",
                        "$~\\[2 4 6 8].translate(ƒ(num·#) num · 2)\\"
                    ],
                    "names": "$~tłumaczyć",
                    "inputs": [
                        {
                            "doc": "$~@FunctionDefinition, która przetłumaczy każdy element.",
                            "names": "$~tłumacz"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "$~Przedmiot tłumaczenia.",
                            "names": "$~przedmiot"
                        },
                        {
                            "doc": "$~Indeks tłumaczonego elementu.",
                            "names": "$~indeks"
                        },
                        {
                            "doc": "$~Lista jest tłumaczona.",
                            "names": "$~lista"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "$~Podaj mi @FunctionDefinition, która przyjmuje wartość i opcjonalny indeks jako dane wejściowe i generuje @Boolean, a ja stworzę nową listę, która będzie zawierała tylko elementy dające wynik \\⊤\\.",
                        "$~Na przykład wyobraź sobie, że jestem listą @Number, a Ty chcesz tylko te dodatnie:",
                        "$~\\[2 -4 8 -16].filtr(ƒ(liczba•#) liczba ≥ 0)\\"
                    ],
                    "names": "$~filtr",
                    "inputs": [
                        {
                            "doc": "$~@FunctionDefinition sprawdza każdy element i zwraca \\⊤\\, jeśli powinien zostać zachowany.",
                            "names": "$~szachownica"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~Sprawdzany element.",
                            "names": "$~przedmiot"
                        },
                        {
                            "doc": "$~Indeks sprawdzanego elementu.",
                            "names": "$~indeks"
                        },
                        {
                            "doc": "$~Lista jest filtrowana.",
                            "names": "$~lista"
                        }
                    ]
                },
                "all": {
                    "doc": [
                        "$~Daj mi @FunctionDefinition, która przyjmuje wartość jako dane wejściowe i generuje @Boolean, jeśli spełnia jakiś warunek. Utworzę \\⊤\\, jeśli wszystkie elementy spełniają warunek.",
                        "$~Na przykład wyobraź sobie, że jestem listą @Number i chcesz wiedzieć, czy wszystko jest dodatnie:",
                        "$~\\[2 -4 8 -16].all(ƒ(liczba •#) liczba ≥ 0)\\"
                    ],
                    "names": "$~Wszystko",
                    "inputs": [
                        {
                            "doc": "$~@FunctionDefinition, która generuje \\⊤\\, jeśli element spełnia warunek.",
                            "names": "$~szachownica"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~Sprawdzany element.",
                            "names": "$~przedmiot"
                        },
                        {
                            "doc": "$~Indeks sprawdzanego elementu.",
                            "names": "$~indeks"
                        },
                        {
                            "doc": "$~Lista, która jest sprawdzana.",
                            "names": "$~lista"
                        }
                    ]
                },
                "until": {
                    "doc": [
                        "$~Daj mi @FunctionDefinition, która przyjmuje wartość jako dane wejściowe i generuje @Boolean, jeśli spełnia jakiś warunek. Utworzę nową @List, która będzie zawierać wszystkie elementy, dopóki warunek nie zostanie spełniony.",
                        "$~Na przykład wyobraź sobie, że jestem listą zwierząt @Text i chcesz znaleźć wszystko aż do znalezienia \\'szczura'\\:",
                        "$~\\['kot' 'pies' 'szczur' 'mysz' 'kucyk'].until(ƒ(zwierzę•'') zwierzę = 'szczur')\\"
                    ],
                    "names": "$~dopóki",
                    "inputs": [
                        {
                            "doc": "$~@FunctionDefinition, która generuje \\⊤\\, jeśli powinienem przestać uwzględniać elementy.",
                            "names": "$~szachownica"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~Sprawdzany element.",
                            "names": "$~przedmiot"
                        },
                        {
                            "doc": "$~Indeks sprawdzanego elementu.",
                            "names": "$~indeks"
                        },
                        {
                            "doc": "$~Lista jest uzupełniana.",
                            "names": "$~lista"
                        }
                    ]
                },
                "find": {
                    "doc": [
                        "$~Podaj mi @FunctionDefinition, która przyjmuje wartość jako dane wejściowe i generuje @Boolean, jeśli spełnia pewne kryteria, a ja ocenię pasujący element.",
                        "$~Na przykład wyobraź sobie, że chcesz znaleźć pierwsze zwierzę, które ma samogłoskę \\'e'\\:",
                        "$~\\['kot' 'pies' 'szczur' 'mysz' 'kucyk'].find(ƒ(zwierzę•'') zwierzę.has('e'))\\"
                    ],
                    "names": "$~znajdować",
                    "inputs": [
                        {
                            "doc": "$~@FunctionDefinition, która generuje \\⊤\\, jeśli spełnia kryteria wyszukiwania.",
                            "names": "$~szachownica"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~Sprawdzany element.",
                            "names": "$~przedmiot"
                        },
                        {
                            "doc": "$~Indeks sprawdzanego elementu.",
                            "names": "$~indeks"
                        },
                        {
                            "doc": "$~Lista, która jest przeszukiwana.",
                            "names": "$~lista"
                        }
                    ]
                },
                "combine": {
                    "doc": [
                        "$~Podaj mi @FunctionDefinition, która przyjmuje najnowszą kombinację i następną wartość, a następnie tworzy następną kombinację. Następnie przejdę od pierwszego do ostatniego elementu, tworząc kolejne kombinacje i oceniając ostatnią kombinację, którą ocenia Twoja @FunctionDefinition.",
                        "$~To naprawdę pomaga połączyć wszystkie elementy w me w jedną wartość. Na przykład wyobraź sobie, że chcesz dodać listę liczb:",
                        "$~\\[3 9 2 8 1 4].combine(0 ƒ(suma•# liczba•#) suma + liczba)\\"
                    ],
                    "names": ["$~łączny", "$~łączyć"],
                    "inputs": [
                        {
                            "doc": "$~Kombinacja początkowa.",
                            "names": "$~wstępny"
                        },
                        {
                            "doc": "$~@FunctionDefinition przyjmuje najnowszą kombinację i następną wartość, a następnie generuje następną kombinację.",
                            "names": "$~łącznik"
                        }
                    ],
                    "combiner": [
                        {
                            "doc": "$~Obecna kombinacja",
                            "names": "$~połączenie"
                        },
                        {
                            "doc": "$~Następny element do połączenia.",
                            "names": "$~Następny"
                        },
                        {
                            "doc": "$~Indeks następnego elementu",
                            "names": "$~indeks"
                        },
                        {
                            "doc": "$~Lista jest łączona.",
                            "names": "$~lista"
                        }
                    ]
                },
                "sorted": {
                    "doc": [
                        "$~Mogę wziąć listę i stworzyć nową listę z posortowanymi wartościami. Tak jak tutaj:",
                        "$~\\[1 5 8 0 2].sortowane()\\",
                        "$~Mogę to zrobić również dla wartości @Text",
                        "$~\\['pomarańczowy' 'kiwi' 'banan' 'jabłko'].sorted()\\",
                        "$~A jeśli masz listę wartości, które nie są @Number lub @Text, możesz podać mi @FunctionDefinition, która zamienia każdy element na @Number, abym mógł je posortować. Na przykład tutaj mamy listę list o różnych długościach; jeśli podasz mi funkcję, która zamienia każdą listę na jej długość, mogę sortować według ich długości.",
                        "$~\\[[1] [2 3] [4 8 12] [8]].sorted(ƒ(lista) lista.długość())\\"
                    ],
                    "names": "$~posortowane",
                    "inputs": [
                        {
                            "doc": "$~Opcjonalna @FunctionDefinition do użycia w celu sortowania wartości listy. Powinna ona zamienić wartość na @Number, który może być użyty do sortowania listy.",
                            "names": "$~sekwencer"
                        }
                    ],
                    "sequencer": [
                        {
                            "doc": "$~Wartość, która ma zostać przekształcona w @Number.",
                            "names": "$~wartość"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Do reprezentacji @Text listy.",
                "set": "$~Do @Set, przydatne przy usuwaniu duplikatów."
            }
        },
        "Set": {
            "doc": [
                "$~Jestem zbiorem wartości! To znaczy, że mogę zawierać dowolną liczbę wartości, w tym żadnych wartości. Możesz mnie zrobić tak:",
                "$~\\{1 2 3}\\",
                "$~Naprawdę dobrze mi idzie, jeśli chcesz zachować kolekcję rzeczy bez duplikatów.",
                "$~Oznacza to, że jeśli podasz mi wartości, które już mam, zignoruję te dodatkowe.",
                "$~Na przykład ten zestaw ma wiele duplikatów:",
                "$~\\{1 1 2 2 3 3}\\",
                "$~Oceniam to po prostu na \\{1 2 3}\\.",
                "$~Jeśli chcesz sprawdzić, czy mam jakąś wartość, @SetOrMapAccess może Ci pomóc:",
                "$~\\{'słoik' 'butelka' 'szklanka'}{'kubek'}\\",
                "$~Zwykle, jeśli podasz mi grupę wartości, które są wspólnego typu, założę, że są listą tego typu. Na przykład ten zestaw to \\{''}\\, ponieważ wszystko to jest @Text.",
                "$~\\{'hej' 'cześć' 'cześć'}\\",
                "$~Ale możesz chcieć wskazać, że jestem zestawem /tylko/ tych wartości, więc mogę ci powiedzieć, kiedy próbujesz użyć niedozwolonej. Jeśli tak, po prostu dodaj ! na końcu me.",
                "$~\\{'hej' 'cześć' 'cześć'}!{'yo'}\\",
                "$~Czy jest coś jeszcze, co chciałbyś ze mną zrobić? Sprawdź wszystkie fajne @FunctionDefinition, które mam!"
            ],
            "name": ["$~{}", "$~Ustawić"],
            "kind": "$~Uprzejmy",
            "out": "$~Wynik",
            "function": {
                "size": {
                    "doc": "$~Powiem ci, ile wartości jest we mnie.",
                    "names": "$~rozmiar",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "$~Jestem \\⊤\\ jeśli dany @Set i I mają dokładnie takie same wartości:",
                        "$~= 1 2 3 = 2 3 4"
                    ],
                    "names": ["$~=", "$~równasię"],
                    "inputs": [
                        {
                            "doc": "$~@Set do porównania.",
                            "names": "$~ustawić"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "$~Jestem \\⊤\\, jeśli podany @Set i I nie mają dokładnie takich samych wartości:",
                        "$~\\{1 2 3} ≠ {2 3 4}\\"
                    ],
                    "names": ["$~≠", "$~nierówny"],
                    "inputs": [
                        {
                            "doc": "$~@Set do porównania.",
                            "names": "$~ustawić"
                        }
                    ]
                },
                "add": {
                    "doc": [
                        "$~Podaj mi element, który mam dodać, a ja stworzę nowy @Set z moimi elementami i danym elementem.",
                        "$~\\{1 2 3} + 4\\"
                    ],
                    "names": ["$~z", "$~dodać", "$~+"],
                    "inputs": [
                        {
                            "doc": "$~Element do dodania",
                            "names": "$~przedmiot"
                        }
                    ]
                },
                "remove": {
                    "doc": [
                        "$~Podaj mi element do usunięcia, a ja stworzę nowy @Set bez tego elementu.",
                        "$~\\{1 2 3} - 2\\",
                        "$~Jeśli nie mam potrzebnego przedmiotu, po prostu ocenię go sam."
                    ],
                    "names": ["$~usunąć", "$~-"],
                    "inputs": [
                        {
                            "doc": "$~Element do usunięcia.",
                            "names": "$~przedmiot"
                        }
                    ]
                },
                "union": {
                    "doc": [
                        "$~Podaj mi @Set, a ja stworzę nowy @Set, który będzie zawierał moje elementy i elementy zestawu.",
                        "$~1 2 3 ∪ {3 4 5}"
                    ],
                    "names": ["$~unia", "$~∪"],
                    "inputs": [
                        {
                            "doc": "$~@Set do połączenia ze mną.",
                            "names": "$~ustawić"
                        }
                    ]
                },
                "intersection": {
                    "doc": [
                        "$~Daj mi @Set, a ja stworzę nowy @Set, który będzie zawierał tylko elementy, które mamy wspólne.",
                        "$~1 2 3 ∩ {3 4 5}"
                    ],
                    "names": ["$~przecięcie", "$~∩"],
                    "inputs": [
                        {
                            "doc": "$~Zestaw do porównania ze mną.",
                            "names": "$~ustawić"
                        }
                    ]
                },
                "difference": {
                    "doc": [
                        "$~Podaj mi @Set, a stworzę nowy @Set, który będzie zawierał tylko te elementy, które mamy wspólne.",
                        "$~\\{1 2 3}.różnica({3 4 5})\\"
                    ],
                    "names": "$~różnica",
                    "inputs": [
                        {
                            "doc": "$~Zestaw, którego elementy powinny zostać ode mnie usunięte.",
                            "names": "$~ustawić"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "$~Podaj mi @FunctionDefinition, która przyjmuje element i generuje \\⊤\\, jeśli powinien on zostać zachowany, a ja utworzę @Set zawierający tylko elementy spełniające Twoje kryteria.",
                        "$~Na przykład znajdźmy liczby nieparzyste we mnie:",
                        "$~\\{1 2 3 4 5 6 7 8 9}.filter(ƒ(liczba•#) (liczba % 2) = 1)\\"
                    ],
                    "names": "$~filtr",
                    "inputs": [
                        {
                            "doc": "$~@FunctionDefinition sprawdza, czy element powinien zostać zachowany.",
                            "names": "$~szachownica"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~Sprawdzany element.",
                            "names": "$~wartość"
                        },
                        {
                            "doc": "$~Zestaw poddawany filtrowaniu",
                            "names": "$~ustawić"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "$~Podaj mi @FunctionDefinition, która przyjmuje element i tworzy na jego podstawie nowy element, a ja przetłumaczę wszystkie elementy w sobie na nowy @Set (usuwając wszelkie duplikaty).",
                        "$~Na przykład, zmieńmy wszystkie moje @Number na @Text:",
                        "$~\\{1 2 3 4 5 6 7 8 9}.translate(ƒ(liczba•#) liczba→'')\\"
                    ],
                    "names": "$~tłumaczyć",
                    "inputs": [
                        {
                            "doc": "$~@FunctionDefinition tłumaczy jeden z moich elementów na nowy element, którego potrzebujesz.",
                            "names": "$~ustawić"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "$~Przedmiot tłumaczenia.",
                            "names": "$~wartość"
                        },
                        {
                            "doc": "$~Zestaw, który jest tłumaczony",
                            "names": "$~ustawić"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Reprezentacja @Text zestawu @Set",
                "list": "$~Reprezentacja @List elementów zestawu."
            }
        },
        "Map": {
            "doc": [
                "$~Łączę wartości, mapując *klucze* na *wartości*. Na przykład:",
                "$~\\{'amy': 6 punktów 'tony':3 punkty 'shiela': 8 punktów}\\",
                "$~Moje klucze mogą mieć dowolną wartość, a moje wartości mogą mieć dowolną wartość.",
                "$~Niektórzy lubią myśleć o mnie jak o indeksie lub słowniku, gdzie podajesz mi coś, a ja podaję ci to, do czego to jest przypisane.",
                "$~Jeśli chcesz sprawdzić, do czego coś jest mapowane, możesz podać @SetOrMapAccess klucz, a otrzymasz wartość:",
                "$~\\{'amy': 6 punktów 'tony':3 punkty 'shiela': 8 punktów}{'amy'}\\",
                "$~Jeśli nie będzie pasującego klucza, podam Ci @None.",
                "$~\\{'amy': 6 punktów 'tony':3 punkty 'shiela': 8 punktów}{'jen'}\\",
                "$~Możesz również utworzyć pustą mapę w ten sposób:",
                "$~\\{:}\\",
                "$~Zazwyczaj widzę wszystkie rodzaje kluczy i wartości, które mi podasz i po prostu wymyślam typ, który reprezentuje je wszystkie. Tak wygląda mapa od liczb do liczb:",
                "$~\\{1:1 2:2 3:3}\\",
                "$~Ale powiedzmy, że chcesz się upewnić, że to konkretnie tylko te wartości; po prostu dodaj ! na końcu me, a nie będę generalizować. To pomoże ci wiedzieć, czy próbujesz uzyskać wartość, której nie zamierzałeś.",
                "$~\\{1:1 2:2 3:3}!{4}\\",
                "$~Wiem, jak wiele wspaniałych rzeczy można zrobić dzięki moim parom."
            ],
            "name": ["$~{:}", "$~Mapa"],
            "key": "$~Klawisz",
            "value": "$~Wartość",
            "result": "$~Wynik",
            "function": {
                "size": {
                    "doc": "$~Powiem ci, ile wartości jest we mnie.",
                    "names": "$~rozmiar",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "$~\\{⊤}\\ jeśli moje pary są dokładnie takie same jak podane @Map.",
                        "$~1:1 2:2 = 1:1 2:3"
                    ],
                    "names": ["$~=", "$~równasię"],
                    "inputs": [
                        {
                            "doc": "$~@Map, z którą mogę porównać.",
                            "names": "$~wartość"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "$~\\{⊤}\\ jeśli moje pary /nie/ są dokładnie takie same jak podane @Map.",
                        "$~\\{1:1 2:2} ≠ {1:1 2:3}\\"
                    ],
                    "names": ["$~≠", "$~nierówny"],
                    "inputs": [
                        {
                            "doc": "$~@Map, z którą mogę porównać.",
                            "names": "$~wartość"
                        }
                    ]
                },
                "set": {
                    "doc": [
                        "$~Stworzę nową @Map ze wszystkimi tymi samymi parami, ale z nową parą, którą mi podasz. Jeśli mam już klucz, sparuję go z nową wartością.",
                        "$~\\{'amy': 6 punktów 'tony':3 punkty}.pair('jen' 0 punktów)\\"
                    ],
                    "names": "$~para",
                    "inputs": [
                        {
                            "doc": "$~Klucz do sparowania z wartością.",
                            "names": "$~klawisz"
                        },
                        {
                            "doc": "$~Wartość do sparowania z kluczem",
                            "names": "$~wartość"
                        }
                    ]
                },
                "unset": {
                    "doc": [
                        "$~Stworzę nową @Map bez klucza, który mi podałeś, usuwając jego parowanie.",
                        "$~\\{'amy': 6 punktów 'tony':3 punkty}.unpair('amy')\\"
                    ],
                    "names": "$~rozparować",
                    "inputs": [
                        {
                            "doc": "$~Klucz do zapomnienia.",
                            "names": "$~klawisz"
                        }
                    ]
                },
                "remove": {
                    "doc": [
                        "$~Utworzę nową @Map bez żadnych kluczy, które mają tę wartość.",
                        "$~\\{'amy': 0 punktów 'jen': 0 punktów 'tony':3 punkty}.remove(0 punktów)\\"
                    ],
                    "names": "$~usunąć",
                    "inputs": [
                        {
                            "doc": "$~Wartość do usunięcia ode mnie wraz z kluczami, z którymi jest sparowana.",
                            "names": "$~wartość"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "$~Podaj mi @FunctionDefinition, która przyjmuje klucz i wartość i ocenia na \\⊤\\, jeśli parowanie powinno być zachowane. Utworzę nową @Map, która spełnia Twoje kryteria.",
                        "$~Na przykład tutaj chcemy zachować wszystkie pary, w których jest Amy lub które mają więcej niż zero punktów.",
                        "$~\\{'amy': 0 punktów 'jen': 0 punktów 'tony':3 punkty}.filter(ƒ(klucz•'' wartość•# punktów) (klucz = 'amy') | (wartość > 0 punktów))\\"
                    ],
                    "names": "$~filtr",
                    "inputs": [
                        {
                            "doc": "$~@FunctionDefinition decyduje, czy zachować parowanie.",
                            "names": "$~szachownica"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~Sprawdzany klucz.",
                            "names": "$~klawisz"
                        },
                        {
                            "doc": "$~Sprawdzana wartość.",
                            "names": "$~wartość"
                        },
                        {
                            "doc": "$~Mapa jest filtrowana.",
                            "names": "$~mapa"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "$~Daj mi @FunctionDefinition, która przyjmuje klucz i wartość i ocenia wartość na nową wartość. Utworzę nową @Map z tymi samymi kluczami, ale zaktualizowanymi wartościami.",
                        "$~Na przykład, przyznajmy każdemu po jednym punkcie, bo byli tacy mili.",
                        "$~\\{'amy': 5 punktów 'jen': 3 punkty 'tony': 0 punktów}.translate(ƒ(klucz•'' wartość•# punktów) wartość + 1 punkt)\\"
                    ],
                    "names": "$~tłumaczyć",
                    "inputs": [
                        {
                            "doc": "$~@FunctionDefinition tłumacząca każdą wartość.",
                            "names": "$~tłumacz"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "$~Klucz tłumaczonej wartości.",
                            "names": "$~klawisz"
                        },
                        {
                            "doc": "$~Wartość podlegająca tłumaczeniu.",
                            "names": "$~wartość"
                        },
                        {
                            "doc": "$~Mapa jest tłumaczona.",
                            "names": "$~mapa"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Reprezentacja mapowania w formacie @Text.",
                "set": "$~Klucze @Map",
                "list": "$~Lista wartości w @Map"
            }
        },
        "Table": {
            "doc": [
                "$~Jestem zbiorem wierszy tabeli! Mogę pomóc ci śledzić duże zbiory wartości, które mają tę samą strukturę.",
                "$~Na przykład wyobraź sobie, że chcesz śledzić grupę skał:",
                "$~\\⎡name•'' kolor•''⎦\n⎡'obsydian' 'czarny'⎦\n⎡'pumeks' 'szary'⎦\n⎡'cytrynowy' 'żółty'⎦\\",
                "$~@Bind może pomóc ci to nazwać! A potem możesz zrobić takie rzeczy jak utworzenie poprawionej tabeli z nowym wierszem @Insert:",
                "$~\\rocks: ⎡name•'' color•''⎦\n⎡'obsydian' 'czarny'⎦\n⎡'pumeks' 'szary'⎦\n⎡'cytryn' 'żółty'⎦\nrocks ⎡+ 'kwarc' 'biały'⎦\\",
                "$~Lub jeśli chcesz znaleźć wiersze, które spełniają warunek, możesz @Select wiersze, które spełniają warunek:",
                "$~\\rocks: ⎡name•'' color•''⎦\n⎡'obsydian' 'czarny'⎦\n⎡'pumeks' 'szary'⎦\n⎡'cytryn' 'żółty'⎦\nrocks ⎡?⎦ color = 'szary'\\",
                "$~A może chcesz utworzyć zmienioną tabelę, która będzie miała różne wartości dla wierszy spełniających warunek:",
                "$~\\rocks: ⎡name•'' color•''⎦\n⎡'obsydian' 'czarny'⎦\n⎡'pumeks' 'szary'⎦\n⎡'cytrynowy' 'żółty'⎦\nrocks ⎡: color: 'czarny' ⎦ name = 'pumeks'\\",
                "$~A może chcesz usunąć wiersze spełniające warunek:",
                "$~\\rocks: ⎡name•'' kolor•''⎦\n⎡'obsydian' 'czarny'⎦\n⎡'pumeks' 'szary'⎦\n⎡'cytrynowy' 'żółty'⎦\nrocks ⎡- name.has('i')\\",
                "$~A jeśli kiedykolwiek będziesz chciał uzyskać ode mnie konkretne wartości, możesz przekonwertować dowolną tabelę na listę i uzyskać dostęp do poszczególnych wierszy za pomocą @PropertyReference",
                "$~\\rocks: ⎡name•'' kolor•''⎦\n⎡'obsydian' 'czarny'⎦\n⎡'pumeks' 'szary'⎦\n⎡'cytryn' 'żółty'⎦\n(rocks → [])[1].name\\"
            ],
            "name": ["$~⎡⎦", "$~Tabela"],
            "row": "$~Wiersz",
            "function": {
                "equals": {
                    "doc": "$~Sprawdzam, czy mam dokładnie te same komórki w dokładnie tej samej kolejności, co w innej tabeli @Table.",
                    "names": ["$~=", "$~równasię"],
                    "inputs": [
                        {
                            "doc": "$~Druga tabela do sprawdzenia.",
                            "names": "$~wartość"
                        }
                    ]
                },
                "notequal": {
                    "doc": "$~Sprawdzam, czy któraś z moich komórek różni się od innej tabeli @Table lub czy jest w innej kolejności.",
                    "names": ["$~≠", "$~nieRównasię"],
                    "inputs": [
                        {
                            "doc": "$~Druga tabela do sprawdzenia.",
                            "names": "$~wartość"
                        }
                    ]
                }
            },
            "conversion": {
                "list": "$~Konwertuję @Table na listę wierszy, gdzie każdy wiersz jest @Structure z nazwami kolumn jako właściwościami.",
                "text": "$~Właśnie konwertuję @Table na tekst."
            }
        },
        "Structure": {
            "doc": "$~Zobacz @StructureDefinition.",
            "name": ["$~Struktura"],
            "function": {
                "equals": {
                    "doc": "$~Sprawdzam, czy moje właściwości mają taką samą nazwę i wartości jak właściwości innej struktury.",
                    "names": ["$~=", "$~równasię"],
                    "inputs": [
                        {
                            "doc": "$~Druga struktura do sprawdzenia.",
                            "names": "$~wartość"
                        }
                    ]
                },
                "notequal": {
                    "doc": "$~Sprawdzam, czy moje właściwości różnią się w jakiś sposób od nazwy i wartości innej struktury.",
                    "names": ["$~≠", "$~nieRówne"],
                    "inputs": [
                        {
                            "doc": "$~Druga struktura do sprawdzenia.",
                            "names": "$~wartość"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~Zmieniam się na @Text."
            }
        }
    },
    "input": {
        "Random": {
            "doc": [
                "$~17!",
                "$~/@FunctionDefinition tutaj, wyjaśnię to./",
                "$~Więc @Random jest ciekawą funkcją, która tworzy liczby losowe. Jest ciekawa, ponieważ za każdym razem, gdy ją oceniasz, tworzy coś innego.",
                "$~Tworzy to cudowny chaos, któremu towarzyszy nieprzewidywalność.",
                "$~Domyślnie @Number nadaje wartości pomiędzy \\0\\ i \\1\\:",
                "$~\\Losowy()\\",
                "$~Możesz jednak nadać mu wartość, a on wygeneruje wartości pomiędzy \\0\\ a wartością:",
                "$~\\Losowo(10)\\",
                "$~A jeśli podasz dwie wartości, wygeneruje wartości pomiędzy tymi dwiema wartościami włącznie:",
                "$~\\Losowo(-10 10)\\",
                "$~Jeśli zakresy mają jednostki, zostaną one zachowane (a jeśli nie będą takie same, zostanie użyta jednostka minimalna):",
                "$~\\Losowo(-10m 10m)\\",
                "$~A jeśli podasz liczby z konkretną liczbą cyfr znaczących po przecinku, precyzja ta zostanie zachowana.",
                "$~\\Losowo(1,00 10,00)\\"
            ],
            "names": ["$~🎲", "$~Losowy"],
            "inputs": [
                {
                    "names": "$~min",
                    "doc": "$~Minimalna wartość, która zostanie utworzona, lub jeśli jest większa od 0, wartość maksymalna. Jeśli podano @None, to minimum wynosi \\0\\."
                },
                {
                    "names": "$~maks",
                    "doc": "$~Maksymalna wartość, która zostanie utworzona, lub jeśli jest mniejsza od podanej wartości minimalnej, wartość minimalna. Jeśli podano @None, to wartość maksymalna wynosi \\1\\."
                }
            ]
        },
        "Choice": {
            "doc": [
                "$~/klik!/",
                "$~/@FunctionDefinition tutaj, wyjaśnię to./",
                "$~Pomyśl o @Choice jak o strumieniu @Phrase/name, które są wybierane przez odbiorców. Jeśli ktoś kliknie, stuknie lub wybierze klawiaturę, naciskając /Enter/ na @Phrase z nazwą -- @Choice będzie mieć nową wartość pasującą do nazwy.",
                "$~Najlepszym sposobem na jego wykorzystanie jest utworzenie występu z nazwanymi frazami do wyboru @Phrase, a następnie użycie @Reaction, aby zdecydować, co zrobić po wybraniu tej nazwy.",
                "$~Oto najprostszy przykład:",
                "$~\\Group(\nStack() \n[\nFraza('jeden' do wyboru:⊤ nazwa:'1') \nFraza('dwa' do wyboru:⊤ nazwa:'2') \nFraza(Wybór())\n]\n)\\",
                "$~Skopiuj to do edytora, a następnie wybierz jedną z dwóch @Phrase. Zobaczysz, że trzecia @Phrase pokazuje nazwę, która została wybrana."
            ],
            "names": ["$~🔘", "$~Wybór"]
        },
        "Button": {
            "doc": [
                "$~/klik klik klik/",
                "$~/@FunctionDefinition tutaj, wyjaśnię to./",
                "$~@Button to świetny sposób na słuchanie myszki lub gładzika. Oczywiście myszka lub gładzik nie są idealnym wyborem do słuchania publiczności, ponieważ nie każdy może ich używać. Bardziej dostępnym wyborem jest @Choice.",
                "$~Ale jeśli /naprawdę/ potrzebujesz słuchać przycisku myszy, to jest sposób, aby to zrobić. Zapewni strumień @Boolean, reprezentujący, czy główny przycisk jest w pozycji w górę \\⊥\\ czy w dół \\⊤\\.",
                "$~Oto prosty przykład:",
                "$~\\Fraza(Przycisk() → '')\\",
                "$~To po prostu tworzy @Phrase, która jest wartością strumienia jako tekst. Jeśli skopiujesz ją do edytora i klikniesz, zobaczysz, że przełącza się ona tam i z powrotem między \\⊥\\ i \\⊤\\."
            ],
            "names": ["$~🖱️", "$~Przycisk"],
            "down": {
                "names": "$~wdół",
                "doc": "$~Jeśli @None, strumień dostarczy zarówno wartości w górę, jak i w dół. Jeśli @Boolean, dostarczy tylko wartość podaną @Boolean."
            }
        },
        "Pointer": {
            "doc": [
                "$~/wrrrrrr/",
                "$~/@FunctionDefinition tutaj, wyjaśnię to./",
                "$~Znasz myszy, gładziki i ekrany dotykowe? Czasami chcesz wiedzieć, gdzie wskazuje publiczność. To właśnie zapewnia @Pointer.",
                "$~Oczywiście, nie jest to dostępny wybór: nie każdy może to zobaczyć lub łatwo wskazać, więc upewnij się, że nie wykluczasz nikogo z uczestnictwa, korzystając z tej transmisji.",
                "$~Jeśli masz pewność, że nikt nie został wykluczony, użycie @Pointer jest tak proste, jak utworzenie strumienia:",
                "$~\\Wskaźnik()\\",
                "$~@Place, które podaje, będzie odpowiadać miejscu, w którym na @Stage wskazuje wskaźnik."
            ],
            "names": ["$~👆🏻", "$~Wskaźnik"]
        },
        "Key": {
            "doc": [
                "$~/klik/",
                "$~/@FunctionDefinition tutaj, wyjaśnię to./",
                "$~Klawiatury mają dużo klawiszy, prawda? @Key powie Ci, który klawisz ktoś naciska i puszcza.",
                "$~Spróbuj tego",
                "$~\\Klawisz()\\",
                "$~Widzisz, jak po wpisaniu klawisza pojawia się on na @Stage? Za każdym razem, gdy klawisz jest wciśnięty, do strumienia dodawany jest nowy @Text, opisujący wciśnięty klawisz.",
                "$~W przypadku klucza reprezentującego znak wartością będzie znak @Text.",
                "$~W przypadku klawiszy specjalnych, takich jak /Escape/, będzie to @Text opisujący klawisz, przy użyciu <wstępnie zdefiniowanej nazwy@https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values>, niestety dostępnej tylko w języku angielskim.",
                "$~Jeśli chcesz dowiedzieć się czegoś o konkretnym kluczu, możesz go podać:",
                "$~\\Klucz('a')\\",
                "$~A jeśli chcesz wiedzieć tylko, kiedy @Key został zwolniony, a nie naciśnięty, możesz podać @Boolean:",
                "$~\\Klucz('a' ⊥)\\"
            ],
            "names": ["$~⌨️", "$~Klawisz"],
            "key": {
                "names": "$~klawisz",
                "doc": "$~Jeśli @None, to wszystkie klucze są dostarczane. Jeśli @Text to konkretny, to tylko ten klucz jest dostarczany."
            },
            "down": {
                "names": "$~wdół",
                "doc": "$~JEŚLI @None, to klawisz down generuje dane wejściowe. Jeśli \\⊤\\, to dostarczane są tylko dane wejściowe down, a jeśli \\⊥\\, to dostarczane są tylko dane wejściowe release."
            }
        },
        "Time": {
            "doc": [
                "$~/tykanie tykanie tykanie/",
                "$~Tutaj @FunctionDefinition, wyjaśnię @Time, ponieważ ono nie mówi.",
                "$~Czas jest strumieniem, który płynie z określoną częstotliwością.",
                "$~Za każdym razem, gdy tak się dzieje, @Program dokonuje ponownej oceny z nową wartością czasu.",
                "$~Na przykład:",
                "$~\\Czas()\\",
                "$~Jeśli podasz czas @Time/frequency, będzie on tykał z tą częstotliwością. Na przykład:",
                "$~\\Czas(1000ms)\\",
                "$~Istnieją jednak pewne ograniczenia co do jego wielkości, ponieważ @Program potrzebuje czasu na ocenę, zanim będzie mógł odpowiedzieć na kolejny sygnał.",
                "$~Najmniejszy jest prawdopodobnie w okolicach \\20ms\\."
            ],
            "names": ["$~🕕", "$~Czas"],
            "frequency": {
                "names": ["$~częstotliwość"],
                "doc": "$~To jest częstotliwość, z jaką czas powinien tykać. Domyślnie jest to \\33ms\\, co odpowiada około 30 razy na sekundę."
            },
            "relative": {
                "names": ["$~względny"],
                "doc": "$~Jeśli \\⊤\\, czas zaczyna się od 0, kiedy program jest po raz pierwszy oceniany. W przeciwnym wypadku zaczyna się od liczby milisekund od początku dnia, UTC (Coordinated Universal Time), co pozwala śledzić czas dnia."
            }
        },
        "Volume": {
            "doc": [
                "$~/bzzzzzzzz/",
                "$~Tutaj @FunctionDefinition, biorę mikrofon.",
                "$~Ten strumień to seria woluminów od 0 do 1, próbkowana z częstotliwością Twojego wyboru. Domyślnie częstotliwość wynosi \\30 Hz\\, czyli 30 razy na sekundę, ale możesz ją zmienić na mniej rzadką.",
                "$~\\Tom()\\",
                "$~To świetne narzędzie, żeby posłuchać, jak głośna jest publiczność!"
            ],
            "names": ["$~🎤", "$~Tom"],
            "frequency": {
                "names": ["$~częstotliwość"],
                "doc": "$~Czas pomiędzy pobraniami próbek."
            }
        },
        "Pitch": {
            "doc": [
                "$~/hummmm/",
                "$~Tutaj @FunctionDefinition. Porozmawiajmy o ofercie!",
                "$~Ten strumień to seria częstotliwości w hercach, wskazująca wysokość dźwięku, próbkowana na częstotliwości twojego wyboru. Odkryliśmy, że głos ludzki ma od 20 Hz do 5000 Hz, więc planuj liczby w tym zakresie.",
                "$~\\Poziom()\\",
                "$~To świetne narzędzie, jeśli chcesz posłuchać tonu głosu osoby mówiącej lub śpiewającej."
            ],
            "names": ["$~🎵", "$~Poziom"],
            "frequency": {
                "names": ["$~częstotliwość"],
                "doc": "$~Czas pomiędzy pobraniami próbek."
            }
        },
        "Camera": {
            "doc": [
                "$~/bzzzzzzzz/",
                "$~@FunctionDefinition tutaj, mogę wyjaśnić @Camera!",
                "$~Więc @Camera dostarcza @List of @Color z twojego świata. Ta lista zasadniczo reprezentuje obraz, ale to od ciebie zależy, co z nim zrobisz.",
                "$~Możesz spróbować przedstawić obraz za pomocą @Phrase, co mogłoby wyglądać całkiem fajnie! Spróbuj skopiować to...",
                "$~\\colors: Kamera(32px 24px 33ms)\n\nScena(\ncolors.combine(\n[] \nƒ(frazy•[Fraza] wiersz•[Kolor] y•#) \nfrazy.append(\nrow.translate(\nƒ(kolor•Kolor x•#)\nFraza('o' miejsce: Miejsce((x - 1) · 0,5m y · -0,5m) kolor: czas trwania koloru: 0s\n)\n)\n)\n)\n)\n)\\",
                "$~Można też analizować kolory, aby zdecydować, czy światło było włączone czy wyłączone, albo czy dany kolor był powszechny. W ten sposób widzowie mogą wpływać na występ za pomocą pokazywanych kolorów."
            ],
            "names": ["$~🎥", "$~Kamera"],
            "width": {
                "names": ["$~szerokość"],
                "doc": "$~Liczba kolorów @Color do pobrania w jednym rzędzie."
            },
            "height": {
                "names": ["$~wysokość"],
                "doc": "$~Liczba kolorów @Color do pobrania w kolumnie."
            },
            "frequency": {
                "names": ["$~częstotliwość"],
                "doc": "$~Czas pomiędzy próbkami @Color."
            }
        },
        "Scene": {
            "doc": [
                "$~/Buu ...",
                "$~/Cześć, @FunctionDefinition tutaj! Widzę, że znalazłeś @Scene.",
                "$~Myślę, że @Scene jest szczególnie fajne. Podstawowy pomysł polega na tym, że podajesz mu listę @Phrase lub @Group, a następnie pokazuje je w kolejności i zatrzymuje się na ostatnim.",
                "$~Aby kontrolować czas, możesz ustawić @Phrase/duration na każdym wyjściu, a ono będzie je wyświetlać przez taki czas przed przejściem do następnego, i użyć dowolnych przejść @Phrase/entering lub @Phrase/exiting, które ustawiłeś. Jeśli ustawisz je na @Sequence, użyje ich czasu trwania.",
                "$~Wszystko to pozwala na wykonywanie takich czynności jak ta mała @Scene, która pokazuje te trzy frazy w kolejności:",
                "$~\\Scene([\nFraza('Witaj' czas trwania: 1s)\nFraza('Jak się masz?' czas trwania: 2s obrót: 5° wejście: Poza(obrót: 0°))\nFraza('Czuję się dobrze')\n])\\",
                "$~Widzisz, jak pierwszy wynik jest wyświetlany przez sekundę, potem drugi przez dwie sekundy, ale animowany w obrocie o pięć stopni, a potem pokazuje ostatni?",
                "$~Za pomocą @Scene można tworzyć bardzo skomplikowane sekwencje wyników i animacji, a nawet nadawać ich fragmentom charakter dynamiczny lub interaktywny, tak jak w przypadku innych @Phrase lub @Group.",
                "$~Jeśli masz zagnieżdżone animowane wyjście (@Group z animowaną @Group w środku), @Scene będzie czekać, aż cała animowana zawartość w @Group się zakończy.",
                "$~O, i jeszcze jeden mały sekret! Możesz nawet umieścić @Boolean na liście, a jeśli są \\⊥\\, @Scene zatrzyma się i zaczeka, aż stanie się prawdą.",
                "$~Na przykład, jeśli chcesz utworzyć sekwencję @Phrase i przechodzić do niej tylko wtedy, gdy @Button się zmieni, możesz zrobić tak:",
                "$~\\click: ∆ Button()\nScena([\nFraza('Witaj')\nkliknij\nFraza('Jak się masz?' czas trwania: 0,25 s obrót: 5° wejście: Poza(obrót: 0°))\nkliknij\nFraza('Czuję się dobrze')\n])\\",
                "$~Widzisz, jak zatrzymuje się po każdym @Phrase i czeka na zmianę @Button, zanim przejdzie dalej?"
            ],
            "names": ["$~🎬", "$~Scena"],
            "outputs": {
                "names": "$~wyjścia",
                "doc": "$~Lista wyników do wyświetlenia w kolejności."
            }
        },
        "Motion": {
            "doc": [
                "$~/boing boing boing/",
                "$~/Cześć! Tutaj @FunctionDefinition. Może wyjaśnię @Motion?",
                "$~Zasadniczo @Motion jest strumieniem @Phrase. Dajesz mu początkowe @Phrase, a następnie udoskonala je za pomocą nowego miejsca i obrotu na podstawie grawitacji.",
                "$~Dzięki temu możesz wykonywać naprawdę proste rzeczy, na przykład tworzyć skaczące emotikony:",
                "$~\\Motion(Fraza('o') miejsce początkowe: Miejsce(0m 10m))\\",
                "$~Widzisz jak o odbija się? Podczas pierwszej oceny dajemy mu miejsce wysoko na @Stage, ale potem otrzymuje @None, co pozwala @Motion zmienić je na dowolną pozycję, jaką umieściłaby grawitacja.",
                "$~Sprawdź poniżej wiele innych sposobów konfiguracji."
            ],
            "names": ["$~⚽️", "$~Ruch"],
            "place": {
                "doc": "$~Miejsce startu.",
                "names": "$~miejsce"
            },
            "velocity": {
                "doc": "$~Prędkość początkowa",
                "names": "$~prędkość"
            },
            "nextplace": {
                "doc": "$~Następne miejsce, nadrzędna fizyka.",
                "names": "$~następnemiejsce"
            },
            "nextvelocity": {
                "doc": "$~Następne miejsce, nadrzędna prędkość.",
                "names": "$~następnaprędkość"
            }
        },
        "Chat": {
            "doc": [
                "$~/Cześć! Tutaj @FunctionDefinition. Więc chcesz pogadać?",
                "$~Podstawowym założeniem transmisji czatu jest to, że odbiorcy piszą wiadomość, a następnie program na nią odpowiada.",
                "$~Na przykład ten prosty program sprawdza, czy wiadomość to 'hello', a jeśli tak, program ocenia ją jako 'hi'. W przeciwnym razie ocenia ją jako 'huh'?",
                "$~\\Chat().has('hello') ? 'cześć!' 'co?'\\",
                "$~To wszystko! Możesz tworzyć wszelkiego rodzaju występy, takie jak boty czatowe, przygody tekstowe lub schematy sterowania oparte na tekście dla innych rodzajów występów."
            ],
            "names": ["$~🗣️", "$~Pogawędzić"]
        },
        "Placement": {
            "doc": [
                "$~/Hej, tutaj @FunctionDefinition. Porozmawiajmy o tym, jak nas ruszyć!/",
                "$~Więc jest wiele sposobów, aby umieścić nas na @Stage. Możesz podać nam wyraźne @Place. Możesz użyć @Motion i pozwolić grawitacji wykonać swoją pracę. Możesz również umieścić nas w @Group i pozwolić im ułożyć nas w określony sposób.",
                "$~Ale czasami chcesz dać /publiczności/ kontrolę nad tym, gdzie jesteśmy na @Stage. Właśnie do tego służy @Placement.",
                "$~Oto jak to działa: po prostu tworzysz @Placement i przekazujesz go naszemu @Place:",
                "$~\\Phrase('hi' miejsce: Umieszczenie())\\",
                "$~Następnie za każdym razem, gdy publiczność użyje klawisza strzałki lub kliknie albo dotknie sceny, @Placement utworzy nowe @Place, które przesunie się w pożądanym kierunku.",
                "$~Spróbuj skopiować to do swojego programu i przesuwać nas zgodnie ze strzałką za pomocą wskaźnika lub klawiatury.",
                "$~Możesz dostosować @Placement, włączając i wyłączając ruch w określonych wymiarach, zmieniając odległość, na jaką przesuwa się @Place, a także początkowe @Place, od którego rozpoczyna się strumień."
            ],
            "names": ["$~✥", "$~Umieszczenie"],
            "inputs": [
                {
                    "doc": "$~Miejsce, od którego należy zacząć.",
                    "names": "$~start"
                },
                {
                    "doc": "$~O ile metrów miejsce powinno się przesunąć, gdy publiczność poprosi o ruch.",
                    "names": "$~dystans"
                },
                {
                    "doc": "$~Jeśli true, pozwala na ruch na osi poziomej. Domyślnie włączone.",
                    "names": "$~poziomy"
                },
                {
                    "doc": "$~Jeśli true, pozwala na ruch na osi pionowej. Domyślnie włączone.",
                    "names": "$~pionowy"
                },
                {
                    "doc": "$~Jeżeli wartość jest równa prawda, umożliwia ruch na osi Z za pomocą klawiszy + i -.",
                    "names": "$~głębokość"
                }
            ]
        },
        "Webpage": {
            "doc": [
                "$~/Hej, tutaj @FunctionDefinition. Porozmawiajmy o tym, jak pobierać strony internetowe z Internetu!/",
                "$~Kiedy pierwszy raz usłyszeliśmy o twoim internecie, uznaliśmy go za fascynujący. Cały świat pełen połączonych komputerów wymieniających się dokumentami? To niesamowite!",
                "$~Więc stworzyliśmy strumień, który się z nim łączy. Podajesz nam adres URL, a my otrzymamy cały tekst. Tak jak tutaj:",
                "$~\\Strona internetowa('https://wordplay.dev')\\",
                "$~I jest podobno coś takiego jak <CSS@https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/What_is_CSS>, co lubi, gdy pytasz o rzeczy na stronie internetowej? Podaj nam zapytanie wyboru CSS, a my otrzymamy tylko tekst, który pasuje do tego zapytania. Jak w tym przykładzie, który otrzymuje nagłówki pierwszego poziomu.",
                "$~\\Strona internetowa('https://wordplay.dev' 'h1')\\",
                "$~Wiele rzeczy może pójść nie tak. Jeśli stracisz połączenie internetowe, lub adres URL nie będzie się rozwiązywał do niczego, lub adres URL nie będzie publiczny, lub adres URL nie będzie stroną HTML... Wszystkie te rzeczy mogą prowadzić do wyjątku. Jeśli znajdziesz stronę, która działa, otrzymasz @Number wskazujący procent ukończenia, a następnie @Number słów na stronie."
            ],
            "names": ["$~🔗", "$~Stronainternetowa"],
            "url": {
                "doc": "$~Adres URL strony internetowej HTML, którą należy pobrać.",
                "names": "$~adresURL"
            },
            "query": {
                "doc": "$~Zapytanie CSS do oceny w HTML",
                "names": "$~zapytanie"
            },
            "frequency": {
                "doc": "$~Liczba minut, które powinny upłynąć, zanim strona zostanie ponownie pobrana.",
                "names": "$~częstotliwość"
            },
            "error": {
                "invalid": "$~to nie jest prawidłowy adres URL",
                "unvailable": "$~ten adres URL jest niedostępny",
                "notHTML": "$~odpowiedź nie była w formacie HTML",
                "noConnection": "$~brak połączenia z Wordplay",
                "limit": "$~zbyt wiele żądań do tej domeny"
            }
        },
        "Collision": {
            "names": "$~Kolizja",
            "doc": [
                "$~/Cześć! Tutaj @FunctionDefinition. Sprawdź ten fajny wpis./",
                "$~Może pomóc ci dowiedzieć się, kiedy @Output wpadnie na siebie! To świetny sposób, aby zrobić coś, kiedy wpadniemy na siebie, poza normalnym odbijaniem się od siebie, jakie może zrobić @Output.",
                "$~Po prostu podaj mi nazwę @Output, a ja stworzę nową wartość @Rebound, gdy napotka inną nazwę. @Rebound ma informacje o nazwach, które się zderzyły, i kierunku ich kolizji.",
                "$~A jeśli podasz mi dwie nazwy, to utworzę nową wartość tylko wtedy, gdy nazwy będą się ze sobą stykać.",
                "$~Zaraz po tym, jak stworzę nową wartość, stworzę \\ø\\, ponieważ kolizja jest zakończona po jej wystąpieniu. Oznacza to, że nie ma już więcej kolizji."
            ],
            "subject": {
                "names": "$~temat",
                "doc": "$~Nazwa @Output, w której mam szukać kolizji."
            },
            "object": {
                "names": "$~Inny",
                "doc": "$~Nazwa drugiego @Output, w którym mam szukać kolizji."
            }
        },
        "Rebound": {
            "names": "$~Odskok",
            "doc": "$~Pochodzę z @Collision i reprezentuję to, z kim doszło do zderzenia i w którym kierunku zderzenie nastąpiło. Użyj mnie, aby zdecydować, czy zareagować na zderzenie w jakiś specjalny sposób, inny niż normalna fizyka.",
            "direction": {
                "names": "$~kierunek",
                "doc": "$~Kierunek i wielkość zderzenia w stosunku do przedmiotu zderzenia"
            },
            "subject": {
                "names": "$~temat",
                "doc": "$~Nazwa wyjścia, które zostało wywołane przez podmiot."
            },
            "object": {
                "names": "$~obiekt",
                "doc": "$~Nazwa wyjścia, które trafiło w temat"
            }
        },
        "Direction": {
            "names": "$~Kierunek",
            "doc": "$~Jestem kierunkiem i wielkością wzdłuż osi x i y.",
            "x": {
                "names": "$~X",
                "doc": "$~Kierunek i wielkość kierunku wzdłuż osi x."
            },
            "y": {
                "names": "$~y",
                "doc": "$~Kierunek i wielkość kierunku wzdłuż osi y."
            }
        }
    },
    "output": {
        "Output": {
            "names": "$~Wyjście",
            "doc": [
                "$~Nie jestem @StructureDefinition, którą możesz faktycznie stworzyć. Ale jestem bardzo ważną osobą, ponieważ inspiruję najważniejsze elementy naszego tańca: @Phrase, @Group i @Stage.",
                "$~Spotkaj się z nimi i dowiedz się więcej na temat ich wykorzystania."
            ]
        },
        "Group": {
            "doc": [
                "$~O cześć, jak się masz? Zawsze jest dobrze, gdy inni są w pobliżu, więc fajnie być z tobą!",
                "$~Grupuję @Phrase i @Group na @Stage i umieszczam je w @Arrangement, dzięki czemu są rozmieszczone w określonej kolejności.",
                "$~Aby to zadziałało, potrzebuję, abyś dał mi @Arrangement, a następnie @List of @Output do zaaranżowania.",
                "$~Na przykład tutaj mam układ @Stack i kilka @Phrase do ułożenia w pionie:",
                "$~\\Group(Stack() [Fraza('pierwsza') Fraza('druga')])\\",
                "$~To, jak dokładnie wszystko uporządkuję, zależy od @Arrangement, który mi podasz."
            ],
            "names": ["$~🔳", "$~Grupa"],
            "layout": {
                "doc": "$~Sposób użycia w celu umieszczenia @Output w odpowiednich miejscach.",
                "names": "$~układ"
            },
            "content": {
                "doc": "$~Lista @Output do uporządkowania.",
                "names": "$~treść"
            },
            "matter": {
                "doc": "$~Jak powinienem zareagować, gdybym zderzył się z czymś innym, materią.",
                "names": "$~materiał"
            },
            "size": {
                "doc": "$~Jak wysoka powinna być cudowna treść we mnie, gdyby nie miała własnego rozmiaru!",
                "names": "$~rozmiar"
            },
            "face": {
                "doc": "$~Nazwę czcionki, którą powinienem mieć w środku, chyba że mam własną czcionkę do wykorzystania.",
                "names": "$~twarz"
            },
            "place": {
                "doc": "$~Miejsce na scenie, w którym powinienem być. Treść we mnie będzie ułożona w stosunku do tego miejsca.",
                "names": "$~miejsce"
            },
            "name": {
                "doc": ["$~To samo co @Phrase/name!"],
                "names": "$~nazwa"
            },
            "description": {
                "doc": [
                    "$~Opis przeznaczony dla odbiorców, którzy nie mogą zobaczyć treści wizualnych."
                ],
                "names": "$~opis"
            },
            "selectable": {
                "doc": "$~Tak samo jak @Phrase/selectable!",
                "names": "$~wybieralny"
            },
            "color": {
                "doc": "$~@Color to kolor, jaki powinna mieć zawartość we mnie, chyba że ma ona swój własny kolor.",
                "names": "$~kolor"
            },
            "background": {
                "doc": "$~@Color do wyświetlenia za mną.",
                "names": "$~tło"
            },
            "opacity": {
                "doc": "$~Jak przejrzyste powinno być wszystko we mnie, pomiędzy \\0\\ i \\1\\, chyba że jest nadpisane przez inną @Pose.",
                "names": "$~nieprzezroczystość"
            },
            "offset": {
                "doc": "$~@Place wskazujące, jak bardzo powinno być przesunięte od mojego normalnego @Place, chyba że zastąpione innym @Pose. Pomocne przy poruszaniu się w miejscu.",
                "names": "$~zrównoważyć"
            },
            "rotation": {
                "doc": "$~Jak bardzo powinienem pochylić się wokół środka, mój @Pose ma inne.",
                "names": ["$~📐", "$~obrót"]
            },
            "scale": {
                "doc": "$~Jak duży powinienem być w stosunku do mojego oryginalnego rozmiaru.",
                "names": "$~skala"
            },
            "flipx": {
                "doc": "$~Tak samo jak @Phrase/flipx!",
                "names": "$~flipx"
            },
            "flipy": {
                "doc": "$~Tak samo jak @Phrase/flipy",
                "names": "$~chytry"
            },
            "entering": {
                "doc": "$~Tak samo jak @Phrase/entering!",
                "names": "$~wstępowanie"
            },
            "resting": {
                "doc": "$~Tak samo jak @Phrase/resting!",
                "names": "$~spoczynkowy"
            },
            "moving": {
                "doc": "$~Tak samo jak @Phrase/moving!",
                "names": "$~poruszający"
            },
            "exiting": {
                "doc": "$~Tak samo jak @Phrase/exiting!",
                "names": "$~wychodzenie"
            },
            "duration": {
                "doc": "$~Tak samo jak @Phrase/duration!",
                "names": ["$~⏳", "$~czastrwania"]
            },
            "style": {
                "doc": "$~Tak samo jak @Phrase/style!",
                "names": "$~styl"
            },
            "defaultDescription": "$~$1[$1|] $2 $3"
        },
        "Phrase": {
            "doc": [
                "$~Cześć, cześć! Pamiętasz mnie? Jak ktoś mógłby zapomnieć /me/. Tak, jestem wspaniałym @Phrase, gotowym reprezentować najpiękniejsze @Text na @Stage.",
                "$~Zrób mi to po prostu tak, a pojawię się na @Stage:",
                "$~\\Phrase('wspaniały!')\\",
                "$~Oczywiście potrzebuję @Text, ale poza tym mogę robić wszystko, co @Output potrafi, łącznie ze zmianą rozmiaru, czcionki, obrotu i wykonywaniem wszystkich moich niesamowitych tańców za pomocą @Pose i @Sequence.",
                "$~Możesz również wybrać mnie na @Stage i edytować na palecie obok."
            ],
            "names": ["$~💬", "$~Wyrażenie"],
            "text": {
                "doc": "$~Postacie do pokazania na @Stage.",
                "names": "$~tekst"
            },
            "size": {
                "doc": "$~Jak wysoki powinienem być, w metrach!",
                "names": "$~rozmiar"
            },
            "face": {
                "doc": "$~Nazwa czcionki, którą powinienem zastosować.",
                "names": "$~twarz"
            },
            "place": {
                "doc": "$~Miejsce na scenie, w którym powinienem być.",
                "names": "$~miejsce"
            },
            "wrap": {
                "doc": "$~Krawędź, przy której powinienem zawijać symbole lub \\ø\\, jeśli nie powinienem ich zawijać.",
                "names": ["$~↵", "$~zawinąć"]
            },
            "alignment": {
                "doc": "$~Jeśli ustawiono granicę @Phrase/wrap, określa ona, czy symbole należy wyrównać do początku, środka czy końca krawędzi.",
                "names": "$~wyrównanie"
            },
            "direction": {
                "doc": "$~Czy symbole są pisane poziomo czy pionowo, a także czy tekst jest zawijany w lewo czy w prawo, jeśli ustawiono opcję @Phrase/wrap.",
                "names": "$~kierunek"
            },
            "matter": {
                "doc": "$~Właściwości, których należy użyć, gdy w coś uderzę!",
                "names": "$~materiał"
            },
            "aura": {
                "doc": "$~Opcjonalnie @Aura do pokazania za mną. Spraw, żebym zajaśniała!",
                "names": "$~aura"
            },
            "name": {
                "doc": [
                    "$~Imię, które mi dasz! To jest pomocne w wielu sprawach.",
                    "$~Po pierwsze, jeśli mam imię, będę go używać do opisywania siebie w opisach czytników ekranowych.",
                    "$~Po drugie, podczas animacji możesz mieć wiele różnych wyrażeń, które mają reprezentować tę samą treść na scenie; nadaj im tę samą nazwę, a będą animowane jako jedna całość.",
                    "$~Na koniec dodam, że pomagam @Choice: podane przez Ciebie nazwy pojawiają się w tym strumieniu.",
                    "$~Możesz podać mi wiele różnych nazw, każdą w innym języku, jeśli to pomoże. Zawsze będę używać nazwy w pierwszym wybranym miejscu."
                ],
                "names": "$~nazwa"
            },
            "description": {
                "doc": [
                    "$~Niestandardowy opis przeznaczony dla odbiorców, którzy nie mogą zobaczyć treści wizualnych."
                ],
                "names": "$~opis"
            },
            "selectable": {
                "doc": "$~Jeśli \\⊤\\, oznacza to, że można mnie wybrać za pomocą wskaźnika lub klawiatury.",
                "names": "$~wybieralny"
            },
            "color": {
                "doc": "$~@Color I powinien być domyślny, chyba że zostanie zastąpiony innym @Pose.",
                "names": "$~kolor"
            },
            "background": {
                "doc": "$~@Color do wyświetlenia za mną.",
                "names": "$~tło"
            },
            "opacity": {
                "doc": "$~Jak przezroczysty powinienem być domyślnie, między \\0\\ i \\1\\, chyba że zastąpiony innym @Pose. Pomocne przy zanikaniu i pojawianiu się.",
                "names": "$~nieprzezroczystość"
            },
            "offset": {
                "doc": "$~@Place wskazujące, jak bardzo powinno być przesunięte od mojego @Place, chyba że zastąpione innym @Pose. Pomocne przy poruszaniu się w miejscu.",
                "names": "$~zrównoważyć"
            },
            "rotation": {
                "doc": "$~Wartość w stopniach I powinna zostać obrócona wokół swojego środka, chyba że zostanie zastąpiona inną wartością @Pose.",
                "names": "$~obrót"
            },
            "scale": {
                "doc": "$~Jak bardzo powiększony powinien być obraz I w stosunku do jego oryginalnego rozmiaru, chyba że zostanie zastąpiony innym @Pose.",
                "names": "$~skala"
            },
            "flipx": {
                "doc": "$~Czy powinienem być odbity na osi x, chyba że zastąpiony innym @Pose.",
                "names": "$~flipx"
            },
            "flipy": {
                "doc": "$~Czy powinienem być odbity na osi y, chyba że zastąpiony innym @Pose.",
                "names": "$~chytry"
            },
            "entering": {
                "doc": "$~@Pose lub @Sequence, którą powinienem wykonać po wejściu na scenę.",
                "names": "$~wstępowanie"
            },
            "resting": {
                "doc": "$~@Pose lub @Sequence, które powinienem wykonać po wejściu na scenę, przed wyjściem, a moje @Place się nie zmienia. Jeśli mi nie podasz, po prostu użyję swoich domyślnych ustawień.",
                "names": "$~spoczynkowy"
            },
            "moving": {
                "doc": "$~@Pose lub @Sequence powinienem stosować przy zmianie miejsca na scenie, zamiast moich domyślnych ustawień.",
                "names": "$~poruszający"
            },
            "exiting": {
                "doc": "$~@Pose lub @Sequence należy wykonać przed opuszczeniem sceny.",
                "names": "$~wychodzenie"
            },
            "duration": {
                "doc": "$~Czas trwania obowiązujący przy przechodzeniu w inne miejsce na scenie.",
                "names": ["$~⏳", "$~czastrwania"]
            },
            "style": {
                "doc": "$~Styl animacji stosowany przy przechodzeniu w inne miejsce sceny.",
                "names": "$~styl"
            },
            "defaultDescription": "$~$3[$3 metr |]fraza $1 $2[nazwana $2|] $4[$4|] $5"
        },
        "Arrangement": {
            "doc": "$~Jestem inspiracją dla wielu innych rodzajów aranżacji w Verse, w tym @Row, @Stack, @Grid i @Free. Współpracuję ściśle z @Group, aby",
            "names": ["$~⠿", "$~Układ"]
        },
        "Row": {
            "doc": "$~Jestem @Row, poziomym @Arrangement @Output, z opcjonalnym wypełnieniem pomiędzy. Czy poznałeś mojego bliźniaka, @Stack?",
            "names": ["$~➡", "$~Wiersz"],
            "description": "$~wiersz $1 fraz i grup",
            "alignment": {
                "doc": "$~Czy tekst ma być wyrównany na początku, na środku czy na końcu każdej kolumny.",
                "names": "$~wyrównanie"
            },
            "padding": {
                "doc": "$~Ilość wypełnienia, jakie należy umieścić pomiędzy danymi wyjściowymi.",
                "names": "$~wyściółka"
            }
        },
        "Stack": {
            "doc": "$~Jestem @Stack, pionowym @Arrangement @Output, z opcjonalnym wypełnieniem pomiędzy. Czy poznałeś mojego bliźniaka, @Row?",
            "names": ["$~⬇", "$~Stos"],
            "description": "$~stos fraz i grup za 1$",
            "alignment": {
                "doc": "$~Czy tekst ma być wyrównany na początku, na środku czy na końcu każdego wiersza.",
                "names": "$~wyrównanie"
            },
            "padding": {
                "doc": "$~Ilość wypełnienia, jakie należy umieścić pomiędzy danymi wyjściowymi.",
                "names": "$~wyściółka"
            }
        },
        "Grid": {
            "doc": "$~Jestem siatką @Output. Podaj mi liczbę wierszy i kolumn, a ja zrobię uporządkowany układ z opcjonalnym wypełnieniem i rozmiarami komórek.",
            "names": ["$~▦", "$~Siatka"],
            "description": "$~$1 wiersz $2 kolumny siatka",
            "rows": {
                "doc": "$~Ile wierszy ma być w siatce.",
                "names": "$~wydziwianie"
            },
            "columns": {
                "doc": "$~Ile kolumn ma być w siatce.",
                "names": "$~kolumny"
            },
            "padding": {
                "doc": "$~Ile wypełnienia umieścić pomiędzy komórkami.",
                "names": "$~wyściółka"
            },
            "cellWidth": {
                "doc": "$~Jak szerokie powinny być komórki.",
                "names": "$~szerokośćkomórki"
            },
            "cellHeight": {
                "doc": "$~Jak wysokie powinny być cele.",
                "names": "$~wypełnieniekomórek"
            }
        },
        "Free": {
            "doc": [
                "$~Ja jestem jak, cokolwiek. Siadaj gdziekolwiek chcesz. Po prostu usiądź gdzieś! Upewnij się, że wszystkie @Output, które mi dajesz, mają @Place, inaczej nie będą wiedzieć, dokąd iść.",
                "$~O, i pamiętaj, że @Place, które nadajesz każdemu @Output, jest względne w stosunku do @Place @Group! Więc jeśli zastanawiasz się, dlaczego rzeczy nie pojawiają się tam, gdzie się spodziewasz, spróbuj również nadać @Group miejsce."
            ],
            "names": ["$~Bezpłatny"],
            "description": "$~wyjścia $1 w dowolnej formie"
        },
        "Shape": {
            "doc": "$~Jestem inspiracją dla wszystkich kształtów. Jestem użyteczna, by powiedzieć @Stage, jaki kształt ma mieć.",
            "names": ["$~⬟", "$~Kształt"],
            "form": {
                "doc": "$~Jestem typem kształtu, który należy pokazać. Każdy kształt wymaga innych informacji, aby zdefiniować jego układ.",
                "names": "$~formularz"
            },
            "name": {
                "doc": "$~Jestem nazwą, której możesz używać do animacji i @Collision. Na przykład, jeśli reprezentujesz podłoże, możesz chcieć nazwać mnie „ground”.",
                "names": "$~nazwa"
            },
            "description": {
                "doc": [
                    "$~Opis przeznaczony dla odbiorców, którzy nie mogą zobaczyć treści wizualnych."
                ],
                "names": "$~opis"
            },
            "selectable": {
                "doc": "$~Czy mogę zostać wybrany/a do programu @Choice.",
                "names": "$~wybieralny"
            },
            "color": {
                "doc": "$~Kolor moich obramowań.",
                "names": "$~kolor"
            },
            "background": {
                "doc": "$~Kolor mojego tła.",
                "names": "$~tło"
            },
            "opacity": {
                "doc": "$~Jak bardzo powinienem być transparentny.",
                "names": "$~nieprzezroczystość"
            },
            "offset": {
                "doc": "$~Jak daleko od mojego miejsca powinienem się wydawać, pozostając na miejscu.",
                "names": "$~zrównoważyć"
            },
            "rotation": {
                "doc": "$~Jak bardzo powinienem być obrócony. To wpływa na @Collision.",
                "names": "$~obrót"
            },
            "scale": {
                "doc": "$~Jak bardzo powinienem być powiększony, nie zmieniając przy tym swojego rzeczywistego rozmiaru.",
                "names": "$~skala"
            },
            "flipx": {
                "doc": "$~Czy mam odbić mnie na osi x.",
                "names": "$~flipx"
            },
            "flipy": {
                "doc": "$~Czy mam odbić mnie lustrzanie na osi y.",
                "names": "$~chytry"
            },
            "entering": {
                "doc": "$~@Pose lub @Sequence należy wykonać przy wejściu do @Stage.",
                "names": "$~wstępowanie"
            },
            "resting": {
                "doc": "$~@Pose lub @Sequence należy wykonać po wejściu i gdy się nie ruszam.",
                "names": "$~spoczynkowy"
            },
            "moving": {
                "doc": "$~@Pose lub @Sequence, które powinienem zastosować przy zmianie miejsca.",
                "names": "$~poruszający"
            },
            "exiting": {
                "doc": "$~@Pose lub @Sequence, które powinienem wykonać opuszczając @Stage.",
                "names": "$~wychodzenie"
            },
            "duration": {
                "doc": "$~Ile czasu powinny trwać animacje, jeśli są pojedynczą edycją @Pose.",
                "names": "$~czastrwania"
            },
            "style": {
                "doc": "$~Styl animacji, którego powinienem użyć.",
                "names": "$~styl"
            }
        },
        "Form": {
            "doc": "$~Jestem formą abstrakcyjną, taką jak @Rectangle lub @Circle.",
            "names": ["$~Formularz"]
        },
        "Rectangle": {
            "doc": "$~Jestem prostokątem, przydatnym do nadania @Stage granicy o wybranym rozmiarze.",
            "names": ["$~Prostokąt"],
            "left": {
                "doc": "$~Lewa krawędź sceny na osi x",
                "names": "$~lewy"
            },
            "top": {
                "doc": "$~Górna krawędź sceny na osiach y",
                "names": "$~szczyt"
            },
            "right": {
                "doc": "$~Prawa krawędź sceny na osi x",
                "names": "$~Prawidłowy"
            },
            "bottom": {
                "doc": "$~Dolna krawędź sceny na osi Y",
                "names": "$~spód"
            },
            "z": {
                "doc": "$~Pozycja głębokości prostokąta.",
                "names": "$~z"
            }
        },
        "Circle": {
            "doc": "$~Jestem okręgiem, przydatnym do tworzenia kształtów na @Stage.",
            "names": ["$~Koło"],
            "radius": {
                "doc": "$~Promień okręgu",
                "names": "$~promień"
            },
            "x": {
                "doc": "$~Poziomy środek okręgu.",
                "names": "$~X"
            },
            "y": {
                "doc": "$~Pionowy środek okręgu.",
                "names": "$~y"
            },
            "z": {
                "doc": "$~Głębokość położenia okręgu.",
                "names": "$~z"
            }
        },
        "Polygon": {
            "doc": "$~Jestem „regularnym” wielokątem o równych bokach i kątach, przydatnym do tworzenia kształtów na @Stage.",
            "names": ["$~Wielokąt"],
            "radius": {
                "doc": "$~Promień wielokąta",
                "names": "$~promień"
            },
            "sides": {
                "doc": "$~Liczba boków wielokąta",
                "names": "$~boki"
            },
            "x": {
                "doc": "$~Poziomy środek wielokąta.",
                "names": "$~X"
            },
            "y": {
                "doc": "$~Pionowy środek wielokąta.",
                "names": "$~y"
            },
            "z": {
                "doc": "$~Pozycja głębokości wielokąta.",
                "names": "$~z"
            }
        },
        "Pose": {
            "doc": [
                "$~Znasz to uczucie, gdy ktoś uderza w najbardziej niesamowity sposób stania, pauzuje i wszyscy patrzą? To ja. Uchwycę pozę, w której @Output ma się znaleźć, i jestem budulcem ich ruchów.",
                "$~Tak wiele jest w pozie. Sprawdź moje liczne sugestie, aby zobaczyć, jakie pozy możesz przyjąć!"
            ],
            "names": ["$~🤪", "$~Poza"],
            "style": {
                "doc": "$~Styl animacji, który należy zastosować przy przyjmowaniu tej pozy.",
                "names": "$~styl"
            },
            "color": {
                "doc": "$~@Color a @Output powinien znajdować się w tej pozycji, a nie w pozycji domyślnej.",
                "names": "$~kolor"
            },
            "opacity": {
                "doc": "$~Jak transparentny powinien być @Output, między \\0\\ i \\1\\, zamiast domyślnego. Pomocne przy zanikaniu i pojawianiu się.",
                "names": "$~nieprzezroczystość"
            },
            "offset": {
                "doc": "$~@Place wskazujący, jak bardzo odsunięte powinno być od miejsca @Output, zamiast jego domyślnego. Pomocne przy poruszaniu się w miejscu.",
                "names": "$~zrównoważyć"
            },
            "rotation": {
                "doc": "$~Jak bardzo obrócony powinien być @Output, zamiast ustawienia domyślnego.",
                "names": "$~obrót"
            },
            "scale": {
                "doc": "$~Stopień powiększenia @Output w stosunku do jego oryginalnego rozmiaru, a nie rozmiaru domyślnego.",
                "names": "$~skala"
            },
            "flipx": {
                "doc": "$~Czy @Output powinno być odzwierciedlone na osi x, zamiast domyślnie.",
                "names": "$~flipx"
            },
            "flipy": {
                "doc": "$~Czy @Output powinno być odbite lustrzanie na osi y, zamiast domyślnie.",
                "names": "$~chytry"
            },
            "description": "$~$1[przezroczysty $1|] $2[obrócony o $2 stopnie|] $3[skalowany $3|] $4[odwrócony w poziomie|] $5[odwrócony w pionie|] $6[cień rozmyty $6 pikseli]"
        },
        "Color": {
            "doc": [
                "$~Jestem widocznym kolorem, składającym się z trzech podstawowych wymiarów.",
                "$~Oto kilka powszechnie występujących kolorów na kole barw, o średniej jasności i wysokim nasyceniu:",
                "$~\\Kolor(50% 100 0°)\\",
                "$~\\Kolor(50% 100 30°)\\",
                "$~\\Kolor(50% 100 60°)\\",
                "$~\\Kolor(50% 100 90°)\\",
                "$~\\Kolor(50% 100 120°)\\",
                "$~\\Kolor(50% 100 150°)\\",
                "$~\\Kolor(50% 100 180°)\\",
                "$~\\Kolor(50% 100 210°)\\",
                "$~\\Kolor(50% 100 240°)\\",
                "$~\\Kolor(50% 100 270°)\\",
                "$~\\Kolor(50% 100 300°)\\",
                "$~\\Kolor(50% 100 330°)\\"
            ],
            "names": ["$~🌈", "$~Kolor"],
            "lightness": {
                "doc": "$~Jak jasny powinienem być od \\0\\ do \\1\\, od czerni przy \\0\\, do szarości przy \\0,5\\, do bieli przy \\1\\.",
                "names": ["$~lekkość", "$~ja"]
            },
            "chroma": {
                "doc": "$~Ile koloru powinienem mieć, od \\0\\ do \\∞\\. Brak koloru oznacza szarość, wyższe liczby oznaczają więcej koloru.",
                "names": ["$~barwa", "$~C"]
            },
            "hue": {
                "doc": "$~Jaki powinienem mieć kolor na kole barw, od megenty \\0\\, przez czerwień \\30\\, zieleń \\120\\, do niebieskiego \\270\\.",
                "names": ["$~odcień", "$~H"]
            }
        },
        "Sequence": {
            "doc": [
                "$~O mój Boże. Dyrektorze, wyglądasz dziś niesamowicie! Chcesz ze mną zatańczyć? To proste.",
                "$~Musisz mi po prostu dać @Map, gdzie każdy klucz reprezentuje procentowy etap tańca, w którym się znajdujemy, a każda wartość tych kluczy to @Pose, w której się znajdujemy.",
                "$~Istnieje /tak/ wiele różnych sposobów na animację! Na przykład, oto prosty sposób:",
                "$~\\Phrase('cześć' odpoczynek:Sekwencja({0%: Poza(obrót: 360°) 100%: Poza(obrót: 0°)})\\",
                "$~To oznacza, /na początku (0%), zacznij od pochylenia 360 i zakończ na pochyleniu 0/. To będzie nas kręcić w kółko na zawsze, ponieważ jestem ustawiony jako pozycja spoczynkowa @Phrase!",
                "$~Wypróbuj swoje własne kreatywne tańce, bawiąc się innymi elementami."
            ],
            "names": ["$~💃", "$~Sekwencja"],
            "poses": {
                "doc": "$~@Map procentów od 0% do 100%, każdy sparowany z @Pose. Nie musisz podawać wszystkich procentów; płynnie przeniosę @Output między tymi, które mi podasz.",
                "names": "$~pozy"
            },
            "duration": {
                "doc": "$~Jak długo powinienem tańczyć ten taniec? Jeśli mam go powtórzyć, nie będę dodawał czasu do jego trwania, po prostu będę tańczył szybciej.",
                "names": ["$~⏳", "$~czastrwania"]
            },
            "style": {
                "doc": "$~Jaki styl powinienem zastosować do tańca?",
                "names": "$~styl"
            },
            "count": {
                "doc": "$~Ile razy sekwencja powinna się powtórzyć, zanim zostanie ukończona. Jest to naprawdę pomocne, gdy wchodzę na scenę, poruszam się po scenie lub wychodzę ze sceny, ale gdy chodzi o sekwencję odpoczynku, jest ignorowane, ponieważ mogę odpoczywać wiecznie.",
                "names": "$~liczyć"
            }
        },
        "Place": {
            "doc": "$~Jestem lokalizacją na @Stage. Wszystkie moje dane wejściowe są opcjonalne, ponieważ domyślnie jestem w centrum.",
            "names": ["$~📍", "$~Miejsce"],
            "x": {
                "doc": "$~Pozycja na osi x.",
                "names": "$~X"
            },
            "y": {
                "doc": "$~Pozycja na osi y",
                "names": "$~y"
            },
            "z": {
                "doc": "$~Pozycja na osi z",
                "names": "$~z"
            },
            "rotation": {
                "doc": "$~Obrót w tej pozycji",
                "names": ["$~📐", "$~obrót"]
            }
        },
        "Velocity": {
            "doc": "$~Jestem lokalizacją na @Stage. Wszystkie moje dane wejściowe są opcjonalne, ponieważ domyślnie jestem w centrum.",
            "names": ["$~💨", "$~Prędkość"],
            "x": {
                "doc": "$~O ile metrów należy przesunąć się na osi x w ciągu sekundy.",
                "names": "$~X"
            },
            "y": {
                "doc": "$~O ile metrów należy przesunąć się na osi y w ciągu sekundy.",
                "names": "$~y"
            },
            "angle": {
                "doc": "$~O ile stopni należy obrócić się na sekundę",
                "names": ["$~kąt", "$~°"]
            }
        },
        "Matter": {
            "doc": "$~Jestem fizycznymi właściwościami wyników, które wpływają na sposób, w jaki wchodzę w interakcję z innymi wynikami na scenie.",
            "names": ["$~⚛️", "$~Materiał"],
            "mass": {
                "doc": "$~Waga w kilogramach",
                "names": "$~masa"
            },
            "bounciness": {
                "doc": "$~Ile energii muszę zachować przy zderzeniu? 0 oznacza, że nic, 1 oznacza, że wszystko.",
                "names": "$~sprężystość"
            },
            "friction": {
                "doc": "$~Jak bardzo należy się ślizgać; 0 oznacza nic, 1 oznacza wieczność.",
                "names": "$~tarcie"
            },
            "roundedness": {
                "doc": "$~O ile zaokrąglić rogi wyniku; 0 oznacza brak zaokrąglenia, a 1 oznacza 100% jego rozmiaru, dzięki czemu rozmiary będą okrągłe.",
                "names": "$~zaokrąglenie"
            },
            "text": {
                "doc": "$~Czy może kolidować z innymi wynikami.",
                "names": "$~tekst"
            },
            "shapes": {
                "doc": "$~Czy może kolidować z innymi kształtami.",
                "names": "$~grunt"
            }
        },
        "Aura": {
            "doc": [
                "$~Jestem AURA. Sprawiam, że @Phrase ŚWIECI! Podoba mi się to:",
                "$~\\Phrase(\n'ŚWIECĘ!' \naura: Aura(Kolor(50% 100 118°) 0,1 m 0 m 0,1 m\n)\\"
            ],
            "names": ["$~🔮", "$~Aura"],
            "color": {
                "doc": "$~@Color powinno być @Aura.",
                "names": "$~kolor"
            },
            "blur": {
                "doc": "$~Jak bardzo rozmyta powinna być @Aura. \\0m\\ oznacza, że wcale nie jest rozmyta.",
                "names": "$~plama"
            },
            "offsetX": {
                "doc": "$~Jak daleko na lewo lub prawo powinienem się pojawić. \\0m\\ jest dokładnie pod.",
                "names": "$~przesunięcieX"
            },
            "offsetY": {
                "doc": "$~Jak wysoko w górę lub w dół powinienem się pojawić.\\0m\\ jest dokładnie pod.",
                "names": "$~przesunięcieY"
            }
        },
        "Stage": {
            "doc": [
                "$~Cześć. Scena tutaj. Powiedz mi co mam pokazać, a ja to pokażę.",
                "$~\\Stage([Fraza('stufffffff')])\\",
                "$~JEŚLI CHCESZ, PODAJ MI TŁO @Color, A JA ODPOWIEDNIO OŚWIETLĘ SCENĘ.",
                "$~\\Stage([Fraza('stuffffff')] tło: Kolor(75% 50 100°)\\",
                "$~MOŻESZ TEŻ DAĆ MI RAMKĘ, A JA JĄ PRZYCINĘ.",
                "$~\\Stage([Fraza('stufffffff')] tło: Kolor(75% 50 100°) ramka: Prostokąt(-1m -1m 1m 1m))\\"
            ],
            "names": ["$~🎭", "$~Scena"],
            "content": {
                "doc": "$~Lista @Output do wyświetlenia na scenie.",
                "names": "$~treść"
            },
            "frame": {
                "doc": "$~Kształt i rozmiar ramy, którą należy umieścić wokół sceny, ukrywając wszystko, co znajduje się poza nią.",
                "names": "$~rama"
            },
            "size": {
                "doc": "$~POLUB @Group/size",
                "names": "$~rozmiar"
            },
            "face": {
                "doc": "$~POLUB @Group/face",
                "names": "$~twarz"
            },
            "place": {
                "doc": "$~GDYBYM BYŁ APARATEM, TO WŁAŚNIE TAM PATRZĘ",
                "names": "$~miejsce"
            },
            "name": {
                "doc": ["$~TAK SAMO JAK @Phrase/name!"],
                "names": "$~nazwa"
            },
            "description": {
                "doc": [
                    "$~Opis przeznaczony dla odbiorców, którzy nie mogą zobaczyć treści wizualnych."
                ],
                "names": "$~opis"
            },
            "selectable": {
                "doc": "$~TAK SAMO JAK @Phrase/selectable!",
                "names": "$~wybieralny"
            },
            "color": {
                "doc": "$~TAK SAMO JAK @Group/color",
                "names": "$~kolor"
            },
            "background": {
                "doc": "$~TAK SAMO JAK @Group/background",
                "names": "$~tło"
            },
            "opacity": {
                "doc": "$~TAK SAMO JAK @Group/opacity",
                "names": "$~nieprzezroczystość"
            },
            "offset": {
                "doc": "$~TAK SAMO JAK @Group/offset",
                "names": "$~zrównoważyć"
            },
            "rotation": {
                "doc": "$~TAK SAMO JAK @Group/rotation",
                "names": ["$~📐", "$~obrót"]
            },
            "scale": {
                "doc": "$~TAK SAMO JAK @Group/scale",
                "names": "$~skala"
            },
            "flipx": {
                "doc": "$~TAK SAMO JAK @Group/flipx",
                "names": "$~flipx"
            },
            "flipy": {
                "doc": "$~TAK SAMO JAK @Group/flipy",
                "names": "$~chytry"
            },
            "entering": {
                "doc": "$~TAK SAMO JAK @Group/entering",
                "names": "$~wstępowanie"
            },
            "resting": {
                "doc": "$~TAK SAMO JAK @Group/resting!",
                "names": "$~spoczynkowy"
            },
            "moving": {
                "doc": "$~TAK SAMO JAK @Group/moving!",
                "names": "$~poruszający"
            },
            "exiting": {
                "doc": "$~TAK SAMO JAK @Group/exiting!",
                "names": "$~wychodzenie"
            },
            "duration": {
                "doc": "$~TAK SAMO JAK @Phrase/duration!",
                "names": ["$~⏳", "$~czastrwania"]
            },
            "style": {
                "doc": "$~TAK SAMO JAK @Phrase/style!",
                "names": "$~styl"
            },
            "gravity": {
                "doc": "$~Grawitacja ma zastosowanie do wyników, których miejsce znajduje się w @Motion.",
                "names": "$~powaga"
            },
            "defaultDescription": "$~etap $2[$2 |]z $1 wyprowadza $3[z ramką $3|] $4"
        },
        "Easing": {
            "straight": "$~prosty",
            "cautious": "$~ostrożny",
            "pokey": "$~ciasny",
            "zippy": "$~pełen werwy"
        },
        "sequence": {
            "sway": {
                "doc": "$~Tworzę @Sequence, która kołysze się tam i z powrotem wokół środka @Output.",
                "names": ["$~kołysać"],
                "angle": {
                    "doc": "$~O ile należy przechylić się w kołysaniu.",
                    "names": ["$~kąt"]
                }
            },
            "bounce": {
                "doc": "$~Tworzę @Sequence, który odbija @Output na zadaną wysokość.",
                "names": ["$~odbićsię"],
                "height": {
                    "doc": "$~Jak wysoko odbijać się.",
                    "names": ["$~wysokość"]
                }
            },
            "spin": {
                "doc": "$~Tworzę @Sequence, która obraca @Output wokół swojego środka.",
                "names": ["$~kręcićsię"]
            },
            "fadein": {
                "doc": "$~Tworzę @Sequence, która powoduje, że @Output staje się niewidoczny i widoczny.",
                "names": ["$~zanikanie"]
            },
            "fadeout": {
                "doc": "$~Tworzę @Sequence, która zanika @Output od widocznego do niewidocznego. Wypróbuj mnie w ekscytującym @Sequence!",
                "names": ["$~wyciszenie"]
            },
            "popup": {
                "doc": "$~Tworzę @Sequence, która powoduje, że @Output skaluje się szybciej, a następnie zmniejsza do normalnego rozmiaru.",
                "names": ["$~wyskakująceokienko"]
            },
            "shake": {
                "doc": "$~Tworzę @Sequence, który sprawia wrażenie, że @Output jest przestraszony.",
                "names": ["$~potrząsnąć"]
            }
        },
        "Source": {
            "names": "$~Źródło",
            "doc": [
                "$~Wiesz, że projekty mogą mieć więcej niż jeden plik @Source? Pozwalam Ci utworzyć @Source na podstawie logiki Twojego projektu. Jest to naprawdę pomocne, jeśli chcesz zapisać pewne dane pomiędzy różnymi ocenami Twojego projektu.",
                "$~Na przykład wyobraź sobie, że chcesz zrobić prosty licznik, który liczy o jeden za każdym razem, gdy naciśniesz przycisk myszy. Możesz go użyć, aby zapamiętać, ile razy coś zrobiłeś.",
                "$~\\↓ count\n[\nFraza(`\\count\\ razy!`)\nŹródło('count' count … ∆ Button() … count + 1 )\n]\\",
                "$~Spróbuj go skopiować, utworzyć nowe @Source o nazwie /count/ i wpisać w nim 0, aby rozpocząć zliczanie od 0. Ten mały projekt pobierze wartość ze źródła /count/ i za każdym razem, gdy zostanie naciśnięty przycisk myszy, edytuje /count/ @Source, tak aby przyjmowało bieżącą wartość /count/ plus /1/."
            ],
            "name": {
                "names": "$~nazwa",
                "doc": "$~Nazwa pliku źródłowego, który ma zostać utworzony lub zaktualizowany."
            },
            "value": {
                "names": "$~wartość",
                "doc": "$~Wartość danych, przy użyciu której powinien zostać utworzony lub zaktualizowany plik źródłowy."
            },
            "DynamicEditLimitException": {
                "description": "$~dynamiczny limit edycji źródła",
                "explanation": "$~Ten projekt zapisał dane do plików @Source zbyt wiele razy, zbyt szybko. Upewnij się, że aktualizuje @Source tylko w odpowiedzi na dane wejściowe, a nie zbyt szybko."
            },
            "ReadOnlyEditException": {
                "description": "$~tylko do odczytu edycja źródła",
                "explanation": "$~Ten projekt zapamiętuje dane, ale nie masz uprawnień do ich edycji. Skopiuj je, jeśli chcesz spróbować."
            },
            "EmptySourceNameException": {
                "description": "$~pusta nazwa źródła",
                "explanation": "$~Podana wartość @Source miała pustą nazwę, więc nie mogliśmy jej zapisać."
            },
            "ProjectSizeLimitException": {
                "description": "$~limit rozmiaru projektu",
                "explanation": "$~W tym projekcie jest za dużo tekstu, dlatego nie można go zapisać."
            }
        }
    },
    "ui": {
        "font": {
            "app": "$~Noto Sans",
            "code": "$~Noto Sans Mono"
        },
        "phrases": {
            "welcome": "$~Witam"
        },
        "widget": {
            "confirm": {
                "cancel": "$~anulować"
            },
            "dialog": {
                "close": "$~zamknąć"
            },
            "loading": {
                "message": "$~Ładowanie czcionek i tekstu. Dziękujemy za czekanie!"
            },
            "home": "$~przejdź do strony głównej",
            "table": {
                "cell": {
                    "description": "$~edytuj tę komórkę",
                    "placeholder": "$~wartość"
                },
                "addcolumn": "$~dodaj kolumnę przed tą kolumną",
                "removecolumn": "$~usuń tę kolumnę"
            }
        },
        "tile": {
            "toggle": {
                "fullscreen": {
                    "on": "$~wyjdź z pełnego ekranu",
                    "off": "$~rozwiń do pełnego ekranu"
                },
                "show": {
                    "on": "$~ukrywać",
                    "off": "$~pokazywać"
                }
            },
            "label": {
                "output": "$~scena",
                "palette": "$~paleta",
                "docs": "$~przewodnik",
                "source": "$~źródło",
                "collaborate": "$~współpracować"
            },
            "button": {
                "collapse": "$~zawiń okno"
            }
        },
        "project": {
            "error": {
                "unknown": "$~Ten projekt nie istnieje lub nie masz do niego dostępu.",
                "translate": "$~Wystąpił problem podczas tłumaczenia Twojego projektu.",
                "tile": "$~Ups, wystąpił błąd",
                "reset": "$~Próba zresetowania..."
            },
            "button": {
                "share": {
                    "tip": "$~pokaż opcje udostępniania projektu",
                    "label": "$~udział"
                },
                "removeCollaborator": "$~usuń współpracownika",
                "copy": "$~skopiuj projekt do schowka jako tekst",
                "addSource": "$~utwórz nowy $source",
                "duplicate": "$~skopiuj ten projekt",
                "revert": "$~powrót do oryginalnego kodu",
                "focusOutput": "$~skup klawiaturę na scenie",
                "focusSource": "$~skup się na następnym źródle",
                "focusDocs": "$~skup się na dokumentacji",
                "focusPalette": "$~skup się na palecie",
                "focusCycle": "$~skup się na następnym kafelku",
                "unsaved": "$~pokaż błąd zapisu",
                "translate": {
                    "tip": "$~edytuj języki tego projektu i przetłumacz go na inne języki.",
                    "label": "$~tłumaczyć"
                },
                "primary": "$~ustaw jako podstawową lokalizację tego projektu",
                "history": {
                    "on": "$~pokaż ostatni kod projektu",
                    "redo": "$~pokaż aktualny kod projektu"
                }
            },
            "field": {
                "name": {
                    "description": "$~edytuj nazwę projektu",
                    "placeholder": "$~nazwa"
                }
            },
            "help": "$~pokaż skróty klawiaturowe",
            "collapsed": "$~Wszystkie Twoje okna są zwinięte! Możesz je znaleźć na pasku narzędzi poniżej",
            "save": {
                "projectsNotSavedLocally": "$~Wystąpił problem podczas zapisywania projektów w Twojej przeglądarce.",
                "projectsCannotNotSaveLocally": "$~Twoja przeglądarka nie obsługuje zapisywania projektów.",
                "projectContainedPII": "$~Aby chronić Twoją prywatność, projekt z potencjalnie identyfikującymi Cię informacjami nie został zapisany online. Sprawdź projekt, aby zobaczyć, czy informacje są identyfikujące.",
                "projectsNotLoadingOnline": "$~Nie można załadować projektów online.",
                "projectNotSavedOnline": "$~Nie można zapisać projektu online.",
                "settingsUnsaved": "$~Nie można zapisać ustawień online."
            },
            "dialog": {
                "unsaved": "$~Niezapisana praca...",
                "translate": {
                    "header": "$~Tłumaczyć",
                    "explanation": [
                        "$~Oto języki, których używa Twój projekt.",
                        "$~Aby spróbować przetłumaczyć swój projekt na inne języki, wybierz główny język źródłowy, a następnie wybierz nowy język.",
                        "$~/Nie wszystkie języki są obsługiwane i tłumaczenia będą niedoskonałe, dlatego sprawdź wyniki!/"
                    ]
                }
            },
            "subheader": {
                "source": "$~Źródło",
                "destination": "$~Miejsce docelowe"
            }
        },
        "checkpoints": {
            "label": {
                "now": "$~Teraz",
                "history": "$~przywrócić",
                "restore": "$~To jest poprzednia wersja tego projektu.",
                "ago": "$~1 $ 2 $ temu"
            },
            "button": {
                "clear": "$~usuń historię",
                "select": "$~zobacz tę wersję",
                "checkpoint": "$~zapisz tę wersję projektu",
                "back": "$~wróć do poprzedniej wersji",
                "forward": "$~powrót do następnej wersji",
                "restore": "$~przywróć tę wersję",
                "now": "$~powrót do aktualnej wersji"
            }
        },
        "gallery": {
            "untitled": "$~Nieuprawny",
            "undescribed": "$~Brak opisu",
            "subheader": {
                "classes": {
                    "header": "$~Klasy",
                    "explanation": "$~Zajęcia powiązane z tą galerią."
                },
                "curators": {
                    "header": "$~Kuratorzy",
                    "explanation": "$~Twórcy zarządzający tą galerią."
                },
                "creators": {
                    "header": "$~Twórcy",
                    "explanation": "$~Twórcy, którzy przyczynili się do powstania tej galerii."
                },
                "delete": {
                    "header": "$~Usuwać",
                    "explanation": "$~Usunięcie tej galerii nie spowoduje usunięcia jej projektów. Galeria zostanie usunięta na zawsze."
                }
            },
            "confirm": {
                "delete": {
                    "description": "$~usuń galerię",
                    "prompt": "$~usuwać"
                },
                "remove": {
                    "description": "$~usuń projekt z galerii",
                    "prompt": "$~usunąć"
                }
            },
            "error": {
                "unknown": "$~Ta galeria nie istnieje lub nie jest publiczna."
            },
            "field": {
                "name": {
                    "description": "$~Nazwa galerii",
                    "placeholder": "$~nazwa"
                },
                "description": {
                    "description": "$~Opis galerii",
                    "placeholder": "$~Opisz swoją galerię. Jaki jest jej temat, cele lub społeczność?"
                }
            }
        },
        "source": {
            "label": "$~edytor programów",
            "empty": [
                "$~Zaczynajmy! Możesz …",
                "$~• Otwórz 📕 i przeciągnij 🖱️ nas do tego programu.",
                "$~• Wpisz $1 i wybierz nas z menu.",
                "$~• Wpisz nas za pomocą ⌨️.",
                "$~• Przeglądaj <galleries@://galleries> w poszukiwaniu inspiracji.",
                "$~Jeśli utknąłeś, <dowiedz się więcej@://learn>."
            ],
            "overwritten": "$~Projekt zmieniony gdzie indziej",
            "confirm": {
                "delete": {
                    "description": "$~usuń to $source",
                    "prompt": "$~usuwać"
                }
            },
            "toggle": {
                "blocks": {
                    "on": "$~edytuj jako tekst",
                    "off": "$~edytuj jako bloki"
                },
                "glyphs": {
                    "on": "$~zwiń pasujące glify",
                    "off": "$~rozwiń pasujące glify"
                }
            },
            "button": {
                "selectOutput": "$~pokaż ten wynik na scenie",
                "expandSequence": "$~rozwiń ten zwinięty kod"
            },
            "field": {
                "name": {
                    "description": "$~edytuj nazwę źródła",
                    "placeholder": "$~nazwa"
                }
            },
            "menu": {
                "label": "$~menu autouzupełniania",
                "show": "$~pokaż menu autouzupełniania",
                "back": "$~opuść podmenu"
            },
            "cursor": {
                "priorLine": "$~przesuń kursor do wiersza przed",
                "nextLine": "$~przesuń kursor do wiersza po",
                "priorInline": "$~przesuń kursor do pozycji przed",
                "nextInline": "$~przesuń kursor do pozycji po",
                "lineStart": "$~przesuń kursor na początek wiersza",
                "lineEnd": "$~przesuń kursor na koniec wiersza",
                "sourceStart": "$~przesuń kursor na początek źródła",
                "sourceEnd": "$~przesuń kursor na koniec źródła",
                "priorNode": "$~wybierz sąsiada przed",
                "nextNode": "$~wybierz sąsiada po",
                "parent": "$~wybierz kontener",
                "selectAll": "$~wybierz program",
                "incrementLiteral": "$~zwiększ liczbę, tekst lub wartość logiczną",
                "decrementLiteral": "$~zmniejsz liczbę, tekst lub wartość logiczną",
                "insertSymbol": "$~wstaw $1",
                "insertTab": "$~wstaw zakładkę",
                "insertTrue": "$~wstaw prawdę",
                "insertFalse": "$~wstaw fałsz",
                "insertNone": "$~nie wstawiaj symbolu",
                "insertNotEqual": "$~wstaw nierówny",
                "insertProduct": "$~wstaw symbol produktu",
                "insertQuotient": "$~wstaw symbol ilorazu",
                "insertDegree": "$~wstaw symbol stopnia",
                "insertFunction": "$~wstaw funkcję",
                "insertLessOrEqual": "$~wstaw mniejsze lub równe",
                "insertGreaterOrEqual": "$~wstaw większe lub równe",
                "insertType": "$~wstaw symbol typu",
                "insertDocs": "$~wstaw symbol wyjaśnienia",
                "insertStream": "$~wstaw symbol strumienia",
                "insertChange": "$~wstaw symbol zmiany",
                "insertConvert": "$~wstaw symbol konwersji",
                "insertPrevious": "$~wstaw poprzedni symbol",
                "insertTable": "$~wstaw symbol otwartej tabeli",
                "insertTableClose": "$~wstaw symbol zamknięcia tabeli",
                "insertBorrow": "$~wstawić pożyczyć",
                "insertShare": "$~wstaw udział",
                "insertLine": "$~wstaw podział wiersza",
                "backspace": "$~usuń zaznaczenie lub poprzedni symbol",
                "delete": "$~usuń zaznaczenie lub następny symbol",
                "cut": "$~wybór cięcia",
                "copy": "$~kopiuj wybór",
                "paste": "$~wklej zawartość klawiatury",
                "parenthesize": "$~zaznaczenie w nawiasach",
                "enumerate": "$~wyliczyć wybór",
                "type": "$~wpisz znaki",
                "undo": "$~cofnij poprzednią edycję",
                "redo": "$~ponów cofniętą edycję",
                "search": "$~wyszukaj znaki specjalne do wstawienia",
                "tidy": "$~schludne odstępy",
                "elide": "$~przełącz elizję"
            },
            "options": {
                "locale": {
                    "tip": "$?",
                    "all": "$?"
                }
            }
        },
        "annotations": {
            "label": "$~konflikty i pomoc",
            "cursor": "$~To jest *$1*$2[ i są one typu $2|]. $3[ Znajdują się wewnątrz *$3*.|]",
            "cursorParent": "$~Znajdują się wewnątrz *$1*$2[ typu $2|].",
            "learn": "$~/Dowiedz się więcej/",
            "evaluating": "$~O, fajnie, oceńmy!",
            "space": "$~To jest kosmos! Kto by pomyślał, że nic nie może powiedzieć tak wiele?",
            "button": {
                "resolution": "$~Rozwiąż ten konflikt"
            }
        },
        "output": {
            "label": "$~wyjście programu",
            "toggle": {
                "grid": {
                    "on": "$~ukryj linie siatki",
                    "off": "$~pokaż linie siatki"
                },
                "fit": {
                    "on": "$~kontroluj zoom ręcznie",
                    "off": "$~dopasuj powiększenie do zawartości"
                },
                "paint": {
                    "off": "$~miejsce wyjścia",
                    "on": "$~wydajność farby"
                }
            },
            "field": {
                "key": {
                    "description": "$~słuchanie naciśnięć klawiszy",
                    "placeholder": "$~wiadomość"
                }
            },
            "button": {
                "submit": "$~wyślij tę wiadomość czatu"
            },
            "options": {
                "locale": "$~wybierz język wyjścia"
            }
        },
        "timeline": {
            "label": "$~oś czasu",
            "slider": "$~suwak czasu",
            "button": {
                "play": "$~oceniać program do końca, reagując na dane wejściowe w czasie rzeczywistym",
                "pause": "$~wstrzymaj program, umożliwiając przewijanie do przodu i do tyłu",
                "backStep": "$~cofnij się o krok",
                "backNode": "$~krok do poprzedniej oceny kursora",
                "backInput": "$~cofnij jedno wejście",
                "out": "$~wyjdź z tej funkcji",
                "forwardStep": "$~zrób krok naprzód",
                "forwardNode": "$~krok do następnej oceny kursora",
                "forwardInput": "$~przejdź do następnego strumienia wejściowego",
                "present": "$~do końca",
                "start": "$~Na początek",
                "reset": "$~ponowne uruchomienie wydajności"
            }
        },
        "docs": {
            "label": "$~przeglądarka dokumentacji",
            "link": "$~pokaż koncepcję $1 w dokumentacji",
            "learn": "$~dowiedz się więcej …",
            "nodoc": "$~Kim jestem? Czym jestem? Jaki jest mój cel?",
            "button": {
                "home": "$~powrót do domu",
                "back": "$~powrót do poprzedniego"
            },
            "field": {
                "search": "$~wyszukaj pojęcia za pomocą słów"
            },
            "header": {
                "inputs": "$~Wejścia",
                "interfaces": "$~Interfejsy",
                "properties": "$~Właściwości",
                "functions": "$~Funkcje",
                "conversions": "$~Konwersje"
            }
        },
        "dialog": {
            "share": {
                "header": "$~Partycypujący",
                "explanation": "$~Podziel się tym projektem z galeriami i całym światem.",
                "subheader": {
                    "gallery": {
                        "header": "$~Galeria",
                        "explanation": "$~Dodaj ten projekt do galerii obok innych twórców lub utwórz galerię na swojej stronie <projects@://projects>. Jeśli dodasz projekt do publicznej galerii, Twój projekt stanie się publiczny."
                    },
                    "public": {
                        "header": "$~Publiczny/Prywatny",
                        "explanation": "$~Projekty publiczne i galerie mogą być oglądane przez każdego na świecie. Naszym celem jest, aby ta treść przynosiła afirmację i radość, a publiczne udostępnianie jest sposobem na to. Ale oznacza to również przestrzeganie pewnych zasad. Obiecujesz, że Twój projekt nie:"
                    },
                    "pii": {
                        "header": "$~Informacje osobiste",
                        "explanation": "$~Udostępnianie publicznie danych osobowych (PII) może narazić twórców na ryzyko, dlatego wykrywamy możliwe PII i ostrzegamy twórców, aby usunęli poufne dane lub oznaczyli je jako niewrażliwe.\n\nPoniżej znajduje się lista możliwych PII w tym projekcie, które oznaczyłeś jako niewrażliwe. Możesz kliknąć przycisk obok niego, aby ponownie oznaczyć go jako poufny, ale spowoduje to, że Twój projekt nie zostanie już zapisany online."
                    }
                },
                "field": {
                    "emailOrUsername": {
                        "placeholder": "$~e-mail lub nazwa użytkownika",
                        "description": "$~adres e-mail lub nazwa użytkownika osoby, której chcesz przyznać dostęp do edycji"
                    }
                },
                "mode": {
                    "public": {
                        "label": "$~widoczność",
                        "modes": ["$~prywatny", "$~publiczny"]
                    }
                },
                "error": {
                    "unknown": "$~Nie znamy twórcy, który posiada ten adres e-mail.",
                    "anonymous": "$~Aby udostępnić, musisz się zalogować."
                },
                "button": {
                    "submit": "$~Udostępnij projekt za pomocą tego adresu e-mail",
                    "sensitive": {
                        "tip": "$~Oznacz ten tekst ponownie jako poufny",
                        "label": "$~wrażliwy"
                    }
                },
                "options": {
                    "gallery": "$~selektor galerii"
                }
            },
            "settings": {
                "header": "$~Ustawienia",
                "explanation": "$~Zmień ustawienia układu, urządzenia i motywu.",
                "button": {
                    "show": "$~pokaż okno dialogowe ustawień"
                },
                "mode": {
                    "layout": {
                        "label": "$~układ",
                        "modes": [
                            "$~automatyczny",
                            "$~poziomy",
                            "$~pionowy",
                            "$~bezpłatny"
                        ]
                    },
                    "animate": {
                        "label": "$~animacje",
                        "modes": [
                            "$~animacje wyłączone",
                            "$~normalna prędkość",
                            "$~połowa prędkości",
                            "$~trzecia prędkość",
                            "$~ćwierć prędkości"
                        ]
                    },
                    "dark": {
                        "label": "$~temat",
                        "modes": [
                            "$~jasne kolory",
                            "$~ciemne kolory",
                            "$~użyj ustawień urządzenia"
                        ]
                    },
                    "space": {
                        "label": "$~wskaźnik przestrzeni",
                        "modes": [
                            "$~pokaż wyraźnie wskaźniki spacji i tabulatorów",
                            "$~nie pokazuj wskaźników spacji i tabulatorów"
                        ]
                    },
                    "lines": {
                        "label": "$~numery linii",
                        "modes": [
                            "$~pokaż numery wierszy w trybie tekstowym",
                            "$~nie pokazuj numerów wierszy w trybie tekstowym"
                        ]
                    },
                    "writing": {
                        "label": "$~układ pisma",
                        "modes": [
                            "$~poziomo, od lewej do prawej",
                            "$~pionowo, od prawej do lewej",
                            "$~pionowo, od lewej do prawej"
                        ]
                    }
                },
                "options": {
                    "face": "$~krój czcionki",
                    "mic": "$~wybrany mikrofon",
                    "camera": "$~wybrana kamera"
                }
            },
            "locale": {
                "header": "$~Język",
                "explanation": "$~Wybierz języki dla interfejsu, samouczka i dokumentacji.",
                "subheader": {
                    "selected": "$~Wybrany",
                    "supported": "$~Dostępny",
                    "help": "$~Pomóż nam tłumaczyć…"
                },
                "button": {
                    "show": "$~zmień ustawienia regionalne",
                    "replace": "$~użyj tej lokalizacji",
                    "add": "$~użyj tej lokalizacji i bieżących",
                    "remove": "$~usuń tę lokalizację"
                }
            },
            "help": {
                "header": "$~Skróty",
                "explanation": "$~Aby uzyskać bardziej efektywną edycję, użyj poniższych poleceń klawiaturowych.",
                "subheader": {
                    "moveCursor": "$~Przenosić",
                    "editCode": "$~Redagować",
                    "insertCode": "$~Wstawić",
                    "debug": "$~Odpluskwić"
                }
            }
        },
        "collaborate": {
            "label": "$~współpracować",
            "role": {
                "owner": "$~właściciel",
                "collaborators": "$~współpracownicy",
                "curators": "$~kuratorzy"
            },
            "field": {
                "message": {
                    "description": "$~Wiadomość czatu do wysłania",
                    "placeholder": "$~Wpisz wiadomość"
                }
            },
            "button": {
                "submit": {
                    "label": "$~Wysłać",
                    "tip": "$~Wyślij wiadomość do swoich współpracowników"
                },
                "start": {
                    "label": "$~Rozpocznij czat",
                    "tip": "$~Rozpocznij dyskusję z samym sobą lub innymi."
                },
                "delete": "$~usuń tę wiadomość"
            },
            "error": {
                "unowned": "$~Ten projekt nie jest przechowywany online, więc nie można na nim prowadzić czatu ani współpracować z innymi osobami.",
                "offline": "$~Nie można załadować tego czatu.",
                "empty": "$~Brak wiadomości.",
                "deleted": "$~Ta wiadomość została usunięta."
            },
            "prompt": {
                "solo": "$~Porozmawiaj sam ze sobą lub dodaj współpracownika, który może edytować i rozmawiać.",
                "owner": "$~Współpracownicy mogą edytować ten projekt i rozmawiać na jego temat.",
                "collaborator": "$~Jesteś współpracownikiem. Możesz edytować ten projekt i o nim rozmawiać.",
                "curator": "$~Jesteś kuratorem galerii tego projektu. Możesz edytować ten projekt i o nim rozmawiać."
            }
        },
        "palette": {
            "label": "$~paleta",
            "labels": {
                "mixed": "$~mieszany",
                "computed": "$~obliczony",
                "default": "$~domyślny",
                "inherited": "$~dziedziczny",
                "notSequence": "$~nie sekwencja",
                "notContent": "$~nie jest to lista treści",
                "format": "$~format",
                "weight": "$~waga",
                "light": "$~światło",
                "normal": "$~normalna",
                "bold": "$~pogrubiony",
                "extra": "$~dodatkowy",
                "italic": "$~italski",
                "underline": "$~podkreślać"
            },
            "button": {
                "revert": "$~przywrócić domyślną wartość",
                "set": "$~edytuj tę nieruchomość",
                "addPhrase": "$~dodaj frazę po tym",
                "addGroup": "$~dodaj grupę po tym",
                "addShape": "$~dodaj kształt po tym",
                "addMotion": "$~ustaw miejsce na strumień ruchu",
                "addPlacement": "$~ustaw miejsce dla strumienia umieszczania",
                "remove": "$~usuń tę treść",
                "up": "$~przenieś tę treść w górę",
                "down": "$~przesuń tę treść w dół",
                "edit": "$~edytuj tę treść",
                "sequence": "$~przekonwertować na sekwencję",
                "createPhrase": "$~utwórz frazę, wyświetlając istniejącą wartość jako tekst",
                "createGroup": "$~utwórz grupę, obejmując dowolną istniejącą frazę",
                "createStage": "$~utwórz scenę, obejmując dowolną istniejącą grupę lub frazę"
            },
            "prompt": {
                "offerPhrase": "$~Jaką wspaniałą wartość stworzyłeś! Czy mam to pokazać na @Stage?",
                "offerGroup": "$~Jakie cudowne @Phrase stworzyłeś. Czy chcesz zebrać je razem w @Group, żeby je uporządkować?",
                "offerStage": "$~BARDZO DOBRE @Program. DODAJ MNIE DO KONTROLI OŚWIETLENIA. KOLORÓW. RAMEK.",
                "pauseToEdit": "$~Jeśli ⏸️ jesteś na etapie, możesz wybrać 💬, 🔳 lub 🎭, aby edytować!",
                "editing": "$~Edytuj mnie!"
            },
            "field": {
                "coordinate": "$~edytuj współrzędne",
                "text": "$~edytuj tekst"
            },
            "sequence": {
                "button": {
                    "add": "$~dodaj pozę",
                    "remove": "$~usuń pozę",
                    "up": "$~przesuń się, postaw się",
                    "down": "$~przesuń pozycję w dół"
                },
                "field": {
                    "percent": "$~edytuj procent"
                }
            }
        },
        "save": {
            "saving": "$~oszczędność",
            "saved": "$~zapisane online",
            "local": "$~zapisano w przeglądarce",
            "unsaved": "$~niezapisany"
        },
        "page": {
            "unknown": {
                "header": "$~Ojej!",
                "message": "$~Gdzie jest to miejsce? Czy możemy wrócić do domu?"
            },
            "landing": {
                "value": "$~Twórz z nami interaktywne historie przy użyciu słów, symboli, emotikonów i kodu!",
                "description": [
                    "$~Wordplay to język programowania umożliwiający:",
                    "$~• Zabawnie animowane słowa i emotikony 🤪",
                    "$~• Wykorzystaj czas 🕦, dźwięk 🎤, strony internetowe 🔗 i fizykę 🌎",
                    "$~• Udostępnij 🤝 znajomym, grupom lub komukolwiek",
                    "$~• Koduj w dowolnym języku świata 🌐",
                    "$~• Edytuj za pomocą myszy 🖱️, dotyku 👆 i klawiatury ⌨️",
                    "$~• Debugowanie do przodu ⏩ i do tyłu ⏪",
                    "$~• Zobacz za pomocą ekranów 🖥️ i czytników ekranu 🔊",
                    "$~Bezpłatnie na zawsze od <University of Washington@https://ischool.uw.edu/>."
                ],
                "beta": [
                    "$~Wordplay jest w wersji *beta*, więc może nie działać zgodnie z przeznaczeniem lub być niekompletny. Zgłaszaj błędy i dziel się pomysłami na <GitHub@https://github.com/wordplaydev/wordplay/issues>, zobacz nasze <1.0 plans@https://github.com/wordplaydev/wordplay/milestones/1.0> i <contribute@https://github.com/wordplaydev/wordplay/wiki/contribute>."
                ],
                "link": {
                    "learn": "$~Naucz się języka z dramatyczną obsadą",
                    "teach": "$~Zarządzaj klasami uczniów i ich projektami",
                    "guide": "$~Wyszukaj i przeglądaj odniesienia językowe",
                    "projects": "$~Twórz i udostępniaj występy",
                    "galleries": "$~Przeżyj występy innych",
                    "rights": "$~Obowiązki nasze i Twoje",
                    "about": "$~Dlaczego to miejsce istnieje?",
                    "community": {
                        "label": "$~Wspólnota",
                        "subtitle": "$~Porozmawiaj z nami na Discordzie."
                    },
                    "contribute": {
                        "label": "$~Brać w czymś udział",
                        "subtitle": "$~Pomóż nam tworzyć Wordplay."
                    }
                }
            },
            "learn": {
                "header": "$~Uczyć się",
                "error": "$~Nie udało nam się znaleźć samouczka dla tego języka.",
                "button": {
                    "next": "$~następna pauza w dialogu",
                    "previous": "$~poprzednia pauza w dialogu"
                },
                "options": {
                    "lesson": "$~bieżąca lekcja"
                }
            },
            "teach": {
                "header": "$~Uczyć",
                "prompt": {
                    "none": "$~Witaj nauczycielu! Utwórz klasę, aby skonfigurować i zarządzać kontami uczniów i galeriami projektów.",
                    "some": "$~Witaj nauczycielu! Zarządzaj swoimi klasami lub stwórz nową."
                },
                "error": {
                    "offline": "$~Nie mogliśmy sprawdzić Twojego statusu nauczyciela. Czy jesteś zalogowany?",
                    "login": "$~Musisz się zalogować, aby zarządzać klasami.",
                    "teacher": "$~Potrzebujesz uprawnień nauczyciela, aby tworzyć i zarządzać klasami. Wypełnij ten formularz i poznajmy się!"
                },
                "link": {
                    "request": "$~Poproś o uprawnienia nauczyciela",
                    "new": "$~Utwórz klasę"
                }
            },
            "newclass": {
                "header": "$~Nowa klasa",
                "subheader": {
                    "class": "$~Twoja klasa",
                    "students": "$~Twoi uczniowie",
                    "credentials": "$~Nazwy użytkowników i hasła",
                    "submit": "$~Składać"
                },
                "prompt": {
                    "start": "$~Utwórz klasę z kontami generte dla wszystkich uczniów w klasie i pozwól na tworzenie galerii, do których wszyscy uczniowie mogą dodawać projekty. Jeśli uczniowie mają istniejące konta, możesz je dodać później.",
                    "review": "$~Przejrzyj nazwy użytkowników i hasła, które utworzyliśmy. Czy chcesz je *edytować* przed kontynuowaniem? Jeśli to zrobisz, nie będziesz mógł edytować powyższych informacji o studentach.",
                    "ready": "$~Daj nam znać, kiedy będziesz gotowy wygenerować powyższe dane uwierzytelniające. Możesz je edytować po tym.",
                    "pending": "$~Generowanie nazw użytkowników i haseł...",
                    "submit": "$~Gotowy do wysłania? Gdy tylko się powiedzie, otrzymasz plik do pobrania z tymi informacjami. Hasła *nie są odzyskiwalne*, więc przechowuj je w bezpiecznym miejscu.",
                    "submitting": "$~Proszę o założenie nowych kont z użyciem powyższych nazw użytkowników i haseł...",
                    "download": "$~Twoja klasa jest gotowa! Powinieneś zobaczyć pobranie danych swojego ucznia w folderze pobierania. *Hasła nie są odzyskiwalne*, więc przechowuj ten plik w bezpiecznym miejscu!"
                },
                "field": {
                    "name": {
                        "description": "$~nazwa klasy",
                        "placeholder": "$~krótka nazwa"
                    },
                    "description": {
                        "description": "$~opis",
                        "placeholder": "$~opis Twoich zajęć, dla Ciebie i Twoich uczniów."
                    },
                    "existing": {
                        "label": "$~studenci z kontami",
                        "prompt": "$~Czy niektórzy z Twoich uczniów mają już konta Wordplay? Dodaj ich tutaj."
                    },
                    "metadata": {
                        "description": "$~informacje dla studentów",
                        "placeholder": "$~np. numer identyfikacyjny studenta, nazwisko, imię",
                        "prompt": "$~Chcesz utworzyć nowe konta dla uczniów? Podaj *dowolne informacje* o uczniach, po jednej w wierszu, rozdzielone przecinkami. Mogą to być nazwiska, imiona, numery uczniów lub inne wyróżniające szczegóły. Wykorzystamy je do wygenerowania nazw użytkowników, które możesz edytować poniżej, co pomoże Ci powiązać nazwy użytkowników z uczniami."
                    },
                    "words": {
                        "description": "$~słowa do użycia w hasłach",
                        "placeholder": "$~np. kot kropka szczur...",
                        "prompt": "$~Podaj co najmniej *25 słów* i losowo wygeneruj 2-3-wyrazowe, łatwe do zapamiętania hasła. Wybierz słowa, które znają Twoi uczniowie, lub poproś ich o burzę mózgów na temat słów. Im bardziej losowo, tym bezpieczniej!"
                    },
                    "generate": {
                        "label": "$~spowodować",
                        "tip": "$~Utwórz nazwy użytkowników i hasła w oparciu o powyższe informacje."
                    },
                    "edit": {
                        "label": "$~redagować",
                        "tip": "$~edytuj wygenerowane informacje o uczniu"
                    },
                    "submit": {
                        "label": "$~utwórz klasę",
                        "tip": "$~Utwórz nową klasę, korzystając z tych informacji."
                    }
                },
                "error": {
                    "duplicates": "$~W informacjach o uczniu znajdują się zduplikowane wpisy.",
                    "columns": "$~Upewnij się, że każdy uczeń ma taką samą liczbę kolumn.",
                    "generate": "$~Nie można utworzyć unikalnych nazw użytkowników.",
                    "taken": "$~Jedna lub więcej powyższych nazw użytkownika jest zajęta",
                    "limit": "$~Nie można utworzyć klasy liczącej więcej niż 35 uczniów na raz.",
                    "words": "$~Podaj co najmniej 25 słów.",
                    "account": "$~Niektórych kont nie można utworzyć.",
                    "generic": "$~Nie mogliśmy utworzyć klasy. Oto kilka informacji, które pomogą programistom ustalić, co poszło nie tak."
                }
            },
            "class": {
                "header": "$~Klasa",
                "subheader": {
                    "teachers": "$~Nauczycielstwo",
                    "students": "$~Studenci",
                    "galleries": "$~Galerie"
                },
                "prompt": {
                    "gallery": "$~Utwórz galerię dla swojej klasy, aby zorganizować zadanie lub projekt. Wszyscy nauczyciele w projekcie będą kuratorami galerii, a wszyscy uczniowie twórcami galerii.",
                    "delete": "$~Usunięcie tych zajęć spowoduje trwałe usunięcie informacji o zajęciach, ale także ich projektów, galerii i kont uczniów."
                },
                "field": {
                    "name": {
                        "description": "$~nazwa klasy",
                        "placeholder": "$~nazwa"
                    },
                    "description": {
                        "description": "$~Opis klasy",
                        "placeholder": "$~opis"
                    },
                    "newteacher": {
                        "placeholder": "$~e-mail lub nazwa użytkownika",
                        "description": "$~adres e-mail lub nazwa użytkownika twórcy, któremu chcesz przyznać dostęp nauczyciela do tej klasy"
                    },
                    "addteacher": "$~Dodaj nauczyciela do tej klasy",
                    "delete": {
                        "tip": "$~Usuń tę klasę na zawsze.",
                        "label": "$~Usuń tę klasę"
                    }
                },
                "error": {
                    "notfound": "$~Nie znaleźliśmy tych zajęć lub nie masz uprawnień do ich przeglądania."
                }
            },
            "guide": {
                "header": "$~Przewodnik",
                "description": "$~To jest odniesienie do każdej części języka programowania Wordplay. Wyszukaj koncepcję lub przejrzyj listę, aby dowiedzieć się więcej."
            },
            "projects": {
                "header": "$~Projektowanie",
                "projectprompt": "$~Chcesz coś powiedzieć? Stwórz projekt lub pracuj nad nim. Jeśli utkniesz, kontynuuj <learning@://learn>.",
                "archiveheader": "$~Zarchiwizowano",
                "archiveprompt": "$~Są to projekty, które zarchiwizowałeś. Tylko właściciele mogą je trwale usunąć lub przywrócić z archiwum. Zarchiwizowane projekty zostaną trwale usunięte 30 dni po ostatniej edycji.",
                "galleriesheader": "$~Galerie",
                "galleryprompt": "$~Twórz i zarządzaj galeriami, aby udostępniać innym kolekcję projektów.",
                "add": {
                    "header": "$~Nowy projekt",
                    "explanation": "$~Wybierz szablon, aby utworzyć nowy projekt."
                },
                "button": {
                    "newproject": "$~nowy projekt",
                    "editproject": "$~edytuj ten projekt",
                    "viewcode": "$~zobacz kod tego projektu",
                    "newgallery": "$~nowa galeria",
                    "unarchive": "$~usuń archiwizację tego projektu"
                },
                "confirm": {
                    "archive": {
                        "description": "$~zarchiwizuj ten występ",
                        "prompt": "$~archiwum"
                    },
                    "delete": {
                        "description": "$~trwale usuń ten występ",
                        "prompt": "$~usuń na zawsze"
                    }
                },
                "error": {
                    "noaccess": "$~Nie mogliśmy połączyć się z internetem.",
                    "nogalleryedits": "$~Aby tworzyć i zmieniać galerie, musisz się zalogować.",
                    "newgallery": "$~Nie udało się utworzyć nowej galerii.",
                    "nodeletes": "$~Aby usunąć zarchiwizowane projekty, musisz się zalogować.",
                    "delete": "$~Ups, nie udało się usunąć projektu!"
                }
            },
            "galleries": {
                "header": "$~Galerie",
                "prompt": "$~To są występy, które wykonali inni. Przeżyj je, przestudiuj lub dostosuj do własnego oświadczenia.",
                "examples": "$~Przykłady"
            },
            "about": {
                "header": "$~O",
                "content": [
                    "$~Czy kiedykolwiek miałeś wrażenie, że kodowanie jest zajęciem zarezerwowanym wyłącznie dla ludzi Zachodu, którzy mówią płynnie po angielsku i mają pełną sprawność, a wychowali się w otoczeniu komputerów?",
                    "$~Tak, my też.",
                    "$~To nie przypadek. Od zarania dziejów informatyki języki programowania były projektowane i tworzone przez tę samą grupę ludzi – głównie białych, cis, mówiących po angielsku mężczyzn w środowisku akademickim i przemyśle w USA i Europie oraz kilka niesamowitych matematyczek. Wykonywali swoją pracę w czasach postkolonialnych, w których zwycięzca bierze wszystko, a języki programowania były kluczowym narzędziem do zabezpieczenia tej władzy.",
                    "$~Historia ta doprowadziła do powstania wizji obliczeń, w których najważniejsze są szybkość, logika, zysk i dominacja.",
                    "$~To niesprawiedliwość. Ponieważ informatyka, na dobre i na złe, obecnie wspiera codzienne życie w widoczny i niewidoczny sposób, a ludzie, którzy mają dostęp do tworzenia za jej pomocą, są najbardziej podobni do jej twórców. Reszta ludzkości pozostaje zobowiązana wobec tej mocy, ponieważ wyobrażenie sobie czegoś innego wymaga umiejętności czytania i pisania, ograniczonej barierami językowymi, barierami dostępności, barierami ekonomicznymi i nierównościami w edukacji publicznej.",
                    "$~*Wordplay* aspiruje do zmiany tego stanu rzeczy. Jest to platforma programistyczna zaprojektowana tak, aby była globalna, obsługiwała /wszystkie/ języki świata, ale także /była o/ językach świata. Platforma, na której każdy może tworzyć, niezależnie od posiadanych umiejętności, aby udostępniać interaktywne treści, których każdy może doświadczyć. Dla młodzieży i młodych dorosłych, którzy chcą wyrażać siebie za pomocą interaktywnych słów, emotikonów i typografii, w zabawny i artystyczny sposób. Nie w celu zdobycia władzy dla siebie, ale w celu stworzenia obliczeniowego świata, który rozpoznaje niesamowitą siłę i konieczność naszych pięknych różnic.",
                    "$~Jesteśmy społecznością projektantów, edukatorów i deweloperów, którzy starają się urzeczywistnić tę wizję. Jesteśmy ludźmi kolorowymi, trans, queer, niepełnosprawnymi, imigrantami, uchodźcami. Jesteśmy skupieni w <University of Washington@https://washington.edu> <Information School@https://ischool.uw.edu/> w Seattle, Waszyngton, USA, miejscu, które aspiruje do przyjęcia wszystkich i cofnięcia niepełnosprawnych i rasistowskich spustoszeń kolonializmu, które trwają do dziś. Stworzenie tego języka programowania i platformy jest małą częścią tej misji, oferującą wgląd w przyszłość informatyki, do której należy /każdy/.",
                    "$~Chętnie pomożemy. Dowiedz się <how to contribute@https://github.com/wordplaydev/wordplay/wiki/contribute>, <donate@://donate> lub śledź nasze <progress@https://github.com/amyjko/wordplay/milestones>. Napisz do naszego organizatora społeczności <Amy@https://amyjko.phd>, jeśli masz pytania."
                ]
            },
            "login": {
                "header": "$~Login",
                "subtitle": "$~Zapisz, współpracuj i udostępniaj",
                "anonymous": "$~login",
                "prompt": {
                    "login": "$~Zaloguj się, aby zapisać swoje projekty, współpracować i udostępniać:",
                    "join": "$~Lub <utwórz konto@://join>, aby rozpocząć.",
                    "forgot": "$~*Zapomniałeś hasła?* Niestety, nie możemy odzyskać Twojego konta, ponieważ nie gromadzimy danych kontaktowych.",
                    "enter": "$~Wygląda na to, że Twój link logowania pochodzi z innej przeglądarki lub urządzenia. Czy możesz wpisać swój adres e-mail jeszcze raz, abyśmy mieli pewność, że to Ty?",
                    "play": "$~Jesteś zalogowany, możemy teraz zapisać Twoje projekty online! Chcesz coś stworzyć?",
                    "tooyoung": "$~Musisz mieć ukończone 13 lat, aby zalogować się za pomocą adresu e-mail.",
                    "passwordrule": "$~Hasło musi mieć co najmniej 10 znaków. Jeśli nie używasz menedżera haseł, wybierz trzy długie słowa, które łatwo zapamiętasz.",
                    "passwordreminder": "$~Wygląda na to, że nie masz jeszcze konta. Wprowadź ponownie swoje hasło i upewnij się, że zapisałeś je bezpiecznie i poprawnie, ponieważ nie można go odzyskać.",
                    "changeEmail": "$~Chcesz zmienić swój adres e-mail? Prześlij nowy, a my wyślemy potwierdzenie na stary.",
                    "changePassword": "$~Chcesz zmienić hasło? Podaj nowe i powtórz je.",
                    "email": "$~Czy masz konto wyłącznie e-mail? Zaloguj się, podając swój adres e-mail, a jeśli jest z nim powiązane konto, wyślemy Ci wiadomość e-mail z linkiem do logowania. Nowe konta wyłącznie e-mail nie są obsługiwane, aby zachować prywatność.",
                    "sent": "$~Jeśli ten adres e-mail jest powiązany z kontem, otrzymasz e-mail z linkiem do logowania. Może minąć kilka minut, zanim się pojawi. Jeśli z tym adresem e-mail nie jest powiązane żadne konto, nie otrzymasz niczego.",
                    "logout": "$~Czy korzystasz ze współdzielonego urządzenia i chcesz zachować prywatność swoich projektów? Wyloguj się, a my *usuniemy Twoje projekty* z tego urządzenia, ale zostaną zapisane online.",
                    "success": "$~Konto utworzone!",
                    "confirm": "$~Sprawdź swój stary adres e-mail, aby potwierdzić nowy adres.",
                    "delete": "$~Chcesz, żebyśmy zapomnieli o wszystkim, co tu zrobiłeś? Tego nie da się cofnąć.",
                    "reallyDelete": "$~Czy jesteś pewien? Twoje konto i ustawienia zostaną natychmiast usunięte, a Twoje projekty zostaną zaplanowane do usunięcia. Współpracownicy nad Twoimi projektami natychmiast utracą do nich dostęp. Wpisz swój adres e-mail lub nazwę użytkownika, aby potwierdzić, że tego chcesz.",
                    "name": "$~Wybierzemoji,którabędzieCięreprezentowaćwoczachinnych."
                },
                "error": {
                    "expired": "$~Ten link wygasł.",
                    "invalid": "$~Ten link jest nieprawidłowy.",
                    "email": "$~Ten adres e-mail jest nieprawidłowy.",
                    "failure": "$~Nie można się zalogować :(",
                    "offline": "$~Nie udało nam się dosięgnąć chmury ☁️.",
                    "unchanged": "$~Nie udało nam się zmienić Twojego adresu e-mail, ale nie wiemy dlaczego.",
                    "delete": "$~Nie mogliśmy usunąć Twojego konta, ale nie wiemy dlaczego.",
                    "wrongPassword": "$~Nieprawidłowa nazwa użytkownika i hasło. Albo twoje hasło jest nieprawidłowe, albo ktoś inny ma tę nazwę użytkownika.",
                    "tooMany": "$~Próbowałeś i nie udało Ci się zalogować zbyt wiele razy. Będziesz musiał poczekać, aby spróbować ponownie."
                },
                "feedback": {
                    "changing": "$~Wysyłanie nowego e-maila...",
                    "deleting": "$~Ok, usuwam Twoje projekty i ustawienia...",
                    "updatedPassword": "$~Twoje hasło zostało zaktualizowane.",
                    "match": "$~Musi być zgodna z nazwą użytkownika Twojego konta."
                },
                "field": {
                    "email": {
                        "description": "$~edytuj e-mail logowania",
                        "placeholder": "$~e-mail"
                    },
                    "username": {
                        "description": "$~login nazwa użytkownika, nie używaj danych osobowych",
                        "placeholder": "$~nazwa użytkownika"
                    },
                    "password": {
                        "description": "$~hasło logowania, co najmniej 10 znaków",
                        "placeholder": "$~hasło"
                    },
                    "currentPassword": {
                        "description": "$~Twoje obecne hasło logowania",
                        "placeholder": "$~aktualne hasło"
                    },
                    "newPassword": {
                        "description": "$~Twoje nowe hasło",
                        "placeholder": "$~nowe hasło"
                    }
                },
                "button": {
                    "logout": {
                        "tip": "$~wyloguj się ze swojego konta",
                        "label": "$~wylogować się"
                    },
                    "login": "$~zaloguj się za pomocą tego adresu e-mail, wysyłając link do logowania",
                    "updateEmail": "$~zmień swój e-mail",
                    "delete": {
                        "tip": "$~usuń swoje konto",
                        "label": "$~usuń moje dane…"
                    },
                    "reallyDelete": {
                        "tip": "$~usuń swoje konto na zawsze",
                        "label": "$~usuń to!!!"
                    },
                    "updatePassword": "$~podaj nowe hasło"
                },
                "toggle": {
                    "reveal": {
                        "on": "$~Pokaż hasło",
                        "off": "$~Ukryj hasło"
                    }
                }
            },
            "join": {
                "header": "$~Dołączyć",
                "prompt": {
                    "create": "$~Utwórz konto, aby zapisywać swoje projekty, współpracować z innymi i udostępniać swoją pracę.",
                    "username": "$~Nazwy użytkowników muszą mieć co najmniej /5 znaków/, nie mogą być adresami e-mail i nie powinny zawierać Twojego imienia ani innych informacji identyfikujących.",
                    "password": "$~Hasła muszą mieć co najmniej /10 znaków/. Wpisz je dwa razy i zapisz w bezpiecznym miejscu, np. w menedżerze haseł. *Nie ma możliwości odzyskania konta*, jeśli je zgubisz, ponieważ nie zbieramy informacji kontaktowych."
                }
            },
            "rights": {
                "header": "$~Prawa",
                "content": [
                    "$~Cześć!",
                    "$~Określmy pewne oczekiwania dotyczące Twoich i naszych praw (również w świetle polityki, takiej jak <COPPA@https://www.ecfr.gov/current/title-16/chapter-I/subchapter-C/part-312> i <GDPR@https://gdpr.eu/compliance-checklist-us-companies/>).",
                    "$~Pierwszą rzeczą, którą należy wiedzieć, jest to, że nie jesteśmy podmiotem komercyjnym. Jesteśmy projektem badawczym opartym na społeczności, mieszczącym się na uniwersytecie non-profit. Naszym celem jest stworzenie platformy, która przynosi radość i pomaga nam dokonywać odkryć na temat bardziej sprawiedliwego i sprawiedliwego świata informatyki. Nie mamy żadnego interesu w zarabianiu pieniędzy na tej platformie; wszelkie pieniądze, które zbieramy (zwykle ze środków publicznych), są wykorzystywane do utrzymania platformy, a nie do wzbogacania osób, które na niej pracują (lub się do niej przyczyniają).",
                    "$~Ponieważ nie dążymy do zysku, oznacza to również, że nie możemy składać żadnych obietnic dotyczących niezawodności, dostępności ani długowieczności tej platformy. Mimo to <Amy@https://amyjko.phd> jest zaangażowana w jej długoterminowe utrzymanie, a jako profesor etatowy ma dość stabilną pracę.",
                    "$~To prowadzi do *danych*. Oto, co zbieramy i przechowujemy w chmurze:",
                    "$~• Twoje *projekty*. Przechowujemy wszystkie projekty, do których się przyczyniasz, i Twoje zmiany w nich, chyba że te projekty wydają się zawierać dane osobowe, takie jak numery telefonów, adresy e-mail, nazwy użytkowników, identyfikatory podatkowe lub adresy.",
                    "$~• Twoje *ustawienia*. Obejmuje to wybrane języki, preferencje animacji i postępy w samouczku. Wszystko inne jest przechowywane tylko na Twoim urządzeniu.",
                    "$~• Łączna *aktywność*. Śledzimy logowania i odwiedzane przez Ciebie strony, ale nie w sposób, który może Cię zidentyfikować, śledzić Cię w witrynie lub śledzić Cię w innych witrynach. Używamy Google Analytics w trybie „odmowa zgody”, który zbiera tylko minimalne nieidentyfikowalne informacje o wyświetleniach stron, bez przechowywania plików cookie lub wysyłania informacji o adresie IP do Google. Używamy tych zbiorczych informacji, aby pomóc w zbieraniu funduszy, raportując, jak bardzo platforma jest używana.",
                    "$~Nie przechowujemy niczego innego. Nasz <source@https://github.com/amyjko/wordplay/tree/main/src> jest publiczny, więc każdy może to zweryfikować i zgłosić wszelkie niezamierzone śledzenie.",
                    "$~*Ty* jesteś właścicielem swoich danych, nie my. To oznacza:",
                    "$~• Masz kontrolę nad tym, kto może uzyskać dostęp do Twoich projektów. Domyślnie są prywatne, ale możesz udostępniać je osobom, grupom lub całkowicie upubliczniać.",
                    "$~• Możesz w każdej chwili całkowicie usunąć dowolny projekt lub swoje konto.",
                    "$~• W każdej chwili możesz wyeksportować dowolny projekt lub całe konto.",
                    "$~Oto, w jaki sposób wykorzystamy Twoje dane:",
                    "$~• Nie będziemy udostępniać Twoich danych nikomu, chyba że będzie to wyraźnie wymagane przez prawo. Zawsze istnieje możliwość, że Twoje dane zostaną pobrane bez naszej zgody („naruszenie danych”). Jeśli odkryjemy, że tak się stało, powiadomimy Cię o tym, korzystając z adresu e-mail, który nam udostępniłeś.",
                    "$~• Nie będziemy się z Tobą kontaktować za pośrednictwem Twojego adresu e-mail, chyba że 1) dokonasz zmiany na koncie, która tego od nas wymaga, 2) wyraźnie wyrazisz zgodę na kontakt z nami lub 3) nastąpi naruszenie danych opisane powyżej.",
                    "$~• Możemy analizować projekty na platformie, aby zrozumieć, co każdy tworzy i jak to robi. Możemy udostępniać te zagregowane, zanonimizowane spostrzeżenia w publikacjach naukowych. Będziemy to robić wyłącznie pod nadzorem instytucjonalnej rady ds. przeglądu, zgodnie z nakazem federalnego prawa USA.",
                    "$~Na koniec uwaga na temat mowy. Możesz powiedzieć cokolwiek chcesz na tej platformie w trybie *prywatnym*. Projekty są domyślnie prywatne, a jeśli udostępnisz je określonym adresom e-mail, nadal będą uważane za prywatne. Nie będziemy moderować niczego w projektach prywatnych.",
                    "$~Ale uczynienie projektu *publicznym* lub umieszczenie go w publicznej galerii jest przywilejem. To platforma stworzona dla miłości, afirmacji, szacunku i godności. Dlatego oczekujemy, że żadna z Twoich *publicznych* treści nie będzie:"
                ],
                "consequences": [
                    "$~Jeśli znajdziemy projekt lub galerię, która narusza te zasady, ostrzeżemy twórców przed ich wyświetleniem lub zablokujemy ich wyświetlanie. Jeśli wielokrotnie naruszysz te zasady, stracisz przywilej publicznego publikowania."
                ]
            },
            "donate": {
                "header": "$~Podarować",
                "prompt": "$~Pomóż nam opłacić przepustowość i wynagrodzić studentów i nauczycieli, którzy się do nas przyczyniają.",
                "content": [
                    "$~Wordplay to darmowy projekt społecznościowy wspierany przez <University of Washington@https://washington.edu>. Polegamy na darach od osób, które wierzą w naszą misję dostępnych, inkluzywnych językowo, edukacyjnych języków programowania.",
                    "$~Oto nasze obecne koszty:",
                    "$~• Rekompensujemy studentom University of Washington, zwłaszcza tym niepełnosprawnym lub tym, których pierwszym językiem nie był angielski, rozwijanie i utrzymywanie projektu. Stanowi to około 90% naszych kosztów.",
                    "$~• Przyznajemy stypendia nauczycielom, z którymi współpracujemy przy opracowywaniu wielojęzycznych, dostępnych programów nauczania.",
                    "$~• Płacimy Google za przepustowość i pamięć masową <Firebase@https://firebase.google.com/> oraz usługi <Workspace@https://workspace.google.com/>.",
                    "$~• Płacimy <Squarespace@https://www.squarespace.com/> rocznie za domenę.",
                    "$~Nasze obecne koszty, zakładając 5 studentów studiów licencjackich w cenie 20 USD za godzinę, 10 godzin tygodniowo w roku akademickim (36 tygodni) i 2 studentów studiów licencjackich w okresie letnim (12 tygodni), plus usługi w chmurze, wynoszą około 60 tys. USD rocznie.",
                    "$~Gdyby 2400 osób przekazało nam 25 USD rocznie, pokryłoby to nasze obecne koszty, a ewentualną nadwyżkę przeznaczylibyśmy na wynagrodzenia dla większej liczby uczniów i nauczycieli.",
                    "$~Czy możesz być jedną z tych 2400 osób? Jeśli tak, oto nasz link do University of Washington:"
                ]
            }
        },
        "edit": {
            "node": "$~$1$2[, typ $2|]",
            "before": "$~przed $1[$1|końcem]",
            "inside": "$~w $1, pomiędzy $2[$2|początek] i $3[$3|koniec]",
            "between": "$~między 1 a 2 dolarami",
            "line": "$~pusta linia pomiędzy $1[$1|start] i $2[$2|end]",
            "conflicts": "$~$1 konflikty",
            "assign": "$~/$2[Chętny do przyłączenia się|Rozważa odejście]…/",
            "append": "$~/Chętnie wstawię…/",
            "remove": "$~/Rozważa opuszczenie…/",
            "replace": "$~/Chce wkroczyć…/",
            "wrap": "$~w nawiasach",
            "unwrap": "$~odwijać się",
            "bind": "$~nazwij to wyrażenie"
        },
        "template": {
            "unwritten": "$~Do ustalenia",
            "unparsable": "$~Niemożliwy do przeanalizowania szablon: $1"
        }
    },
    "moderation": {
        "warning": {
            "header": "$~Ostrzeżenie",
            "explanation": "$~Moderator uznał, że ta treść może:"
        },
        "blocked": {
            "header": "$~Zablokowany",
            "explanation": "$~Moderator uznał, że ta treść może:"
        },
        "unmoderated": {
            "header": "$~Notatka",
            "explanation": "$~Ta treść nie została jeszcze zmoderowana. Może:"
        },
        "moderate": {
            "header": "$~Umiarkowany",
            "explanation": "$~Przejrzyj ten projekt i zdecyduj, czy jego zawartość spełnia którykolwiek z poniższych warunków. Jeśli tak, treść zostanie ostrzeżona lub zablokowana. Możesz pominąć, jeśli nie masz pewności."
        },
        "flags": {
            "violence": "$~Podżegać, zachęcać do przemocy, wyrządzania krzywdy lub samookaleczenia kogokolwiek lub celebrować je.",
            "dehumanization": "$~Dehumanizować jednostki lub grupy ze względu na rasę, przynależność etniczną, narodowość, kastę, orientację seksualną, płeć, religię, wiek, sprawność lub wygląd.",
            "disclosure": "$~Ujawniaj prywatne informacje o innych osobach, takie jak imiona, dane kontaktowe lub adresy fizyczne",
            "misinformation": "$~Zawierają fałszywe, wprowadzające w błąd, oszukańcze lub manipulacyjne informacje"
        },
        "progress": "$~*$1* moderowane, pozostało *$2*",
        "button": {
            "submit": {
                "tip": "$~Zapisz te ustawienia moderacji",
                "label": "$~ratować"
            },
            "skip": {
                "tip": "$~Pomiń ten projekt",
                "label": "$~pominąć"
            }
        }
    },
    "gallery": {
        "games": {
            "name": "$~Zawodysportowe",
            "description": "$~Interaktywne gry ze słowami i symbolami."
        },
        "visualizations": {
            "name": "$~Wizualizacje",
            "description": "$~Wizualizacje tekstu i za pomocą tekstu."
        },
        "motion": {
            "name": "$~Ruch",
            "description": "$~Przykłady ruchu i kolizji."
        },
        "av": {
            "name": "$~Dźwięk/Wideo",
            "description": "$~Używanie głośności, wysokości dźwięku i obrazu wideo jako danych wejściowych."
        },
        "tools": {
            "name": "$~Narzędzia",
            "description": "$~Proste narzędzia i aplikacje."
        }
    }
}
