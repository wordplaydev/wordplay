{
    "$schema": "../../schemas/LocaleText.json",
    "language": "zh",
    "region": "CN",
    "wordplay": "双关语",
    "term": {
        "evaluate": "评价",
        "bind": "联结",
        "decide": "决定",
        "document": "文件",
        "project": "工程",
        "source": "来源",
        "input": "输入",
        "output": "输出",
        "convert": "转变",
        "act": "表演",
        "scene": "场景",
        "phrase": "短语",
        "group": "组",
        "stage": "舞台",
        "type": "类型",
        "start": "开始",
        "entered": "进入",
        "changed": "改变了",
        "moved": "移动了",
        "name": "姓名",
        "value": "价值",
        "text": "文字",
        "boolean": "布尔值",
        "map": "映射",
        "number": "数字",
        "function": "函数",
        "exception": "异常",
        "table": "表格",
        "none": "空的",
        "list": "列表",
        "stream": "溪流",
        "structure": "结构",
        "index": "索引",
        "query": "询问",
        "row": "排",
        "set": "组",
        "key": "钥匙",
        "help": "帮助",
        "feedback": "反馈"
    },
    "token": {
        "EvalOpen": "评估开放",
        "EvalClose": "评估结束",
        "SetOpen": "设置打开",
        "SetClose": "设置关闭",
        "ListOpen": "组打开",
        "ListClose": "组关闭",
        "TagOpen": "标签打开",
        "TagClose": "标签关闭",
        "Bind": "联结",
        "Access": "访问",
        "Function": "函数",
        "Borrow": "借",
        "Share": "分享",
        "Convert": "转变",
        "Doc": "文件",
        "Formatted": "格式化的",
        "FormattedType": "格式化类型",
        "Words": "字",
        "Link": "链接",
        "Italic": "斜体",
        "Underline": "底线",
        "Light": "轻",
        "Bold": "粗体",
        "Extra": "额外的",
        "Concept": "概念",
        "URL": "网址",
        "Code": "代码",
        "Mention": "提到",
        "Otherwise": "否则",
        "Match": "匹配",
        "None": "空的",
        "Type": "类型",
        "Literal": "字面量",
        "TypeOperator": "类型运算符",
        "TypeOpen": "类型打开",
        "TypeClose": "类型关闭",
        "Separator": "分隔器",
        "Language": "语言",
        "Region": "地区",
        "BooleanType": "布尔类型",
        "NumberType": "数字类型",
        "JapaneseNumeral": "日语数字",
        "RomanNumeral": "罗马数字",
        "Pi": "Pi",
        "Infinity": "无穷",
        "TableOpen": "表格打开",
        "TableClose": "表格关闭",
        "Select": "选择",
        "Insert": "插入",
        "Update": "更新",
        "Delete": "删除",
        "Union": "联盟",
        "Stream": "溪流",
        "Change": "改变",
        "Initial": "初步",
        "Previous": "以前的",
        "Placeholder": "占位符",
        "Etc": "Etc",
        "This": "这",
        "Operator": "运算符",
        "Conditional": "有条件的",
        "Text": "文本",
        "Number": "数字",
        "Decimal": "小数",
        "Base": "基数",
        "Boolean": "布尔值",
        "Name": "名字",
        "Unknown": "不明",
        "Locale": "语言环境",
        "End": "结束"
    },
    "node": {
        "Dimension": {
            "name": "尺寸",
            "description": "尺寸",
            "emotion": "serious",
            "doc": [
                "我是一个/计量单位/！",
                "我可以是任何标准化单位，例如 \\1米\\、\\10秒\\、\\100克\\ 或任何其他科学单位。我也很高兴能成为任何想要组成的单位，比如\\17苹果\\。",
                "我可以与 \\/\\ 组合起来制作比率单位，如 \\17苹果/日\\ ，并与 \\^\\ 组合制作指数单位，如 \\9.8米/秒^2\\",
                "我必须始终追随@Number。 如果不这样做，我可能会被误认为@Reference",
                "我也很擅长发现单位之间的不一致之处。 例如，\\1猫 + 1狗\\没有任何意义！",
                "如果你想在不同的单位值之间进行转换，请和@Convert说说吧。"
            ]
        },
        "Doc": {
            "name": "解释说明",
            "emotion": "serious",
            "doc": [
                "我用 @Markup 来格式化别的东西, 比如你的 @Program 的解释说明, 甚至是你用 @Phrase 放上这个舞台的文字。",
                "举个例子，我可以跑到任何句子的前面:",
                "\\¶这真的会是7吗?¶\n7\\",
                "又比如，你可以把我放在 @Bind 的前面：",
                "\\¶我可以测量一个人有多高¶\n高度: 5米\\",
                "或者在一个 @FunctionDefinition 的前面:",
                "\\¶我把两个数字相加¶\nƒ 总和(a•# b•#) a + b\\",
                "或者在一个 @StructureDefinition 的前面:",
                "\\¶我记得别人的名字和他们爱吃的水果¶\n•人名(名字•'' 水果•'')\\",
                "你也可以把我放在一个 @Program 的前面来说明这整个项目是在干什么",
                "\\¶这个项目在说你好¶\n\n'你好!'\\",
                "你还可以给我一个 @Language 来告诉其他人我在讲什么语言:",
                "\\¶我是一篇中文文档¶/zh\n持续时长: 5秒\\",
                "不过，你知道你可以创造一整个列表那样多的我吗？ 去跟 @Docs 聊聊这件事吧。"
            ]
        },
        "Docs": {
            "name": "解释清单列表",
            "emotion": "serious",
            "doc": [
                "我是 @Doc 的一个列表， 在你有许多不同语言的 @Doc 的翻译时会非常有用。",
                "创造一个列表不需要你做任何特殊的事情， 只用把一些 @Doc 像这样排列在一起，一个就在另一个的旁边:",
                "\\¶你好¶/zh\n¶Hola¶/es\n问候语: '…'\\"
            ],
            "start": "来多写一些句子吧！"
        },
        "KeyValue": {
            "name": "映射",
            "emotion": "kind",
            "doc": [
                "我是在一个 @Map 中从一个 *关键码* 到一个 *值* 的映射。",
                "我可以映射任意类型的值。比如，这里有一个数字们的映射:",
                "\\{1:1}\\",
                "或者映射数字和一个词语:",
                "\\{'兔子':1}\\"
            ]
        },
        "Language": {
            "name": "语言",
            "description": "语言 $1[$1|unknown]",
            "emotion": "eager",
            "doc": [
                "我是一个语言标签，我与 @Name 和 @Doc 一起工作!",
                "我真的擅长让别人 *超级清楚* 事物是用什么语言撰写的。",
                "这就是我做的事情。 只需一个小小斜线和几个字母，大家就都清楚一些文本使用的是什么语言了。",
                "比如，你要是想说我的 $name， 但想让别人清楚地知道它是中文：",
                "\\\"语言\"/zh\\",
                "要是你想要这样处理 @Name 也可以。",
                "\\声音/zh: '喵'\\",
                "甚至是用在 @Doc 身上！",
                "\\¶拟声词¶/zh\n声音/zh: \"喵\"\\",
                "这里还有许多我能理解的 <两个字母的语言表达代码@https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes> 。如果你没有使用它们中的任意一个，我会告诉你的。"
            ],
            "conflict": {
                "UnknownLanguage": "我不知道这个语言呢",
                "MissingLanguage": "这里缺少了对语言的描述，你能加上一个吗？"
            }
        },
        "Name": {
            "name": "命名",
            "description": "$1[$1 | unnamed]",
            "emotion": "kind",
            "doc": [
                "我会识别一个值，而且能够帮你给难以运算的事物贴上简洁的的标签，不然你就要一遍又一遍地运算它们。",
                "@Bind 像这样给我命名：",
                "\\嗨: 5\\",
                "我只能代表一个值，一旦我被赋予了一个值，我就不能改变它。比如，要是你尝试对 @Bind 这样做，我们就会抱怨。",
                "\\嗨: 5\n嗨: 3\\",
                "要是你想得到我的值，就需要让 @Reference 或者 @PropertyReference 使用名字。在这里，@Bind 给我命名，然后用 @Reference 就会得到我的值。",
                "\\嗨: 5\n嗨\\",
                "因为 @Bind 可以在许多地方出现，我也可以在那么多的地方出现。我刚才在一个上面的 @Block ，但我也可以在一个 @FunctionDefinition 里面。现在我暂时地给一条信息命名：",
                "\\ƒ 说(信息•'') 信息\\",
                "我在 @FunctionDefinition 里面被定义，当这个功能完成它的评估后，我就消失啦。",
                "你可以用 @Language 来表示我的名字是什么语言的。这会在你与别人分享你的程序并想让别人阅读它的时候非常有帮助。"
            ]
        },
        "Names": {
            "name": "命名列表",
            "emotion": "kind",
            "doc": [
                "我是一个 @Name 的列表，当你想给一个值几个名字的时候特别有用，常常是和不同的 @Language。",
                "名字们用 \\,\\ 符号隔开。比如， 这就是 @Bind 给一个值好几个 @Name :",
                "\\嗨/zh,你好/zh,hola/es: '欢迎'\\"
            ]
        },
        "Row": {
            "name": "排",
            "emotion": "shy",
            "doc": "我代表了一个 @Table 中的一排。你最好和 @Table 聊聊这个，因为它知道我的所有事情。我只是在这里确保所有值都在一行里。 :(",
            "conflict": {
                "InvalidRow": "行要么是所有值，要么必须是所有 @Bind 。",
                "MissingCell": {
                    "primary": "我和一列 $1 走散啦。",
                    "secondary": "这里是需要我的，但是 $1 好像没有提供呢。"
                },
                "UnknownColumn": "我不知道有哪一列是这个名字呀。",
                "ExtraCell": {
                    "primary": "我真的应该在这里吗？",
                    "secondary": "嘿 $1，你不是 @Table 的一部分呀!"
                },
                "UnexpectedColumnBind": {
                    "primary": "我真的应该是一个 @Bind 吗?",
                    "secondary": "嘿，我是一个 @Table, 我需要一个值，而不是 @Bind。"
                }
            }
        },
        "Token": {
            "name": "令牌",
            "description": "$1 $2",
            "emotion": "neutral",
            "doc": [
                "你怎么找到我的？",
                "我是表演中最微小的一部分。我是让所有文字成为文字的基础。我是我们编舞里原子大小的微粒。"
            ]
        },
        "TypeInputs": {
            "name": "输入类型",
            "emotion": "curious",
            "doc": "我是一个类型列表，可以代替 @StructureDefinition 或 @FunctionDefinition 中的 @TypeVariables。我可以帮助每个人知道他们将收到什么样的输入。"
        },
        "TypeVariable": {
            "name": "变量类型",
            "emotion": "curious",
            "doc": "我是 @FunctionDefinition 或 @StructureDefinition 上的神秘类型，由 @TypeInputs 在对其中任一类型进行求值时提供。@Set、@List 和 @Map 都可以使用我。",
            "conflict": {
                "DuplicateTypeVariable": {
                    "primary": "我和 $1 有一样的值。",
                    "secondary": "我和 $1 有一样的名字。"
                }
            }
        },
        "TypeVariables": {
            "name": "变量类型列表",
            "emotion": "curious",
            "doc": "我是一个列表的 @TypeVariable 。"
        },
        "Markup": {
            "name": "标记",
            "description": "$1 段落",
            "emotion": "serious",
            "doc": [
                "我是一个段落列表，使用了解释中可用的多种标记，如 @Words、@WebLink、@ConceptLink 和 @Example 等."
            ]
        },
        "Paragraph": {
            "name": "段落",
            "emotion": "serious",
            "doc": [
                "我是一系列的 @Words、@ConceptLink、@WebLink 和 @Example ，我们在 @Doc 内用空行隔开。",
                "你只在 @Doc 写好多好多字就可以构成我:",
                "\\¶我是文档中的一个段落。¶'一个段落'\\",
                "如果你想要多个段落，只要在中间隔上空行。",
                "\\¶段落一\n\n段落二\n\n段落三¶'三个段落'\\"
            ]
        },
        "WebLink": {
            "name": "链接",
            "description": "链接 $1",
            "emotion": "serious",
            "doc": [
                "我是能带你去网络上一个地方的链接。我只需要一个描述和一个网址:",
                "\\¶我是一个在文档中的 <链接@https://wordplay.dev>¶\n'链接示例'\\",
                "如果有人选中了我，我将会打开去往这个网址的新窗口。"
            ]
        },
        "ConceptLink": {
            "name": "概念",
            "description": "概念链接",
            "emotion": "serious",
            "doc": [
                "我是一个通往诗篇角色的链接。 我在你想要写一篇 @Doc 以及引用我们中的任何一个时非常有帮助。",
                "比如说，要是你想要谈谈 @Evaluate 以及它们有多好，你就可以这样写:",
                "\\¶你知道吗？ @Evaluate 真的非常出色。¶\n'看，一个概念链接！'\\",
                "当你写的 @Doc 出现在这里，它就会出现一个联通这个概念的链接。"
            ]
        },
        "Words": {
            "name": "文字",
            "emotion": "serious",
            "doc": [
                "我是你在一篇 @Doc 中喜爱的所有文字。比如:",
                "\\¶愿力量与你同在。¶\n'只是一些文字！'\\",
                "虽然有些时候，你可能想用@Doc 里的特殊字符 /作为/ 文字。比如:",
                "\\¶我的朋友使用 @@, //, **, ||, 以及其他符号。¶\n'使用了特殊字符！'\\",
                "如果你重复地使用一些特殊字符，你可能会得到一些文字而不是它们本身的特殊意义。"
            ]
        },
        "Example": {
            "name": "例子",
            "emotion": "serious",
            "doc": [
                "我是一个例子，能够帮助解释 @Doc 中的一些功能是怎么运用的！",
                "\\¶这里是一个相加的例子： \\1 + 1\\¶'示例代码'\\",
                "如果你把我单独放在一个段落里，我就会出现在一个漂亮的盒子里，展示我的评估结果。",
                "\\¶这里是一个相加的例子：\n\n\\1 + 1\\¶\\"
            ]
        },
        "Mention": {
            "name": "提到",
            "description": "提到 $1",
            "emotion": "serious",
            "doc": [
                "我是一个术语 \\$program\\ 或者一个动态输入 \\$1\\的参考资料。",
                "不过这主要是一个内部功能，你应该不需要知道。"
            ]
        },
        "Branch": {
            "name": "分支",
            "emotion": "serious",
            "doc": [
                "我是一个种在两个部分之间根据有无定义和真假与否进行选择的方法。",
                "不过这主要是一个内部功能，你应该不需要知道。"
            ]
        },
        "BinaryEvaluate": {
            "name": "二进制评估",
            "description": "$1 操作",
            "emotion": "insecure",
            "doc": [
                "我是形式更简单的 @Evaluate,当你想使用接收两个输入的 @FunctionDefinition 时很有用。",
                "比如，这样就是你怎样用 @Evaluate 来添加两个数字：",
                "\\1.+(1)\\",
                "那样看起来不是很有趣吗？它也没错: 它只是说在1上使用相加功能，然后对其进行求值。",
                "单但用 @BinaryEvaluate 可以使它更加简洁。",
                "\\1 + 1\\",
                "这让一切都变得更简洁了，尽管它们本质上是一样的。",
                "不过这里有一件事需要注意：当我处于这种形式时，我会从左到右进行评估。如果你习惯了数学中的运算顺序，这可能会让你感到困惑。",
                "我是在说我可能会以你意想不到的方式进行评估：",
                "\\1 + 2 · 3 + 4\\",
                "在数学中，乘法是第一位的，然后是加法，所以这样算的结果会是\\11\\。但因为我是按照读取顺序演算的，结果就会是\\13\\。"
            ],
            "right": "输入",
            "start": "让我们先来运算 $1 吧",
            "finish": "你看，我创造了 $1!",
            "conflict": {
                "OrderOfOperations": "我是按照读取顺序而非数学运算顺序来评估一个值的。你想用 @Block 来来指定我的运算顺序吗？"
            }
        },
        "Bind": {
            "name": "联结",
            "description": "联结 $1",
            "emotion": "excited",
            "doc": [
                "我给 *values* 命名。",
                "就像这样！",
                "\\pi: 3.1415926\\",
                "我给 @FunctionDefinition 和 @StructureDefinition 的输入值取名，我也给 @Block 中的值取名字。我可以给任何东西命名！",
                "噢，不过你知道你可以让一个值有 *许多个名字* 吗?",
                "我好高兴我能告诉你这个！一个值可以有好几个 @Names。比如:",
                "\\乔，泰斯，艾米: 5\\",
                "所以我在这里干了什么呢？",
                "我给一个值起了三个名字！",
                "你可以用那些名字里的 *任意一个* 来指代那个五。",
                "尤其是你想用多种语言命名时：",
                "\\joe/en,aimee/fr,明/zh: 5\\",
                "你看见我在这干什么了吗？我给了一个值三个不同语言的名字！",
                "好了，我还有最后一个秘密。",
                "你知道我可以和 @Is 一起来了解我需要什么样的数字吗？要是我找不到，我会告诉你的！",
                "像这样:",
                "\\极大的数字•#: \"一千亿\"\\",
                "你看，我说 \\极大的数字\\ 应该是一个数字，但它实际上是一个文本，而且它们彼此不是对应的!",
                "当它们不是互相对应的时候，我会通知你！",
                "有些时候你 *需要* 告诉我你给我的数据是什么类型的，因为我自己可不知道，这样的事通常发生在 @FunctionDefinition。",
                "比如在这里的时候， @FunctionDefinition 不知道它会有什么样的 \\a\\ 和 \\b\\,因为我没有告诉它们。",
                "\\ƒ 总和(a b) a + b\\",
                "但我们可以改变它来加上 @Is，那现在 @FunctionDefinition 就知道它们都是数字啦：",
                "\\ƒ 总和(a•# b•#) a + b\\"
            ],
            "start": "让我们看看我们能从 $1 里得到什么值吧!",
            "finish": "太好啦，我得到了 $1! 让我们给它命名为 $2",
            "conflict": {
                "DuplicateName": {
                    "conflict": {
                        "primary": "有其他人已经被命名为 $1 了，所以我不能叫这个名字。",
                        "secondary": "噢, $1 是我的名字"
                    },
                    "resolution": "有重复的名称，是否要删除一个？"
                },
                "DuplicateShare": {
                    "primary": "我有和 $1 一样的名字，这让事情有些模棱两可",
                    "secondary": "我有和 $1 一样的名字"
                },
                "IncompatibleType": {
                    "primary": "我应该是 $2 的，但现在我是 $1",
                    "secondary": "噢……抱歉，你输入了什么？ $1, 真的吗?"
                },
                "MisplacedShare": "我只能分享在 @Program 等级的事物，但没办法解释它里面的一切！",
                "MissingShareLanguages": "如果你想要分享这个，你需要说明它是什么语言的，这样其他人才知道他们能不能阅读你分享的东西！",
                "RequiredAfterOptional": "我不能在这，这里还有一个可选的 @Bind 在我前面",
                "UnexpectedEtc": "只有在 @FunctionDefinition 中我才是可变的长度",
                "UnusedBind": "嘿，我给这这个变量命名了，但是它还没有被使用呢！"
            }
        },
        "Block": {
            "name": "区块",
            "description": "$1 陈述",
            "emotion": "shy",
            "doc": [
                "嗨。我给出一小块安静的私人空间用于演算事物。",
                "像这样:",
                "\\(1 - 1) + 2\\",
                "这样可以帮助我们明确运算顺序。",
                "@Bind 也在这里帮忙了。",
                "\\(数量: 10 数量 ^ 数量)\\",
                "看见 @Bind 在这里是怎样创造 \\数量\\的了吗?它只能在我的里面命名，所以这样是行不通的:",
                "\\(数量: 10 数量 ^ 数量) + 数量\\",
                "因为数量是在我里面的一个名字。",
                "你也可以按照你的喜好在我里面放好多好多名字，但是我只会记得最后一个：",
                "\\(1 2 3 4 5)\\",
                "所以一般来讲，我只是一些 @Bind 以及在末尾的一个表述。",
                "\\(\n  a: 1\n  b: 2\n  c: 3\n  d: 4\n  a + b + c + d\n)\\"
            ],
            "statement": "陈述",
            "start": "第一个表述",
            "finish": "好啦，我现在有 $1 了",
            "conflict": {
                "ExpectedEndingExpression": "我需要一个表述。",
                "IgnoredExpression": {
                    "primary": "$~我将忽略 $1，因为它没有定义任何东西并且不是我的最后一个表达式。",
                    "secondary": "$~@Block，不要忽略我！",
                    "resolution": "$~您的意思是将其改为 @BinaryEvaluate 而不是 @UnaryEvaluate 吗？我可以添加一个空格，这样我就知道这就是您的意思。"
                }
            }
        },
        "BooleanLiteral": {
            "name": "特殊布尔值",
            "description": "$1[正确|错误]",
            "emotion": "precise",
            "doc": "我要么是 \\⊤\\ ，要么是 \\⊥\\。去看看 @Boolean 来更多地了解我们美丽的逻辑学吧。",
            "start": "$1!"
        },
        "Borrow": {
            "name": "借用",
            "description": "借用 $1[$1|不存在的命名]",
            "emotion": "excited",
            "doc": "如果你用多种 @Source 创造了一个表演，你可以使用我去借用在其他 @Source 里共享的 @Bind 。只要使用它们的名字，我就可以同时带来它们的名字和值。",
            "start": "向 $1 借用 $2",
            "source": "$source",
            "bind": "命名",
            "version": "版本",
            "conflict": {
                "UnknownBorrow": "我不知道哪个 $source 是叫这个名字的",
                "BorrowCycle": "这取决于 $1，而它取决于 $source，所以这个程序不能被运算。"
            },
            "exception": {
                "CycleException": {
                    "description": "借用循环",
                    "explanation": "$1 取决于它自己"
                }
            }
        },
        "Changed": {
            "name": "改变",
            "emotion": "serious",
            "doc": [
                "我检查流是否导致 @Program 重新评估，并生成一个 @Boolean 值。像这样",
                "\\∆ 时间()\\",
                "我会很好地在你想只有数据流发生变化才改变某些内容的时候帮到你。",
                "这就是全部了。"
            ],
            "start": "让我们看看 $1 有没有改变……"
        },
        "Conditional": {
            "name": "有条件的",
            "emotion": "curious",
            "doc": [
                "I我想我应该是来做出决定的？就像这样？",
                "\\数字: -100\n数字 < 0 ? '负数' '正数'\\",
                "但你有没有想过我们是怎样做出选择的呢？",
                "难道决定不应该比是或不是更细致吗？在 \\⊤\\ 和 \\⊥\\ 之间决定就是全部了吗?",
                "如果我们只能做这些决定，难道你不担心我们就会错过一些重要的世界的内容吗?"
            ],
            "start": "让我们看看 $1 是不是正确的",
            "afterthen": "$1[跳过这些代码 | 不要跳过这些代码]",
            "else": "已经完成了是的情况，要不我们就跳过否的情况吧?",
            "finish": "我想这就是 $1 了吧?",
            "condition": "条件",
            "yes": "是",
            "no": "否",
            "conflict": {
                "ExpectedBooleanCondition": {
                    "primary": "我怎样才能用 $1 来选择是或不是呢? 这样是没办法的",
                    "secondary": "我感觉 @Conditional 想要我成为一个 @Boolean，但我现在还是 $1。"
                }
            }
        },
        "ConversionDefinition": {
            "name": "转换定义",
            "description": "$1 → $2",
            "emotion": "excited",
            "doc": [
                "哥们儿，我定义了从一种类型到另一种类型的转换！我在 @Block 中执行，就像这样：",
                "\\→ #猫咪 #猫 . ÷ 2\n6猫咪→#猫\\",
                "看我是如何将猫咪变成猫的？酷毙了！",
                "你可能想知道那个 \\.\\ 是干嘛的。那代表了正在转换的值。我用它是因为这个值不然会没有名字。"
            ],
            "start": "太棒了，一个新的转换！",
            "conflict": {
                "MisplacedConversion": "哇，我不能在这里，只能在 @Block 中。"
            }
        },
        "Convert": {
            "name": "转换",
            "emotion": "cheerful",
            "doc": [
                "嘿，我可以将一个类型的值转换成另一个类型。看看这个例子：",
                "\\1 → \"\"\\",
                "\\5s → #毫秒\\",
                "\\\"你好\" → []\\",
                "你甚至可以将它们串联起来：",
                "\\\"你好\" → [] → {}\\",
                "值具有一组预定义的 @ConversionDefinition，但如果你为一个新类型的值创建了 @StructureDefinition，你可以使用 @ConversionDefinition 定义自己的转换规则。"
            ],
            "start": "从 $1 获取那个值！",
            "finish": "太棒了，我做到了 $1",
            "conflict": {
                "UnknownConversion": "糟糕，无法将 $1 转成 $2"
            },
            "exception": {
                "ConversionException": {
                    "description": "不可能的转换",
                    "explanation": "我不知道如何从 $1 转成 $2"
                }
            }
        },
        "Delete": {
            "name": "删除",
            "emotion": "angry",
            "doc": [
                "有时候你有一个表格，它里面有太多东西了！",
                "比如说你在一个游戏中有一些玩家，其中一个离开了，你只想说“走开吧，玩家，离开我的桌子！”",
                "\\玩家们: ⎡姓名•'' 队伍•'' 分数•#⎦\n⎡'珍' '红' 8⎦\n⎡'琼' '蓝' 11⎦\n⎡'杰夫' '红' 9⎦\n⎡'珍妮特' '蓝' 7⎦\n玩家们 ⎡- 姓名 = '杰夫'\\",
                "哦，杰夫走了。再见，杰夫。请记住，我不会改变原始表格，我会创建一个新的没有杰夫的表格。你决定它去哪里。"
            ],
            "start": "首先让我们获取那张表格",
            "finish": "我创建了一张新表格，没有匹配的行！"
        },
        "DocumentedExpression": {
            "name": "解释表达式",
            "emotion": "eager",
            "doc": [
                "我是任何表达式，但附带了 @Doc！",
                "要创建我，只需在表达式前面加上 @Doc，然后你就会得到我：",
                "\\双加: 1\n(2 · 双加) + \n¶让它再大一点点¶\n1\\",
                "我在对程序的某部分进行评论时很有用。"
            ],
            "start": "让我们评估这个表达式"
        },
        "Evaluate": {
            "name": "评估",
            "description": "评估 $1[$1|匿名]",
            "emotion": "shy",
            "doc": [
                "嗨。我会评估我心爱的 @FunctionDefinition",
                "\\ƒ 问候(消息•'')\n问候('小猫')\\",
                "函数可以来自任何地方。例如，@Text 有函数。就像这样：",
                "\\'小猫'.长度()\\",
                "如果一个函数只有一个符号名称，你可以将我写成 @BinaryEvaluate",
                "\\'小猫' ⊆ 'itty'\\",
                "这与下面的语句做的是一样的事情：",
                "\\'小猫'.⊆('itty')\\",
                "当然，没有 @FunctionDefinition 我什么也做不了。我只是为它们提供输入，然后按照它们的步骤执行。"
            ],
            "start": "首先让我们评估输入",
            "evaluate": "现在让我们评估函数",
            "finish": "我评估为 $1",
            "function": "函数",
            "input": "输入",
            "conflict": {
                "IncompatibleInput": {
                    "primary": "我应该是一个 $1，但我是一个 $2",
                    "secondary": "嗯，我得到了一个 $2 而不是 $1"
                },
                "UnexpectedTypeInput": {
                    "primary": "我没料到会得到这种类型的输入",
                    "secondary": "哦，我这里不应该出现吗？"
                },
                "MissingInput": {
                    "primary": "$~如果没有名为 $1 的输入，我无法进行评估:(",
                    "secondary": "$~哦，哎呀。你能帮我们把它添加到我的输入列表中吗？"
                },
                "NotInstantiable": "我不能创建这个 @StructureDefinition，它有未实现的函数。",
                "UnexpectedInput": {
                    "primary": "我没预料到会得到这个输入 $1",
                    "secondary": "哦，我这里不应该出现吗？"
                },
                "UnknownInput": {
                    "primary": "我不知道这个名字的输入",
                    "secondary": "我觉得我不应该在这里"
                },
                "InputListMustBeLast": "输入列表必须放在最后",
                "SeparatedEvaluate": "$1 是你要评估的 $2[$structure|$function] 的名称吗？请尝试删除我后面的空格，这样我就知道它是 @Evaluate 而不是单独的 @Block。"
            },
            "exception": {
                "FunctionException": {
                    "description": "未知函数",
                    "explanation": "哦不，$1 在 $2[$2|这个 @Block] 中不是一个函数！"
                }
            }
        },
        "Input": {
            "name": "输入",
            "description": "命名输入",
            "emotion": "serious",
            "doc": [
                "我是提供给 @Evaluate 的输入。我的名字对应于正在评估的 @FunctionDefinition 或 @StructureDefinition 中的输入名称。",
                "我对于具有许多默认值的函数非常有用，你只需要覆盖特定的输入，而不需要提供其他所有内容。",
                "例如，@Phrase 有许多默认值来控制其样式。假设你想在其输入列表中提供一些 @Text 和 @Color，但没有其他内容。你可以用我来做到这一点。：",
                "\\Phrase('我是紫色的！' 颜色：颜色（50% 52 300°））\\"
            ],
            "start": "评估一下我的价值。"
        },
        "ExpressionPlaceholder": {
            "name": "表达式占位符",
            "description": "$1[$1|占位符]",
            "emotion": "scared",
            "doc": [
                "我是一个 *表达式*，但不是一个真正的表达式... 我只是替代品。",
                "如果你还不知道要写什么，我很有用。就像这样：",
                "\\1 + _\\",
                "我们要加什么？我不知道。你告诉我。",
                "或者如果有人在用 @Evaluate 评估一个函数时，我可能会代替该函数",
                "\\_(1 2 3)\\",
                "我不喜欢待在 @Stage 上！"
            ],
            "start": "哎呀，我不知道该怎么办！",
            "placeholder": "表达式",
            "conflict": {
                "Placeholder": "有人能顶替我吗？"
            },
            "exception": {
                "UnimplementedException": {
                    "description": "未实现",
                    "explanation": "我不知道该怎么办！"
                }
            }
        },
        "FunctionDefinition": {
            "name": "函数",
            "description": "函数 $1",
            "emotion": "kind",
            "doc": [
                "嗨又见面了！我接受一些输入，然后使用它们来评估一个表达式，产生一个输出。",
                "这里有一个简单的例子：",
                "\\ƒ 重复(消息•'') 消息 · 5\n重复('你好')\\",
                "该函数接受一个输入，\\消息\\，并使用 @Text/repeat 函数将消息重复五次。",
                "如果你想一遍又一遍地评估某些东西，但使用不同的输入，我非常有用！",
                "我还有许多其他小技巧。例如，我不一定要有一个名字。在这里，我直接转到 @Evaluate 作为一个值。",
                "\\(ƒ(消息•'') 消息 · 5)('你好')\\",
                "或者，这是一个接受任意数量输入的函数，在输入名称后加上 \\…\\ 字符。",
                "\\ƒ 是的(消息…•'') 消息.排除('不')\n是的('是' '是' '不' '是' '不')\\",
                "看看它是如何取出所有的 '不' 并将它们去掉的？这是因为消息是一个 @List，所以我们可以使用 @List/sansAll.",
                "有时你可能想要明确我产生的值是什么类型的。为此，在输入列表之后添加一个 @Is 即可：",
                "\\ƒ 添加(x•# y•#)•'' x + y\\",
                "你可能会注意到这个例子有一个问题：它说它评估为 @Text，但它接受两个 @Number。我可以告诉你什么时候事情不一致！",
                "当然，没有 @Evaluate，我根本不实用；他们让我活了过来。"
            ],
            "start": "让我们创建这个函数！",
            "conflict": {
                "NoExpression": "我需要一个要评估的表达式，你能添加一个吗?"
            }
        },
        "Iteration": {
            "name": "高阶函数",
            "emotion": "kind",
            "doc": "我是一种非常特殊的 @FunctionDefinition，用于操作物品列表。除了我使得像 @List/translate 这样的函数成为可能之外，你不需要了解太多关于我。",
            "start": "评估给定的函数",
            "initialize": "准备逐个遍历项目",
            "next": "移动到下一个项目",
            "check": "决定是否继续",
            "finish": "我评估为 $1"
        },
        "Initial": {
            "name": "开始",
            "emotion": "curious",
            "doc": [
                "我告诉你 @Program 的当前评估是否是第一个，评估为一个 @BooleanLiteral",
                "\\◆ ? 时间() '你好'\\",
                "你没有看到它，但第一次评估是一个时间，但随后所有未来的时间标记，我都是 \\⊥\\，所以 @Conditional 使得 \\⊤\\。",
                "如果你正在处理一个流，并且你只想在第一次执行某些操作时使用我，或者在第一次时根本不使用我，那我会非常有用！"
            ]
        },
        "Insert": {
            "name": "插入",
            "emotion": "kind",
            "doc": [
                "你知道当你有一个 @Table 时，总觉得缺了点什么吗？我可以帮你添加！",
                "想象一下你有一个游戏中的玩家表，你想添加一个新玩家：",
                "\\玩家: ⎡姓名•'' 队伍•'' 分数•#⎦\n⎡'珍' '红' 1⎦\n⎡'琼' '蓝' 0⎦\n⎡'杰夫' '红' 3⎦\n⎡'珍妮特' '蓝' 2⎦\n玩家 ⎡+ '贾森' '红' 0⎦\\",
                "请记住，就像 Verse 中的所有事物一样，我不会改变表格，我会修订它。所以你需要想清楚你想把你修改后的表格放在哪里。最有可能的是你会想在对某个输入的 @Reaction 中修改一个表格，并将其存储在 @Bind 中。"
            ],
            "start": "让我们找到要更新的表格",
            "finish": "我创建了一张带有修订行的新表格！"
        },
        "Is": {
            "name": "是",
            "description": "是",
            "emotion": "curious",
            "doc": [
                "你知道吗？有很多种意味着很多不同含义的值。我可以帮忙确定它们是什么。",
                "例如，假设你有一个神秘值。我可以告诉你它是否是一个 @Number，给你一个 @Boolean：",
                "\\神秘: '秘密！'\n神秘•#\\",
                "这不是一个数字，所以我得到了 \\⊥\\。但如果我们检查它是否是 @TextType？",
                "\\神秘: '秘密！'\n神秘•''\\",
                "我们得到了 \\⊤\\！",
                "当你需要知道某个 @Name 是否具有特定类型的值时，我非常有用。"
            ],
            "start": "首先让我们获取 $1 的值",
            "finish": "$1[值是 $2|值不是 $2]",
            "conflict": {
                "ImpossibleType": "这永远不可能是这种类型 $1"
            },
            "exception": {
                "TypeException": {
                    "description": "不兼容的值",
                    "explanation": "我预期得到一个 $1，但收到了一个 $2"
                }
            }
        },
        "IsLocale": {
            "name": "区域语言检查",
            "description": "区域语言检查",
            "emotion": "kind",
            "doc": [
                "我将帮你检查观众是否选择了特定的语言或地区：",
                "\\🌍/en\\",
                "\\🌍/es-MX\\",
                "如果你想根据选择的语言来改变表现，这将会很有帮助。"
            ],
            "start": "这种语言是 $1 吗？"
        },
        "ListAccess": {
            "name": "列表访问",
            "emotion": "cheerful",
            "doc": [
                "我与 @List 密切合作，帮助它们在特定位置获取值。所以，比如，如果你有一个列表，想要获取它的第二个项目，你会写成：",
                "\\列表: ['鸟' '鸭' '鱼' '蛇']\n列表[2]\\"
            ],
            "start": "首先让我们获取列表 $1",
            "finish": "项目是 $1！"
        },
        "ListLiteral": {
            "name": "特定列表",
            "description": "$1 项目列表",
            "emotion": "eager",
            "doc": "我是一个具体的值 @List！查看 @List 以了解更多关于如何使用我的信息。",
            "start": "让我们先评估这些项目",
            "finish": "我创建了一个我！ $1",
            "item": "项目"
        },
        "Spread": {
            "name": "列表展开",
            "emotion": "serious",
            "doc": [
                "我帮助你使用其他列表的值创建列表。就像这样：",
                "\\列表1: [1 2 3]\n列表2: [4 5 6]\n最终: [列表1… 列表2…]"
            ]
        },
        "MapLiteral": {
            "name": "映射",
            "description": "$1 配对映射",
            "emotion": "kind",
            "doc": "我是一个具体的键值对 @Map。查看 @Map 以了解我如何提供帮助的更多信息。",
            "start": "让我们先评估键和值",
            "finish": "我把每个连接在一起了，$1",
            "conflict": {
                "NotAKeyValue": {
                    "primary": "我的某个键缺少值",
                    "secondary": "哎呀，我的值在哪里？"
                }
            }
        },
        "Match": {
            "name": "匹配",
            "emotion": "curious",
            "doc": [
                "我是条件检查中的高手！我可以取一个值并将其与多个情况进行比较，然后评估匹配的表达式。",
                "例如，如果你有一个 @Number 并想将其转换为 @Text，你可以这样做：",
                "\\number: 2\nnumber ??? 1: '一' 2: '二' 3: '三' '更大！'\\",
                "如果没有匹配，我会评估你给我的默认表达式。",
                "我非常适合将多种可能的 @Number、@Text 或更复杂的值转换为其他值。",
                "你也可以将我用于 @Boolean 或 @None，但它们的可能性不多，所以对于这些简单值，我的用处就没那么大了。"
            ],
            "start": "让我们看看 1 美元是多少",
            "case": "让我们检查一下这种情况",
            "finish": "我们有了最终的值！",
            "value": "价值",
            "other": "默认"
        },
        "NumberLiteral": {
            "name": "具体数字",
            "description": "$1 $2[$2|]",
            "emotion": "excited",
            "doc": "我是一个具体的 @Number。你可以用任何语言的任何数字来书写我。查看 @Number 了解我能做的一切。",
            "start": "$1!",
            "conflict": {
                "NotANumber": "我以为我认识所有的数字，但我不认识这个"
            }
        },
        "InternalExpression": {
            "name": "内部表达式",
            "emotion": "neutral",
            "doc": "你是怎么找到我的？我是只有原创作者才使用的表达式。要了解更多关于我的信息，你需要和他们交谈。",
            "start": "秘密表达式"
        },
        "NoneLiteral": {
            "name": "非字面意义",
            "emotion": "neutral",
            "doc": "/@FunctionDefinition 在此。这只是 @None。它们是独一无二的！查看 @None 以了解更多关于它们的信息。",
            "start": "… ø"
        },
        "Otherwise": {
            "name": "否则",
            "emotion": "curious",
            "doc": [
                "/@FunctionDefinition 这里。这是一种方便的方法，用于检查一个值是否为@None，如果是，就提供一个备用值。/",
                "/例如，如果你有一个可能是@Number或@None的值，@Otherwise可以帮助你提供一个默认的数字：/",
                "\\maybeNumber•#|ø: 1 maybeNumber ?? 0\\"
            ],
            "start": "ø ??",
            "finish": "… $1"
        },
        "Previous": {
            "name": "之前",
            "emotion": "serious",
            "doc": [
                "你有没有想过记住过去？",
                "我是 诗 的官方记录员。给我一个流和一个数字，我会往回看，告诉你那个流在历史上的值是什么。",
                "例如，这是五个滴答前的 @Time 是什么时候：",
                "\\← 5 时间(1000ms)\\",
                "看到了吗？它在 5 秒钟内都是 @None，然后突然出现了一个先前的时间？",
                "如果你想要最后几个值，给我两个箭头，我会将数字解释为一个计数：",
                "\\←← 5 时间(1000ms)\\",
                "看到了吗？这是五个先前的时间，而不是只有一个时间？",
                "当你想要创建依赖于过去的表演时，我会很有帮助。"
            ],
            "start": "首先获取 $1",
            "finish": "评估为流值 $1"
        },
        "Program": {
            "name": "节目",
            "emotion": "serious",
            "doc": [
                "我是表演的开始和结束，包含了所有编排表演的其他角色。",
                "你知道 @Block 如何评估表达式列表，并将其列表中的最后一个评估结果返回？",
                "我也一样，但与其将我的值提供给我所在的表达式，我会将该值放在 @Stage 上。",
                "这个值可以是任何东西：@Number、@Text 或 @Boolean，@List、@Set、@Map，甚至更复杂的东西，如 @Phrase、@Group 或 @Stage。",
                "如果你没有给我一个在舞台上展示的值，我会要求你提供一个。",
                "如果在表演过程中出现问题，我会显示出这个问题。",
                "如果你的表演依赖于一个*流*，我会在该流改变时重新评估。"
            ],
            "unevaluated": "你选择的节点没有被评估",
            "start": "$1[$1 流变为 $2！|这是我的第一次评估]",
            "halt": "遇到异常，停止",
            "finish": "所有都完成了，我评估为 $1",
            "done": "没有任何评估",
            "exception": {
                "BlankException": {
                    "description": "空程序",
                    "explanation": "让我们开个演出吧！我们应该从哪里开始？"
                },
                "EvaluationLimitException": {
                    "description": "评估限制",
                    "explanation": "@Evaluate 和我对于评估感到疲惫，尤其是 $1。\n\n是不是可能 $1 在永远地评估自己，永远不会停止？"
                },
                "StepLimitException": {
                    "description": "步骤限制",
                    "explanation": "有如此之多的步骤 - 太多了，无法完成！你能让表演变得简单一些吗？"
                },
                "ValueException": {
                    "description": "缺少值",
                    "explanation": "我期待一个值，但却没有得到！"
                }
            }
        },
        "PropertyBind": {
            "name": "精炼",
            "description": "精炼$1[$1|缺少名称]",
            "emotion": "kind",
            "doc": [
                "有时，当你创建一个@StructureDefinition时，你想要改变它的最小的东西，而不必用所有相同的值创建一个新的。",
                "例如，如果你正在保存猫的记录，但然后想创建一个具有不同爱好的猫的副本，该怎么办?我可以帮你改。",
                "\\•猫(名称•爱好•“颜色•)\n\nkitty:猫(“洒”“橙色”“舔”)\nkitty.hobby: \\“呼噜声”",
                "这比做一个全新的\\猫\\ \\要简单得多，除了爱好之外，还有相同的值，不是吗?"
            ],
            "start": "首先让我们获取值",
            "finish": "我复制了这个结构，但是把1$改成了2$",
            "conflict": {
                "InvalidProperty": {
                    "primary": "我不是1美元的输入，所以无法被分析。",
                    "secondary": "我没有名为 $1 的输入值"
                }
            }
        },
        "PropertyReference": {
            "name": "性质",
            "description": "属性$1[$1|缺少名称]",
            "emotion": "kind",
            "doc": [
                "当你创建一个@StructureDefinition时，你如何获得它的一个输入?我如何",
                "比如，如果你有一个关于城市的结构，你可以像这样得到它的值:",
                "\\•城市(名称•人口•#people)\n\nportland:城市('Portland' 800000people)\n\nportland.population\\"
            ],
            "start": "首先让我们获取值",
            "finish": "发现属性$1，它是$2",
            "property": "性质"
        },
        "Reaction": {
            "name": "反应",
            "emotion": "excited",
            "doc": [
                "流是如此的棒!我可以根据它们的变化来制作新的，这太酷了!",
                "比如，如果你想让@Time打勾，但想显示单词而不是数字，你可以这样做:",
                "\\时间:时间(1000毫秒)\n 'start“∆时间……((% 2)= 0 ms) ?“偶数”\\“奇数”",
                "这就像说“/以单词'start'开始，然后如果时间改变，根据时间改变为偶数或奇数。/\\”",
                "所以我就像一个流，但是一个基于其他流的流。挺奇怪吧,是吧?"
            ],
            "start": "让我们看看是否应该更新流",
            "finish": "新的流值是1$",
            "initial": "初始",
            "condition": "条件",
            "next": "下一项",
            "conflict": {
                "ExpectedStream": "$1没有引用流，所以我永远不会做出反应!"
            }
        },
        "Reference": {
            "name": "参考",
            "description": "$1",
            "emotion": "shy",
            "doc": [
                "你知道@Bind怎么给东西 @Name 吗?我就是你所说的他们。我看看@Bind是否有那个名字，如果有，给你它的值。是这样的:",
                "\\鹦鹉:\nparrot \\“波利”",
                "如果我找不到名字，我就不知道该怎么办了。",
                "\\鹦鹉:\nperry\\“波利”"
            ],
            "start": "1$有什么价值?",
            "conflict": {
                "UnknownName": {
                    "conflict": "我不知道有谁叫$1在$2里$2这个 @Block 你能给我一个名字吗?］",
                    "resolution": "$~您的意思是 *$1 吗？*"
                },
                "ReferenceCycle": "1$的值取决于它本身，所以我怎么知道应该给它什么值呢?",
                "UnexpectedTypeVariable": "我不知道该怎么处理这些输入"
            },
            "exception": {
                "NameException": {
                    "description": "未知名字",
                    "explanation": "$1[我不知道有谁在$2[$2]中命名$1[$2]…］"
                }
            }
        },
        "Select": {
            "name": "选择",
            "emotion": "excited",
            "doc": [
                "有时你有一张桌子，你只想占有它的一部分。我可以帮你拿来!",
                "比如，如果你在游戏中有一张玩家表格，你想找出得分在10分以上的人，看看谁赢了:",
                "\\球员:⎡名字•“团队•”点•#⎦\n⎡“jen”“红色”8⎦\n⎡“琼”“蓝”11⎦\n⎡“杰夫”“红色”9⎦\n⎡“珍妮”“蓝”7⎦\nplayers⎡吗?名称⎦分≥10\\",
                "就这样，我得到了一排获胜者的名单!记住，我不会换桌子，我会做一张新的。你得决定把它放在哪里。"
            ],
            "start": "我们先拿那个表格",
            "finish": "我用选定的行和列创建了一个新的表格!",
            "conflict": {
                "ExpectedSelectName": "我至少需要一个列名"
            }
        },
        "SetLiteral": {
            "name": "具体组",
            "description": "$1，物体",
            "emotion": "eager",
            "doc": "我是特定值的特定集合。查看@Set了解更多关于如何与我合作的信息。",
            "start": "让我们先估计数值吧",
            "finish": "我做了一个组$1"
        },
        "SetOrMapAccess": {
            "name": "组/映射组的访问",
            "emotion": "kind",
            "doc": [
                "我可以看到@Set或@Map是否有值或键。",
                "这并不难。是这样的:",
                "\\最爱:{“鸭”“鹅”‘猴子’}\nfaves{‘老鼠’}\\",
                "或者使用@Map:",
                "\\faves: {' mac&cheese':五星'麦片':2星'稀饭':1星}\nfaves{'稀饭'}\\"
            ],
            "start": "地图是什么?",
            "finish": "数值为$1",
            "conflict": {
                "IncompatibleKey": {
                    "primary": "我想要一把1$的钥匙",
                    "secondary": "我得到了1$，而不是2$"
                }
            }
        },
        "Source": {
            "name": "资源",
            "emotion": "curious",
            "doc": [
                "哦，你知道 @Program 吗?我帮你取名字。把我想象成 @Program 周围的窗口，以及你给他们起的名字。",
                "你也可以创建其他 @Source @UI/addSource ，使用其他 @Program ，并从其他@Program中@Borrow东西以供其他程序使用。",
                "这是将大型表现组织到单独文档中的好方法。"
            ]
        },
        "StreamDefinition": {
            "name": "流",
            "emotion": "curious",
            "doc": "我/我想/我应该创造新的溪流。但我真的不知道该怎么做。现在，我想就用现有的流吧?",
            "start": "创建这种新的流"
        },
        "StructureDefinition": {
            "name": "结构",
            "description": "结构 $1",
            "emotion": "kind",
            "doc": [
                "你好，你好吗?我吗?我很好。我喜欢定义存储值和功能的结构，所以只要我能整天这样做，我就很高兴。",
                "我这样工作！",
                "\\•披萨( \\ 原料•['']\n大小•#in\n) (\n\tƒ 成本() 大小 · 10美元/in\n)\n\n披萨(['意大利腊肠' '胡椒'] 12in).成本()\\",
                "明白是怎么回事了吧?我定义了\\Pizza\\，它有两个输入，\\ingredients\\ (@Text列表)和\\size\\(以英寸为单位的数字)。",
                "在内部，@FunctionDefinition创建了一个计算披萨价格的函数，假设每英寸$10。",
                "我不需要@FunctionDefinition。我可以只是输入。",
                "\\•披萨(\n原料•['']\n大小•#in\n)\\",
                "我也可以把@Bind放在里面，这样我们就可以提前评估成本。",
                "\\•披萨(\n原料•['']\n大小•#in\n) (\n\t成本: 大小 · 10美金/in\n)\n\n披萨(['意大利腊肠' '胡椒'] 12in).cost\\"
            ],
            "start": "让我们来定义这个可爱的结构",
            "conflict": {
                "DisallowedInputs": "我不能有输入，因为我的一个或多个接口函数没有实现",
                "IncompleteImplementation": "我的函数要么需要全部实现，要么不需要实现。没有混乱的混合物!",
                "NotAnInterface": "我不是一个界面;一个结构只能实现接口，而不能实现其他结构",
                "UnimplementedInterface": "我实现了1$，但没有实现2$"
            }
        },
        "StructureDefinitionType": {
            "name": "结构定义",
            "emotion": "kind",
            "description": "$1 的定义",
            "doc": ["我指的是某种@StructureDefinition。人们通常不会直接提到我"]
        },
        "TableLiteral": {
            "name": "表面量",
            "description": "$1 行表格",
            "emotion": "angry",
            "doc": "我是一个具有特定行数的特定表格。请参阅 @Table 了解我如何提供帮助。",
            "start": "首先评估行数",
            "finish": "评估为新表格 $1"
        },
        "TextLiteral": {
            "name": "文本量",
            "description": "文本 $1",
            "emotion": "serious",
            "doc": "我代表一个或多个特定的文本翻译。请参阅 @Text 以了解我可以做什么！",
            "start": "让我们在当前语言环境中创建文本"
        },
        "Translation": {
            "name": "翻译",
            "description": "翻译 $1",
            "emotion": "serious",
            "doc": "我代表一些文本，带有 @Language 标签。请参阅 @Text 以了解更多！",
            "conflict": {
                "phone": "*$1* 是某人的电话号码吗？如果是的话，请不要在网上分享我！\n\n$2",
                "email": "*$1* 是某人的电子邮箱吗？如果是的话，请不要在这里分享我！\n\n$2",
                "tin": "*$1* 是税务识别符吗？如果是，绝对不要分享给我，我的信息非常敏感！\n\n$2",
                "address": "*$1* 是某人的家庭住址吗？如果是，别把我放在这里，我们不想让任何人被跟踪！\n\n$2",
                "handle": "*$1* 是你在互联网上其他地方的用户名吗？如果是，请不要在这里分享我，除非你真的想这样做。\n\n$2",
                "resolution": "这不是敏感数据",
                "reminder": "注意：你可以撤消此操作并在共享对话框中查看你标记为非敏感的其他内容。"
            }
        },
        "FormattedLiteral": {
            "name": "格式文本",
            "description": "文本 $1",
            "emotion": "serious",
            "doc": "我代表许多不同的格式化文本的 @FormattedTranslation。当我进行评估时，我会根据受众选择的语言选择最佳匹配。",
            "start": "让我们创建当前语言环境下的文本"
        },
        "FormattedTranslation": {
            "name": "格式化",
            "description": "文本 $1",
            "emotion": "serious",
            "doc": [
                "我代表一些格式化的文本，带有 @Language 标签。",
                "我可以是：",
                "\\`/斜体/`\\",
                "\\`*加粗*`\\",
                "\\`^超粗^`\\",
                "\\`_下划线_`\\",
                "\\`<链接@https://wordplay.dev>`\\",
                "\\`\\'代码'\\`\\",
                "我与 @Phrase 结合使用，将漂亮的文本呈现在 @Stage 上。"
            ]
        },
        "This": {
            "name": "这个",
            "emotion": "serious",
            "doc": [
                "有时候，隐含地引用值比命名它更有帮助。",
                "例如，假设你想创建一个新的 @ConversionDefinition，它不命名正在转换的值。你可以使用我来引用它：",
                "\\→ #彩虹 #欢乐 . · 1000000欢乐\n2彩虹 → #欢乐\\",
                "看看这里，代表彩虹数量的部分？",
                "或者，假设你想创建一个 @Reaction，但不想为最近的值命名：",
                "\\2 … ∆ 时间(1000毫秒) … . · 2\\",
                "看看我，代表前一个反应值。",
                "我不经常出现，但当出现时，我可以帮助值摆脱 @Bind！"
            ],
            "start": "评估为 $1",
            "conflict": {
                "MisplacedThis": "我只允许出现在结构、转换或反应中。"
            }
        },
        "UnaryEvaluate": {
            "name": "一元评估",
            "description": "$1",
            "emotion": "kind",
            "doc": [
                "你知道当我仅对一个值进行 @FunctionDefinition 评估时，@FunctionDefinition 的名称只是一个单一的符号，你可以将名称放在输入值之前吗？",
                "像这样：",
                "\\-(1 + 1)\\",
                "或者这样：",
                "\\~⊥\\",
                "相比 \\(1 + 1).negate()\\ 或 \\⊥.not()\\，这样写更容易阅读，不是吗？",
                "你不必这样写，但总体来说可能更容易。",
                "只有一个规则：名称和值之间不能有空格。否则，你可能会创建 @Reference 或 @BinaryEvaluate。"
            ],
            "start": "值是什么？",
            "finish": "我完成了 $1"
        },
        "UnparsableExpression": {
            "name": "不可解析",
            "emotion": "excited",
            "doc": [
                "/嗨，这里是 @FunctionDefinition。由于通常很难解释 @UnparsableExpression，我将代为翻译。",
                "jkwel fjiwojvioao jjiweo jrfe",
                "/并不是每个表达式在舞台上都有意义/",
                "s w ieorjwei iojwi jfkdlsfdsk",
                "/事实上，有各种各样的东西可以说出来，但根本没有任何意义/",
                "dsk sdlk jdkfiewipapweiurb,v kdsfdsf",
                "/当你这样做时，我会出现，因为我不知道你的意思/",
                "毕竟你是导演，只有你知道你可能的意思！"
            ],
            "start": "???",
            "conflict": {
                "UnparsableConflict": {
                    "conflict": "@FunctionDefinition 在此，@UnparsableExpression 不知道这是什么类型的 $1[表达式 | 类型]。",
                    "resolution": "你的意思是 1 美元还是 2 美元？"
                },
                "UnclosedDelimiter": "我期望在 $1 之后的某个时刻会有 $2"
            },
            "exception": {
                "UnparsableException": {
                    "description": "???",
                    "explanation": "/嗨，这里是 @FunctionDefinition！我们不知道这是什么类型的指令，所以不得不停下来！/"
                }
            }
        },
        "Update": {
            "name": "更新",
            "emotion": "kind",
            "doc": [
                "我帮助修订 @Table，找到与条件匹配的行，然后创建具有新值的修订行。",
                "例如，如果你有一个包含角色和点数的表格，并且想要为同一团队的每个角色添加一个点数，你可以这样做：",
                "\\players: ⎡name•'' team•'' points•#⎦\n⎡'jen' 'red' 1⎦\n⎡'joan' 'blue' 0⎦\n⎡'jeff' 'red' 3⎦\n⎡'janet' 'blue' 2⎦\nplayers ⎡: points: points + 1 ⎦ team = 'blue'\\",
                "你可以使用 @Bind 指定要更改的列，还可以在条件中使用列名称或范围中的其他名称。"
            ],
            "start": "首先让我们获取表格",
            "finish": "评估为具有修订行的新表格！",
            "conflict": {
                "ExpectedColumnBind": "我需要每列的值",
                "IncompatibleCellType": {
                    "primary": "我需要一个 $1，但得到了 $2",
                    "secondary": "我得到了一个 $2"
                }
            }
        },
        "AnyType": {
            "name": "任意",
            "emotion": "curious",
            "doc": "我代表任何可能的类型。有时我会出现，因为不知道某些东西是什么类型，所以它可以是任何类型。"
        },
        "BooleanType": {
            "name": "布尔",
            "emotion": "kind",
            "doc": [
                "我与 @Bind 一起工作，声明名称是 @Boolean 值。就像这样：",
                "\\hungry•?: 'jello'\\",
                "如果要确保某物是 @Boolean，请使用我，我会检查！"
            ]
        },
        "ConversionType": {
            "name": "转换",
            "emotion": "serious",
            "doc": [
                "我与 @Bind 一起工作，指示名称是 @ConversionDefinition。你可能不需要使用我，因为没有多少人将我作为值传递，但如果你这样做，我将如下所示：",
                "\\magic•?→'': → ? '' . ? 'yep' 'nope'\\"
            ]
        },
        "FormattedType": {
            "name": "格式化",
            "emotion": "serious",
            "doc": [
                "我与 @Bind 一起注明名称是 @FormattedLiteral 值。就像这样：",
                "\\hungry•`…`: `I am so /fancy/!`\\",
                "想要确保某物是 @FormattedLiteral 值？这就是你确保的方法。"
            ]
        },
        "ExceptionType": {
            "name": "异常",
            "emotion": "neutral",
            "doc": "我代表一个异常。没有办法告诉绑定我是一个异常，因为异常只会中止 @Program，所以无法将它们用作值。"
        },
        "FunctionType": {
            "name": "函数",
            "description": "带有 $1 输入和 $2 输出的函数",
            "emotion": "curious",
            "doc": [
                "我代表 @FunctionDefinition。如果要说明 @Bind 包含的是什么类型的函数，我会非常有帮助！就像这样：",
                "\\math•ƒ (# # # #) #: ƒ interesting(a•# b•# c•# d•#) a + b + c + d\\"
            ]
        },
        "ListType": {
            "name": "列表",
            "description": "$1[$1 列表|$1]",
            "emotion": "cheerful",
            "doc": [
                "我是 @List 的狂热爱好者。我可以告诉 @Bind 他们是什么类型的列表！就像这样，我告诉他们这是 @Number 的列表：",
                "\\things•[#]: [ 1 2 3 4 5 ]\\"
            ]
        },
        "MapType": {
            "name": "映射",
            "description": "$1[$1|任意] 到 $2[$2|任意] 的映射",
            "emotion": "kind",
            "doc": [
                "你知道 @Map 有多棒吗？真的很棒。我总是告诉 @Bind 他们是什么类型的映射，就像这样将数字映射到列表：",
                "\\stuff•{'':[]}: {}\\"
            ]
        },
        "NumberType": {
            "name": "数值",
            "description": "$1[$1 | 数值]",
            "emotion": "precise",
            "doc": [
                "你知道 @Bind 应该是什么吗？应该是 @Number。因为数值是最好的。",
                "\\计数•#: 17\\"
            ]
        },
        "NameType": {
            "name": "结构",
            "description": "$1 类型",
            "emotion": "curious",
            "doc": [
                "我通过名称代表 @StructureDefinition。所以，如果你有这样一个结构，你可以创建一个 @Bind 来存储它所创建的值。",
                "\\•朋友(名字•'')\n最好朋友•朋友: 朋友('乔纳')\\"
            ],
            "conflict": {
                "UnknownTypeName": "类型名称只能指代结构或类型变量，但这里指代了一个 $1"
            }
        },
        "NeverType": {
            "name": "不可能",
            "emotion": "curious",
            "doc": "我代表一种不可能的类型。就像当你询问 @Is 是否是 @Number，但它永远不可能是一个数值时一样。"
        },
        "NoneType": {
            "name": "无",
            "emotion": "neutral",
            "doc": [
                "@None 是最好的不存在之一，而我是它们的忠实代表。",
                "\\空间•ø: ø\\"
            ]
        },
        "SetType": {
            "name": "集合",
            "description": "$1[$1 集合|集合]",
            "emotion": "kind",
            "doc": [
                "@Set 是最好的，真的。我一直告诉 @Bind，让事物成为某种东西的集合！",
                "\\独特•{''}: {'某物' '任何物' '某人'}\\"
            ]
        },
        "StreamDefinitionType": {
            "name": "流定义",
            "emotion": "angry",
            "doc": "我代表你定义的流，这是不可能的，那么为什么你还在阅读这个？"
        },
        "StreamType": {
            "name": "串流",
            "emotion": "curious",
            "doc": [
                "我庆祝串流的美丽和意义,通过告诉 @Bind 来存储它们：",
                "\\时间•…#毫秒: 时间()\\"
            ]
        },
        "StructureType": {
            "name": "结构",
            "description": "$1",
            "emotion": "kind",
            "doc": "我是一个内部类型，代表默认值类型的类型。"
        },
        "UnknownType": {
            "name": "未知",
            "connector": "，因为",
            "emotion": "curious",
            "doc": "嗯……我不知道我代表什么，但我真的很好奇。你知道吗？似乎我们应该知道。如果我们无法弄清楚，你可能需要告诉我们。"
        },
        "TableType": {
            "name": "表",
            "emotion": "angry",
            "doc": "我代表一个表。",
            "conflict": {
                "ExpectedColumnType": "我需要一个竖列类型"
            }
        },
        "TextType": {
            "name": "文本",
            "description": "$1[$1|文本]",
            "emotion": "happy",
            "doc": [
                "我精彩地代表最精彩的值，@Text。",
                "\\故事•'': '从前有一个故事……'\\"
            ]
        },
        "TypePlaceholder": {
            "name": "占位",
            "emotion": "eager",
            "doc": "我希望有一天能代表一种类型，有点像我的好朋友 @ExpressionPlaceholder 代表一个表达式！你会帮助我决定是什么类型吗？"
        },
        "UnionType": {
            "name": "选项",
            "description": "$1 | $2",
            "emotion": "curious",
            "doc": [
                "我应该代表谁，A 还是 B 还是其他什么？我永远无法决定！",
                "\\犹豫•''|#|{ø}: \"我不知道！\"\\"
            ]
        },
        "Unit": {
            "name": "单位",
            "description": "$1",
            "emotion": "precise",
            "doc": [
                "我代表 @Number 可能具有的任何单位，包括无单位，以及你可以想象的最复杂单位。比如重力：",
                "\\重力•米/秒^2: 9.8米/秒^2\\",
                "我出现在 @Bind 之后，也出现在 @Number 之后。我帮助确保数字具有相同的类型，如果它们不同，我肯定会告诉你，以防它是个错误！"
            ]
        },
        "UnparsableType": {
            "name": "无法解析",
            "emotion": "curious",
            "doc": "我代表未知表达式的类型。当你尝试将该表达式用于某事时，我会出现。"
        },
        "VariableType": {
            "name": "变量类型",
            "emotion": "curious",
            "doc": "你了解 @TypeVariable，以及它们代表某种未知类型的值吗？我在值之间的所有协商中代表它们。"
        },
        "CycleType": {
            "name": "循环",
            "description": "依赖于自身",
            "emotion": "curious",
            "doc": "有时值依赖于自身，所以我们不知道它们是什么类型的值。我代表这种情况。"
        },
        "UnknownVariableType": {
            "name": "未知变量",
            "emotion": "curious",
            "doc": "有时我们试图猜测某种值的类型；当我们不知道时，我会出现。"
        },
        "NotAType": {
            "name": "意外",
            "description": "不是 $1",
            "emotion": "curious",
            "doc": "有时我们知道某种值应该是什么类型，就像 @ListAccess 需要 @Number 一样。如果我们没有得到它，我代表某个类型与我们预期的不同。"
        },
        "NoExpressionType": {
            "name": "无表达式",
            "emotion": "angry",
            "doc": "你知道 @Block 至少需要一个表达式吗？当你不提供一个表达式时，我就是你得到的。所以，请提供一个！"
        },
        "NotEnclosedType": {
            "name": "不在结构、转换或反应中",
            "emotion": "curious",
            "doc": "@This，尽管它很好，但只适用于特定的地方。当它们迷路时，我会出现，所以没有人知道它们代表什么值。"
        },
        "NotImplementedType": {
            "name": "未实现",
            "emotion": "curious",
            "doc": "当你使用 @ExpressionPlaceholder，但没有说明它们的类型时，我就是你得到的类型。接受吧！"
        },
        "UnknownNameType": {
            "name": "未知名称",
            "description": "$1[$1 未定义|未提供名称]",
            "emotion": "curious",
            "doc": "你知道有时候 @Reference 和 @PropertyReference 不知道你在谈论什么名称吗？当发生这种情况时，我会出现，代表我们不知道你在谈论谁。"
        },
        "NonFunctionType": {
            "name": "非函数",
            "description": "非函数",
            "emotion": "confused",
            "doc": "有些人期望函数；当我们没有得到函数时，我就会出现。"
        }
    },
    "basis": {
        "Boolean": {
            "doc": [
                "我们是 \\⊤\\ 和 \\⊥\\。 \\⊤\\ 为真。 \\⊥\\ 为假。 \\⊤\\ 不是 \\⊥\\； \\⊥\\ 也不是 \\⊤\\。 就是这样。",
                "要如何创建我们？只需要 \\⊤\\ 和 \\⊥\\，没有多余的东西。",
                "有些人使用键盘（按 /ctrl+9/ 输入 \\⊤\\，按 /ctrl+0/ 输入 \\⊥\\）。有些人使用编辑器底部的字符搜索功能。或者，你可以从这里拖动我们。",
                "请查看我们下面的 @FunctionDefinition。它们非常遵循逻辑。"
            ],
            "name": ["⊤⊥", "布尔类型"],
            "function": {
                "and": {
                    "doc": [
                        "我仅在两个值都是 \\⊤\\ 时才评估为 \\⊤\\。对于确定许多事情是否都为真非常有帮助。只有四种可能的结果",
                        "\\⊤ & ⊤\\",
                        "\\⊤ & ⊥\\",
                        "\\⊥ & ⊤\\",
                        "\\⊥ & ⊥\\"
                    ],
                    "names": ["&", "和"],
                    "inputs": [
                        {
                            "doc": "用于检查的另一个 @Boolean。如果第一个是 \\⊥\\，那么这个值是什么不重要，该函数将评估为 \\⊥\\。",
                            "names": "值"
                        }
                    ]
                },
                "or": {
                    "doc": [
                        "我仅在两个值中有一个是 \\⊤\\ 时才评估为 \\⊤\\。对于确定许多事情是否有一个为真非常有帮助。只有四种可能的结果",
                        "\\⊤ | ⊤\\",
                        "\\⊤ | ⊥\\",
                        "\\⊥ | ⊤\\",
                        "\\⊥ | ⊥\\"
                    ],
                    "names": ["|", "或"],
                    "inputs": [
                        {
                            "doc": "用于检查的另一个 @Boolean。如果第一个是 \\⊥\\，该函数将仅在此值为 \\⊤\\ 时评估为 \\⊤\\。",
                            "names": "值"
                        }
                    ]
                },
                "not": {
                    "doc": "我得到与自己相反的结果：如果是 \\⊤\\，则得到 \\⊥\\；如果是 \\⊥\\，则得到 \\⊤\\。",
                    "names": ["~", "非"],
                    "inputs": []
                },
                "equals": {
                    "doc": "如果两者都是 \\⊤\\ 或两者都是 \\⊥\\，则为 \\⊤\\。",
                    "names": ["=", "等于"],
                    "inputs": [
                        {
                            "doc": "要检查的另一个值。",
                            "names": "值"
                        }
                    ]
                },
                "notequal": {
                    "doc": "如果两者相反，则为 \\⊤\\。",
                    "names": ["≠", "不等于"],
                    "inputs": [
                        {
                            "doc": "要检查的另一个值。",
                            "names": "值"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "将 @布尔 转换为等效的 @文本 值，即 \\'⊤'\\ 和 \\'⊥'\\"
            }
        },
        "None": {
            "doc": [
                "/嗨，@FunctionDefinition 在这里。@None 不太喜欢说话，所以我来解释一下。/",
                "我是 @None。使用 \\ø\\ 调用我。当你想要表示不存在的东西时，我很有用。"
            ],
            "name": ["ø", "无"],
            "function": {
                "equals": {
                    "doc": "另一个值也是不存在吗？最好是，否则，\\⊥\\。",
                    "names": ["=", "等于"],
                    "inputs": [
                        {
                            "doc": "另一个值。",
                            "names": "值"
                        }
                    ]
                },
                "notequals": {
                    "doc": "另一个值是否 /不/ 不存在？",
                    "names": ["≠", "不等于"],
                    "inputs": [
                        {
                            "doc": "另一个值。",
                            "names": "值"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "想要将 \\ø\\ 转换为 \\'ø'\\ 吗？这是你的机会。"
            }
        },
        "Text": {
            "doc": [
                "我可以是你喜欢的任何文字，来自任何语言，并使用这些开头和结尾符号之一：\\\"\"\\、\\“”\\、\\„“\\、\\''\\、\\‘’\\、\\‹›\\、\\«»\\、\\「」\\或 \\『』\\。",
                "举个例子，考虑这些美丽的短语",
                "\\“生活有两种方式。一种是好像没有什么是奇迹的。另一种是好像一切都是奇迹的。”\\",
                "\\『一日三秋』\\",
                "只需记住，如果你打开了我，就要关闭我，并使用相匹配的符号。否则，我就不知道你已经用完了你的话。",
                "\\'hello'/en'hola'/es-MX\\",
                "你还可以为我加上语言标记，甚至提供多个翻译。如果当前选择了匹配的语言，我将评估为相应的语言。",
                "如果你想用一些其他值来制作我，你可以使用一个符号",
                "例如，考虑这个：",
                "\\\"这里有一些和 \\1 + 2\\, \\2 + 3\\, \\3 + 4\\\"\\",
                "看看我是如何优雅地评估这些和，并将它们放在 @Text 中的？",
                "另外，@FunctionDefinition 为我准备了许多精彩的函数，可以用各种文字做各种事情！"
            ],
            "name": ["''", "文本"],
            "function": {
                "length": {
                    "doc": [
                        "我评估为文本中可读字符的数量；一个字母是一个字符，一个表情符号也是一个字符，依此类推。例如：",
                        "\\'hello'.length()\\",
                        "\\'🐈📚'.length()\\"
                    ],
                    "names": ["📏", "长度"],
                    "inputs": []
                },
                "equals": {
                    "doc": "如果我与给定的 @Text 具有相同的字符序列，则为 \\⊤\\。",
                    "names": ["=", "等于"],
                    "inputs": [
                        {
                            "doc": "要比较的 @Text。",
                            "names": "值"
                        }
                    ]
                },
                "notequals": {
                    "doc": "如果我与给定的 @Text 的字符序列不同，则为 \\⊤\\。",
                    "names": "≠",
                    "inputs": [
                        {
                            "doc": "要比较的 @Text",
                            "names": "值"
                        }
                    ]
                },
                "has": {
                    "doc": [
                        "如果给定的 @Text 出现在我中，为 \\⊤\\。",
                        "\\'你找到你要找的东西了吗？'.has('you')\\"
                    ],
                    "names": ["⊆", "包含"],
                    "inputs": [
                        {
                            "doc": "要在我中搜索的 @Text。",
                            "names": "文本"
                        }
                    ]
                },
                "starts": {
                    "doc": [
                        "\\⊤\\ 如果我以 @Text 来开始",
                        "\\'你好，词句！'。以('你好')开始\\",
                        "\\'词句，你好！'。以('词句')开始\\"
                    ],
                    "names": ["开始"],
                    "inputs": [
                        {
                            "doc": "这样的 @Text 为我检查了文本的开头",
                            "names": "文本"
                        }
                    ]
                },
                "ends": {
                    "doc": [
                        "\\⊤\\ 如果我以 @Text 来结尾。",
                        "\\'我是一个问句吗？'。以('?')结尾\\",
                        "\\'我不是一个问句。'。 以('?')结尾\\"
                    ],
                    "names": ["结束"],
                    "inputs": [
                        {
                            "doc": "这样的 @Text 为我检查了文本的结尾。",
                            "names": "文本"
                        }
                    ]
                },
                "repeat": {
                    "doc": [
                        "我创建一个新的 @Text，就是我，重复了 \\计数\\ 次：",
                        "\\'嗨 ' · 5\\",
                        "如果你给我一个分数 @Number，我会忽略小数部分：",
                        "\\'嗨 ' · 5.5\\",
                        "如果你给我一个负数 @Number 或零，我会返回一个空的 @Text。",
                        "\\'嗨 ' · -5\\"
                    ],
                    "names": ["·", "🔁", "重复"],
                    "inputs": [
                        {
                            "doc": "在新文本中重复自己的次数。",
                            "names": "计数"
                        }
                    ]
                },
                "segment": {
                    "doc": [
                        "我将自己分成一个 @Text 的 @List，使用给定的 @Text 作为分隔符，并删除分隔符。例如：",
                        "\\'苹果，橙子，葡萄' ÷ ', '\\",
                        "如果分隔符是一个空的 @Text，我会将自己分成字符：",
                        "\\'🖌️🏠🥸' ÷ ''\\"
                    ],
                    "names": ["÷", "分段"],
                    "inputs": [
                        {
                            "doc": "要用作分隔符的 @Text。",
                            "names": "分隔符"
                        }
                    ]
                },
                "combine": {
                    "doc": [
                        "有时将两个 @Text 合并在一起很有帮助。给我另一个 @Text，我会创建一个新的文本，将我们连接在一起：",
                        "\\'你好 ' + '诗'\\"
                    ],
                    "names": ["+", "组合"],
                    "inputs": [
                        {
                            "doc": "要附加的 @Text。",
                            "names": "文本"
                        }
                    ]
                }
            },
            "conversion": {
                "list": "将文本分割成单个字符的列表。",
                "number": "将文本转换成 @Number，如果不是数值，则为非数值值。"
            }
        },
        "Number": {
            "doc": [
                "如果我创造一个 @Number, 这个数字可以是你能想象到的任何单位",
                "这是我能想到的前五项：",
                "\\0\\",
                "\\1个故事\\",
                "\\π派\\",
                "\\∞个石头\\",
                "\\1000000个拥抱\\",
                "简单来说，我们有无数个数字。",
                "同时，我们也有无数个单位！",
                "同样地，无数个数字和单位的排列组合……",
                "我可以是整数、实数、负数、正数、分数、小数，甚至不是一个数字。",
                "你可以将我用不同的数字系统表达, 像阿拉伯数字 \\123\\, 罗马数字 \\ⅩⅩⅩⅠⅩ\\, 日本数字 \\二十\\, 甚至将它们混合起来:",
                "\\1 + I + 一\\",
                "你也可以将我写成二进制,比如二进制的16会像这样:",
                "\\2;11111111\\",
                "\\10;255\\",
                "\\16;FF\\",
                "这里有一个特殊的数字叫NaN，它可能出现在你没有写下数字的时候：",
                "\\2;22\\",
                "这里没有数字显示, 是因为数字2不会出现在二进制当中。 如果你想要将非数字的文本变成数字，NaN 同样会出现：",
                "\\'嗨'→#\\"
            ],
            "name": ["#", "数字"],
            "function": {
                "add": {
                    "doc": [
                        "我把自己加上一个同样 @Unit 的 @Number , 就会出现同样的 @Unit 的 @Number。",
                        "比如：",
                        "\\1 + 1\\",
                        "\\3只猫 + 5只猫\\",
                        "如果它们的单位不一样，就不会出现结果。",
                        "\\3只猫 + 5只狗\\"
                    ],
                    "names": ["+", "加号"],
                    "inputs": [
                        {
                            "doc": "要添加的 @Number 。",
                            "names": "数字"
                        }
                    ]
                },
                "subtract": {
                    "doc": [
                        "我把自己减去你指定的 @Number , 得出一个以同样的 @Unit 结尾的新的 @Number。",
                        "比如：",
                        "\\1 - 1\\",
                        "\\3只猫 - 5只猫\\",
                        "如果它们的单位不一样，就不会出现结果。",
                        "\\3只猫 - 5只狗\\"
                    ],
                    "names": ["-", "减号"],
                    "inputs": [
                        {
                            "doc": "这是我要从我自己减去的 @Number。",
                            "names": "数字"
                        }
                    ]
                },
                "multiply": {
                    "doc": [
                        "我在我自己的基础上乘以你给我的 @Number , 得到以我的 @Unit 和指定数字的 @Unit 相结合的结果：",
                        "\\5 · 5\\",
                        "\\5米 · 5米\\",
                        "\\5米 · 1/秒\\"
                    ],
                    "names": ["·", "乘号"],
                    "inputs": [
                        {
                            "doc": "需要相乘的数字",
                            "names": "数字"
                        }
                    ]
                },
                "divide": {
                    "doc": [
                        "我将自己除以你指定的 @Number , 得到以我的 @Unit 和指定数字的 @Unit 相结合的结果：",
                        "\\5 ÷ 5\\",
                        "\\5米 ÷ 5米\\",
                        "\\5米 ÷ 5秒\\"
                    ],
                    "names": ["÷", "除以"],
                    "inputs": [
                        {
                            "doc": "让我被除的 @Number。",
                            "names": "数字"
                        }
                    ]
                },
                "remainder": {
                    "doc": [
                        "我把自己除以你指定的 @Number ，但我会给出这个结果的余数：",
                        "\\10 % 2\\",
                        "\\10米 % 2\\",
                        "\\10米/秒 % 3\\"
                    ],
                    "names": ["%", "取模"],
                    "inputs": [
                        {
                            "doc": "让我被除的 @Number。",
                            "names": "数字"
                        }
                    ]
                },
                "positive": {
                    "doc": [
                        "我会给出一个新的 @Number 使我是一个正数，即使输入的数字是一个负数。",
                        "\\-200.正数()\\"
                    ],
                    "names": ["正数"],
                    "inputs": []
                },
                "round": {
                    "doc": [
                        "我会把 @Number 四舍五入成最接近的一个整数。",
                        "\\9.4.round()\\",
                        "\\9.5.round()\\",
                        "\\9.6.round()\\"
                    ],
                    "names": ["舍入"],
                    "inputs": []
                },
                "roundDown": {
                    "doc": [
                        "我会把 @Number 变成最接近我的比我小的整数。",
                        "\\10.5.roundDown()\\",
                        "\\10.1.roundDown()\\",
                        "\\10.01.roundDown()\\"
                    ],
                    "names": ["向下取整"],
                    "inputs": []
                },
                "roundUp": {
                    "doc": [
                        "我会把 @Number 变成最接近我的比我大的整数。",
                        "\\10.5.roundUp()\\",
                        "\\10.9.roundUp()\\",
                        "\\10.99.roundUp()\\"
                    ],
                    "names": ["向上取整"],
                    "inputs": []
                },
                "power": {
                    "doc": [
                        "我将自己提高到给定 @Number 的幂次方 小数指数也可以！",
                        "\\2 ^ 8\\",
                        "\\10 ^ -2\\",
                        "\\5 ^ -.5\\"
                    ],
                    "names": ["^", "次方"],
                    "inputs": [
                        {
                            "doc": "将我提升到的指数",
                            "names": "数"
                        }
                    ]
                },
                "root": {
                    "doc": [
                        "我使用给定的根号创建自己的根。",
                        "\\4 √ 2\\",
                        "\\1000 √ 3\\"
                    ],
                    "names": ["√", "根号"],
                    "inputs": [
                        {
                            "doc": "要计算的根。",
                            "names": "数"
                        }
                    ]
                },
                "lessThan": {
                    "doc": [
                        "\\⊤\\ 如果我小于 @Number:",
                        "\\1 < 2\\",
                        "\\2 < 1\\"
                    ],
                    "names": ["<", "小于"],
                    "inputs": [
                        {
                            "doc": "与我进行比较的 @Number",
                            "names": "数"
                        }
                    ]
                },
                "lessOrEqual": {
                    "doc": [
                        "\\⊤\\ 如果我小于或等于 @Number:",
                        "\\1 ≤ 2\\",
                        "\\2 ≤ 1\\",
                        "\\2 ≤ 2\\"
                    ],
                    "names": ["≤", "小于或等于"],
                    "inputs": [
                        {
                            "doc": "与我进行比较的 @Number",
                            "names": "数"
                        }
                    ]
                },
                "greaterThan": {
                    "doc": [
                        "\\⊤\\ 如果我大于 @Number:",
                        "\\1 > 2\\",
                        "\\2 > 1\\"
                    ],
                    "names": [">", "大于"],
                    "inputs": [
                        {
                            "doc": "与我进行比较的 @Number",
                            "names": "数"
                        }
                    ]
                },
                "greaterOrEqual": {
                    "doc": [
                        "\\⊤\\ 如果我大于或等于 @Number:",
                        "\\1 ≥ 2\\",
                        "\\2 ≥ 1\\",
                        "\\2 ≥ 2\\"
                    ],
                    "names": ["≥", "大于或等于"],
                    "inputs": [
                        {
                            "doc": "与我进行比较的 @Number",
                            "names": "数"
                        }
                    ]
                },
                "equal": {
                    "doc": [
                        "\\⊤\\ 如果我等于 @Number:",
                        "\\1 = 2\\",
                        "\\2 = 2\\"
                    ],
                    "names": ["=", "等于"],
                    "inputs": [
                        {
                            "doc": "与我进行比较的 @Number",
                            "names": "数"
                        }
                    ]
                },
                "notequal": {
                    "doc": ["\\⊤\\ 不等于 @Number:", "\\1 ≠ 2\\", "\\2 ≠ 2\\"],
                    "names": ["≠", "不等于"],
                    "inputs": [
                        {
                            "doc": "与我进行比较的 @Number",
                            "names": "数"
                        }
                    ]
                },
                "cos": {
                    "doc": ["计算我的余弦值。", "\\π.cos()\\"],
                    "names": ["$~余弦", "$~余弦"],
                    "inputs": []
                },
                "sin": {
                    "doc": "计算我的正弦值。",
                    "names": ["$~罪", "$~正弦"],
                    "inputs": []
                },
                "min": {
                    "doc": ["找到我和其他人中的最小数。", "\\1.min(2 3 -1)\\"],
                    "names": "最小",
                    "inputs": [
                        {
                            "doc": "你想给我的任意数量的数字！",
                            "names": "数字"
                        }
                    ]
                },
                "max": {
                    "doc": ["找到我和其他人中的最大数。", "\\1.max(2 3 4)\\"],
                    "names": "最大",
                    "inputs": [
                        {
                            "doc": "你想给我的任意数量的数字！",
                            "names": "数字"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "我的数字的阿拉伯文@Text表示。",
                "list": "一个从1到给定数字的数字列表，例如\\10→[]\\。",
                "s2m": "秒到分钟",
                "s2h": "秒到小时",
                "s2day": "秒到天",
                "s2wk": "秒到周",
                "s2year": "秒到年",
                "s2ms": "秒到毫秒",
                "ms2s": "毫秒到秒",
                "min2s": "分钟到秒",
                "h2s": "小时到秒",
                "day2s": "天到秒",
                "wk2s": "周到秒",
                "yr2s": "年到秒",
                "m2pm": "米到皮米",
                "m2nm": "米到纳米",
                "m2micro": "米到微米",
                "m2mm": "米到毫米",
                "m2cm": "米到厘米",
                "m2dm": "米到分米",
                "m2km": "米到千米",
                "m2Mm": "米到兆米",
                "m2Gm": "米到吉米",
                "m2Tm": "米到太米",
                "pm2m": "皮米到米",
                "nm2m": "纳米到米",
                "micro2m": "微米到米",
                "mm2m": "毫米到米",
                "cm2m": "厘米到米",
                "dm2m": "分米到米",
                "km2m": "千米到米",
                "Mm2m": "兆米到米",
                "Gm2m": "吉米到米",
                "Tm2m": "太米到米",
                "km2mi": "千米到英里",
                "mi2km": "英里到千米",
                "cm2in": "厘米到英寸",
                "in2cm": "英寸到厘米",
                "m2ft": "米到英尺",
                "ft2m": "英尺到米",
                "g2mg": "克到毫克",
                "mg2g": "毫克到克",
                "g2kg": "克到千克",
                "kg2g": "千克到克",
                "g2oz": "克到盎司",
                "oz2g": "盎司到克",
                "oz2lb": "盎司到磅",
                "lb2oz": "磅到盎司"
            }
        },
        "List": {
            "doc": [
                "我是一个值的序列，可以是任何类型的值！",
                "你可以在我里面放任何东西：@Boolean、@Number、@Text、@None，甚至其他的@List、@Set、@Map或任何表达式。这是一个简单的例子：",
                "\\['苹果' '香蕉' '芒果']\\",
                "我特殊的地方在于我保持顺序，并且为所有的项从1编号。",
                "我的项是有编号的，从1开始。你可以用@ListAccess获取我存储的值，使用它们的编号：",
                "例如，在这个列表中，第二个值是 \\['香蕉']\\",
                "\\['苹果' '香蕉' '芒果'][2]\\",
                "我里面可以放任何东西。看看这个列表，包含@Text、@Number和@Time！",
                "\\['苹果' 10 + 10 Time()]\\",
                "当你给我很多东西的列表时，如果它们有共同的类型，我会将它们概括起来。但有时你可能确实是指的那些特定的东西。如果是的话，只需在我后面加上一个！，我会确保我只代表那些特定的值的列表。",
                "\\['苹果' '香蕉' '芒果']!\\",
                "大致就是这样。但是，我可以使用我的@FunctionDefinition做很多令人兴奋的事情！"
            ],
            "name": ["[]", "列表"],
            "kind": "类型",
            "out": "结果",
            "outofbounds": "越界",
            "function": {
                "add": {
                    "doc": [
                        "我创建一个包含给定项的新@List。",
                        "\\['苹果' '香蕉' '芒果'].加('西瓜')\\"
                    ],
                    "names": ["加"],
                    "inputs": [
                        {
                            "doc": "你想要添加的值。",
                            "names": "项"
                        }
                    ]
                },
                "append": {
                    "doc": [
                        "我创建一个包含我的值以及在我后面的给定@List的所有值的新@List。",
                        "\\['苹果' '香蕉' '芒果'].append(['西瓜' '杨桃'])\\",
                        "不过，使用@Spread会更方便，像这样：",
                        "\\['苹果' '香蕉' '芒果' :['西瓜' '杨桃']]\\"
                    ],
                    "names": ["附加"],
                    "inputs": [
                        {
                            "doc": "要添加的值的列表。",
                            "names": "列表"
                        }
                    ]
                },
                "replace": {
                    "doc": [
                        "我创建一个新的列表，用给定值替换给定索引处的值。",
                        "\\['苹果' '香蕉' '芒果'].replace(1 '猕猴桃')\\"
                    ],
                    "names": ["替换"],
                    "inputs": [
                        {
                            "doc": "要替换的值的索引。",
                            "names": "索引"
                        },
                        {
                            "doc": "替换的值",
                            "names": "值"
                        }
                    ]
                },
                "length": {
                    "doc": "我里面的项数，作为@Number返回。",
                    "names": ["📏", "长度"],
                    "inputs": []
                },
                "random": {
                    "doc": [
                        "从我的项中随机选择一个项，如果我是空的则返回@None。",
                        "\\['苹果' '香蕉' '芒果'].随机()\\"
                    ],
                    "names": "随机",
                    "inputs": []
                },
                "shuffled": {
                    "doc": [
                        "将最后列出的项目按随机顺序排列，制作一份新列表。",
                        "\\['苹果' '香蕉' '芒果'].shuffled()\\"
                    ],
                    "names": "洗牌",
                    "inputs": []
                },
                "first": {
                    "doc": [
                        "我里面的第一个项，如果我是空的则返回@None。",
                        "\\['苹果' '香蕉' '芒果'].first()\\"
                    ],
                    "names": "第一个",
                    "inputs": []
                },
                "last": {
                    "doc": [
                        "我里面的最后一个项，如果我是空的则返回@None。",
                        "\\['苹果' '香蕉' '芒果'].first()\\"
                    ],
                    "names": "最后一个",
                    "inputs": []
                },
                "has": {
                    "doc": [
                        "如果我里面有与给定项相等的项，则返回\\⊤\\。",
                        "\\['苹果' '香蕉' '芒果'].has('香蕉')\\"
                    ],
                    "names": "包含",
                    "inputs": [
                        {
                            "doc": "要搜索的值。",
                            "names": "项"
                        }
                    ]
                },
                "join": {
                    "doc": [
                        "我将我的列表中的项组合成@Text，用给定的分隔符@Text分隔。",
                        "\\['苹果' '香蕉' '芒果'].join(', ')\\"
                    ],
                    "names": "连接",
                    "inputs": [
                        {
                            "doc": "用于分隔项的文本，可以为空。",
                            "names": "分隔符"
                        }
                    ]
                },
                "subsequence": {
                    "doc": [
                        "我获得一个在此列表内部的列表，从你提供的索引开始，到最后一个项结束，或者如果你提供了一个，直到特定项结束。",
                        "\\['苹果' '香蕉' '芒果'].subsequence(2)\\",
                        "\\['苹果' '香蕉' '芒果'].subsequence(1 2)\\",
                        "看！如果你提供的数字是无序的，我会给你反向的结果",
                        "\\['苹果' '香蕉' '芒果'].subsequence(3 1)\\",
                        "如果你给我一个小于1的索引，我会认为你是指的1。",
                        "\\['苹果' '香蕉' '芒果'].subsequence(-1003243 2)\\",
                        "如果你给我一个大于最大索引的值，我会假设你指的是末尾。",
                        "\\['苹果' '香蕉' '芒果'].subsequence(3 2304032432)\\"
                    ],
                    "names": "子序列",
                    "inputs": [
                        {
                            "doc": "你想要的子序列的第一个项的索引。",
                            "names": "开始"
                        },
                        {
                            "doc": "你想要的子序列的最后一个项的索引，可选。如果你不提供，你的列表将以列表中的最后一项结束。",
                            "names": "结束"
                        }
                    ]
                },
                "sansFirst": {
                    "doc": [
                        "我创建一个没有我的第一个项的@List。",
                        "\\['苹果' '香蕉' '芒果'].sansFirst()\\"
                    ],
                    "names": "除第一个",
                    "inputs": []
                },
                "sansLast": {
                    "doc": [
                        "我创建一个没有我的最后一个项的@List。",
                        "\\['苹果' '香蕉' '芒果'].sansLast()\\"
                    ],
                    "names": "除最后一个",
                    "inputs": []
                },
                "sans": {
                    "doc": [
                        "我，但是没有给定值的第一个出现。",
                        "\\['苹果' '香蕉' '芒果' '苹果'].sans('苹果')\\"
                    ],
                    "names": "除",
                    "inputs": [
                        {
                            "doc": "要删除第一个出现的值。",
                            "names": "值"
                        }
                    ]
                },
                "sansAll": {
                    "doc": [
                        "我，但是没有给定值的所有出现。",
                        "\\['苹果' '香蕉' '芒果' '苹果'].sans('苹果')\\"
                    ],
                    "names": "全部除",
                    "inputs": [
                        {
                            "doc": "要从列表中删除所有出现的值。",
                            "names": "值"
                        }
                    ]
                },
                "reverse": {
                    "doc": [
                        "我，但是倒序！",
                        "\\['苹果' '香蕉' '芒果'].reverse()\\"
                    ],
                    "names": "倒序",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "如果我的项和顺序与给定的@List完全相同，则返回\\⊤\\。",
                        "\\['苹果' '香蕉' '芒果'] = ['苹果' '芒果' '香蕉']\\"
                    ],
                    "names": ["=", "等于"],
                    "inputs": [
                        {
                            "doc": "要与我比较的@List。",
                            "names": "列表"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "如果我的项和顺序/不/与给定的@List完全相同，则返回\\⊤\\。",
                        "\\['苹果' '香蕉' '芒果'] ≠ ['苹果' '芒果' '香蕉']\\"
                    ],
                    "names": ["≠", "不等于"],
                    "inputs": [
                        {
                            "doc": "要与我比较的@List。",
                            "names": "列表"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "给我一个以值和可选索引为输入的@FunctionDefinition，产生一个值，我会在我的每个项上评估它，将我的值转化为新的值。",
                        "例如，假设我是@Number的列表，你想将它们都加倍：",
                        "\\[2 4 6 8].translate(ƒ(num•#) num · 2)\\"
                    ],
                    "names": "翻译",
                    "inputs": [
                        {
                            "doc": "将转化每个项的@FunctionDefinition。",
                            "names": "翻译器"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "正在被转化的项。",
                            "names": "项"
                        },
                        {
                            "doc": "正在被转化的项的索引。",
                            "names": "索引"
                        },
                        {
                            "doc": "正在被转化的列表。",
                            "names": "列表"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "给我一个接受一个值和可选的索引作为输入并产生一个 @Boolean 值的 @FunctionDefinition，我将创建一个只包含结果为 \\⊤\\ 的新列表。",
                        "例如，假设我是一个 @Number 列表，你只想要其中的正数：",
                        "\\[2 -4 8 -16].filter(ƒ(num•#) num ≥ 0)\\"
                    ],
                    "names": "过滤器",
                    "inputs": [
                        {
                            "doc": "一个 @FunctionDefinition，检查每个项目，如果应该保留，则产生 \\⊤\\。",
                            "names": "检查器"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "正在检查的项目。",
                            "names": "项"
                        },
                        {
                            "doc": "正在检查的项目的索引。",
                            "names": "索引"
                        },
                        {
                            "doc": "被过滤的列表。",
                            "names": "列表"
                        }
                    ]
                },
                "all": {
                    "doc": [
                        "给我一个 @FunctionDefinition 把一个值作为输入值并且如果它满足一些条件就产生一个@Boolean. 如果所有的物品满足条件, 我会创造一个\\⊤\\",
                        "例如, 想象我是一串 @Number 并且你想要去知道是不是所有数字都是正数:",
                        "\\[2 -4 8 -16].all(ƒ(数字•#) 数字 ≥ 0)\\"
                    ],
                    "names": "所有",
                    "inputs": [
                        {
                            "doc": "@FunctionDefinition that 产生 \\⊤\\ 如果一个物品满足你的条件。",
                            "names": "检验员"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "这个物品正在被检查。",
                            "names": "物品"
                        },
                        {
                            "doc": "这个物品的索引正在被检查。",
                            "names": "索引"
                        },
                        {
                            "doc": "这个列表正在被检查。",
                            "names": "列表"
                        }
                    ]
                },
                "until": {
                    "doc": [
                        "给我一个@FunctionDefinition 把一个值作为输入值并且如果它满足一些条件就产生一个@Boolean. 我会创造一个包含所有物品的@List直到条件不被满足。",
                        "例如, 想象我是一个@Text动物的列表并且你想要所有的 东西直到\\'rat'\\被找到:",
                        "\\['cat' 'dog' 'rat' 'mouse' 'pony'].until(ƒ(animal•'') animal = 'rat')\\"
                    ],
                    "names": "直到",
                    "inputs": [
                        {
                            "doc": "@FunctionDefinition 会产生\\⊤\\如果我应该停止再囊括更多物品。",
                            "names": "检验员"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "这个物品正在被检查。",
                            "names": "物品"
                        },
                        {
                            "doc": "这个物品的索引正在被检查。",
                            "names": "索引"
                        },
                        {
                            "doc": "列表正在排序。",
                            "names": "列表"
                        }
                    ]
                },
                "find": {
                    "doc": [
                        "给我一个@FunctionDefinition 把一个值作为输入值并且如果它满足一些标准就产生一个@Boolean, 并且我会计算满足条件的物品。",
                        "例如, 想象你想要去找出第一个有这个元音\\'e'\\的动物:",
                        "\\['cat' 'dog' 'rat' 'mouse' 'pony'].找(ƒ(动物•'') 动物.有('e'))\\"
                    ],
                    "names": "找到",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition 如果匹配你的搜索条件, 会产生\\⊤\\。",
                            "names": "检验员"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "这个物品正在被检查。",
                            "names": "物品"
                        },
                        {
                            "doc": "这个物品的索引正在被检查。",
                            "names": "索引"
                        },
                        {
                            "doc": "这个列表正在搜索。",
                            "names": "列表"
                        }
                    ]
                },
                "combine": {
                    "doc": [
                        "给我一个接收最近一个的结合和下一个值的@FunctionDefinition, 并且创造下一个结合, 并且我将从第一个项目到最后一个项目, 创造连续的结合, 并且计算你的@FunctionDefinition 也计算的最后一个结合。",
                        "这对于结合在我这里的所有物品到一个单独的值非常有帮助的。例如, 想象你要想去增加一个数字的列表:",
                        "\\[3 9 2 8 1 4].结合(0 ƒ(总和•# 数字•#) 总和 + 数字)\\"
                    ],
                    "names": "结合",
                    "inputs": [
                        {
                            "doc": "开始的结合。",
                            "names": "初始的"
                        },
                        {
                            "doc": "接收最新的结合和下一个值并且产生下一个结合的@FunctionDefinition。",
                            "names": "组合器"
                        }
                    ],
                    "combiner": [
                        {
                            "doc": "当前的组合",
                            "names": "合并"
                        },
                        {
                            "doc": "下一个将被合并的物品。",
                            "names": "下一个"
                        },
                        {
                            "doc": "下一个合并的索引",
                            "names": "索引"
                        },
                        {
                            "doc": "正在合并的列表。",
                            "names": "列表"
                        }
                    ]
                },
                "sorted": {
                    "doc": [
                        "我可以接受一个列表，并且创造一个值是排序好的新的列表，像这个:",
                        "\\[1 5 8 0 2].排序()\\",
                        "我也可以为@Text 值做这个",
                        "\\['橙子' '猕猴桃' '香蕉' '苹果'].排序()\\",
                        "并且如果你有一个值既不是@Number 也不是@Text 的列表, 你可以给我把每个物品变成@Number 的@FunctionDefinition, 我就可以将它们排序. 例如, 在这里我们有一个包含不同长度列表的列表; 如果你给我一个可以将每个列表变成它的长度的功能, 我就可以将它们按长度排序。",
                        "\\[[1] [2 3] [4 8 12] [8]].排序(ƒ(列表) 列表.长度())\\"
                    ],
                    "names": "排序好的",
                    "inputs": [
                        {
                            "doc": "可选择性使用@FunctionDefinition 来给列表的值排序。它应该将值变成可以被用来给列表排序的@Number。",
                            "names": "定序器"
                        }
                    ],
                    "sequencer": [
                        {
                            "doc": "变成@Number 的值。",
                            "names": "值"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "@Text 列表的表现。",
                "set": "@Set, 对于移除重复有帮助。"
            }
        },
        "Set": {
            "doc": [
                "我是一组值! 这意味着我可以包含任何值的数字, 包括没有值。你可以让我这样:",
                "\\{1 2 3}\\",
                "如果你想保存的东西没有任何重复的，我就什么也不会做。",
                "这意味着如果你给我已经有的值，我将忽略额外的值。",
                "例如, 这一组有很多重复:",
                "\\{1 1 2 2 3 3}\\",
                "我将它计算为只有\\{1 2 3}\\.",
                "如果你想要去看我有没有一个值, @SetOrMapAccess 可以帮助:",
                "\\{'罐子' '瓶子' '玻璃'}{'杯子'}\\"
            ],
            "name": ["{}", "指令"],
            "kind": "和蔼的",
            "out": "结果",
            "function": {
                "size": {
                    "doc": "我会告诉你我有几个值。",
                    "names": "大小",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "我是\\⊤\\ 如果已有的@Set 和我有一摸一样的值:",
                        "\\{1 2 3} = {2 3 4}\\"
                    ],
                    "names": ["=", "等于"],
                    "inputs": [
                        {
                            "doc": "拿来比较的@Set.",
                            "names": "指令"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "我是\\⊤\\如果已有的@Set 和我有一摸一样的值:",
                        "\\{1 2 3} ≠ {2 3 4}\\"
                    ],
                    "names": ["≠", "不等于"],
                    "inputs": [
                        {
                            "doc": "拿来比较的@Set.",
                            "names": "指令"
                        }
                    ]
                },
                "add": {
                    "doc": [
                        "给我一个拿来增加的值并且我会拿我的物品和给我的物品做一个新的@Set。",
                        "\\{1 2 3} + 4\\"
                    ],
                    "names": ["加号", "+"],
                    "inputs": [
                        {
                            "doc": "拿来增加的物品",
                            "names": "物品"
                        }
                    ]
                },
                "remove": {
                    "doc": [
                        "给我一个拿来移除的物品并且我会产生一个没有物品的@Set。",
                        "\\{1 2 3} - 2\\",
                        "如果我没有物品, 我就只会自己算一下。"
                    ],
                    "names": ["减号", "-"],
                    "inputs": [
                        {
                            "doc": "拿来减去的物品。",
                            "names": "物品"
                        }
                    ]
                },
                "union": {
                    "doc": [
                        "给我一个@Set, 并且我会创造一个新的有我物品的@Set 和这指令的值。",
                        "\\{1 2 3} ∪ {3 4 5}\\"
                    ],
                    "names": ["联合", "∪"],
                    "inputs": [
                        {
                            "doc": "和我结合的@Set。",
                            "names": "指令"
                        }
                    ]
                },
                "intersection": {
                    "doc": [
                        "给我一个@Set并且我会创造一个新的@Set, 它里面只有我们都有的物品。",
                        "\\{1 2 3} ∩ {3 4 5}\\"
                    ],
                    "names": ["交集", "∩"],
                    "inputs": [
                        {
                            "doc": "和我比较的一个指令.",
                            "names": "指令"
                        }
                    ]
                },
                "difference": {
                    "doc": [
                        "给我一个@Set 并且我会创造一个新的@Set, 它里面只有我们都有的物品.",
                        "\\{1 2 3}.difference({3 4 5})\\"
                    ],
                    "names": "不同",
                    "inputs": [
                        {
                            "doc": "这套的物品应该从我这里移除的物品.",
                            "names": "组"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "给我一个可以接收物品并且产生\\⊤\\的@FunctionDefinition, 如果它应该被保留, 我会创造一个只包含可以满足你要求的物品的@Set.",
                        "例如, 让我们找出我这里的奇数:",
                        "\\{1 2 3 4 5 6 7 8 9}.过滤(ƒ(数字•#) (数字 % 2) = 1)\\"
                    ],
                    "names": "过滤",
                    "inputs": [
                        {
                            "doc": "检查物品是否需要被保留的@FunctionDefinition。",
                            "names": "检验员"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "正在被检查的物品。",
                            "names": "值"
                        },
                        {
                            "doc": "被过滤的组。",
                            "names": "组"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "给我一个可以接收物品并且可以产生新的物品的@FunctionDefinition, 之后我会翻译我的所有物品到新的@Set (移除任何的重复)。",
                        "例如, 让我们把所有的@Number变成@Text:",
                        "\\{1 2 3 4 5 6 7 8 9}.translate(ƒ(数字•#) 数字→'')\\"
                    ],
                    "names": "翻译",
                    "inputs": [
                        {
                            "doc": "可以将我其中一个物品翻译成你想要的新物品的@FunctionDefinition。",
                            "names": "指令"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "正在被翻译的物品。",
                            "names": "值"
                        },
                        {
                            "doc": "正在被翻译的值",
                            "names": "指令"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "@Set 的体现@Text",
                "list": "在指令里面的物品的代表@List。"
            }
        },
        "Map": {
            "doc": [
                "我将值放在一起, 映射*密钥*到*值*. 例如:",
                "\\{'艾米': 6分 '托尼':3分 '希拉': 8分}\\",
                "我的密钥可以是任何类型的值, 我的值也可以是任何类型的值。",
                "一些人喜欢把我想成索引, 或者是目录, 你可以给我一些东西的地方, 并且我给你映射过的。",
                "如果你想要检查映射过的东西, 你可以用@SetOrMapAccess, 一个密钥并且它们会给你值:",
                "\\{'艾米': 6分 '托尼':3分 '希拉': 8分}{'艾米'}\\",
                "如果这里没有匹配的密钥, 我会给你显示@None。",
                "\\{'艾米': 6分 '托尼':3分 '希拉': 8分}{'詹'}\\",
                "你也可以做一个空的映射, 就像这样:",
                "\\{:}\\",
                "我知道和我的匹配可以创造出多少美好的事情。"
            ],
            "name": ["{:}", "映射"],
            "key": "密钥",
            "value": "值",
            "result": "结果",
            "function": {
                "size": {
                    "doc": "我会告诉你我有多少值。",
                    "names": "大小",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "\\{⊤}\\ 如果我的匹配和给出的@Map 一模一样。",
                        "\\{1:1 2:2} = {1:1 2:3}\\"
                    ],
                    "names": ["=", "等于"],
                    "inputs": [
                        {
                            "doc": "比较我的@Map。",
                            "names": "值"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "\\{⊤}\\ 如果我的匹配并/不是/ 和给出的@Map的 一摸一样。",
                        "\\{1:1 2:2} ≠ {1:1 2:3}\\"
                    ],
                    "names": ["≠", "不等于"],
                    "inputs": [
                        {
                            "doc": "和我比较的@Map。",
                            "names": "值"
                        }
                    ]
                },
                "set": {
                    "doc": [
                        "我会创造一个新的@Map, 它有一样的配对, 但是有你给我的新的配对. 如果我已经有密钥, 我会将它配对到新的值。",
                        "\\{'艾米': 6分 '托尼':3分}.匹配('詹' 0分)\\"
                    ],
                    "names": "配对",
                    "inputs": [
                        {
                            "doc": "匹配值的密钥.",
                            "names": "密钥"
                        },
                        {
                            "doc": "和密钥匹配的值",
                            "names": "值"
                        }
                    ]
                },
                "unset": {
                    "doc": [
                        "我会创造一个没有你给我密钥的@Map, 移除配对。",
                        "\\{'艾米': 6分 '托尼':3分}.不匹配('艾米')\\"
                    ],
                    "names": "不匹配",
                    "inputs": [
                        {
                            "doc": "忘记的密钥.",
                            "names": "密钥"
                        }
                    ]
                },
                "remove": {
                    "doc": [
                        "我会创造一个新的没有任何密钥的@Map, 这些密钥是没有值的。",
                        "\\{'艾米': 0分 '詹': 0分 '托尼':3分}.移除(0分)\\"
                    ],
                    "names": "移除",
                    "inputs": [
                        {
                            "doc": "从我身上移除的值，以及与之配对的任何密钥。",
                            "names": "值"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "给我一个可以接收密钥和值的@FunctionDefinition 计算\\⊤\\ 如果一个配对应该被保留。我会创造一个新的可以满足你要求的@Map。",
                        "例如，在这里我们希望保留艾米或者积分超过零的配对。",
                        "\\{'艾米': 0分 '詹': 0分 '托尼':3分}.过滤(ƒ(密钥•'' 值•#分) (密钥 = '艾米') | (值 > 0分))\\"
                    ],
                    "names": "过滤",
                    "inputs": [
                        {
                            "doc": "可以决定是否保留一个配对的@FunctionDefinition.",
                            "names": "检验员"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "正在被检查的密钥.",
                            "names": "密钥"
                        },
                        {
                            "doc": "正在被检查的值.",
                            "names": "值"
                        },
                        {
                            "doc": "正在被过滤的密钥.",
                            "names": "映射"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "可以接收密钥和值的@FunctionDefinition, 并且计算值到一个新的值. 我会创造一个新的带着一样密钥的但是更新过值的@Map.",
                        "例如, 让我们给每个人一分自从他们一直表现的很好.",
                        "\\{'艾米': 5分 '詹': 3分 '托尼': 0分}.翻译(ƒ(密钥•'' 值•#分数) 值 + 1分数)\\"
                    ],
                    "names": "翻译",
                    "inputs": [
                        {
                            "doc": "翻译每个值的@FunctionDefinition.",
                            "names": "翻译家"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "正在被翻译的值的密钥.",
                            "names": "密钥"
                        },
                        {
                            "doc": "正在被翻译的值.",
                            "names": "值"
                        },
                        {
                            "doc": "正在被翻译的映射",
                            "names": "映射"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "映射的代表@Text.",
                "set": "@Map 的密钥",
                "list": "一个在带有值的@Map 里面带有值的列表"
            }
        },
        "Table": {
            "doc": [
                "我是一组表行! 我可以帮助你跟踪具有相同结构的值的大型集合.",
                "例如, 想象你想要去追踪一大堆石头:",
                "\\⎡名字•'' 颜色•''⎦\n⎡'黑曜石' '黑色'⎦\n⎡'浮岩' '灰色'⎦\n⎡'黄水晶' '黄色'⎦\\",
                "@Bind 可以帮助你命名它! 并且之后你可以做这些事情,例如, 做一个有新的行@Insert 的修正过的数据库:",
                "\\石头: ⎡名字•'' 颜色•''⎦\n⎡'黑曜石' '黑色'⎦\n⎡'浮岩' '灰色'⎦\n⎡'黄水晶' '黄色'⎦\n石头 ⎡+ '石英' '白色'⎦\\",
                "或者如果你想要去找出可以符合的行, 你可以用@Select 可以符合条件的行:",
                "\\石头: ⎡名字•'' 颜色•''⎦\n⎡'黑曜石' '黑色'⎦\n⎡'浮岩' '灰色'⎦\n⎡'黄水晶' '黄色'⎦\n石头 ⎡?⎦ 颜色 = '灰色'\\",
                "或者如果你想要做一个修正过的数据库, 这个数据库对于可以满足条件的行有不同的值:",
                "\\石头: ⎡名字•'' 颜色•''⎦\n⎡'黑曜石' '黑色'⎦\n⎡'浮岩' '灰色'⎦\n⎡'黄水晶' '黄色'⎦\n石头 ⎡: 颜色: '黑色' ⎦ 名称 = '浮岩'\\",
                "或者你可能想要删掉可以满足条件的行:",
                "\\石头: ⎡名字•'' 颜色•''⎦\n⎡'黑曜石' '黑色'⎦\n⎡'浮岩' '灰色'⎦\n⎡'黄水晶' '黄色'⎦\n石头 ⎡- 名字.有('i')\\",
                "并且如果你想从我这里得到具体的值, 你可以把任何一个数据库转换成一个列表, 并且可以用@PropertyReference 访问单独的行.",
                "\\石头: ⎡名字•'' 颜色•''⎦\n⎡'黑曜石' '黑色'⎦\n⎡'浮岩' '灰色'⎦\n⎡'黄水晶' '黄色'⎦\n(石头 → [])[1].名称\\"
            ],
            "name": ["⎡⎦", "工作台"],
            "row": "排",
            "function": {
                "equals": {
                    "doc": "我如果我有和另一个@Table一样的以同样顺序排列的单元, 我会检查。",
                    "names": ["=", "等于"],
                    "inputs": [
                        {
                            "doc": "检查的另一个工作台.",
                            "names": "值"
                        }
                    ]
                },
                "notequal": {
                    "doc": "如果和另一个@Table 比较起来, 任何我的单元是不同的或者以一个不同的顺序排列, 我会检查。",
                    "names": ["≠", "不相等"],
                    "inputs": [
                        {
                            "doc": "检查的另一个工作台.",
                            "names": "值"
                        }
                    ]
                }
            },
            "conversion": {
                "list": "我把一个@Table转换成一个含有行的列表, 这个列表的每一行是@Structure而且它的列的名字是它的参数。",
                "text": "我就是把一个@Table转换成文字。"
            }
        },
        "Structure": {
            "doc": "看@StructureDefinition。",
            "name": ["结构"],
            "function": {
                "equals": {
                    "doc": "如果我的参数与另外一个结构的参数是同样的名字和值, 我会检查。",
                    "names": ["=", "等于"],
                    "inputs": [
                        {
                            "doc": "另一个要检查的结构.",
                            "names": "值"
                        }
                    ]
                },
                "notequal": {
                    "doc": "如果我的参数和另外一个结构的参数有任何的名字和值上面的不同, 我会检查.",
                    "names": ["≠", "不等于"],
                    "inputs": [
                        {
                            "doc": "另一个要检查的结构.",
                            "names": "值"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "我把我自己转换成@Text."
            }
        }
    },
    "input": {
        "Random": {
            "doc": [
                "17!",
                "/@FunctionDefinition, 我会解释这个./",
                "所以 @Random 是一个充满好奇心的生成随机数的方法 他很好奇，因为每次你评估它时，它都会创造出不同的东西。",
                "这造成了一种奇妙的混乱，并伴随着不可预测性。",
                "在默认情况下, 他会给出 @Number 类型 在 \\0\\ 和 \\1\\之间的值:",
                "\\随机()\\",
                "但是你可以给他输入一个参数, 他就会生成一个在\\0\\ 和那个参数之间的值：",
                "\\随机(10)\\",
                "如果你给他输入两个参数，那他就会生成两个参数之间的值:",
                "\\随机(-10 10)\\",
                "如果你的区间有单位的话，单位会被保存 (如果单位不统一，最小的单位会被采用):",
                "\\随机(-10m 10m)\\",
                "如果你给出的数字在小数点后具有特定数量的有效数字，则将保留该精度。",
                "\\随机(1.00 10.00)\\"
            ],
            "names": ["🎲", "随机"],
            "inputs": [
                {
                    "names": "最小值",
                    "doc": "最小的可能值"
                },
                {
                    "names": "最大值",
                    "doc": "最大的可能值"
                }
            ]
        },
        "Choice": {
            "doc": [
                "/clickety tap!/",
                "/@FunctionDefinition, 我来解释下这个吧！/",
                "将 @Choice 视为由受众选择的 @Phrase/name 流。如果有人在带有名称的 @Phrase 上单击、敲击或按 /Enter/ 进行键盘选择，@Choice 将有一个与名称匹配的新值。",
                "因此，使用它的最佳方法是使用命名的可选短语@Phrase 创建一个表演，然后使用@Reaction 来决定选择该名称时要执行的操作。",
                "这里有一个简单的例子：",
                "\\Group(\nStack() \n[\nPhrase('一个'可选:⊤名称:'1') \nPhrase('两个'可选:⊤名称:'2') \nPhrase(Choice())\n ]\n)\\",
                "将其复制到编辑器中，然后选择两个 @Phrase 之一。你将看到第三个 @Phrase 显示所选的名称。"
            ],
            "names": ["🔘", "选择"]
        },
        "Button": {
            "doc": [
                "/click click click/",
                "/@FunctionDefinition 这里，我解释一下这个。/",
                "@Button 是监听鼠标或触控板的好方法。当然，鼠标或触控板并不是聆听观众讲话的理想选择，因为并非每个人都可以使用。更容易访问的选择是@Choice。",
                "但如果你/确实/需要监听鼠标按钮，这就是实现的方法。它将提供一个 @Boolean 流，表示主按钮是向上 \\⊥\\ 还是向下 \\⊤\\。",
                "这是一个简单的例子：",
                "\\短语(按钮() → '')\\",
                "这只是创建一个@Phrase，它是流的文本值。如果将其复制到编辑器中并单击，你将看到它在 \\⊥\\ 和 \\⊤\\ 之间来回切换。"
            ],
            "names": ["按钮"],
            "down": {
                "names": "按下",
                "doc": "如果@None，流将提供向上和向下值。如果@Boolean，它只会提供给定@Boolean值的值。"
            }
        },
        "Pointer": {
            "doc": [
                "/嗡嗡嗡/",
                "/@FunctionDefinition 这里，我解释一下这个。/",
                "你了解鼠标、触控板和触摸屏吗？有时你想知道观众指向哪里。这就是 @Pointer 提供的。",
                "当然，这不是一个易于访问的选择：并非每个人都可以看到或轻松指出，因此请务必确保你不会排除某人通过使用此流参与。",
                "如果你确定没有人被排除在外，那么使用 @Pointer 就像创建一个流一样简单：",
                "\\Pointer()\\",
                "它提供的@Place将对应于@Stage上指针所指向的位置。"
            ],
            "names": ["⛓", "链接"]
        },
        "Key": {
            "doc": [
                "/咔嗒！/",
                "/@FunctionDefinition在这里，我来解释一下",
                "键盘有很多键，不是吗?@Key会告诉你哪个人在按哪个键。",
                "试试这个吧！",
                "\\Key()\\",
                "看到了吗，当你输入一个键时，它会出现在@Stage上?每次按下一个键时，一个新的@Text将被添加到流中，描述按下的键。",
                "对于表示字符的键，其值将是字符@Text。",
                "对于特殊的键，如/Escape/键，将使用@Text描述键，使用<预定义名称@https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values>，不幸的是只有英文版本。",
                "如果你只想知道一个特定的密钥，你可以提供它:",
                "\\Key('a')\\",
                "如果你只想知道@Key什么时候被释放而不是按下，你可以提供一个@Boolean值:",
                "\\Key('a' ⊥)\\"
            ],
            "names": ["⌨️", "钥匙"],
            "key": {
                "names": "钥匙",
                "doc": "如果是@None，则提供所有键。如果是特定的@Text，则只提供该键"
            },
            "down": {
                "names": "下",
                "doc": "如果@None，则按下键生成输入。如果\\⊥\\，那么只提供向下的输入，如果\\⊥\\，那么只提供释放的输入。"
            }
        },
        "Time": {
            "doc": [
                "/嘀嗒嘀嗒嘀嗒～/",
                "@FunctionDefinition在这里，我将解释@Time，因为它没有说话。",
                "时间是一条以一定频率滴答作响的溪流。",
                "每次执行时，@Program用新的时间值重新求值。",
                "比如说：",
                "\\Time()\\",
                "如果你为时间提供@Time/frequency，它将以该速率滴答。例如:",
                "\\Time(1000ms)\\",
                "然而，它可以有多小是有限的，因为@Program需要时间来评估，然后才能响应下一个tick。",
                "最小的可能在\\20ms\\左右."
            ],
            "names": ["🕕", "时间"],
            "frequency": {
                "names": ["频率"],
                "doc": "这是时间应该滴答作响的频率。它的默认值是\\33ms\\，大约每秒30次。"
            },
            "relative": {
                "names": ["相对的"],
                "doc": "如果是 \\⊤\\，时间从0开始，当程序首次评估时。否则，它从今天开始的毫秒数开始，以协调世界时（UTC）为基准，使你能够跟踪一天中的时间。"
            }
        },
        "Volume": {
            "doc": [
                "/滋滋滋～/",
                "@FunctionDefinition，我来拿麦克风吧。",
                "该流是一系列介于0和1之间的音量，以你选择的频率采样。默认情况下，频率为30hz，即每秒30次，但你可以将其更改为更低的频率。",
                "\\Volume()\\",
                "这对于倾听听众的声音是很好的!"
            ],
            "names": ["🔊", "音量"],
            "frequency": {
                "names": ["频率"],
                "doc": "采样间隔时间"
            }
        },
        "Pitch": {
            "doc": [
                "/嗡嗡嗡/",
                "@FunctionDefinition在这里，让我们来谈谈音调!",
                "这个流是一系列以赫兹为单位的频率，表示声音的音高，以你选择的频率采样。我们发现人类的声音在20赫兹到5000赫兹之间，所以计划在这个范围内的数字。",
                "\\Pitch()\\",
                "这对听别人说话或唱歌的语气很有帮助。"
            ],
            "names": ["🎵", "音调"],
            "frequency": {
                "names": ["频率"],
                "doc": "采样间隔时间"
            }
        },
        "Camera": {
            "doc": [
                "/嗡嗡嗡～/",
                "@FunctionDefinition在这里，我可以解释@Camera!",
                "所以@Camera提供了一个来自你的世界的@Color的@List。该列表本质上代表一个图像，但如何处理它取决于你",
                "你可以尝试使用一堆@Phrase来表示图像，这看起来非常酷!试着复制这个…",
                "\\colors: Camera(32px 24px 33ms)\n\nStage(\ncolors.combine(\n[] \nƒ(phrases•[Phrase] row•[Color] y•#) \nphrases.append(\nrow.translate(\nƒ(color•Color x•#)\nPhrase('o' place: Place((x - 1) · 0.5m y · -0.5m) color: color duration: 0s\n)\n)\n)\n)\n)\\",
                "但是你也可以通过分析颜色来决定一盏灯是开着还是关着，或者一种特定的颜色是否常见，让观众用他们展示的颜色来影响表演。"
            ],
            "names": ["🎥", "相机"],
            "width": {
                "names": ["宽度"],
                "doc": "要在一行中采样的@Color的数量。"
            },
            "height": {
                "names": ["高度"],
                "doc": "列中要采样的@Color的个数。"
            },
            "frequency": {
                "names": ["频率"],
                "doc": "@Color样本之间的时间间隔。"
            }
        },
        "Scene": {
            "doc": [
                "/嘟嘟嘟/",
                "你好，我是@FunctionDefinition！我看到你找到了@Scene。",
                "我认为 @Scene 特别酷。基本思路是，你给它一个 @Phrase 或 @Group 列表，然后它会按顺序显示它们，并在最后一个停止。",
                "要控制时间，你可以设置每个输出的 @Phrase/duration，它会显示该时间，然后再转到下一个输出，并使用你可能设置的任何 @Phrase/entering 或 @Phrase/exiting 转换。如果你将它们设置为 @Sequence，它将使用其持续时间。",
                "所有这些让你可以做类似这个小@Scene 的事情，它按顺序显示这三个短语：",
                "\\Scene([\nPhrase('你好' 持续时间：1 秒)\nPhrase('你好吗？' 持续时间：2 秒 旋转：5° 输入：姿势（旋转：0°）)\nPhrase('我很好')\n])\\",
                "看看第一个输出如何显示一秒，然后下一个输出显示两秒，但动画旋转五度，然后显示最后一个？",
                "你可以使用@Scene 制作非常复杂的输出和动画序列，甚至可以使它们的部分内容动态化或交互化，就像任何其他@Phrase 或@Group 一样。",
                "如果你有嵌套的动画输出（@Group 里面有动画@Phrase），@Scene 将等待@Group 中的所有动画内容完成。",
                "哦，还有最后一个小秘密！你甚至可以将 @Boolean 放入列表中，如果它们是 \\⊥\\，则 @Scene 将暂停并等待它变为真。",
                "例如，如果你想要制作一个@Phrase序列，并且只有当@Button 发生变化时才前进，你可以这样做：",
                "\\点击：∆ 按钮（）\n场景（[\n短语（'你好'）\n点击\n短语（'你好吗？' 持续时间：0.25 秒 旋转：5° 输入：姿势（旋转：0°））\n点击\n短语（'我很好'）\n]）\\",
                "看看它如何在每个@Phrase之后暂停，并等待@Button 改变后再前进？"
            ],
            "names": ["🎬", "场景"],
            "outputs": {
                "names": "输出",
                "doc": "按顺序显示的输出列表。"
            }
        },
        "Motion": {
            "names": ["⚽️", "运动"],
            "doc": [
                "/砰！砰！砰！/",
                "/嗨！@FunctionDefinition这里。我来解释一下@Motion怎么样?",
                "基本上，@Motion是@Phrase的流。你给它一个起始的@Phrase，然后它会根据重力用一个新的位置和旋转来改进它。",
                "它可以让你做一些非常简单的事情，比如创建弹跳的表情符号:",
                "\\运动(短语('o') startplace: Place(0m 10m))\\",
                "看到0是如何反弹的了吗?在第一次评估时，我们给它一个@Stage的高位置，但之后，它得到@None，这允许@Motion将其更改为重力将其放置的任何位置。",
                "查看下面配置它的许多其他方法"
            ],
            "place": {
                "doc": "开始点",
                "names": "点"
            },
            "velocity": {
                "doc": "初始速度",
                "names": "速度"
            },
            "nextplace": {
                "doc": "下一地点，无视物理",
                "names": "下一地点"
            },
            "nextvelocity": {
                "doc": "下一地点，无视速度",
                "names": " 下一个速度"
            }
        },
        "Chat": {
            "doc": [
                "/你好!@FunctionDefinition这里。你想聊聊吗?",
                "聊天流的基本思想是受众输入消息，然后程序对其进行响应。",
                "例如，这个简单的程序检查消息是否为“hello”，如果是，程序计算为“hi”。否则，它的求值为 \"huh\" ?",
                "\\Chat().has('hello') ? 'hi!' 'huh?'\\",
                "就是这样!你可以用它制作各种各样的表演，比如聊天机器人、文本冒险或其他表演的基于文本的控制方案。"
            ],
            "names": ["🗣️", "聊天"]
        },
        "Placement": {
            "doc": [
                "/嘿，这里是@FunctionDefinition。我们来谈谈如何让我们行动起来!/",
                "所以有很多方法可以把我们放在@Stage上。你可以给我们一个显式的@Place。你可以使用@Motion，让重力发挥作用。你也可以把我们放在一个@Group里，让他们按照特定的方式安排我们。",
                "但有时你想让观众控制我们在舞台上的位置。这就是@Placement的作用。",
                "它的工作原理是这样的:你只需要创建一个@Placement并把它赋给我们的@Place:",
                "\\Phrase('hi' place: Placement())\\",
                "然后，每当观众使用箭头键或在舞台上点击或轻敲时，@Placement将创建一个新的@Place，该@Place将朝着所需的方向移动。",
                "试着把这个复制到你的程序中，然后用指针或键盘移动箭头。",
                "你可以自定义@Place，在某些维度上启用和禁用移动，更改@Place移动的距离，以及流开始的初始@Place。"
            ],
            "names": ["✥", "摆放"],
            "inputs": [
                {
                    "doc": "开始的初始位置。",
                    "names": "初始"
                },
                {
                    "doc": "当观众要求移动时，场地应该移动多少米。",
                    "names": "距离"
                },
                {
                    "doc": "如果为true，则允许在水平轴上移动。默认为开启。",
                    "names": "水平的"
                },
                {
                    "doc": "如果为true，则允许在垂直轴上移动。默认为开启。",
                    "names": "竖直的"
                },
                {
                    "doc": "如果为true，则允许使用and -键在z轴上移动。",
                    "names": "深度"
                }
            ]
        },
        "Webpage": {
            "doc": [
                "/嘿，这里是@FunctionDefinition。让我们来谈谈如何从互联网上获得网页!/",
                "当我们第一次听说你们的互联网时，我们觉得它很迷人。一个充满了相互连接的计算机共享文档的世界?那太神奇了!",
                "所以我们制作了一条与之相连的流。你给我们一个网页链接，我们会得到所有的文本。是这样的:",
                "\\Webpage('https://wordplay.dev')\\",
                "而且显然有一种东西叫做 <CSS@https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/What_is_CSS>, 它想让你在网页上查询东西?给我们一个CSS选择查询，我们将只获得与该查询匹配的文本。就像这个例子，它获得一级标头",
                "\\Webpage('https://wordplay.dev' 'h1')\\",
                "这款手机可能会出很多问题。如果你失去了互联网连接、不能解析网页链接、网页链接不是公开的，或者网页链接不是HTML页面……所有这些都可能导致异常。如果你找到一个合适的页面，你会得到一个@Number，表示完成百分比，然后是一个@List的单词页面。"
            ],
            "names": ["🔗", "网页"],
            "url": {
                "doc": "要获取的HTML网页链接。",
                "names": "网页链接"
            },
            "query": {
                "doc": "要在HTML上计算的CSS查询",
                "names": "请求"
            },
            "frequency": {
                "doc": "在再次获取该页之前应该经过的分钟数",
                "names": "频率"
            },
            "error": {
                "invalid": "这不是一个有效的URL",
                "unvailable": "这个URL无法访问",
                "notHTML": "这个回应不是HTML",
                "noConnection": "无法连接到双关语",
                "limit": "对该域的请求太多"
            }
        },
        "Collision": {
            "names": "撞击",
            "doc": [
                "/你好!@FunctionDefinition这里。看看这个很酷的输入/",
                "它可以帮助你发现@Output何时相互碰撞!当我们相互碰撞时，这是一种很好的方式，而不是像@Output那样相互反弹。",
                "只要给我一个@Output的名字，当它碰到另一个名字时，我将创建一个新的@Rebound值。@Rebound有关于碰撞的名字和它们碰撞的方向的信息。",
                "如果你给了我两个名字，我只会在两个名字相遇的时候创建一个新值。",
                "在我创建一个新值之后，我将创建一个\\ø\\，因为碰撞是在它发生之后完成的。这表明不会再发生碰撞。",
                ""
            ],
            "subject": {
                "names": "主题",
                "doc": "我应该查找碰撞的@Output的名称。"
            },
            "object": {
                "names": "其他",
                "doc": "我应该查找碰撞的另一个@Output的名称。"
            }
        },
        "Rebound": {
            "names": "回弹",
            "doc": "我来自 @Collision，代表谁被碰撞了，碰撞发生在哪个方向。用我来决定是否以某种特殊的方式对碰撞做出反应，而不是普通的物理反应。",
            "direction": {
                "names": "方向",
                "doc": "碰撞的方向和大小，相对于碰撞的主体"
            },
            "subject": {
                "names": "主观",
                "doc": "主观所命中的输出的名称"
            },
            "object": {
                "names": "客观",
                "doc": "命中主题的输出的名称"
            }
        },
        "Direction": {
            "names": "方向",
            "doc": "我是方向和大小，沿着x轴和y轴。",
            "x": {
                "names": "x",
                "doc": "沿着x轴方向的方向和大小。"
            },
            "y": {
                "names": "y",
                "doc": "沿y轴方向的方向和大小。"
            }
        }
    },
    "output": {
        "Output": {
            "names": "输出",
            "doc": "我不是你真正可以制作的 @StructureDefinition 定义。但我是一个非常重要的人，因为我激发了我们舞蹈中最重要的元素：@Phrase、@Group 和 @Stage。去见见他们，去了解更多关于如何使用它们的信息。"
        },
        "Group": {
            "doc": "哦你好，你过的怎么样？当有其他人在身边时，我总是很愉快，所以能和你在一起真是太好了！\n 我将 @Phrase 和 @Group 组合在一起放在 @Stage上，并将它们放在@Arrangement中，这样它们的位置就有了一些秩序。\n 要使我工作，你需要给我一个@Arrangement，然后是一个@Output的@List以进行安排。\n 例如，在这里我用了一个@Stack Arrnagement和一些垂直堆叠的@Phrase：\n \\组(堆栈() [短语('第一个') 短语('第二个')])\\ \n 我如何安排事物取决于你给我的 @Arrangement。",
            "names": ["🔳", "组合"],
            "layout": {
                "doc": "将 @Output 放置在其位置的安排方式。",
                "names": "布局"
            },
            "content": {
                "doc": "安排的 @Output 列表。",
                "names": "内容"
            },
            "matter": {
                "doc": "如果我不小心碰到其他物体，我应该如何反应。",
                "names": "物体"
            },
            "size": {
                "doc": "我内心里美好的内容应该有多高，除非它们有自己的尺寸！",
                "names": "尺寸"
            },
            "face": {
                "doc": "我内部的字体名称内容应该有，除非他们有自己的字体可以使用。",
                "names": "表面"
            },
            "place": {
                "doc": "舞台上我应该在的位置。 我内部的内容会相对于那里进行排列。",
                "names": "位置"
            },
            "name": {
                "doc": "与 @Phrase/name 相同！",
                "names": "名称"
            },
            "description": {
                "doc": ["$~针对无法看到视觉输出的观众使用的描述。"],
                "names": "$~描述"
            },
            "selectable": {
                "doc": "与 @Phrase/selectable 的相同! ",
                "names": "可选择的"
            },
            "color": {
                "doc": "我内部的内容应该是 @Color，除非它们有自己的颜色。",
                "names": "颜色"
            },
            "background": {
                "doc": "投影在我背后的 @Color。",
                "names": "背景"
            },
            "opacity": {
                "doc": "我体内的一切在 \\0\\ 和 \\1\\ 之间应该是多么不透明，除非被不同的 @Pose 覆盖。",
                "names": "不透明度"
            },
            "offset": {
                "doc": "一个 @Place 指示它与我的正常 @Place 的偏移量，除非被不同的 @Pose 覆盖。 有助于就地摆动。",
                "names": "偏移"
            },
            "rotation": {
                "doc": "我应该围绕我的中心倾斜多少，我的 @Pose 有不同的倾斜。",
                "names": ["📐", "自转"]
            },
            "scale": {
                "doc": "相对于我原来的尺寸我应该有多大。",
                "names": "缩放"
            },
            "flipx": {
                "doc": "与 @Phrase/flipx 翻转相同！",
                "names": "水平翻转"
            },
            "flipy": {
                "doc": "与 @Phrase/flipy 相同！",
                "names": "垂直翻转"
            },
            "entering": {
                "doc": "与 @Phrase/entering 相同！",
                "names": "进入"
            },
            "resting": {
                "doc": "与 @Phrase/resting 相同！",
                "names": "休息"
            },
            "moving": {
                "doc": "与 @Phrase/moving 相同！",
                "names": "移动"
            },
            "exiting": {
                "doc": "与 @Phrase/exiting 相同！",
                "names": "退出"
            },
            "duration": {
                "doc": "与 @Phrase/duration 相同！",
                "names": ["⏳", "持续时间"]
            },
            "style": {
                "doc": "与 @Phrase/style 相同！",
                "names": "风格"
            },
            "defaultDescription": "$~$1[$1|] $2 $3"
        },
        "Phrase": {
            "doc": [
                "你好，你好！还记得我吗？怎么会有人忘记/我/。没错，我就是伟大的 @Phrase，准备好在 @Stage 上表达最可爱的 @Text.",
                "只要让我这样，我就会出现在 @Stage：",
                "\\Phrase('magnificient!')\\",
                "显然，我需要一些 @Text，但除此之外，我可以做任何 @Output 可以做的所有事情，包括更改我的大小、字体、旋转，以及使用 @Pose 和 @Sequence 进行所有令人难以置信的舞蹈.",
                "你也可以在 @Stage 上选择我，然后在隔壁的调色板上编辑我。"
            ],
            "names": ["💬", "短语"],
            "text": {
                "doc": "在 @Stage 上展示的角色。",
                "names": "文字"
            },
            "size": {
                "doc": "我应该多高，以米为单位！",
                "names": "尺寸"
            },
            "face": {
                "doc": "我应该使用的字体名称。",
                "names": "表面"
            },
            "place": {
                "doc": "舞台上我应该在的地方。",
                "names": "位置"
            },
            "wrap": {
                "doc": "我应该包裹符号的边缘，或者 \\ø\\ 如果我不应该包裹它们。",
                "names": ["↵", "包裹"]
            },
            "alignment": {
                "doc": "如果有 @Phrase/wrap 的边界集，我是否应该将符号与边缘的开始、中心或结束对齐。",
                "names": "对齐"
            },
            "direction": {
                "doc": "符号是水平书写还是垂直书写，如果设置了垂直和 @Phrase/wrap，则文本是左换行还是右换行。",
                "names": "方向"
            },
            "matter": {
                "doc": "碰到东西时可以使用的属性！",
                "names": "物体"
            },
            "aura": {
                "doc": "可选的在我背后的 @Aura,让我发光吧！",
                "names": "光晕"
            },
            "name": {
                "doc": "你给我起一个名字！这对很多事情都有帮助。\n 首先，如果我有名字，我会用它在屏幕阅读器描述中描述自己。\n 第二，在制作动画时，你可能有多个不同的表达式，这些表达式应该在舞台上表示相同的内容；给它们相同的名称，它们就会作为一个动画。 \n 最后，我对 @Choice 很有帮助：你给我的名字出现在该信息流中。 \n 如果有帮助的话，你可以给我许多不同的名称，每个名称都采用不同的语言。我将始终在第一个选定的区域设置中使用该名称",
                "names": "名字"
            },
            "description": {
                "doc": ["$~为无法看到视觉输出的观众提供的自定义描述。"],
                "names": "$~描述"
            },
            "selectable": {
                "doc": "如果是\\⊤\\，则表示我可以通过指针或键盘选择。",
                "names": "可选择的"
            },
            "color": {
                "doc": "@Color 应该是默认的，除非被不同的 @Pose 覆盖。",
                "names": "颜色"
            },
            "background": {
                "doc": "投射在我身后的 @Color",
                "names": "背景"
            },
            "opacity": {
                "doc": "默认情况下我应该有多不透明，在 \\0\\ 和 \\1\\ 之间，除非被不同的 @Pose 覆盖。有助于淡入和淡出。",
                "names": "不透明度"
            },
            "offset": {
                "doc": "一个 @Place 指示它与我的 @Place 的偏移量，除非被不同的 @Pose 覆盖。 有助于就地摆动。",
                "names": "偏移"
            },
            "rotation": {
                "doc": "我应围绕其中心旋转的度数，除非被不同的 @Pose 覆盖。",
                "names": ["📐", "旋转"]
            },
            "scale": {
                "doc": "我应该相对于其原始大小放大多少。",
                "names": "缩放"
            },
            "flipx": {
                "doc": "我是否应该在x轴上镜像, 除非被不同的 @Pose 覆盖。",
                "names": "水平翻转"
            },
            "flipy": {
                "doc": "我是否应该在y轴上镜像, 除非被不同的 @Pose 覆盖。",
                "names": "垂直翻转"
            },
            "entering": {
                "doc": "上台时我应该做的 @Pose 或 @Sequence",
                "names": "进入"
            },
            "resting": {
                "doc": "我应该在进入舞台之后、退出之前以及我的@Place没有改变的情况下执行 @Pose 或 @Sequence。 如果你不给我，我将使用默认值。",
                "names": "休息"
            },
            "moving": {
                "doc": "在舞台上移动位置时我应该执行的 @Pose 或 @Sequence，而不是我的默认设置。",
                "names": "移动"
            },
            "exiting": {
                "doc": "@Pose 或 @Sequence应该在退出阶段之前执行。",
                "names": "退出"
            },
            "duration": {
                "doc": "移动到舞台上不同位置时适用的持续时间。",
                "names": ["⏳", "持续时间"]
            },
            "style": {
                "doc": "移动到舞台上不同位置时使用的动画风格。",
                "names": "风格"
            },
            "defaultDescription": "$~$3[$3 韵律 |]短语 $1 $2[命名 $2|] $4[$4|] $5"
        },
        "Arrangement": {
            "doc": "我是Verse中各种排列方式的灵感, 包括@Row、@Stack、@Grid和@Free。我与@Group密切合作，",
            "names": ["⠿", "排列"]
        },
        "Row": {
            "doc": "我是@Row, 一个水平的@Arrangement,包含@Output，中间可以添加可选的填充。你见过我的孪生兄弟@Stack吗？",
            "names": ["➡", "行"],
            "description": "$1个短语和组的行",
            "alignment": {
                "doc": "是否在每列上的起始、中间或末尾对齐文本。",
                "names": "对齐"
            },
            "padding": {
                "doc": "在输出之间放置的填充量。",
                "names": "填充"
            }
        },
        "Stack": {
            "doc": "我是@Stack，一个垂直的@Arrangement，包含@Output，中间可以添加可选的填充。你见过我的孪生兄弟@Row吗？",
            "names": ["⬇", "堆叠"],
            "description": "$1个短语和组的堆叠",
            "alignment": {
                "doc": "是否在每行上的起始、中间或末尾对齐文本。",
                "names": "对齐"
            },
            "padding": {
                "doc": "在输出之间放置的填充量。",
                "names": "填充"
            }
        },
        "Grid": {
            "doc": "我是@Output的网格。告诉我行数和列数，我将制作一个整齐的排列，可选的填充和单元格大小。",
            "names": ["▦", "网格"],
            "description": "$1行$2列的网格",
            "rows": {
                "doc": "网格中的行数。",
                "names": "行数"
            },
            "columns": {
                "doc": "网格中的列数。",
                "names": "列数"
            },
            "padding": {
                "doc": "在单元格之间放置的填充量。",
                "names": "填充"
            },
            "cellWidth": {
                "doc": "单元格应有多宽。",
                "names": "单元格宽度"
            },
            "cellHeight": {
                "doc": "单元格应有多高。",
                "names": "单元格高度"
            }
        },
        "Free": {
            "doc": [
                "我随便怎么样。随便坐在哪里都行。只要坐在某个地方！确保你给我所有的@Output都有一个@Place，否则它们就不知道该去哪里。",
                "哦，记住，你给每个@Output的@Place都是相对于@Group的@Place！所以如果你想知道为什么事情没有出现在你期望的地方，尝试给@Group也设置一个地方。"
            ],
            "names": ["自由"],
            "description": "自由形式的$1输出"
        },
        "Shape": {
            "doc": "我是所有形状的灵感。我用于告诉@Stage应该是什么形状。",
            "names": ["⬟", "形状"],
            "form": {
                "doc": "我是要显示的形状种类。每种形状需要不同的信息来定义其排列。",
                "names": "形状"
            },
            "name": {
                "doc": "我是你可以使用的名称，用于动画和@Collision。例如，如果代表地面，你可能想叫我'地面'。",
                "names": "名称"
            },
            "selectable": {
                "doc": "是否可以作为@Choice的一部分选择。",
                "names": "可选择性"
            },
            "color": {
                "doc": "我的边框颜色。",
                "names": "颜色"
            },
            "background": {
                "doc": "我的背景颜色。",
                "names": "背景"
            },
            "opacity": {
                "doc": "我应该有多不透明。",
                "names": "不透明度"
            },
            "offset": {
                "doc": "我应该距离我的位置多远出现，同时保持在原地。",
                "names": "偏移"
            },
            "rotation": {
                "doc": "我应该旋转多少。这会影响@Collision。",
                "names": "旋转"
            },
            "scale": {
                "doc": "我应该放大多少，而不改变我的实际大小。",
                "names": "缩放"
            },
            "flipx": {
                "doc": "是否在x轴上镜像我。",
                "names": "水平翻转"
            },
            "flipy": {
                "doc": "是否在y轴上镜像我。",
                "names": "垂直翻转"
            },
            "entering": {
                "doc": "我进入@Stage时应该执行的@Pose或@Sequence。",
                "names": "进入时"
            },
            "resting": {
                "doc": "我进入并且不移动时应该执行的@Pose或@Sequence。",
                "names": "静止时"
            },
            "moving": {
                "doc": "我移动位置时应该执行的@Pose或@Sequence。",
                "names": "移动时"
            },
            "exiting": {
                "doc": "我离开@Stage时应该执行的@Pose或@Sequence。",
                "names": "离开时"
            },
            "duration": {
                "doc": "如果是单个@Pose，我的动画应该持续多长时间。",
                "names": "持续时间"
            },
            "style": {
                "doc": "我应该使用的动画样式。",
                "names": "样式"
            },
            "description": {
                "doc": ["$~针对无法看到视觉输出的观众使用的描述。"],
                "names": "$~描述"
            }
        },
        "Form": {
            "doc": "我是一种图像形式，像@Rectangle 或@Circle。",
            "names": ["形式"]
        },
        "Rectangle": {
            "doc": "我是一个矩形，用于使@Stage具有你选择的大小的边界。",
            "names": ["矩形"],
            "left": {
                "doc": "x轴上的舞台左边缘",
                "names": "左边"
            },
            "top": {
                "doc": "y轴上的舞台顶部",
                "names": "顶部"
            },
            "right": {
                "doc": "x轴上的舞台右边缘",
                "names": "右边"
            },
            "bottom": {
                "doc": "y轴上的舞台底部",
                "names": "底部"
            },
            "z": {
                "doc": "矩形的深度位置。",
                "names": "z"
            }
        },
        "Circle": {
            "doc": "我是一个圆圈，用于在@Stage 上制作形状。",
            "names": ["圆圈"],
            "radius": {
                "doc": "圆的半径",
                "names": "半径"
            },
            "x": {
                "doc": "圆的水平中心。",
                "names": "X"
            },
            "y": {
                "doc": "圆的垂直中心。",
                "names": "是"
            },
            "z": {
                "doc": "圆的深度位置。",
                "names": "是"
            }
        },
        "Polygon": {
            "doc": "我是一个“规则”多边形，边长和角相等，可用于在@Stage 上制作形状。",
            "names": ["多边形"],
            "radius": {
                "doc": "多边形的半径",
                "names": "半径"
            },
            "sides": {
                "doc": "多边形的边数",
                "names": "双方"
            },
            "x": {
                "doc": "多边形的水平中心。",
                "names": "X"
            },
            "y": {
                "doc": "多边形的垂直中心。",
                "names": "是"
            },
            "z": {
                "doc": "多边形的深度位置。",
                "names": "是"
            }
        },
        "Pose": {
            "doc": [
                "想象一下，某某一下子摆了个最精彩的姿势，一停顿，每个人的目光都聚集在了他身上。所说的姿势就是我，我为 @Output 勾勒姿势，而他们的动作都是以我组成的。",
                "别小瞧我！自个看一看我的许多的$input，你会创造出什么样的姿势呢？"
            ],
            "names": ["🤪", "姿势"],
            "style": {
                "doc": "进入这个姿势时应该用的动画风格",
                "names": "风格"
            },
            "color": {
                "doc": "@Output 在这姿势时应该用的 @Color，代替默认值",
                "names": "颜色"
            },
            "opacity": {
                "doc": "@Output 的不透明度，介于 \\0\\ 和 \\1\\ 之间，代替默认值。有助于淡入和淡出。",
                "names": "不透明度"
            },
            "offset": {
                "doc": "一个 @Place 指示它应该与 @Output 位置偏移多少，代替默认值。有助于扭扭动动。",
                "names": "偏移"
            },
            "rotation": {
                "doc": "@Output 应该旋转多少，代替默认值。",
                "names": "旋转"
            },
            "scale": {
                "doc": "@Output 应该相对于原始大小放大多少，代替默认值。",
                "names": "缩放"
            },
            "flipx": {
                "doc": "@Output 是否应该x轴对称，代替默认值。",
                "names": "水平翻转"
            },
            "flipy": {
                "doc": "@Output 是否应该y轴对称，代替默认值。",
                "names": "垂直翻转"
            },
            "description": "$1[transparent $1|] $2[rotated $2 degrees|] $3[scaled $3|] $4[flipped horizontally|] $5[flipped vertically|]"
        },
        "Color": {
            "doc": [
                "我是一种可见的颜色，由三个维度构成。",
                "一下是一些色轮上常见的颜色，用中等亮度和高色度显示。",
                "\\Color(50% 100 0°)\\",
                "\\Color(50% 100 30°)\\",
                "\\Color(50% 100 60°)\\",
                "\\Color(50% 100 90°)\\",
                "\\Color(50% 100 120°)\\",
                "\\Color(50% 100 150°)\\",
                "\\Color(50% 100 180°)\\",
                "\\Color(50% 100 210°)\\",
                "\\Color(50% 100 240°)\\",
                "\\Color(50% 100 270°)\\",
                "\\Color(50% 100 300°)\\",
                "\\Color(50% 100 330°)\\"
            ],
            "names": ["🌈", "颜色"],
            "lightness": {
                "doc": "我应该有多亮，从 \\0\\ 到 \\1\\。\\0\\ 是黑色， \\0.5\\ 灰色，\\1\\ 白色。",
                "names": ["明度", " l"]
            },
            "chroma": {
                "doc": "我应该有多少色彩，从 \\0\\ 到 \\∞\\。没有色彩表示是灰色，数字越大色彩就越足。",
                "names": ["色度", "c"]
            },
            "hue": {
                "doc": "我应该是色轮上的什么颜色，从品红色 \\0\\，红色 \\30\\，绿色 \\120\\，到蓝色 \\270\\。",
                "names": ["色调", "h"]
            }
        },
        "Sequence": {
            "doc": [
                "哦。哦。哇！导演，你今天精神看起来棒极了！你想跟我一起跳舞吗？这很容易。",
                "你只要给我一个 @Map。每个$key表示我们跳的过程完成了百分之多少，每个$key的值都应该有个 @Pose。",
                "有好多不同的方式用这个功能制作动画。给你一个比较简单的例子：",
                "\\Phrase('hi' resting:Sequence({0%: Pose(rotation: 360°) 100%: Pose(rotation: 0°)})\\",
                "这个意思是，/开头是 0%，以 360 倾斜度开始。最后以 0 倾斜度结束/。因为我把 @Phrase 的休息姿势设成了这个，我们就会永远转圈子！",
                "现在你自己试一试，用其他的输入创造一些独特的舞蹈。"
            ],
            "names": ["💃", "排序"],
            "poses": {
                "doc": "一个由百分比组成的@Map介于 0% 到 100%，每个百分比都分配一个@Pose。你不用提供每个百分比，我会基于你给我的百分比无缝隙的把@Output从一个移到下一个。",
                "names": "姿势"
            },
            "duration": {
                "doc": "我应该跳这个舞跳多长时间啊？如果要重复的跳，我不会延长时间，我只会跳的更快。",
                "names": ["⏳", "时长"]
            },
            "style": {
                "doc": "我跳舞时应该用的风格。",
                "names": "风格"
            },
            "count": {
                "doc": "该序列在完成之前应该重复多少遍。助于我上$stage、在$stage上移动或退出$stage。但在休息序列时，它就会被忽略，因为我可以永远休息。",
                "names": "计数"
            }
        },
        "Place": {
            "doc": "我是 @Stage 上的一个定位。我的所有输入都是可有可无的，因为我的默认值就是定位在中央。",
            "names": ["📍", "位置"],
            "x": {
                "doc": "x 轴上的位子",
                "names": "x"
            },
            "y": {
                "doc": "y 轴上的位子",
                "names": "y"
            },
            "z": {
                "doc": "z 轴上的位子",
                "names": "z"
            },
            "rotation": {
                "doc": "在此位置的旋转",
                "names": ["📐", "旋转"]
            }
        },
        "Velocity": {
            "doc": "我是@Stage上的一个位置。我的所有输入都是可选的，因为默认情况下我位于中心。",
            "names": ["💨", "速度"],
            "x": {
                "doc": "每秒在x轴上移动多少米。",
                "names": "x"
            },
            "y": {
                "doc": "每秒在y轴上移动多少米。",
                "names": "y"
            },
            "angle": {
                "doc": "每秒旋转多少度",
                "names": ["角度", "°"]
            }
        },
        "Matter": {
            "doc": "我是输出的物理属性，影响我与舞台上其他输出的互动。",
            "names": ["⚛️", "物质"],
            "mass": {
                "doc": "质量，以千克为单位",
                "names": "质量"
            },
            "bounciness": {
                "doc": "碰撞时保留多少能量，0表示没有，1表示全部。",
                "names": "弹性"
            },
            "friction": {
                "doc": "保持滑动的程度；0表示没有，1表示永远。",
                "names": "摩擦"
            },
            "roundedness": {
                "doc": "圆角输出的程度；0表示没有，1表示其尺寸的100%，使尺寸成圆形。",
                "names": "圆角"
            },
            "text": {
                "doc": "它是否可以与其他输出发生碰撞。",
                "names": "文本"
            },
            "shapes": {
                "doc": "它是否可以与其他形状发生碰撞。",
                "names": "地面"
            }
        },
        "Aura": {
            "doc": [
                "我是光晕. 我让 @Phrase 发光，就像这样：",
                "\\Phrase(\n\t'I am GLOWING!' \n\taura: Aura(Color(50% 100 118°) 0.1m 0m 0.1m\n)\\"
            ],
            "names": ["🔮", "光晕"],
            "color": {
                "doc": "@Aura 的 @Color",
                "names": "颜色"
            },
            "blur": {
                "doc": "@Aura 的模糊程度 \\0m\\ 表示一点都不模糊.",
                "names": "模糊度"
            },
            "offsetX": {
                "doc": "我应该在左右偏移多少的地方出现。 \\0m\\. 代表直接在下面",
                "names": "水平偏移量"
            },
            "offsetY": {
                "doc": "我应该在上下偏移多少的地方出现。  \\0m\\. 代表直接在下面 ",
                "names": "垂直偏移量"
            }
        },
        "Stage": {
            "doc": [
                "嗨。舞台在这里。告诉我要展示什么，我会展示出来。",
                "\\Stage([Phrase('stufffffff')])\\",
                "如果你愿意，给我一个背景@Color，我会相应地照亮舞台。",
                "\\Stage([Phrase('stufffffff')] Color(0% 0 0°) color: Color(100% 0 0°))\\",
                "你也可以给我一个边框，我会进行裁剪。",
                "\\Stage([Phrase('stufffffff')] Color(0% 0 0°) Rectangle(-1m -1m 1m 1m) color: Color(100% 0 0°))\\"
            ],
            "names": ["🎭", "舞台"],
            "content": {
                "doc": "要在舞台上展示的@Output列表。",
                "names": "画框"
            },
            "frame": {
                "doc": "用于围绕舞台放置的形状和大小，隐藏其外部的一切。",
                "names": "边框"
            },
            "size": {
                "doc": "类似于@Group/size",
                "names": "大小"
            },
            "face": {
                "doc": "类似于@Group/face",
                "names": "朝向"
            },
            "place": {
                "doc": "如果我是一台相机，这就是我正在看向的地方。",
                "names": "位置"
            },
            "name": {
                "doc": ["与@Phrase/name!相同"],
                "names": "名称"
            },
            "description": {
                "doc": ["$~针对无法看到视觉输出的观众使用的描述。"],
                "names": "$~描述"
            },
            "selectable": {
                "doc": "与@Phrase/selectable!相同",
                "names": "可选择性"
            },
            "color": {
                "doc": "与@Group/color相同",
                "names": "颜色"
            },
            "background": {
                "doc": "与@Group/background相同",
                "names": "背景"
            },
            "opacity": {
                "doc": "与@Group/opacity相同",
                "names": "不透明度"
            },
            "offset": {
                "doc": "与@Group/offset相同",
                "names": "偏移"
            },
            "rotation": {
                "doc": "与@Group/rotation相同",
                "names": ["📐", "旋转"]
            },
            "scale": {
                "doc": "与@Group/scale相同",
                "names": "缩放"
            },
            "flipx": {
                "doc": "与@Group/flipx相同",
                "names": "水平翻转"
            },
            "flipy": {
                "doc": "与@Group/flipy相同",
                "names": "垂直翻转"
            },
            "entering": {
                "doc": "与@Group/entering相同",
                "names": "进入时"
            },
            "resting": {
                "doc": "与@Group/resting!相同",
                "names": "休息时"
            },
            "moving": {
                "doc": "与@Group/moving!相同",
                "names": "移动时"
            },
            "exiting": {
                "doc": "与@Group/exiting!相同",
                "names": "离开时"
            },
            "duration": {
                "doc": "与@Phrase/duration!相同",
                "names": ["⏳", "持续时间"]
            },
            "style": {
                "doc": "我应该使用的动画样式。",
                "names": "样式"
            },
            "gravity": {
                "doc": "应用于其位置在@Motion中的输出的重力。",
                "names": "重力"
            },
            "defaultDescription": "$~$1阶段$2[$2 |]输出$3[带有框架$3|]$4"
        },
        "Easing": {
            "straight": "直线",
            "cautious": "谨慎",
            "pokey": "慢吞吞",
            "zippy": "迅速"
        },
        "sequence": {
            "sway": {
                "doc": "我创建一个@Sequence, 围绕@Output's的中心来回摆动。",
                "names": ["摇摆"],
                "angle": {
                    "doc": "在摇摆中倾斜的角度。",
                    "names": ["角度"]
                }
            },
            "bounce": {
                "doc": "我创建一个@Sequence, 使@Output以指定的高度弹跳。",
                "names": ["弹跳"],
                "height": {
                    "doc": "弹跳的高度。",
                    "names": ["高度"]
                }
            },
            "spin": {
                "doc": "我创建一个@Sequence, 使@Output围绕其中心旋转。",
                "names": ["旋转"]
            },
            "fadein": {
                "doc": "我创建一个@Sequence, 将@Output从不可见状态淡入可见状态。",
                "names": ["淡入"]
            },
            "fadeout": {
                "doc": "我创建了一个 @Sequence，它使 @Output 从可见逐渐变为不可见。在激动人心的 @Sequence 中尝试我的方法吧！",
                "names": ["消退"]
            },
            "popup": {
                "doc": "我创建一个@Sequence, 使@Output迅速放大然后缩小到正常尺寸。",
                "names": ["弹出"]
            },
            "shake": {
                "doc": "我创建一个@Sequence, 使@Output看起来像是害怕的。",
                "names": ["抖动"]
            }
        },
        "Source": {
            "names": "来源",
            "doc": [
                "你知道项目可以有多个 @Source 文件吗？我让你根据项目的逻辑创建一个 @Source。如果你想在项目的不同评估之间保存一些数据，这确实很有帮助。",
                "例如，假设你想制作一个简单的计数器，每次按下鼠标按钮时，计数器都会加一。你可以用它来记住你做了多少次某事。",
                "\\↓ 计数\n[\n短语（`\\count\\ 次！`）\n源（'count' 计数 … ∆ 按钮（） … 计数 + 1 ）\n]\\",
                "尝试复制它，创建一个名为 /count/ 的新 @Source，并在其中输入 0，从 0 开始计数。这个小项目将获取 /count/ 源中的值，并且每次按下鼠标按钮时，都会编辑 /count/ @Source 作为当前 /count/ 值加 /1/。"
            ],
            "name": {
                "names": "姓名",
                "doc": "要创建或更新的源文件的名称。"
            },
            "value": {
                "names": "价值",
                "doc": "应创建或更新源文件的数据值。"
            },
            "DynamicEditLimitException": {
                "description": "动态源编辑限制",
                "explanation": "该项目将数据保存到 @Source 文件的次数过多，速度过快。确保它只在响应输入时更新 @Source，并且速度不要太快。"
            },
            "ReadOnlyEditException": {
                "description": "只读源编辑",
                "explanation": "此项目会记住数据，但你无权编辑它。如果你想尝试，请复制它。"
            },
            "EmptySourceNameException": {
                "description": "空源名称",
                "explanation": "给定的@Source 有一个空名称，因此我们无法保存它。"
            },
            "ProjectSizeLimitException": {
                "description": "项目规模限制",
                "explanation": "该项目的文本太多，因此我们无法保存。"
            }
        }
    },
    "ui": {
        "font": {
            "app": "Noto Sans Simplified Chinese",
            "code": "Noto Sans Mono"
        },
        "phrases": {
            "welcome": "你好"
        },
        "widget": {
            "confirm": {
                "cancel": "取消"
            },
            "dialog": {
                "close": "关闭"
            },
            "loading": {
                "message": "正在加载字体和文本，请稍候！"
            },
            "home": "去首页",
            "table": {
                "cell": {
                    "description": "$~编辑此单元格",
                    "placeholder": "$~价值"
                },
                "addcolumn": "$~在此列之前添加一列",
                "removecolumn": "$~移除此列"
            }
        },
        "tile": {
            "toggle": {
                "fullscreen": {
                    "on": "退出全屏",
                    "off": "扩展到全屏"
                },
                "show": {
                    "on": "隐藏",
                    "off": "显示"
                }
            },
            "label": {
                "output": "舞台",
                "palette": "调色板",
                "docs": "指南",
                "source": "源文件",
                "collaborate": "$~合作"
            },
            "button": {
                "collapse": "折叠窗口"
            }
        },
        "project": {
            "error": {
                "unknown": "该演出不存在或未公开",
                "translate": "翻译你的项目时出现问题。",
                "tile": "$~糟糕，出现错误。",
                "reset": "$~尝试重置..."
            },
            "button": {
                "removeCollaborator": "移除合作者",
                "copy": "将项目复制为文本",
                "addSource": "创建新的源",
                "duplicate": "复制这个项目",
                "revert": "恢复到原始代码",
                "focusOutput": "聚焦舞台上的键盘乐器",
                "focusSource": "聚焦到下一个源",
                "focusDocs": "聚焦文档",
                "focusPalette": "聚焦调色板",
                "focusCycle": "聚焦到下一个瓷砖",
                "unsaved": "显示保存错误",
                "translate": "编辑该项目的语言并将其翻译成其他语言。",
                "primary": "设置为该项目的主要语言环境",
                "share": {
                    "tip": "$~显示项目共享选项",
                    "label": "$~分享"
                },
                "history": {
                    "on": "$~显示最近的项目代码",
                    "redo": "$~显示当前项目代码"
                }
            },
            "field": {
                "name": {
                    "description": "编辑项目名称",
                    "placeholder": "名称"
                }
            },
            "help": "显示键盘快捷键",
            "collapsed": "你的所有窗口都已折叠！你可以在下面的工具栏中找到它们",
            "save": {
                "projectsNotSavedLocally": "你的浏览器中保存项目时出现问题。",
                "projectsCannotNotSaveLocally": "你的浏览器不支持保存项目。",
                "projectContainedPII": "为了保护你的隐私，包含可能个人身份信息的项目未在线保存。请检查该项目以查看该信息是否具有身份识别性。",
                "projectsNotLoadingOnline": "无法加载在线项目。",
                "projectNotSavedOnline": "无法在线保存项目。",
                "settingsUnsaved": "无法在线保存设置。"
            },
            "dialog": {
                "unsaved": "未保存",
                "translate": {
                    "header": "语言",
                    "explanation": [
                        "这些是你的项目正在使用的语言。",
                        "如果想翻译你的项目，请选择一种主要源语言，然后选择一种新语言。",
                        "并非所有语言都受支持，并且翻译可能不完美，请见谅！/"
                    ]
                }
            },
            "subheader": {
                "source": "来源",
                "destination": "目的地"
            }
        },
        "gallery": {
            "untitled": "未命名",
            "undescribed": "未说明",
            "subheader": {
                "curators": {
                    "header": "策展人",
                    "explanation": "管理此画廊的创作者。"
                },
                "creators": {
                    "header": "创作者",
                    "explanation": "为此画廊做出贡献的创作者。"
                },
                "delete": {
                    "header": "删除",
                    "explanation": "删除该图库不会删除其项目。图库将被永久删除。"
                },
                "classes": {
                    "header": "$~课程",
                    "explanation": "$~与此画廊相关的类别。"
                }
            },
            "confirm": {
                "delete": {
                    "description": "删除画廊",
                    "prompt": "删除"
                },
                "remove": {
                    "description": "从画廊中删除项目",
                    "prompt": "删除"
                }
            },
            "error": {
                "unknown": "此画廊不存在或不是公开的。"
            },
            "field": {
                "name": {
                    "description": "画廊名称",
                    "placeholder": "名称"
                },
                "description": {
                    "description": "画廊描述",
                    "placeholder": "描述你的画廊。它的主题、目标或社区是什么？"
                }
            }
        },
        "source": {
            "label": "程序编辑器",
            "empty": [
                "让我们开始吧！你可以……",
                "• 打开 📕 并将 🖱️ 拖到此程序中。",
                "• 输入 $1 并从菜单中选择我们。",
                "• 如果你熟悉我们，可以开始输入。",
                "• 浏览画廊以获取灵感。",
                "如果遇到困难，请参阅 <learn more@://learn>。"
            ],
            "overwritten": "收到了更新版本！",
            "confirm": {
                "delete": {
                    "description": "删除此$source",
                    "prompt": "删除"
                }
            },
            "toggle": {
                "blocks": {
                    "on": "隐藏块背景",
                    "off": "显示块背景"
                },
                "glyphs": {
                    "on": "折叠匹配的字形",
                    "off": "展开匹配的字形"
                }
            },
            "button": {
                "selectOutput": "在舞台上显示此输出",
                "expandSequence": "展开此折叠的代码"
            },
            "field": {
                "name": {
                    "description": "编辑源名称",
                    "placeholder": "名称"
                }
            },
            "menu": {
                "label": "自动完成菜单",
                "show": "显示自动完成菜单",
                "back": "退出子菜单"
            },
            "cursor": {
                "priorLine": "将光标移至前一行",
                "nextLine": "将光标移至后一行",
                "priorInline": "将光标移到前一个位置",
                "nextInline": "将光标移到后一个位置",
                "lineStart": "将光标移到行的开头",
                "lineEnd": "将光标移到行的末尾",
                "sourceStart": "将光标移至源文件的开头",
                "sourceEnd": "将光标移至源文件的末尾",
                "priorNode": "选择前一个邻居",
                "nextNode": "选择后一个邻居",
                "parent": "选择容器",
                "selectAll": "选择程序",
                "incrementLiteral": "增加数字、文本或布尔值",
                "decrementLiteral": "减少数字、文本或布尔值",
                "insertSymbol": "插入$1",
                "insertTab": "插入 tab",
                "insertTrue": "插入 true",
                "insertFalse": "插入 false",
                "insertNone": "插入无符号",
                "insertNotEqual": "插入不等号",
                "insertProduct": "插入乘号",
                "insertQuotient": "插入除号",
                "insertDegree": "插入度符号",
                "insertFunction": "插入函数",
                "insertLessOrEqual": "插入小于或等于",
                "insertGreaterOrEqual": "插入大于或等于",
                "insertType": "插入类型符号",
                "insertStream": "插入流符号",
                "insertChange": "插入更改符号",
                "insertConvert": "插入转换符号",
                "insertPrevious": "插入前一个符号",
                "insertTable": "插入表符号",
                "insertTableClose": "插入表格关闭符号",
                "insertBorrow": "插入借阅",
                "insertShare": "插入分享",
                "insertLine": "插入换行符",
                "backspace": "删除选择或前一个字符",
                "delete": "删除",
                "cut": "剪切选择",
                "copy": "复制选择",
                "paste": "粘贴键盘内容",
                "parenthesize": "括号化选择",
                "enumerate": "枚举选择",
                "type": "键入字符",
                "undo": "类型字符",
                "redo": "撤销上次编辑",
                "search": "查找要插入的特殊字符",
                "tidy": "整理间距",
                "elide": "切换省略",
                "insertDocs": "$~插入解释符号"
            }
        },
        "annotations": {
            "label": "冲突",
            "cursor": "这是 *$1*$2[ 并且它们的类型是 $2|]。$3[ 它们在 *$3* 里面。|]",
            "cursorParent": "它们位于 *$1*$2[ 类型为 $2|] 里面。",
            "learn": "/了解更多/",
            "evaluating": "好玩哦，大家来评价一下吧！",
            "space": "这就是太空！谁知道没有什么东西能表达这么多？",
            "button": {
                "resolution": "解决这一冲突"
            }
        },
        "output": {
            "label": "程序输出",
            "toggle": {
                "grid": {
                    "on": "隐藏网格线",
                    "off": "显示网格线"
                },
                "fit": {
                    "on": "手动控制缩放",
                    "off": "适应内容缩放"
                },
                "paint": {
                    "on": "场所输出",
                    "off": "放置输出"
                }
            },
            "field": {
                "key": {
                    "description": "聆听按键",
                    "placeholder": "消息"
                }
            },
            "button": {
                "submit": "提交此聊天消息"
            },
            "options": {
                "locale": "$~选择输出语言"
            }
        },
        "timeline": {
            "label": "时间轴",
            "slider": "时间轴滑块",
            "button": {
                "play": "对程序进行实时输入响应的评估",
                "pause": "暂停程序，允许前进和后退",
                "backStep": "后退一步",
                "backNode": "后退到上一个节点评估",
                "backInput": "后退一个输入",
                "out": "退出此功能",
                "forwardStep": "前进一步",
                "forwardNode": "前进到下一个节点评估",
                "forwardInput": "前进到下一个流输入",
                "present": "到现在",
                "start": "返回开头",
                "reset": "重新启动性能"
            }
        },
        "docs": {
            "label": "文档浏览器",
            "link": "在文档中显示概念 $1",
            "learn": "了解更多……",
            "nodoc": "我是谁？我是什么？我的目的是什么？",
            "button": {
                "home": "返回主页",
                "back": "返回上一页"
            },
            "field": {
                "search": "使用关键词搜索概念"
            },
            "header": {
                "inputs": "投入",
                "interfaces": "接口",
                "properties": "属性",
                "functions": "函数",
                "conversions": "转换"
            }
        },
        "dialog": {
            "share": {
                "header": "分享",
                "explanation": "控制谁可以编辑和查看此项目。",
                "subheader": {
                    "gallery": {
                        "header": "画廊",
                        "explanation": "将此项目添加到画廊中，与其他创作者并列，或在你的 <projects@://projects> 页面上创建一个画廊。如果你将项目添加到公开画廊，你的项目将变为公开。"
                    },
                    "public": {
                        "header": "公开/私有",
                        "explanation": "公开项目和画廊可以被世界上任何人看到。通过将项目或画廊设为公开，你承诺："
                    },
                    "pii": {
                        "header": "个人信息",
                        "explanation": "公开分享个人身份信息 (PII) 可能会使创作者面临风险，因此我们会检测可能的 PII，并警告创作者删除敏感数据或将其标记为非敏感数据。\n\n以下是此项目中你已标记为非敏感的可能 PII 列表。你可以点击旁边的按钮将其再次标记为敏感，但这样做意味着你的项目将不再在线保存。"
                    }
                },
                "field": {
                    "emailOrUsername": {
                        "placeholder": "電子郵件或使用者名稱",
                        "description": "你想要授予編輯權限的人員的電子郵件或使用者名"
                    }
                },
                "mode": {
                    "public": {
                        "label": "可见性",
                        "modes": ["私有", "公开"]
                    }
                },
                "error": {
                    "unknown": "我们不知道这封邮件的创建者是谁。",
                    "anonymous": "你必須登入才能共享。"
                },
                "button": {
                    "submit": "通过此电子邮件地址分享项目",
                    "sensitive": {
                        "tip": "再次将此文本标记为敏感文本",
                        "label": "重要的"
                    }
                },
                "options": {
                    "gallery": "画廊"
                }
            },
            "settings": {
                "header": "设置",
                "explanation": "更改布局、设备和主题设置。",
                "button": {
                    "show": "显示设置对话框"
                },
                "mode": {
                    "layout": {
                        "label": "布局",
                        "modes": ["自动", "水平", "垂直", "自由"]
                    },
                    "animate": {
                        "label": "动画",
                        "modes": [
                            "关闭",
                            "开启",
                            "半速",
                            "三分之一速度",
                            "四分之一速度"
                        ]
                    },
                    "dark": {
                        "label": "主题",
                        "modes": ["浅色", "深色", "使用设备设置"]
                    },
                    "space": {
                        "label": " 空格指示器",
                        "modes": [" 开启", " 关闭"]
                    },
                    "writing": {
                        "label": "写作布局",
                        "modes": [
                            "水平，从左到右",
                            "垂直，从右到左",
                            "垂直，从左到右"
                        ]
                    },
                    "localized": {
                        "label": "代码本地化",
                        "modes": [
                            "不本地化代码",
                            "可用时本地化代码",
                            "本地化代码但更喜欢符号"
                        ]
                    },
                    "lines": {
                        "label": "$~行号",
                        "modes": [
                            "$~在文本模式下显示行号",
                            "$~在文本模式下不显示行号"
                        ]
                    }
                },
                "options": {
                    "mic": "选定的麦克风",
                    "camera": "选定的相机",
                    "face": "$~字体"
                }
            },
            "locale": {
                "header": "语言",
                "explanation": "选择你的语言和地区",
                "subheader": {
                    "selected": "选择",
                    "supported": "可用的",
                    "coming": "即将上线",
                    "help": "帮我们翻译……"
                },
                "button": {
                    "show": "切换语言",
                    "replace": "替换这个语言",
                    "add": "添加语言",
                    "remove": "删除语言"
                }
            },
            "help": {
                "header": "快捷键",
                "explanation": "使用这些键盘命令进行更高效的编辑。",
                "subheader": {
                    "moveCursor": "移动",
                    "editCode": "编辑",
                    "insertCode": "插入",
                    "debug": "调试"
                }
            }
        },
        "palette": {
            "label": "调色板",
            "labels": {
                "mixed": "混合的",
                "computed": "计算的",
                "default": "默认",
                "inherited": "继任",
                "notSequence": "不是一个序列",
                "notContent": "不是内容列表",
                "format": "格式",
                "weight": "字体粗细",
                "light": "细体",
                "normal": "正常",
                "bold": "加粗",
                "extra": "超级粗",
                "italic": "斜体",
                "underline": "下划线"
            },
            "button": {
                "revert": "回复默认设置",
                "set": "编辑此属性",
                "addPhrase": "在此之后添加一个短语",
                "addGroup": "在此之后添加一个群组",
                "addShape": "在此之后添加一个形状",
                "addMotion": "将位置设置为运动流",
                "addPlacement": "将位置设置为放置流",
                "remove": "移除这个内容",
                "up": "将此内容上移",
                "down": "将此内容下移",
                "edit": "编辑这个内容",
                "sequence": "转换为序列",
                "createPhrase": "创建一个短语，显示现有值为文本",
                "createGroup": "创建一个群组，将任何现有的短语包括进来",
                "createStage": "创建一个舞台，将任何现有的群组或短语囊括起来"
            },
            "prompt": {
                "offerPhrase": "你创造了一个漂亮的值！我应该在 @Stage 上展示吗？",
                "offerGroup": "你做了一个很棒的 @Phrase。你想将它们组合到 @Group 中，以便进行排列吗？",
                "offerStage": "非常好的 @Program。将我添加到控制灯光、颜色和帧数的项目中。",
                "pauseToEdit": "如果你 ⏸️ 舞台，你可以选择 💬、🔳 或 🎭 来编辑！",
                "editing": "编辑我！"
            },
            "field": {
                "coordinate": "编辑坐标",
                "text": "编辑文本"
            },
            "sequence": {
                "button": {
                    "add": "添加姿势",
                    "remove": "移除姿势",
                    "up": "姿势往上移",
                    "down": "姿势往下移"
                },
                "field": {
                    "percent": "编辑百分比"
                }
            }
        },
        "save": {
            "saving": "保存",
            "saved": "在线保存",
            "local": "本地保存",
            "unsaved": "未保存"
        },
        "page": {
            "unknown": {
                "header": "哎呀！",
                "message": "这是什么地方？我们能回家吗？"
            },
            "landing": {
                "value": "与我们一起用文字、符号、表情符号和代码创建互动故事！",
                "description": [
                    "Wordplay 是一种编程语言，它使你能够：",
                    "• 以有趣的方式为文字和表情符号制作动画 🤪︎",
                    "• 使用时间 🕦︎、声音 🎤︎、网站 🔗︎ 和物理 🌎︎",
                    "• 与朋友、群组或任何人分享 🤝︎",
                    "• 使用任何世界语言编写代码 🌐︎",
                    "• 使用鼠标 🖱︎️、触摸 👆︎ 和键盘 ⌨︎️ 编辑",
                    "• 向前调试 ⏩︎ 和向后调试 ⏪︎",
                    "• 使用屏幕 🖥︎️ 和屏幕阅读器查看 🔊",
                    "华盛顿大学永久免费↗。"
                ],
                "beta": [
                    "Wordplay 处于*测试阶段*。这意味着功能可能会更改或无法按预期工作，并且本地化可能不完整。"
                ],
                "link": {
                    "about": "这个地方为什么存在？",
                    "learn": "通过戏剧化的角色来学习语言",
                    "guide": "搜索和浏览语言参考",
                    "projects": "创建并分享表演",
                    "galleries": "体验他人的表演",
                    "rights": "责任，我们的和你们的",
                    "community": {
                        "label": "社区",
                        "subtitle": "在 Discord 上与我们聊天。"
                    },
                    "contribute": {
                        "label": "贡献",
                        "subtitle": "帮助我们制作 Wordplay。"
                    },
                    "teach": "$~管理学生班级及其项目"
                }
            },
            "learn": {
                "header": "学习",
                "error": "我们无法找到这种语言的教程。",
                "button": {
                    "next": "对话中的下一个暂停",
                    "previous": "对话中的前一个暂停"
                },
                "options": {
                    "lesson": "当前课程"
                }
            },
            "guide": {
                "header": "指导",
                "description": "这是 Wordplay 编程语言每个部分的参考资料。搜索概念或浏览列表以了解更多信息。"
            },
            "projects": {
                "header": "项目",
                "projectprompt": "准备好说些什么了吗？你可以开始创建一个新项目，或者继续在现有项目上工作。如果你遇到困难，继续学习 <learning@://learn>",
                "archiveheader": "已归档",
                "archiveprompt": "这些是你已归档的项目。只有所有者才能永久删除或取消归档它们。归档的项目将在最后编辑后的30天内永久删除。",
                "galleriesheader": "画廊",
                "galleryprompt": "创建和策划画廊，与他人分享项目集合",
                "add": {
                    "header": "新项目",
                    "explanation": "选择一个模板来创建一个新项目。"
                },
                "button": {
                    "newproject": "新项目",
                    "editproject": "编辑这个项目",
                    "viewcode": "查看该项目的代码",
                    "newgallery": "新画廊",
                    "unarchive": "取消归档此项目"
                },
                "confirm": {
                    "archive": {
                        "description": "存档这个表演",
                        "prompt": "存档"
                    },
                    "delete": {
                        "description": "永久删除这个表演",
                        "prompt": "永久删除"
                    }
                },
                "error": {
                    "noaccess": "无法连接网络。",
                    "nogalleryedits": "你必须登录才能创建和修改画廊。",
                    "newgallery": "我们无法创建新的画廊。",
                    "nodeletes": "你必须登录才能删除已归档的项目。",
                    "delete": "哎呀，我们无法删除该项目！"
                }
            },
            "galleries": {
                "header": "画廊",
                "prompt": "这些是其他人创作的表演作品。体验它们，学习它们，或者将它们改编成你自己的作品陈述。",
                "examples": "例子"
            },
            "about": {
                "header": "关于",
                "content": [
                    "你是否曾经感觉到编程只是为那些懂英语、非残疾的西方人，他们痴迷于计算机？",
                    "是的，我们也有同感。",
                    "这不是偶然的。自计算机诞生以来，编程语言一直由同一群人设计和构建——主要是美国和欧洲的白人、身份认同符合自己性别的男性，还有一些出色的女性数学家。他们在后殖民、胜者通吃的时代进行工作，而编程语言是确保他们权力的关键工具。",
                    "无论是有意还是无意，这段历史导致了计算的愿景主要是关于速度、逻辑、利润和统治。",
                    "这是一种不公正。因为计算，无论是好是坏，现在以可见和不可见的方式支撑着日常生活，而有权创建的人大多与它的创造者相似。其余的人类仍然受制于这种力量，因为想象任何不同的事物都需要能够获得，而这被语言障碍、无障碍性障碍、经济障碍和公共教育中的不平等所阻碍。",
                    "*Wordplay*的愿景是与众不同的。这是一个旨在全球范围内支持 /所有/ 世界语言，同时也是 /关于/ 世界语言的编程平台。在这个平台上，每个人都可以创造，无论他们有什么能力，都可以分享任何人都可以体验的互动内容，无论他们有什么能力。这是为年轻人和年轻成年人设计的，他们想要以*富有游戏性*、*艺术性*和*互动性*的方式表达自己。并非为了获取权力，而是为了创建一个多元化的社区，认识到我们美丽的差异所带来的不可思议的力量。",
                    "我们是一个由设计师、教育者和开发者组成的社区，试图将这一愿景变为现实。我们是有色人种，我们是跨性别者，我们是酷儿，我们是残疾人，我们来自世界各地。我们的中心在美国华盛顿州西雅图的<华盛顿大学@https://washington.edu> <信息学院@https://ischool.uw.edu/>，这是一个希望欢迎每个人并试图消除今天仍然存在的殖民主义破坏的地方。创建这种编程语言和平台是这个使命的一部分。",
                    "请查看我们的<里程碑@https://github.com/amyjko/wordplay/milestones>以了解我们正在进行的工作，如果你想帮助，请了解<如何做出贡献@https://github.com/amyjko/wordplay/blob/main/CONTRIBUTING.md>。或者向我们的社区组织者<Amy@https://amyjko.phd>提问。"
                ]
            },
            "login": {
                "header": "登录",
                "anonymous": "匿名",
                "prompt": {
                    "forgot": "*忘记密码？*遗憾的是，由于我们没有收集联系信息，因此我们无法恢复你的帐户。",
                    "enter": "看起来你的登录链接来自不同的浏览器或设备。你可以再次输入你的电子邮件地址，以确保是你吗？",
                    "play": "你已登录，现在我们可以将你的项目保存在线上！想要创建点什么吗？",
                    "tooyoung": "你必须年满13岁或以上才能使用电子邮件登录。",
                    "passwordrule": "密码必须至少为10个字符长；如果你没有使用密码管理器，请选择三个你会记住的长单词。",
                    "passwordreminder": "看起来你正在创建一个账户。请检查你的密码，确保它被安全地保存并输入正确，然后重新提交以创建你的账户。",
                    "changeEmail": "想要更改你的电子邮件地址吗？提交新的电子邮件地址，我们将向旧的地址发送确认信息。",
                    "changePassword": "想要更改你的密码吗？提交一个新密码并重复输入。",
                    "email": "你有仅用于电子邮件的帐户吗？请提交你的电子邮件登录，如果有与之关联的帐户，我们将向你发送一封包含登录链接的电子邮件。为了保护隐私，不支持新的仅用于电子邮件的帐户。",
                    "sent": " 请检查你的电子邮件以获取登录链接。",
                    "logout": "离开共享设备，想要保持项目的私密性吗？注销，我们将从该设备中删除你的项目。它们仍将在线存储。",
                    "success": "帐户已创建！",
                    "confirm": "请检查你的旧电子邮件地址以确认你的新地址。",
                    "delete": "希望我们忘记你在这里做的一切吗？这将无法撤消。",
                    "reallyDelete": "你确定吗？你的账户和设置将立即被删除，你的项目将被安排删除。与你的项目合作的人将立即失去对它们的访问权限。输入你的电子邮件或用户名以确认这是你想要的。",
                    "name": "选择一个表情符号代表你自己。",
                    "login": "$~登录以保存您的项目、协作和共享：",
                    "join": "$~或者，<create an account@://join> 开始。"
                },
                "error": {
                    "expired": "此链接已过期。",
                    "invalid": "此链接无效。",
                    "email": "此电子邮件地址无效。",
                    "failure": "无法登录 :(",
                    "offline": "你似乎处于离线状态。",
                    "unchanged": "我们无法更改你的电子邮件地址，但我们不知道原因。",
                    "delete": "我们无法删除你的帐户，但我们不知道原因。",
                    "wrongPassword": "无效的用户名和密码。可能是密码错误，或者其他人已经使用了这个用户名。",
                    "tooMany": "你尝试登录失败的次数过多。你必须等待一段时间才能重试。"
                },
                "feedback": {
                    "changing": "正在提交新的电子邮件地址……",
                    "deleting": "好的，正在删除你的项目和设置……",
                    "updatedPassword": "你的密碼已更新。",
                    "match": " 這必須與你帳戶的用戶名相符。"
                },
                "field": {
                    "email": {
                        "description": "编辑登录邮件",
                        "placeholder": "邮件"
                    },
                    "username": {
                        "description": "登录用户名，请勿使用可识别个人身份的信息",
                        "placeholder": "用户名"
                    },
                    "password": {
                        "description": "登录密码，至少10个字符",
                        "placeholder": "密码"
                    },
                    "currentPassword": {
                        "description": "你当前的登录密码",
                        "placeholder": "当前密码"
                    },
                    "newPassword": {
                        "description": "你的新密码",
                        "placeholder": "新密码"
                    }
                },
                "button": {
                    "logout": {
                        "tip": "登出你的账号",
                        "label": "登出"
                    },
                    "login": "用这个邮件登录，发送一个登录链接",
                    "updateEmail": "修改邮件",
                    "updatePassword": "提交新密碼",
                    "delete": {
                        "tip": "注销我的账号",
                        "label": "删除我的用户信息……"
                    },
                    "reallyDelete": {
                        "tip": "永远注销账号",
                        "label": "注销！！！"
                    }
                },
                "toggle": {
                    "reveal": {
                        "on": "显示密码",
                        "off": "隐藏密码"
                    }
                },
                "subtitle": "$~保存、协作和共享"
            },
            "join": {
                "header": "加入",
                "prompt": {
                    "create": "$~创建一个帐户来保存您的项目、与他人合作并分享您的工作。",
                    "username": "$~用户名必须至少包含 /5 个字符/，不能是电子邮件，并且不应包含您的姓名或其他身份信息。",
                    "password": "$~密码必须至少为 /10 个字符/。输入两次密码并将其写在安全的地方，例如密码管理器。如果您丢失了帐户，*将无法恢复*，因为我们不会收集联系信息。"
                }
            },
            "rights": {
                "header": "权利",
                "content": [
                    "你好！",
                    "这里是我们关于你的权利和我们的期望的地方（也考虑到政策，比如 <COPPA@https://www.ecfr.gov/current/title-16/chapter-I/subchapter-C/part-312> 和 <GDPR@https://gdpr.eu/compliance-checklist-us-companies/>)",
                    "首先要知道的是，我们不是一个商业实体。我们是一个社区性的研究项目，隶属于一个非盈利大学。我们的目标是创建一个平台，为你带来快乐，并帮助我们在计算机领域探索更加公平和正义的世界。我们对在这个平台上赚钱没有兴趣；我们收集到的任何资金（通常是通过公共资助获得）都是用来维持这个平台，而不是让任何参与其中的人（或为其做出贡献的人）受益。",
                    "因为我们不追求利润，这也意味着我们不能对这个平台的可靠性、可用性或持久性作出任何承诺。话虽如此，<Amy@https://amyjko.phd> 致力于长期维持它，并且作为终身教授，她的工作相当稳定。",
                    "这就引出了*数据*。以下是我们在云端收集和存储的内容：",
                    "• 你的*项目*。你做出的任何贡献我们都会存储。这包括你在项目中输入的任何个人身份信息（因为都是文本，所以内容可能是任何东西！）。",
                    "• 你的*设置*。这包括你选择的语言环境、动画偏好和教程进度。其他所有内容都存储在你的设备上。",
                    "• *流量*。我们使用基本的<Google Analytics@https://en.wikipedia.org/wiki/Google_Analytics>来收集关于人们访问哪些页面和项目以及访问次数的聚合匿名数据。我们使用这些数据帮助筹集资金以维持这个平台。",
                    "我们不存储其他任何东西。除了谷歌分析使用的“cookie”外，没有其他跟踪标识符，没有摄像头或麦克风输入的录音。我们的<源代码@https://github.com/amyjko/wordplay/tree/main/src>是公开的，你可以随时验证这一点。",
                    "*你*拥有你的数据，而不是我们。这意味着：",
                    "• 你可以控制谁能访问你的项目。它们默认是私有的，但你可以将它们与个人、团体分享，或者完全公开。",
                    "• 你可以随时完全删除任何项目或你自己的帐户。",
                    "• 你可以随时导出任何项目或整个帐户。",
                    "下面是我们会和不会使用你的数据的方式：",
                    "• 我们不会与任何人分享你的数据，除非法律明确要求。你的数据可能被未经许可取走（即“数据泄露”）。如果我们发现发生了这种情况，我们会通过你与我们分享的电子邮件通知你。",
                    "• 我们不会通过你的电子邮件地址联系你，除非你 1) 进行需要我们联系的帐户更改，2) 你明确同意我们联系你，或者 3) 在上述的数据泄露情况下。",
                    "• 我们可能会分析平台上的项目，以了解每个人在制作什么以及制作方式。我们可能会在学术出版物中分享这些汇总的、匿名的见解。我们只会在受美国联邦法律监管的机构审查委员会的监督下进行。",
                    "最后，关于言论的一点。在这个平台上，你可以在*私下*说任何你想说的话。项目默认是私有的，即使你将它们分享给特定的电子邮件地址，它们仍然被视为私有的。在私人项目中，我们不会进行任何审查。",
                    "但是将一个项目设为*公开*，或者将其包含在公共画廊中，是一种特权。这是一个以爱、认可、尊重和尊严为基础的平台。因此，我们期望你的*公共*内容遵循这些规则："
                ],
                "consequences": [
                    "如果我们发现一个项目或画廊违反了这些规定，我们将把它标记为私有，并阻止他们将来发布任何公开项目。你可以通过举报任何你认为违反规定的内容来帮助我们执行这些规定。"
                ]
            },
            "donate": {
                "header": "捐赠",
                "prompt": "支持更具普及性、全球性的编程",
                "content": [
                    "Wordplay 是一个由<University of Washington@https://washington.edu>支持的免费、社区驱动的项目。我们依赖那些相信我们使命——提供可访问、包容各种语言的教育性编程语言——的人们的捐赠。",
                    "以下是我们当前的支出：",
                    "• 我们给华盛顿大学的本科生提供报酬，尤其是那些残疾人或者母语不是英语的学生，用于推动项目的发展和维护。这大约占据我们支出的90%。",
                    "• 我们给与我们合作开发多语言、可访问的课程大纲的教师提供津贴。",
                    "• 我们支付 Google 用于<Firebase@https://firebase.google.com/>带宽和存储，以及<Workspace@https://workspace.google.com/>服务的费用。",
                    "• 我们每年支付<Squarespace@https://www.squarespace.com/>用于域名的费用。",
                    "我们当前的支出，假设每小时 $$20 美元的标准，雇佣 5 名本科生，每周工作 10 小时（36周）以及在夏季雇佣 2 名本科生（12周），再加上云服务的费用，大约是每年 $$60,000 美元。",
                    "如果有 2,400 人每年捐赠 $$25 美元，这将足以支付我们的支出，多出的资金将用于报酬更多的学生和教师。",
                    "你能成为那 2,400 人之一吗？如果可以，请使用以下链接捐赠给我们的华盛顿大学捐赠平台："
                ]
            },
            "teach": {
                "header": "$~教",
                "prompt": {
                    "none": "$~欢迎老师！创建一个班级来设置和管理学生帐户和项目库。",
                    "some": "$~欢迎老师！管理您的课程或创建新课程。"
                },
                "error": {
                    "offline": "$~我们无法检查您的教师身份。",
                    "login": "$~您需要登录才能管理课程。",
                    "teacher": "$~您需要教师权限才能创建和管理课程。填写此表单，让我们互相了解！"
                },
                "link": {
                    "request": "$~申请教师权限",
                    "new": "$~创建类"
                }
            },
            "newclass": {
                "header": "$~新类",
                "subheader": {
                    "class": "$~你的班级",
                    "students": "$~你的学生",
                    "credentials": "$~用户名和密码",
                    "submit": "$~提交"
                },
                "prompt": {
                    "start": "$~创建一个班级，为班级中的所有学生生成帐户，并允许您创建画廊，所有学生都可以向其中添加项目。如果学生已有帐户，您可以稍后添加。",
                    "review": "$~检查我们设置的用户名和密码。在继续操作之前，您是否要*编辑*它们？如果这样做，您将无法编辑上述学生信息。",
                    "ready": "$~当您准备好生成上述凭证时，请告知我们。完成后，您可以编辑它们。",
                    "pending": "$~生成用户名和密码...",
                    "submit": "$~准备提交了吗？提交成功后，您将收到此信息的下载。密码*不可恢复*，因此请将其保存在安全的地方。",
                    "submitting": "$~正在使用上述用户名和密码请求新帐户...",
                    "download": "$~您的课程已准备就绪！您应该会在下载文件夹中看到学生数据的下载。*密码不可恢复*，因此请将此文件保存在安全的地方！"
                },
                "field": {
                    "name": {
                        "description": "$~类名",
                        "placeholder": "$~简称"
                    },
                    "description": {
                        "description": "$~描述",
                        "placeholder": "$~针对您和您的学生的课程描述。"
                    },
                    "existing": {
                        "label": "$~有账户的学生",
                        "prompt": "$~您的一些学生是否已经拥有 Wordplay 帐户？请将他们包括在此处。"
                    },
                    "metadata": {
                        "description": "$~学生信息",
                        "placeholder": "$~例如，学生 ID、姓氏、名字",
                        "prompt": "$~想要为学生创建新帐户？请提供关于学生的*任何信息*，每行一个，以逗号分隔。这些信息可以是姓氏、名字、学生编号或其他可区分的详细信息。我们将使用它来生成您可以在下面编辑的用户名，帮助您将用户名与学习者关联起来。"
                    },
                    "words": {
                        "description": "$~密码中使用的单词",
                        "placeholder": "$~例如，猫点鼠……",
                        "prompt": "$~提供至少 *25 个单词* 随机生成 2-3 个单词的易记密码。选择您的学生知道的单词或让他们集思广益。随机性越高，越安全！"
                    },
                    "generate": {
                        "label": "$~产生",
                        "tip": "$~根据以上信息创建用户名和密码。"
                    },
                    "edit": {
                        "label": "$~编辑",
                        "tip": "$~编辑生成的学生信息"
                    },
                    "submit": {
                        "label": "$~创建类",
                        "tip": "$~使用此信息创建一个新类。"
                    }
                },
                "error": {
                    "duplicates": "$~学生信息中有重复的条目。",
                    "columns": "$~确保每个学生都有相同数量的列。",
                    "generate": "$~无法创建唯一的用户名。",
                    "taken": "$~上述一个或多个用户名已被使用",
                    "limit": "$~您一次不能创建一个拥有超过 35 名学生的班级。",
                    "words": "$~提供至少 25 个单词。",
                    "account": "$~无法创建某些帐户。",
                    "generic": "$~我们无法创建该类。以下是一些可帮助开发人员找出问题所在信息。"
                }
            },
            "class": {
                "header": "$~班级",
                "subheader": {
                    "teachers": "$~教师",
                    "students": "$~学生",
                    "galleries": "$~画廊"
                },
                "prompt": {
                    "gallery": "$~为您的班级创建一个画廊，以组织作业或项目。项目中的所有教师都将成为画廊策展人，所有学生都将成为画廊创建者。",
                    "delete": "$~删除此类课程将永久删除有关该课程的信息，但会删除其项目、图库或学生帐户。"
                },
                "field": {
                    "name": {
                        "description": "$~班级名称",
                        "placeholder": "$~姓名"
                    },
                    "description": {
                        "description": "$~类别描述",
                        "placeholder": "$~描述"
                    },
                    "newteacher": {
                        "placeholder": "$~电子邮件或用户名",
                        "description": "$~您希望授予教师访问此课程的创建者的电子邮件或用户名"
                    },
                    "addteacher": "$~为该班级添加老师",
                    "delete": {
                        "tip": "$~永久删除此类。",
                        "label": "$~删除此类"
                    }
                },
                "error": {
                    "notfound": "$~我们找不到此类，或者您没有查看它的权限。"
                }
            }
        },
        "edit": {
            "node": "$1$2[, 类型 $2|]",
            "before": "在 $1[$1|end] 之前",
            "inside": "在 $1 内, 在 $2[$2|初] 和 $3[$3|界限] 之間",
            "between": "在 $1 和 $2 之间",
            "line": "$1[$1|start] 和 $2[$2|end]之间的空行",
            "conflicts": "$1 冲突",
            "assign": "/$2[急于插入|考虑离开]……/",
            "append": "/急于插入……/",
            "remove": "/考虑离开……/",
            "replace": "/想要介入……/",
            "wrap": "加括号",
            "unwrap": "揭开",
            "bind": "给这个表达命名"
        },
        "template": {
            "unwritten": "待定",
            "unparsable": "无法解析的模板: $1"
        },
        "collaborate": {
            "label": "$~合作",
            "role": {
                "owner": "$~所有者",
                "collaborators": "$~合作者",
                "curators": "$~策展人"
            },
            "field": {
                "message": {
                    "description": "$~要提交的聊天消息",
                    "placeholder": "$~键入消息"
                }
            },
            "button": {
                "submit": {
                    "label": "$~发送",
                    "tip": "$~向您的合作者发送消息"
                },
                "start": {
                    "label": "$~开始聊天",
                    "tip": "$~开始与自己或他人讨论。"
                },
                "delete": "$~删除此消息"
            },
            "error": {
                "unowned": "$~该项目没有所有者，因此无法聊天。",
                "offline": "$~无法加载此聊天。",
                "empty": "$~没有消息。",
                "deleted": "$~该消息已被删除。"
            },
            "prompt": {
                "solo": "$~与自己聊天或添加可以编辑和聊天的合作者。",
                "owner": "$~合作者可以编辑该项目并进行讨论。",
                "collaborator": "$~您是协作者。您可以编辑此项目并进行讨论。",
                "curator": "$~您是此项目画廊的管理员。您可以编辑此项目并就此项目进行讨论。"
            }
        },
        "checkpoints": {
            "label": {
                "now": "$~现在",
                "history": "$~恢复",
                "restore": "$~这是该项目的先前版本。",
                "ago": "$~$1 $2 前"
            },
            "button": {
                "clear": "$~删除历史记录",
                "select": "$~查看此版本",
                "checkpoint": "$~保存此版本的项目",
                "back": "$~返回上一版本",
                "forward": "$~返回下一版本",
                "restore": "$~恢复此版本",
                "now": "$~返回当前版本"
            }
        }
    },
    "moderation": {
        "warning": {
            "header": "警告",
            "explanation": "一位版主认为这个内容可能："
        },
        "blocked": {
            "header": "已封锁",
            "explanation": "一位版主认为这个内容可能："
        },
        "unmoderated": {
            "header": "注意",
            "explanation": "此内容尚未经过审核。可能："
        },
        "moderate": {
            "header": "审查",
            "explanation": "请审查此项目，判断其是否包含以下内容。如果包含，内容将受到警告或封锁。如果不确定，你可以跳过。"
        },
        "flags": {
            "violence": "煽动、鼓励或庆祝对任何人的暴力、伤害或自残行为。",
            "dehumanization": "基于种族、民族、国籍、种姓、性取向、性别、宗教、年龄、能力或外貌对个人或群体进行非人格化描述。",
            "disclosure": "披露其他人的私人信息，如姓名、联系方式或实际地址。",
            "misinformation": "包含虚假、误导性、欺骗性或操纵性信息。"
        },
        "progress": "*$1* 已审核，*$2* 剩余",
        "button": {
            "submit": {
                "tip": "保存这些审查设置",
                "label": "保存"
            },
            "skip": {
                "tip": "跳过此项目",
                "label": "跳过"
            }
        }
    },
    "gallery": {
        "games": {
            "name": "游戏",
            "description": "交互式文字和符号游戏。"
        },
        "visualizations": {
            "name": "可视化",
            "description": "文字的可视化展示。"
        },
        "motion": {
            "name": "运动",
            "description": "运动和碰撞的示例。"
        },
        "av": {
            "name": "音频/视频",
            "description": "使用音量、音调和视频作为输入。"
        },
        "tools": {
            "name": "工具",
            "description": "简单的实用工具和应用程序。"
        }
    }
}
