记录游戏状态

大多数游戏在进行过程中都会跟踪多种信息：分数、玩家位置以及其他细节，这些都是游戏的关键组成部分。
每次进行输入时，游戏状态就会发生变化，然后我们希望根据这些变化展示新的输出，并以此作为响应。

任何游戏通常都会用一个通用模式，包含三个部分：

• 定义一个游戏状态的数据结构，用于存储所有游戏状态信息
• 定义一个反应（reaction），当有新的输入时，根据先前的游戏状态创建一个新的游戏状态
• 使用 @Stage  ，  @Group  和  @Phrase 来显示游戏状态

例如，加入我们有一个简单的游戏，其中玩家需要在文本框中输入秘密单词，每次猜出一个秘密单词就会获得一分：

\•Game(secrets•[''] points•#)
state: Game(['猫' '狗'] 0) … state.secrets.has(Chat()) … state.points:state.points + 1
Stage(state.points = state.secrets.length() ? [Phrase("你赢了！")] [
			Group(Stack() [
					Phrase("猜猜我的秘密单词")
					Phrase(`\state.secrets.length() - state.points\更多秘密`)
				])
		])\

让我们来逐步分解一下。

• 第一行，\•Game(secrets•[''] points•#)\表示，/创建一个名为 \Game\ 的数据结构，用来存储秘密单词列表和分数/
• 第二行表示/游戏状态从“包含一组秘密单词、分数为 0”开始。每当\Chat\改变时，如果输入的单词存在于秘密单词列表中，就创建一个新的游戏状态，并将分数增加1/。
• 每次程序重新计算时（当\Chat\发生变化时），显示一个阶段（stage）。如果分数等于秘密单词的数量，则显示胜利界面。如果分数不相等，则显示提示信息和剩余未被猜中的秘密单词数量。

这个例子存在一些问题：

• 如果他们多次猜出同一个秘密单词，就能获得更多分数！我们的游戏状态可能还需要记住已经猜对的秘密单词，所以每个单词只能被计算两次。
• 如果玩家一次性输入多个单词，是否应该算作一次正确猜测？

要处理这些情况，就需要设计更复杂的游戏状态和更完善的状态更新逻辑。

track-points