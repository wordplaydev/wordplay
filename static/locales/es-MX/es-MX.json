{
    "$schema": "../../schemas/LocaleText.json",
    "language": "es",
    "region": "MX",
    "wordplay": "Wordplay",
    "term": {
        "evaluate": "evaluar",
        "bind": "unir",
        "decide": "decidir",
        "document": "documento",
        "project": "proyecto",
        "source": "fuente",
        "input": "input",
        "output": "producción",
        "convert": "convertir",
        "act": "acto",
        "scene": "escena",
        "phrase": "frase",
        "group": "grupo",
        "stage": "escenario",
        "type": "tipo",
        "start": "comenzar",
        "entered": "ingresó",
        "changed": "cambiada",
        "moved": "movido",
        "name": "nombre",
        "value": "valor",
        "text": "texto",
        "boolean": "booleano",
        "map": "mapa",
        "number": "número",
        "function": "función",
        "exception": "excepción",
        "table": "tabla",
        "none": "ninguna",
        "list": "lista",
        "stream": "arroyo",
        "structure": "estructura",
        "index": "índice",
        "query": "pregunta",
        "row": "fila",
        "set": "set",
        "key": "clave",
        "help": "ayuda",
        "feedback": "feedback"
    },
    "token": {
        "EvalOpen": "evaluación abierta",
        "EvalClose": "evaluación cerrada",
        "SetOpen": "conjunto abierta",
        "SetClose": "conjunto cerrada",
        "ListOpen": "lista abierta",
        "ListClose": "lista cerrada",
        "TagOpen": "etiqueta abierta",
        "TagClose": "etiqueta cerrada",
        "Bind": "unir",
        "Access": "acceso de propiedad",
        "Function": "función",
        "Borrow": "pedir prestado",
        "Share": "compartir",
        "Convert": "convertir",
        "Doc": "explicación",
        "Formatted": "formateado",
        "FormattedType": "tipo formateado",
        "Words": "palabras",
        "Link": "enlace web",
        "Italic": "itálica",
        "Underline": "subrayar",
        "Light": "ligero",
        "Bold": "negrita",
        "Extra": "extra",
        "Concept": "enlace conceptual",
        "URL": "URL",
        "Code": "codigo",
        "Mention": "mencionar",
        "Otherwise": "si no",
        "Match": "$~fósforo",
        "None": "nada",
        "Type": "escribir",
        "Literal": "literal",
        "TypeOperator": "es",
        "TypeOpen": "input para escribir abierto",
        "TypeClose": "input para escribrir cerrado",
        "Separator": "separadora de nombres",
        "Language": "etiqueta de idioma",
        "Region": "guión de región",
        "BooleanType": "tipo booleano",
        "NumberType": "tipo de número",
        "JapaneseNumeral": "número japonés",
        "RomanNumeral": "número romano",
        "Pi": "pi",
        "Infinity": "infinidad",
        "TableOpen": "tabla abierta",
        "TableClose": "tabla cerrada",
        "Select": "seleccionar",
        "Insert": "insertar",
        "Update": "actualizar",
        "Delete": "borrar",
        "Union": "unión",
        "Stream": "próxima",
        "Change": "cambiar",
        "Initial": "evaluacion primera",
        "Previous": "anterior",
        "Placeholder": "marcador de posición",
        "Etc": "etcétera",
        "This": "esta",
        "Operator": "operadora",
        "Conditional": "condicional",
        "Text": "texto",
        "Number": "número",
        "Decimal": "número decimal",
        "Base": "numeral base",
        "Boolean": "booleano",
        "Name": "nombre",
        "Unknown": "desconocido",
        "Locale": "lugar local",
        "End": "final"
    },
    "node": {
        "Dimension": {
            "name": "dimensión",
            "description": "dimensión",
            "emotion": "serious",
            "doc": [
                "¡Soy un /unidad de medida/!",
                "Yo puedo ser cualquier unidad estandarizada, come \\1m\\, \\10s\\, \\100g\\, o cualquier unidid cientifica. Estoy feliz ser cualqueir unidad que quieres inventar tu también, como \\17manzana\\.",
                "Puedo combinar con \\/\\ para formar unidades de proporción, como \\17manzanas/día\\ y con \\^\\ para formar unidades exponenciales como \\9.8m/s^2\\.",
                "Siempre debo ir después de @Number. Si no lo hago, podrían confudirme con @Reference, ¡lo cual sería bastantate embarazoso!",
                "Siempre debo ir después de @Number. Si no lo hago, podrían confudirme con @Reference, ¡lo cual sería bastantate embarazoso!",
                "También soy bastante bueno para encontrar inconsistencies entre unidades. Por ejemplo, !\\1gato + 1perro\\ no tiene ningún sentido!"
            ]
        },
        "Doc": {
            "name": "explicación",
            "emotion": "serious",
            "doc": [
                "Formateo ricamente las cosas con @Markup, como explicaciones de algunos de tus @Program, o incluso las palabras que pones en el escenario con @Phrase.",
                "Por ejemplo, puedo ir antes de cualquier expresión:",
                "\\¶¿Se supone que esto realmente es 7?¶\n7\\",
                "Por ejemplo, puedes ponerme antes de @Bind:",
                "\\¶Mido la altura de alguien¶\naltura: 5m\\",
                "O antes de una @FunctionDefinition:",
                "\\¶Sumo dos números¶\nƒ suma(a•# b•#) a + b\\",
                "O antes de una @StructureDefinition:",
                "\\¶Recuerdo el nombre y la fruta favorita de las personas¶\n•Persona(nombre•'' fruta•'')\\",
                "También puedes ponerme al principio de @Program para decir de qué trata toda la actuación",
                "\\¶Este programa saluda¶\n\n'¡hola!'\\",
                "Puedes darme un @Language para ayudar a otros a saber en qué idioma estoy escrito:",
                "\\¶Soy un documento en inglés¶/en\nduración: 5s\\",
                "¿Sabías que puedes hacer una lista de mí? Ve a hablar con @Docs."
            ]
        },
        "Docs": {
            "name": "lista de explicaciones",
            "emotion": "serious",
            "doc": [
                "Soy una lista de @Doc, útil cuando tienes múltiples traducciones de @Doc en diferentes idiomas.",
                "No tienes que hacer nada especial para hacer una lista. Solo pon un montón de @Doc uno al lado del otro, así:",
                "\\¶Hola¶/es\n¶Hello¶/en\nsaludo: '…'\\"
            ],
            "start": "¡Creando el valor de los documentos!"
        },
        "KeyValue": {
            "name": "mapeo",
            "emotion": "kind",
            "doc": [
                "Soy un mapeo de una *clave* a un *valor*, siempre en un @Map.",
                "Puedes mapear cualquier tipo de valor a cualquier otro. Por ejemplo, aquí tienes un mapeo de números:",
                "\\{1:1}\\",
                "O un mapeo de texto a números:",
                "\\{'conejo':1}\\"
            ]
        },
        "Language": {
            "name": "idioma",
            "description": "idioma $1[$1|desconocido]",
            "emotion": "eager",
            "doc": [
                "¡Soy una etiqueta de idioma y trabajo con @Name y @Doc!",
                "Soy realmente bueno para dejar *muy claro* en qué idioma está escrito algo.",
                "Eso es lo que hago. Solo una pequeña barra inclinada, y un par de letras, y nadie volverá a confundirse sobre en qué idioma está algún texto.",
                "Por ejemplo, digamos que quieres decir mi $name, pero dejar claro que estoy en inglés:",
                "\\\"Idioma\"/en\\",
                "O supongamos que quieres hacer esto para un @Name.",
                "\\sonido/en: 'miau'\\",
                "¡O incluso para @Doc!",
                "\\¶Onomatopeya¶/en\nsonido/en: \"miau\"\\",
                "Hay muchos <códigos de idioma de 2 letras@https://es.wikipedia.org/wiki/ISO_639-1> que entiendo. Si no usas uno de esos, te lo haré saber."
            ],
            "conflict": {
                "UnknownLanguage": "No conozco este idioma",
                "MissingLanguage": "Me falta un idioma. ¿Puedes añadir uno?"
            }
        },
        "Name": {
            "name": "nombre",
            "description": "$1[$1 | sin nombre]",
            "emotion": "kind",
            "doc": [
                "Identifico un valor y soy una forma útil de darle una etiqueta abreviada a algo que fue difícil de evaluar o que no quieres tener que evaluar una y otra vez.",
                "@Bind me da mi nombre de esta manera:",
                "\\hola: 5\\",
                "Solo represento un valor y, una vez que lo tengo, no puedo cambiarlo. Por ejemplo, si intentaras hacer esto con @Bind, nos quejaríamos.",
                "\\hola: 5\nhola: 3\\",
                "Todo lo que tienes que hacer para obtener mi valor es tener @Reference o @PropertyReference usar mi nombre. Aquí, @Bind me nombra y luego @Reference obtiene el valor que me dieron.",
                "\\hola: 5\nhola\\",
                "Porque @Bind puede aparecer en tantos lugares, yo también puedo aparecer en muchos lugares. Estuve en un @Block arriba, pero puedo estar en un @FunctionDefinition. Aquí estoy nombrando un mensaje temporalmente:",
                "\\ƒ decir(mensaje•'') mensaje\\",
                "Me definen dentro de @FunctionDefinition y, tan pronto como la función termina de evaluarse, desaparezco.",
                "Puedes usar @Language para indicar en qué idioma está mi nombre. Esto es útil al compartir tu actuación con otros, por si quieren leer tu programa."
            ]
        },
        "Names": {
            "name": "lista de nombres",
            "emotion": "kind",
            "doc": [
                "Soy una lista de @Name, útil cuando quieres darle varios nombres a un valor, muchas veces con diferentes @Language.",
                "Los nombres están separados por símbolos \\,\\ . Por ejemplo, aquí está @Bind dando un valor a varios @Name",
                "\\hi/en,hello/en,hola/es: 'bienvenido'\\"
            ]
        },
        "Row": {
            "name": "fila",
            "emotion": "shy",
            "doc": "Represento una fila en una @Table. Probablemente sea mejor hablar con @Table, ellos saben todo sobre mí. Solo estoy por aquí y mantengo los valores en línea :(",
            "conflict": {
                "InvalidRow": "Las filas deben ser todas valores o todas @Bind.",
                "MissingCell": {
                    "primary": "Me falta la columna $1",
                    "secondary": "Soy obligatoria, pero $1 no la proporcionó"
                },
                "ExtraCell": {
                    "primary": "¿Se supone que debo estar aquí?",
                    "secondary": "¡Oye $1, no eres parte de esta @Table!"
                },
                "UnknownColumn": "No conozco una columna con este nombre",
                "UnexpectedColumnBind": {
                    "primary": "¿Se supone que debo ser un @Bind?",
                    "secondary": "Oye, soy una @Table, necesito valores, no @Bind."
                }
            }
        },
        "Token": {
            "name": "token",
            "description": "$1 $2",
            "emotion": "neutral",
            "doc": [
                "¿Cómo me encontraste?",
                "Soy la parte más pequeña de una actuación. Soy el sustrato del cual se hacen todos los caracteres en el Verso. Soy la partícula atómica de nuestra coreografía."
            ]
        },
        "Markup": {
            "name": "marcado",
            "description": "$1 párrafos",
            "emotion": "serious",
            "doc": [
                "Soy una lista de párrafos, utilizando los diversos tipos de marcado disponibles en explicaciones, como @Words, @WebLink, @ConceptLink y @Example."
            ]
        },
        "Paragraph": {
            "name": "párrafo",
            "emotion": "serious",
            "doc": [
                "Soy una serie de @Words, @ConceptLink, @WebLink y @Example, separados por una línea en blanco, y dentro de @Doc.",
                "Todo lo que necesitas hacer para escribirme es escribir un montón de palabras en un @Doc:",
                "\\¶Soy un párrafo en un documento.¶'un párrafo'\\",
                "Si quieres varios párrafos, solo pon líneas en blanco.",
                "\\¶Párrafo 1.\n\nPárrafo 2.\n\nPárrafo 3.¶'tres párrafos'\\"
            ]
        },
        "WebLink": {
            "name": "enlace",
            "description": "enlace $1",
            "emotion": "serious",
            "doc": [
                "Soy un enlace a algo en el internet. Solo necesito una descripción y una URL:",
                "\\¶Soy un <enlace@https://wordplay.dev> en un documento.¶\n'enlace de ejemplo'\\",
                "Si alguien me selecciona, se abrirá una nueva ventana con la URL."
            ]
        },
        "ConceptLink": {
            "name": "concepto",
            "description": "concepto $1",
            "emotion": "serious",
            "doc": [
                "Soy un enlace a un personaje del Verso. Soy útil cuando quieres escribir un @Doc y referirte a alguno de nosotros.",
                "Por ejemplo, digamos que quieres hablar sobre @Evaluate y lo increíble que es. Podrías escribir:",
                "\\¶Sabes, @Evaluate es bastante increíble.¶\n'mira, ¡un enlace de concepto!'\\",
                "Cuando aparezca el @Doc que escribiste aquí, mostrará un enlace al concepto."
            ]
        },
        "Words": {
            "name": "palabras",
            "emotion": "serious",
            "doc": [
                "Soy cualquier palabra que desees en un @Doc. Por ejemplo:",
                "\\¶Que la Fuerza te acompañe.¶\n'solo algunas palabras'\\",
                "Sin embargo, a veces puedes querer usar los caracteres especiales que @Doc usa /como/ palabras. Por ejemplo:",
                "\\¶Mis amigas usan @@, //, **, || y otros símbolos.¶\n'usando caracteres especiales'\\",
                "Si simplemente repites esos caracteres especiales, obtendrás el carácter en lugar de su significado especial."
            ]
        },
        "Example": {
            "name": "ejemplo",
            "emotion": "serious",
            "doc": [
                "Soy un rendimiento de ejemplo, ¡útil para escribir @Doc que explique cómo usar algo!",
                "\\¶Aquí tienes un ejemplo de suma: \\1 + 1\\¶'código de ejemplo'\\",
                "Si me pones en un párrafo completamente solo, apareceré en una caja elegante y mostraré el resultado de evaluarme.",
                "\\¶Aquí tienes un ejemplo de suma:\n\n\\1 + 1\\¶\\"
            ]
        },
        "Mention": {
            "name": "mención",
            "description": "mención $1",
            "emotion": "serious",
            "doc": [
                "Soy una referencia a la terminología \\$programa\\ o una entrada dinámica \\$1\\.",
                "Sin embargo, esto es principalmente una función interna, así que no deberías necesitar conocerla."
            ]
        },
        "Branch": {
            "name": "rama",
            "emotion": "serious",
            "doc": [
                "Soy una forma de elegir entre dos segmentos de explicación basados en si un valor de entrada de explicación está definido o verdadero.",
                "Esto es principalmente una característica interna, así que no deberías necesitar conocerla."
            ]
        },
        "BinaryEvaluate": {
            "name": "evaluación binaria",
            "description": "$1 operación",
            "emotion": "insecure",
            "doc": [
                "Soy @Evaluate, pero en una forma más simple, útil cuando quieres usar un @FunctionDefinition que toma dos entradas.",
                "Por ejemplo, así es como podrías usar @Evaluate para sumar dos números:",
                "\\1.+(1)\\",
                "¿No se ve un poco raro? No está mal: simplemente dice obtén la función de suma en 1 y luego evalúala.",
                "Pero es mucho más fácil usar @BinaryEvaluate:",
                "\\1 + 1\\",
                "Esto hace que todo sea un poco más ordenado, aunque es básicamente lo mismo.",
                "Solo hay una cosa a tener en cuenta: cuando estoy en esta forma, evalúo de izquierda a derecha. Eso podría ser confuso si estás acostumbrado a cosas como el orden de las operaciones en matemáticas.",
                "Significa que esto se evalúa de una manera que quizás no esperes:",
                "\\1 + 2 · 3 + 4\\",
                "En matemáticas, la multiplicación vendría primero y luego la adición, y así el resultado sería \\11\\. Pero como evalúo en el orden de lectura, el resultado es \\13\\."
            ],
            "right": "entrada",
            "start": "vamos a evaluar primero $1",
            "finish": "mira, ¡hice $1!",
            "conflict": {
                "OrderOfOperations": "Evalúo en orden de lectura, no en el orden de operaciones matemáticas. ¿Quieres usar @Block para especificar el orden en el que debería evaluar?"
            }
        },
        "Bind": {
            "name": "unir",
            "description": "vincula $1",
            "emotion": "excited",
            "doc": [
                "Yo doy *nombres*.",
                "¡Así es!",
                "\\pi: 3.1415926\\",
                "Doy nombres a las entradas de @FunctionDefinition y @StructureDefinition, nombro valores en @Block. ¡Nombro todo!",
                "Pero, ¿sabías que puedes darle a un valor *muchos nombres*?",
                "¡Estoy emocionado por contarte esto! Un valor, muchos @Names. Por ejemplo:",
                "\\joe,tess,amy: 5\\",
                "¿Ves lo que hice allí?",
                "Un valor, tres nombres.",
                "Puedes referirte a ese cinco con *cualquiera* de esos nombres.",
                "Esto es especialmente útil cuando quieres dar nombres en muchos idiomas:",
                "\\joe/en,aimee/fr,明/zh: 5\\",
                "¿Ves lo que hice allí? ¡Tres nombres para un valor, solo en diferentes idiomas!",
                "Ok, tengo un último secreto.",
                "¿Sabías que puedo trabajar con @Is para decirme qué tipo de valor debería tener un nombre? ¿Y si no lo tiene, te lo diré?",
                "Así:",
                "\\bignumber•#: \"un trillón\"\\",
                "Ves, dije que \\bignumber\\ debería ser un número, pero es texto, y eso no es compatible, ¡así que BOOM!",
                "Te lo haré saber si no están de acuerdo.",
                "A veces, es posible que *tengas* que decirme qué tipo de datos tiene algo más porque no puedo entenderlo yo mismo. Eso suele pasar en @FunctionDefinition.",
                "Por ejemplo, aquí, @FunctionDefinition no sabe qué tipo de valores tienen \\a\\ y \\b\\, porque no se los dije.",
                "\\ƒ sum(a b) a + b\\",
                "Pero podemos cambiar esto para agregar el @Is, y ahora @FunctionDefinition sabe que son números:",
                "\\ƒ sum(a•# b•#) a + b\\"
            ],
            "start": "¡Veamos qué valor obtenemos de $1!",
            "finish": "¡Oh bien, obtuve $1! Vamos a llamarlo $2",
            "conflict": {
                "DuplicateName": {
                    "conflict": {
                        "primary": "alguien tiene el nombre $1, así que no puedo tener este nombre.",
                        "secondary": "eh, $1 es mi nombre"
                    },
                    "resolution": "$~Hay nombres duplicados, ¿quieres eliminar uno?"
                },
                "DuplicateShare": {
                    "primary": "tengo el mismo nombre que $1, lo que hace que lo compartido sea ambiguo",
                    "secondary": "tengo el mismo nombre que $1"
                },
                "IncompatibleType": {
                    "primary": "se supone que soy un $2, pero soy un $1",
                    "secondary": "Oh... lo siento, ¿un $1, en serio?"
                },
                "MisplacedShare": "Solo puedo compartir cosas a nivel de @Program, ¡no dentro de nada!",
                "MissingShareLanguages": "si quieres compartir esto, debes decir en qué idioma está, para que los demás sepan si pueden leerlo!",
                "RequiredAfterOptional": "No puedo estar aquí, hay un @Bind opcional antes que yo",
                "UnexpectedEtc": "Solo puedo tener una longitud variable en un @FunctionDefinition",
                "UnusedBind": "$! oye, le puse nombre a este valor, ¡pero nadie lo está usando!"
            }
        },
        "Block": {
            "name": "bloque",
            "description": "$1 declaraciones",
            "emotion": "shy",
            "doc": [
                "Hola. Creo un pequeño espacio tranquilo y privado para evaluar cosas.",
                "Como esto:",
                "\\(1 - 1) + 2\\",
                "Eso ayuda a aclarar el orden de la evaluación.",
                "@Bind también ayuda.",
                "\\(count: 10 count ^ count)\\",
                "¿Ves cómo @Bind hizo \\count\\? Solo está nombrado dentro de mí. Así que esto no funcionará:",
                "\\(count: 10 count ^ count) + count\\",
                "Porque count solo fue nombrado dentro de mí.",
                "Puedes poner tantas expresiones como quieras en mí. Pero solo me importa la última:",
                "\\(1 2 3 4 5)\\",
                "Así que normalmente soy solo un montón de @Bind y luego una expresión al final.",
                "\\(\n  a: 1\n  b: 2\n  c: 3\n  d: 4\n  a + b + c + d\n)\\"
            ],
            "statement": "declaración",
            "start": "primera expresión",
            "finish": "listo, obtuve $1",
            "conflict": {
                "ExpectedEndingExpression": "Necesito una expresión.",
                "IgnoredExpression": {
                    "primary": "$~Voy a ignorar $1, ya que no define nada y no es mi última expresión.",
                    "secondary": "$~@Block, ¡no me ignores!",
                    "resolution": "$~¿Querías decir que esto fuera @BinaryEvaluate en lugar de @UnaryEvaluate? Puedo agregar un espacio, así sé que eso es lo que quisiste decir."
                }
            }
        },
        "BooleanLiteral": {
            "name": "booleano específico",
            "description": "$1[verdadero|falso]",
            "emotion": "precise",
            "doc": "Soy o \\⊤\\ o \\⊥\\. Consulta @Boolean para aprender más sobre nuestra hermosa lógica.",
            "start": "¡$1!"
        },
        "Borrow": {
            "name": "pedir prestado",
            "description": "pedir prestado $1[$1|nombre faltante]",
            "emotion": "excited",
            "doc": "Si creas una actuación con múltiples @Source, puedes usarme para pedir prestados @Bind que se comparten en esas otras @Source. Simplemente usa su nombre y traeré su nombre y valor.",
            "start": "préstamo $2 de $1",
            "source": "$source",
            "bind": "nombre",
            "version": "versión",
            "conflict": {
                "UnknownBorrow": "No conozco una $source con este nombre",
                "BorrowCycle": "esto depende de $1, que depende de esta $source, por lo que el programa no se puede evaluar"
            },
            "exception": {
                "CycleException": {
                    "description": "ciclo de préstamo",
                    "explanation": "$1 depende de sí mismo"
                }
            }
        },
        "Changed": {
            "name": "cambiado",
            "emotion": "serious",
            "doc": [
                "Verifico si un flujo causó que @Program se revaluara y creo un @Boolean. Así:",
                "\\∆ Tiempo()\\",
                "Soy realmente útil cuando quieres que algo cambie solo si cambia un flujo.",
                "Eso es todo."
            ],
            "start": "veamos si $1 cambió…"
        },
        "Conditional": {
            "name": "condicional",
            "emotion": "curious",
            "doc": [
                "Creo que se supone que tomo decisiones. ¿Así?",
                "\\número: -100\nnúmero < 0 ? 'negativo' 'positivo'\\",
                "Pero ¿alguna vez has pensado en cómo decidimos?",
                "¿No parece que las decisiones deberían ser más matizadas que simplemente sí o no? ¿Decidir entre \\⊤\\ y \\⊥\\ es todo lo que hay?",
                "¿No te preocupa que si estos son el único tipo de decisiones que podemos tomar, estaremos perdiendo algún contexto importante sobre el mundo?"
            ],
            "start": "veamos si $1 es verdadero",
            "else": "$1[saltando sobre código | no saltando sobre código]",
            "afterthen": "terminado con sí, ¿saltemos el no?",
            "finish": "Supongo que es $1?",
            "condition": "condición",
            "yes": "sí",
            "no": "no",
            "conflict": {
                "ExpectedBooleanCondition": {
                    "primary": "¿Cómo puedo elegir sí y no con un $1? No en serio, ¿cómo?",
                    "secondary": "Creo que @Conditional quería que fuera un @Boolean, pero soy un $1."
                }
            }
        },
        "ConversionDefinition": {
            "name": "definición de conversión",
            "description": "$1 → $2",
            "emotion": "excited",
            "doc": [
                "Amigo, ¡defino conversiones de un tipo a otro! Voy en un @Block, algo así:",
                "\\→ #gatito #gato . ÷ 2\n6gatito→#gato\\",
                "¿Ves cómo convertí gatitos en gatos? ¡Increíble!",
                "Quizás te estés preguntando qué hace ese \\.\\ allí. Eso representa el valor que se está convirtiendo. Lo uso porque el valor no tiene nombre de lo contrario."
            ],
            "start": "¡increíble, una nueva conversión!",
            "conflict": {
                "MisplacedConversion": "¡guau, no puedo estar aquí, solo en @Block!"
            }
        },
        "Convert": {
            "name": "convertir",
            "emotion": "cheerful",
            "doc": [
                "Hola. Convierto valores de un tipo a otro. Échale un vistazo:",
                "\\1 → \"\"\\",
                "\\5s → #ms\\",
                "\\\"hola\" → []\\",
                "Incluso puedes encadenar estos:",
                "\\\"hola\" → [] → {}\\",
                "Los valores tienen un conjunto de @ConversionDefinition que están predefinidos, pero si haces una @StructureDefinition para un nuevo tipo de valor, puedes definir el tuyo con @ConversionDefinition."
            ],
            "start": "¡obtén ese valor de $1!",
            "finish": "Increíble, hice $1",
            "conflict": {
                "UnknownConversion": "Vaya, no hay forma de hacer que $1 sea $2"
            },
            "exception": {
                "ConversionException": {
                    "description": "conversión imposible",
                    "explanation": "No sé cómo convertir de $1 a $2"
                }
            }
        },
        "Delete": {
            "name": "eliminar",
            "emotion": "angry",
            "doc": [
                "A veces tienes una tabla y ¡TIENE DEMASIADO EN ELLA!",
                "Como si tuvieras algunos jugadores en un juego y uno se fue y solo querías decir ¡FUERA JUGADOR, SAL DE MI TABLA!",
                "\\jugadores: ⎡nombre•'' equipo•'' puntos•#⎦\n⎡'jen' 'rojo' 8⎦\n⎡'juan' 'azul' 11⎦\n⎡'javier' 'rojo' 9⎦\n⎡'juanita' 'azul' 7⎦\njugadores ⎡- nombre = 'javier'\\",
                "Uf, Javier se fue. ADIÓS Javier. Solo recuerda que no cambio la tabla original, hago una nueva, sin Javier. Tú decides a dónde va."
            ],
            "start": "vamos a obtener primero la tabla",
            "finish": "¡Hice una nueva tabla sin las filas coincidentes!"
        },
        "DocumentedExpression": {
            "name": "expresión explicada",
            "emotion": "eager",
            "doc": [
                "Soy cualquier expresión, ¡pero con un @Doc!",
                "Para hacerme, simplemente coloca un @Doc antes de una expresión, y obtendrás esto:",
                "\\dobleplus: 1\n(2 · dobleplus) + \n¶Hagámoslo un poco más grande¶\n1\\",
                "Soy útil para hacer un comentario sobre alguna parte de un programa."
            ],
            "start": "evaluemos la expresión"
        },
        "Evaluate": {
            "name": "evaluar",
            "description": "evaluar $1[$1|anónimo]",
            "emotion": "shy",
            "doc": [
                "Hola. Evalúo a mi querida @FunctionDefinition. Así:",
                "\\ƒ saludo(mensaje•'')\nsaludo('gatito')\\",
                "Las funciones pueden venir de cualquier lugar. Por ejemplo, @Text tiene funciones. Como esto:",
                "\\'gatito'.longitud()\\",
                "Si una función tiene un nombre de símbolo único, puedes escribirme como un @BinaryEvaluate.",
                "\\'gatito' ⊆ 'itty'\\",
                "Eso hace lo mismo que esto:",
                "\\'gatito'.⊆('itty')\\",
                "Por supuesto, no soy nada sin @FunctionDefinition. Todo lo que hago es darles inputs y luego seguir sus pasos."
            ],
            "start": "evaluemos los inputs primero",
            "evaluate": "vamos a evaluar la función ahora",
            "finish": "Evalué a $1",
            "function": "función",
            "input": "input",
            "conflict": {
                "IncompatibleInput": {
                    "primary": "Se supone que debo ser un $1, pero soy un $2",
                    "secondary": "Mmm, obtuve un $2 en lugar de un $1"
                },
                "UnexpectedTypeInput": {
                    "primary": "No esperaba este tipo de input",
                    "secondary": "oh, ¿no debería estar aquí?"
                },
                "MissingInput": {
                    "primary": "$~No puedo evaluar sin la entrada llamada $1 :(",
                    "secondary": "$~Ah, vaya. ¿Puedes ayudarnos y agregarlo a mi lista de entradas?"
                },
                "NotInstantiable": "No puedo hacer esta @StructureDefinition, tiene funciones no implementadas.",
                "UnexpectedInput": {
                    "primary": "No esperaba este input $1",
                    "secondary": "Oh, ¿no debería estar aquí?"
                },
                "UnknownInput": {
                    "primary": "No conozco un input con este nombre",
                    "secondary": "No creo que pertenezca aquí"
                },
                "InputListMustBeLast": "la lista de inputs debe ir al final",
                "SeparatedEvaluate": "$~¿Es $1 el nombre de una $2[$structure|$function] que estás intentando evaluar? Intente eliminar el espacio después de mí, para saber que es un @Evaluate y no un @Block separado."
            },
            "exception": {
                "FunctionException": {
                    "description": "función desconocida",
                    "explanation": "oh no, $1 no es una función en $2[$2|este @Block!"
                }
            }
        },
        "Input": {
            "name": "$~Aporte",
            "description": "$~entrada nombrada",
            "emotion": "serious",
            "doc": [
                "$~Soy una entrada dada a un @Evaluate. Mi nombre corresponde al nombre de la entrada en @FunctionDefinition o @StructureDefinition que se está evaluando.",
                "$~Soy útil con funciones que tienen muchos valores predeterminados, donde solo deseas anular una entrada específica, sin dar todo lo demás.",
                "$~Por ejemplo, @Phrase tiene muchísimos valores predeterminados para controlar su estilo. Digamos que deseas agregar algo de @Text y @Color, pero nada más en su lista de entrada. Puedes usarme para hacer eso:",
                "$~\\Phrase('¡Soy morado!' color: Color(50% 52 300°))\\"
            ],
            "start": "$~Evaluemos mi valor."
        },
        "ExpressionPlaceholder": {
            "name": "marcador de posición",
            "description": "$1[$1|marcador de posición]",
            "emotion": "scared",
            "doc": [
                "Soy una *expresión*, pero no una real... solo ocupo su lugar.",
                "Soy útil si aún no sabes qué escribir. Como esto:",
                "\\1 + _\\",
                "¿Qué estamos sumando? No lo sé. Tú me dices.",
                "O si alguien estuviera evaluando una función con @Evaluate, podría representar a la función",
                "\\_(1 2 3)\\",
                "¡No me gusta estar en @Stage!"
            ],
            "start": "¡ay!, no sé qué hacer",
            "placeholder": "expresión",
            "conflict": {
                "Placeholder": "¿alguien puede ocupar mi lugar?"
            },
            "exception": {
                "UnimplementedException": {
                    "description": "sin implementar",
                    "explanation": "¡No sé qué hacer!"
                }
            }
        },
        "FunctionDefinition": {
            "name": "función",
            "description": "función $1",
            "emotion": "kind",
            "doc": [
                "¡Hola de nuevo! Tomo algunos inputs, luego evalúo una expresión usando esos inputs, y produzco un output.",
                "Aquí tienes un ejemplo simple:",
                "\\ƒ repetir(mensaje•'') mensaje · 5\nrepetir('hola')\\",
                "Esa función toma un input, \\message\\, y usa la función @Text/repeat para repetir el mensaje cinco veces.",
                "¡Soy realmente útil si quieres evaluar algo una y otra vez, pero con diferentes inputs!",
                "Tengo muchos otros trucos. Por ejemplo, no necesito tener un nombre. Aquí, voy directamente a @Evaluate como un valor.",
                "\\(ƒ(mensaje•'') mensaje · 5)('hola')\\",
                "O, aquí hay una función que toma cualquier cantidad de inputs, usando el carácter \\…\\ después del nombre del input.",
                "\\ƒ si(mensajes…•'') mensajes.sans('no')\nsi('sí' 'sí' 'no' 'sí' 'no')\\",
                "¿Ves cómo tomó todos los 'no' y se deshizo de ellos? Eso es porque messages es un @List, y así pudimos usar @List/sansAll.",
                "A veces es posible que desees dejar claro qué tipo de valor produzco. Para hacer eso, agrega un @Is después de la lista de inputs:",
                "\\ƒ a(x•# y•#)•'' x + y\\",
                "Puede que notes un problema con este: dice que se evalúa como @Text, pero toma dos @Number. ¡Puedo decirte cuando las cosas son inconsistentes!",
                "Por supuesto, no soy realmente útil en absoluto sin @Evaluate; ellos me dan vida."
            ],
            "start": "¡vamos a crear esta función!",
            "conflict": {
                "NoExpression": "Necesito una expresión para evaluar, ¿puedes agregar una?"
            }
        },
        "Iteration": {
            "name": "función de orden superior",
            "emotion": "kind",
            "doc": "Soy un tipo muy especial de @FunctionDefinition que opera en listas de cosas. No necesitas saber nada sobre mí, excepto que hago funciones como @List/translate posibles.",
            "start": "evaluando la función dada",
            "initialize": "preparándome para recorrer los elementos",
            "next": "pasando al siguiente elemento",
            "check": "decidiendo si continuar",
            "finish": "Me evalué como $1"
        },
        "Initial": {
            "name": "inicio",
            "emotion": "curious",
            "doc": [
                "Te digo si la evaluación actual de @Program es la primera, dando como resultado un @Boolean. Por ejemplo:",
                "\\◆ ? Tiempo() 'hola'\\",
                "No lo viste, pero la primera evaluación fue una hora, pero luego todas las futuras marcas de tiempo fueron \\⊥\\, así que @Conditional hizo \\⊤\\.",
                "¡Soy realmente útil si estás trabajando con un flujo y solo quieres hacer algo la primera vez, o nunca en la primera vez!"
            ]
        },
        "Insert": {
            "name": "insertar",
            "emotion": "kind",
            "doc": [
                "¿Sabes cuándo tienes una @Table y sientes que le falta algo? ¡Yo puedo agregarlo!",
                "Imagina que tenías una tabla de jugadores en un juego y querías agregar uno nuevo:",
                "\\jugadores: ⎡nombre•'' equipo•'' puntos•#⎦\n⎡'jen' 'rojo' 1⎦\n⎡'juan' 'azul' 0⎦\n⎡'javier' 'rojo' 3⎦\n⎡'juanita' 'azul' 2⎦\njugadores ⎡+ 'jasón' 'red' 0⎦\\",
                "Solo recuerda, como todo en el Verso, no cambio una tabla, la reviso. Así que debes decidir dónde quieres poner la tabla revisada que haces. Lo más probable es que quieras revisar una tabla en una @Reaction a algún input y almacenarla en un @Bind."
            ],
            "start": "encontremos la tabla a actualizar",
            "finish": "¡Hice una nueva tabla con filas revisadas!"
        },
        "Is": {
            "name": "es",
            "description": "es",
            "emotion": "curious",
            "doc": [
                "¿Sabes qué? Hay tantos tipos de valores que significan tantas cosas diferentes. Ayudo a descifrar qué son.",
                "Por ejemplo, supongamos que tenías un valor misterioso. Puedo decirte si es un @Number, dándote un @Boolean:",
                "\\misterio: 'secreto!'\nmisterio•#\\",
                "No es un número, así que hice \\⊥\\. Pero, ¿y si verificamos si es @TextType?",
                "\\misterio: 'secreto!'\nmisterio•''\\",
                "¡Obtenemos \\⊤\\!",
                "Soy realmente útil cuando necesitas saber si algún @Name tiene un valor de un tipo particular."
            ],
            "start": "vamos a obtener el valor de $1 primero",
            "finish": "$1[el valor es $2|el valor no es $2]",
            "conflict": {
                "ImpossibleType": "esto no puede ser nunca de este $1"
            },
            "exception": {
                "TypeException": {
                    "description": "valores incompatibles",
                    "explanation": "Esperaba un $1 pero recibí un $2"
                }
            }
        },
        "IsLocale": {
            "name": "es localización",
            "description": "es localización",
            "emotion": "kind",
            "doc": [
                "Te ayudaré a verificar si la audiencia ha seleccionado un idioma o región en particular:",
                "\\🌍/en\\",
                "\\🌍/es-MX\\",
                "Esto es útil si deseas cambiar tu actuación según el idioma elegido."
            ],
            "start": "¿es el idioma $1?"
        },
        "ListAccess": {
            "name": "acceso a lista",
            "emotion": "cheerful",
            "doc": [
                "Trabajo en estrecha colaboración con @List para ayudarles a obtener valores en una posición particular. Así que, por ejemplo, si tuvieras una lista y quisieras su segundo elemento, escribirías:",
                "\\lista: ['pájaro' 'pato' 'pez' 'serpiente']\nlista[2]\\"
            ],
            "start": "vamos a obtener la lista $1 primero",
            "finish": "¡el elemento es $1!"
        },
        "ListLiteral": {
            "name": "lista específica",
            "description": "lista de $1 elementos",
            "emotion": "eager",
            "doc": "Soy una @List específica de valores. Consulta @List para aprender más sobre lo que puedes hacer conmigo.",
            "start": "evaluemos primero los elementos",
            "finish": "¡Creé una lista! $1",
            "item": "elemento"
        },
        "Spread": {
            "name": "expansión de lista",
            "emotion": "serious",
            "doc": [
                "Te ayudo a crear listas con los valores de otras listas. Como esto:",
                "\\lista1: [1 2 3]\nlista2: [4 5 6]\nfinal: [lista1… lista2…]"
            ]
        },
        "MapLiteral": {
            "name": "mapa",
            "description": "mapa de $1 pares",
            "emotion": "kind",
            "doc": "Soy un @Map específico entre claves y valores. Consulta @Map para aprender más sobre cómo soy útil.",
            "start": "evaluemos primero las claves y los valores",
            "finish": "Conecté a todos, $1",
            "conflict": {
                "NotAKeyValue": {
                    "primary": "una de mis claves no tiene un valor",
                    "secondary": "ups, ¿dónde está mi valor?"
                }
            }
        },
        "Match": {
            "name": "$~fósforo",
            "emotion": "curious",
            "doc": [
                "$~¡Soy el más glorioso de todos los controles condicionales! Tomo un valor y lo comparo con cualquier número de casos, y evalúo la expresión correspondiente que coincide.",
                "$~Por ejemplo, si tuviera un @Number y quisiera convertirlo en un @Text, podría hacer algo como esto:",
                "$~\\Número 2\nnúmero ??? 1: 'uno' 2: 'dos' 3: 'tres' '¡más grande!'\\",
                "$~Si ninguno coincide, evalúo la expresión predeterminada que me das.",
                "$~Soy realmente útil para convertir uno de los muchos posibles @Number, @Text o valores más complejos en otra cosa.",
                "$~Puedes usarlo para @Boolean o @None, pero en realidad no pueden ser tantas cosas, por lo que no soy tan útil para esos valores simples."
            ],
            "start": "$~Veamos qué es 1 dólar...",
            "case": "$~Comprobemos esta condición.",
            "finish": "$~Bien, ¡tenemos un valor final!",
            "value": "$~valor",
            "other": "$~por defecto"
        },
        "NumberLiteral": {
            "name": "número específico",
            "description": "$1 $2[$2|]",
            "emotion": "excited",
            "doc": "Soy un @Number específico. Puedes escribirme con cualquier tipo de dígitos de cualquier idioma. Consulta @Number para conocer todo lo que puedo hacer.",
            "start": "¡$1!",
            "conflict": {
                "NotANumber": "Pensé que conocía todos los números, pero no conozco este"
            }
        },
        "InternalExpression": {
            "name": "expresión interna",
            "emotion": "neutral",
            "doc": "¿Cómo me encontraste? Soy una expresión que solo los creadores originales utilizan. Para obtener más información sobre mí, tendrás que hablar con ellos.",
            "start": "expresión secreta"
        },
        "NoneLiteral": {
            "name": "simplemente ninguna",
            "emotion": "neutral",
            "doc": "/@FunctionDefinition aquí. Esto es simplemente @None. ¡Son únicos en su tipo! Consulta @None para aprender más sobre ellos.",
            "start": "… ø"
        },
        "Otherwise": {
            "name": "si no",
            "emotion": "curious",
            "doc": [
                "/@FunctionDefinition aquí. Esta es una forma práctica de verificar si un valor es @None, y si lo es, proporcionar un valor de respaldo./",
                "/Por ejemplo, si tienes un valor que podría ser un @Number o @None, @Otherwise ayuda a dar un número predeterminado:",
                "\\quizásNúmero•#|ø: 1 quizásNúmero ?? 0\\"
            ],
            "start": "ø ??",
            "finish": "… $1"
        },
        "Previous": {
            "name": "anterior",
            "emotion": "serious",
            "doc": [
                "¿Alguna vez has querido recordar el pasado?",
                "Soy el archivista oficial del Universo. Dame un stream y un número para mirar hacia atrás y te diré cuál fue el valor de ese stream en la historia.",
                "Por ejemplo, esto es lo que era @Time hace cinco ticks:",
                "\\← 5 Tiempo(1000ms)\\",
                "¿Ves cómo es @None durante 5 segundos, y luego de repente un tiempo anterior?",
                "Si quieres los últimos varios valores, dame dos flechas, e interpretaré el número como un recuento:",
                "\\←← 5 Tiempo(1000ms)\\",
                "¿Ves cómo son los cinco tiempos anteriores, en lugar de solo uno?",
                "Soy útil cuando quieres crear actuaciones que dependen del pasado."
            ],
            "start": "primero obtener $1",
            "finish": "evaluado al valor del stream $1"
        },
        "Program": {
            "name": "programa",
            "emotion": "serious",
            "doc": [
                "Soy donde comienza y termina una actuación, conteniendo a todos los demás personajes que coreografían un espectáculo.",
                "¿Sabes cómo @Block evalúa una lista de expresiones y se evalúa como la última en su lista?",
                "Soy lo mismo, pero en lugar de dar mi valor a cualquier expresión en la que esté, pongo el valor en @Stage.",
                "El valor puede ser cualquier cosa: un @Number, @Text o @Boolean, un @List, @Set, @Map, o incluso algo más complejo, como un @Phrase, @Group o @Stage.",
                "Si no me das un valor para mostrar en el escenario, te preguntaré por uno.",
                "Si hay un problema durante una actuación, mostraré ese problema.",
                "Y si tu actuación depende de un *flujo*, lo reevaluaré cada vez que ese flujo cambie."
            ],
            "unevaluated": "el nodo que elegiste no se evaluó",
            "start": "$1[$1 el flujo cambió a $2|es mi primera evaluación]",
            "halt": "se encontró una excepción, deteniéndose",
            "finish": "todo listo, me evalué como $1",
            "done": "no hay nada evaluando",
            "exception": {
                "BlankException": {
                    "description": "programa vacío",
                    "explanation": "¡Vamos a hacer un espectáculo! ¿Dónde deberíamos comenzar?"
                },
                "EvaluationLimitException": {
                    "description": "límite de evaluación",
                    "explanation": "@Evaluate y yo estamos cansados de evaluar, especialmente $1.\n\n¿Es posible que $1 se esté evaluando a sí mismo para siempre, sin detenerse nunca?"
                },
                "StepLimitException": {
                    "description": "límite de pasos",
                    "explanation": "hay tantos. pasos. -- ¡demasiados para terminar! ¿Puedes hacer que la actuación sea más sencilla?"
                },
                "ValueException": {
                    "description": "valor faltante",
                    "explanation": "¡Esperaba un valor pero no obtuve ninguno!"
                }
            }
        },
        "PropertyBind": {
            "name": "ajustar",
            "description": "ajustar $1[$1|nombre faltante]",
            "emotion": "kind",
            "doc": [
                "A veces, cuando haces una @StructureDefinition, quieres cambiar la cosa más pequeña al respecto, sin tener que hacer una nueva con todos los mismos valores.",
                "Por ejemplo, ¿qué pasa si estás llevando un registro de gatos, pero luego quieres crear una copia de un gato con un pasatiempo diferente? Puedo ayudarte a cambiarlo:",
                "\\•Gato(nombre•'' color•'' pasatiempo•'')\n\ngatito: Gato('sprinkles' 'naranja' 'lamiendo')\ngatito.pasatiempo:'ronroneando'\\",
                "¡Eso es mucho más fácil que hacer un nuevo \\Gato\\ con los mismos valores excepto por el pasatiempo, ¿verdad?"
            ],
            "start": "primero obtengamos el valor",
            "finish": "Copié la estructura, pero con $1 como $2",
            "conflict": {
                "InvalidProperty": {
                    "primary": "$~No soy un insumo de $1, por lo que no puedo ser refinado.",
                    "secondary": "$~No tengo una entrada llamada $1"
                }
            }
        },
        "PropertyReference": {
            "name": "propiedad",
            "description": "propiedad $1[$1|nombre faltante]",
            "emotion": "kind",
            "doc": [
                "Cuando haces una @StructureDefinition, ¿cómo obtienes uno de sus inputs? Soy cómo",
                "Como si tuvieras una estructura sobre ciudades, podrías obtener sus valores conmigo así:",
                "\\•Ciudad(nombre•'' población•#personas)\n\nportland: Ciudad('Portland' 800000personas)\n\nportland.población\\"
            ],
            "start": "primero obtengamos el valor",
            "finish": "se encontró la propiedad $1, es $2",
            "property": "propiedad"
        },
        "Reaction": {
            "name": "reacción",
            "emotion": "excited",
            "doc": [
                "¡Los streams son increíbles! Puedo crear nuevos basados en cuando cambian, ¡lo cual es súper genial!",
                "Como, si quisieras que @Time avanzara, pero para mostrar palabras en lugar de números, podrías hacer algo así:",
                "\\tiempo: Tiempo(1000ms)\n'inicio' … ∆ tiempo … ((tiempo % 2) = 0ms) ? 'par' 'impar'\\",
                "Eso es como decir \"/comienza con la palabra 'inicio' y luego si el tiempo cambia, cambia a 'par' o 'impar', según el tiempo./\"",
                "Entonces, soy como un stream, pero uno basado en otros streams. ¿Increíble, verdad?"
            ],
            "start": "veamos si debemos actualizar el stream",
            "finish": "el nuevo valor del stream es $1",
            "initial": "inicial",
            "condition": "condición",
            "next": "siguiente",
            "conflict": {
                "ExpectedStream": "$1 no referencia un stream, ¡así que nunca reaccionaré!"
            }
        },
        "Reference": {
            "name": "referencia",
            "description": "$1",
            "emotion": "shy",
            "doc": [
                "¿Sabes cómo @Bind le da a las cosas @Name? Soy cómo te refieres a ellas. Verifico si algún @Bind tiene ese nombre, si es así, te doy su valor. Como esto:",
                "\\loro: 'polly'\nloro\\",
                "Si no encuentro el nombre, entonces no sé qué hacer.",
                "\\loro: 'polly'\nperry\\"
            ],
            "start": "¿qué valor tiene $1?",
            "conflict": {
                "UnknownName": {
                    "conflict": "$1[No conozco a nadie llamado $1 en $2[$2|este @Block]|¿Puedes darme un nombre?]",
                    "resolution": "$~¿Quisiste decir *$1*?"
                },
                "ReferenceCycle": "um, el valor de $1 depende de sí mismo, ¿cómo sé qué valor darle?",
                "UnexpectedTypeVariable": "No sé qué hacer con estos inputs de tipo"
            },
            "exception": {
                "NameException": {
                    "description": "nombre desconocido",
                    "explanation": "$1[No conozco a nadie llamado $1 en $2[$2|este @Block]…|¡Ay, sin nombre!]"
                }
            }
        },
        "Select": {
            "name": "seleccionar",
            "emotion": "excited",
            "doc": [
                "A veces tienes una tabla y solo quieres parte de ella. ¡Puedo conseguirlo para ti!",
                "Como, ¿y si tuvieras una tabla de jugadores en un juego y quisieras encontrar a los que tienen 10 o más puntos para ver quién ganó:",
                "\\jugadores: ⎡nombre•'' equipo•'' puntos•#⎦\n⎡'jen' 'rojo' 8⎦\n⎡'javier' 'azul' 11⎦\n⎡'juan' 'rojo' 9⎦\n⎡'juanita' 'azul' 7⎦\njugadores ⎡? nombre ⎦ puntos ≥ 10\\",
                "Así, de esa manera, ¡obtuve una lista de filas de ganadores! Solo recuerda que no cambio la tabla, hago una nueva. Tendrás que decidir dónde guardarla."
            ],
            "start": "primero obtengamos la tabla",
            "finish": "¡Hice una nueva tabla solo con las filas y columnas seleccionadas!",
            "conflict": {
                "ExpectedSelectName": "Necesito al menos un nombre de columna."
            }
        },
        "SetLiteral": {
            "name": "conjunto específico",
            "description": "$1 elementos",
            "emotion": "eager",
            "doc": "Soy un @Set específico de valores específicos. Mira @Set para aprender más sobre cómo trabajar conmigo.",
            "start": "¡evaluemos los valores primero!",
            "finish": "¡Hice un conjunto $1!"
        },
        "SetOrMapAccess": {
            "name": "acceso a conjunto/mapa",
            "emotion": "kind",
            "doc": [
                "Puedo ver si un @Set o @Map tiene un valor o clave.",
                "No es tan difícil. Como esto:",
                "\\favoritos: {'pato' 'ganso' 'mono'}\nfavoritos{'ratón'}\\",
                "O esto, con un @Map:",
                "\\favoritos: {'macarrones con queso': 5estrellas 'cereal': 2estrellas 'gachas': 1estrella}\nfavoritos{'gachas'}\\"
            ],
            "start": "¿cuál es el conjunto o mapa?",
            "finish": "el valor es $1",
            "conflict": {
                "IncompatibleKey": {
                    "primary": "Esperaba una clave $1",
                    "secondary": "Obtuve un $1 en lugar de un $2"
                }
            }
        },
        "Source": {
            "name": "fuente",
            "emotion": "curious",
            "doc": [
                "¡Oh, conoces @Program? Te ayudo a nombrarlos. Piensa en mí como la ventana alrededor de un @Program y el nombre que les das.",
                "También puedes hacer otros @Source @UI/addSource, con otros @Program, y @Borrow cosas de esos otros @Program para usar en otro programa.",
                "Esto puede ser una buena manera de organizar una gran actuación en documentos separados."
            ]
        },
        "StreamDefinition": {
            "name": "stream",
            "emotion": "curious",
            "doc": "Creo que se supone que debo hacer nuevos streams. Pero realmente no sé cómo hacer eso. Por ahora, supongo que solo usa los streams que existen, ¿eh?",
            "start": "crea este nuevo tipo de stream"
        },
        "StructureDefinition": {
            "name": "estructura",
            "description": "estructura $1",
            "emotion": "kind",
            "doc": [
                "Hola, ¿cómo estás? ¿Yo? Estoy genial. Me encanta definir estructuras que almacenan valores y funciones, así que mientras pueda hacer eso todo el día, soy feliz.",
                "Trabajo así:",
                "\\•Pizza(\ningredientes•['']\ntamaño•#in\n) (\n\tƒ costo() tamaño · 10dólares/pulgada\n)\n\nPizza(['pepperoni' 'pimientos'] 12pulg).costo()\\",
                "¿Ves cómo funciona? Definí \\Pizza\\, que tiene dos entradas, \\ingredientes\\ (una lista de @Text) y \\tamaño\\ (un número en pulgadas).",
                "Dentro, @FunctionDefinition creó una función que evalúa el costo de una pizza, asumiendo $$10 por pulgada.",
                "No necesito tener @FunctionDefinition en mí. Puedo ser solo entradas.",
                "\\•Pizza(\ningredientes•['']\ntamaño•#in\n)\\",
                "También puedo tener @Bind dentro, así que podríamos evaluar el costo de antemano.",
                "\\•Pizza(\ningredientes•['']\ntamaño•#in\n) (\n\tcosto: tamaño · 10dólares/pulgada\n)\n\nPizza(['pepperoni' 'pimientos'] 12pulg).costo\\"
            ],
            "start": "definamos esta encantadora estructura",
            "conflict": {
                "DisallowedInputs": "No puedo tener entradas porque una o más de mis funciones de interfaz no están implementadas",
                "IncompleteImplementation": "mis funciones deben estar todas implementadas o ninguna. ¡Nada de mezclas confusas!",
                "NotAnInterface": "No soy una interfaz; una estructura solo puede implementar interfaces, no otras estructuras",
                "UnimplementedInterface": "Implemento $1 pero no he implementado $2"
            }
        },
        "StructureDefinitionType": {
            "name": "$~definición de estructura",
            "emotion": "kind",
            "description": "$~definicion de $1",
            "doc": [
                "$~Me refiero a algún tipo de @StructureDefinition. La gente no suele referirse a mí directamente."
            ]
        },
        "TableLiteral": {
            "name": "tabla específica",
            "description": "tabla de $1 filas",
            "emotion": "angry",
            "doc": "Soy una tabla específica con filas específicas. Mira @Table para saber cómo puedo ayudar.",
            "start": "primero evalúa las filas",
            "finish": "evaluado como nueva tabla $1"
        },
        "TextLiteral": {
            "name": "texto específico",
            "description": "texto $1",
            "emotion": "serious",
            "doc": "Represento una o más traducciones específicas de texto. ¡Consulta @Text para aprender más sobre lo que puedo hacer!",
            "start": "creemos texto en el idioma actual"
        },
        "Translation": {
            "name": "traducción",
            "description": "traducción $1",
            "emotion": "serious",
            "doc": "Represento algún texto, con una etiqueta @Language. ¡Consulta @Text para aprender más!",
            "conflict": {
                "phone": "¿Es *$1* el número de teléfono de alguien? ¡No me compartas en línea si es así!\n\n$2",
                "email": "¿Es *$1* el correo electrónico de alguien? ¡No me lo compartas aquí si es así!\n\n$2",
                "tin": "¿Es *$1* un identificador fiscal? Si es así, ¡definitivamente no me compartas, soy información muy sensible!\n\n$2",
                "address": "¿Es *$1* la dirección de la casa de alguien? Si es así, no me pongas aquí, ¡no queremos que nadie sea acosado!\n\n$2",
                "handle": "¿Es *$1* tu nombre de usuario en algún otro lugar de Internet? Si es así, no me lo compartas aquí a menos que realmente lo desees.\n\n$2",
                "resolution": "Esto no es información sensible",
                "reminder": "$~Nota: Puedes deshacer esta acción y ver otras cosas que hayas marcado como no confidenciales en el cuadro de diálogo para compartir."
            }
        },
        "FormattedLiteral": {
            "name": "texto formateado",
            "description": "texto $1",
            "emotion": "serious",
            "doc": "Represento muchas @FormattedTranslation diferentes de texto formateado. Cuando evalúo, elegiré la mejor coincidencia según los idiomas seleccionados por la audiencia.",
            "start": "creemos texto en el idioma actual"
        },
        "FormattedTranslation": {
            "name": "texto formateado",
            "description": "texto $1",
            "emotion": "serious",
            "doc": [
                "Represento algún texto formateado, con una etiqueta @Language.",
                "Puedo ser:",
                "\\`/cursiva/`\\",
                "\\`*negrita*`\\",
                "\\`^extra negrita^`\\",
                "\\`_subrayado_`\\",
                "\\`<enlace@https://wordplay.dev>`\\",
                "\\`\\'código'\\`\\",
                "Trabajo muy bien con @Phrase para poner texto hermoso en @Stage."
            ]
        },
        "This": {
            "name": "esto",
            "emotion": "serious",
            "doc": [
                "A veces, es útil referirse a un valor implícitamente, en lugar de tener que nombrarlo.",
                "Por ejemplo, supongamos que quieres crear una nueva @ConversionDefinition, que no nombra el valor que se está convirtiendo. Puedes referirte a él conmigo:",
                "\\→ #arcoiris #alegrías . · 1000000alegrías\n2arcoiris → #alegrías\\",
                "¿Me ves ahí, representando la cantidad de arcoíris?",
                "O supongamos que quieres hacer una @Reaction, pero no quieres nombrar el valor más reciente:",
                "\\2 … ∆ Tiempo(1000ms) … . · 2\\",
                "Échame un vistazo, representando el valor de reacción anterior.",
                "No aparezco a menudo, pero cuando lo hago, ¡puedo ayudar realmente a un valor a salir de un @Bind!"
            ],
            "start": "evaluado como $1",
            "conflict": {
                "MisplacedThis": "Solo se me permite en una estructura, conversión o reacción."
            }
        },
        "UnaryEvaluate": {
            "name": "evaluación unaria",
            "description": "$1",
            "emotion": "kind",
            "doc": [
                "¿Sabías que cuando estoy evaluando un @FunctionDefinition con solo un valor, y el nombre del @FunctionDefinition es solo un símbolo, puedes poner el nombre antes de la entrada?",
                "Así:",
                "\\-(1 + 1)\\",
                "O así:",
                "\\~⊥\\",
                "Esos son mucho más fáciles de leer que \\(1 + 1).negate()\\ o \\⊥.no()\\, ¿verdad?",
                "No tienes que escribirme de esa manera, pero podría ser más fácil en general.",
                "Solo hay una regla: no puedes poner ningún espacio entre el nombre y el valor. De lo contrario, podrías estar creando un @Reference o @BinaryEvaluate."
            ],
            "start": "¿cuál es el valor?",
            "finish": "Lo hice $1"
        },
        "UnparsableExpression": {
            "name": "no parsable",
            "emotion": "excited",
            "doc": [
                "/Hola @FunctionDefinition aquí. Estoy traduciendo para @UnparsableExpression, ya que a menudo son difíciles de interpretar./",
                "jkwel fjiwojvioao jjiweo jrfe",
                "/No todas las expresiones tienen sentido en el escenario./",
                "s w ieorjwei iojwi jfkdlsfdsk",
                "/De hecho, hay todo tipo de cosas que puedes decir que no tienen sentido en absoluto./",
                "dsk sdlk jdkfiewipapweiurb,v kdsfdsf",
                "/Cuando lo haces, aparezco, porque no sé lo que quisiste decir./",
                "Eres el director después de todo, así que solo tú sabes lo que podrías haber querido decir."
            ],
            "start": "???",
            "conflict": {
                "UnparsableConflict": {
                    "conflict": "@FunctionDefinition aquí, @UnparsableExpression no sabe qué tipo de $1[ expresión | tipo ] es esto/",
                    "resolution": "$~¿Quiso decir $1, $2?"
                },
                "UnclosedDelimiter": "Esperaba $2 en algún momento después de $1"
            },
            "exception": {
                "UnparsableException": {
                    "description": "???",
                    "explanation": "/¡Hola, @FunctionDefinition aquí! Tuvimos que detener la actuación porque no sabíamos qué tipo de instrucción es esta./"
                }
            }
        },
        "Update": {
            "name": "actualización",
            "emotion": "kind",
            "doc": [
                "Ayudo a revisar una @Table, encontrando las filas que coinciden con una condición y luego creando filas revisadas con nuevos valores.",
                "Entonces, por ejemplo, si tuvieras una tabla de personajes y puntos, y quisieras darle un punto a cada personaje de un equipo, podrías hacer esto:",
                "\\jugadores: ⎡nombre•'' equipo'' puntos#⎦\n⎡'jen' 'rojo' 1⎦\n⎡'javier' 'azul' 0⎦\n⎡'juan' 'rojo' 3⎦\n⎡'juanita' 'azul' 2⎦\njugadores ⎡: puntos: puntos + 1 ⎦ equipo = 'azul'\\",
                "Puedes usar un @Bind para decir qué columnas cambiar, y puedes usar cualquiera de los nombres de columna u otros nombres en el ámbito en la condición."
            ],
            "start": "vamos a obtener la tabla primero",
            "finish": "¡evaluado como una nueva tabla con filas revisadas!",
            "conflict": {
                "ExpectedColumnBind": "Necesito un valor para cada columna",
                "IncompatibleCellType": {
                    "primary": "Necesitaba un $1, pero obtuve un $2",
                    "secondary": "Obtuve un $2"
                }
            }
        },
        "AnyType": {
            "name": "cualquier tipo",
            "emotion": "curious",
            "doc": "Represento cualquier tipo posible. A veces aparezco porque no sé qué tipo de valor es algo, así que podría ser cualquier cosa."
        },
        "BooleanType": {
            "name": "booleano",
            "emotion": "kind",
            "doc": [
                "Trabajo con @Bind para declarar que un nombre es un valor @Boolean. Como esto:",
                "\\hambriento•?: 'gelatina'\\",
                "Si quieres estar seguro de que algo es @Boolean, úsame y ¡lo comprobaré!"
            ]
        },
        "ConversionType": {
            "name": "conversión",
            "emotion": "serious",
            "doc": [
                "Trabajo con @Bind para indicar que un nombre es una @ConversionDefinition. Probablemente no necesites usarme, porque no mucha gente me pasa como un valor, pero si lo hicieras, se vería así:",
                "\\magia•?→'': → ? '' . ? 'sí' 'no'\\"
            ]
        },
        "FormattedType": {
            "name": "formateado",
            "emotion": "serious",
            "doc": [
                "Trabajo con @Bind para indicar que un nombre es un valor @FormattedLiteral. Como esto:",
                "\\hambriento•`…`: `¡Soy tan /elegante/!`\\",
                "¿Quieres asegurarte de que algo sea un valor @FormattedLiteral? Así es como te aseguras."
            ]
        },
        "ExceptionType": {
            "name": "excepción",
            "emotion": "neutral",
            "doc": "Represento una excepción. No hay forma de decirle a @Bind que soy una, porque las excepciones solo detienen @Program, así que no puedes usarlas como valores."
        },
        "FunctionType": {
            "name": "tipo de función",
            "description": "función con $1 entradas, $2 salida",
            "emotion": "curious",
            "doc": [
                "Represento una @FunctionDefinition. ¡Soy realmente útil si quieres decir qué tipo de función tiene un @Bind! Como esto:",
                "\\math•ƒ (# # # #) #: ƒ interesante(a•# b•# c•# d•#) a + b + c + d\\"
            ]
        },
        "ListType": {
            "name": "tipo de lista",
            "description": "$1[lista de $1|lista]",
            "emotion": "cheerful",
            "doc": [
                "¡Soy /tan/ fan de @List! ¡Puedo decirle a @Bind qué tipo de lista son! Como esto, estoy diciendo que es una lista de @Number:",
                "\\cosas•[#]: [ 1 2 3 4 5 ]\\"
            ]
        },
        "MapType": {
            "name": "tipo de mapa",
            "description": "mapa de $1[$1|cualquier] a $2[$2|cualquier]",
            "emotion": "kind",
            "doc": [
                "¿Sabes lo increíble que es @Map? Muy increíble. Le digo a @Bind qué tipo de mapa son todo el tiempo, como este mapa de números a listas:",
                "\\cosas•{'':[]}: {}\\"
            ]
        },
        "NumberType": {
            "name": "tipo de número",
            "description": "$1[$1 | número]",
            "emotion": "precise",
            "doc": [
                "¿Sabes qué debería ser @Bind? Un @Number. Porque los números son lo mejor.",
                "\\conteo•#: 17\\"
            ]
        },
        "NameType": {
            "name": "tipo de nombre",
            "description": "$1 tipo",
            "emotion": "curious",
            "doc": [
                "Represento una @StructureDefinition por su nombre. Entonces, si tuvieras una estructura como esta, podrías hacer un @Bind que almacene los valores que crea.",
                "\\•Amigo(nombre•'')\nmejorAmigo•Amigo: Amigo('Jonah')\\"
            ],
            "conflict": {
                "UnknownTypeName": "los nombres de tipo solo pueden referirse a estructuras o variables de tipo, pero esto se refiere a un $1"
            }
        },
        "NeverType": {
            "name": "tipo nunca",
            "emotion": "curious",
            "doc": "Represento un tipo que es imposible. Como cuando preguntas a @Is si algo es un @Number, pero nunca puede ser un número."
        },
        "NoneType": {
            "name": "tipo nulo",
            "emotion": "neutral",
            "doc": [
                "@None es el mejor nada que hay, y yo soy su fiel representante.",
                "\\espacio•ø: ø\\"
            ]
        },
        "SetType": {
            "name": "tipo de conjunto",
            "description": "$1[tipo de conjunto|$1 set]",
            "emotion": "kind",
            "doc": [
                "@Set es lo MEJOR, en serio. ¡Le digo a @Bind todo el tiempo, haz cosas un conjunto de algo!",
                "\\único•{''}: {'algo' 'cualquier cosa' 'alguien'}\\"
            ]
        },
        "StreamDefinitionType": {
            "name": "tipo de definición de flujo",
            "emotion": "angry",
            "doc": "Represento un flujo que has definido, lo cual no es posible, así que ¿por qué incluso estás leyendo esto?"
        },
        "StreamType": {
            "name": "tipo de flujo",
            "emotion": "curious",
            "doc": [
                "Celebro la belleza y el significado de los flujos... diciéndole a @Bind que los almacene:",
                "\\tiempo•…#ms: Tiempo()\\"
            ]
        },
        "StructureType": {
            "name": "tipo de estructura",
            "description": "$1",
            "emotion": "kind",
            "doc": "Soy un tipo interno para representar el tipo de tipos de valores predeterminados."
        },
        "UnknownType": {
            "name": "tipo desconocido",
            "connector": ", porque ",
            "emotion": "curious",
            "doc": "Mmm... no sé qué represento, pero realmente tengo curiosidad. ¿Tú sabes? Parece que deberíamos saberlo. Es posible que necesites decirnos si no podemos entenderlo."
        },
        "TableType": {
            "name": "tipo de tabla",
            "emotion": "angry",
            "doc": "Represento una tabla.",
            "conflict": {
                "ExpectedColumnType": "Necesito un tipo de columna"
            }
        },
        "TextType": {
            "name": "tipo de texto",
            "description": "$1[$1|texto]",
            "emotion": "happy",
            "doc": [
                "Fabulosamente represento el tipo más fabuloso de valor que existe, @Text.",
                "\\historia•'': 'Érase una vez...'\\"
            ]
        },
        "TypePlaceholder": {
            "name": "tipo de marcador de posición",
            "emotion": "eager",
            "doc": "Espero representar un tipo algún día, ¡algo así como mi mejor amigo @ExpressionPlaceholder representa una expresión! ¿Me ayudarás a decidir qué tipo ser?"
        },
        "UnionType": {
            "name": "tipo de opción",
            "description": "$1 | $2",
            "emotion": "curious",
            "doc": [
                "¿A quién debería representar, A o B o algo más? ¡Nunca puedo decidir!",
                "\\indecisión•''|#|{ø}: \"¡No lo sé!\"\\"
            ]
        },
        "Unit": {
            "name": "unidad",
            "description": "$1",
            "emotion": "precise",
            "doc": [
                "Represento cualquier unidad que pueda tener un @Number, incluida la ausencia de unidad, hasta la unidad más complicada que puedas imaginar. Como la gravedad, por ejemplo:",
                "\\gravedad•m/s^2: 9.8m/s^2\\",
                "Aparezco en @Bind, pero también justo después de @Number. Ayudo a asegurarme de que los números sean del mismo tipo y definitivamente te diré si no lo son, ¡en caso de que sea un error!"
            ]
        },
        "TypeInputs": {
            "name": "entradas de tipo",
            "emotion": "curious",
            "doc": "Soy una lista de tipos que ocupan el lugar de @TypeVariables en una @StructureDefinition o @FunctionDefinition. Ayudo a todos a saber qué tipo de entradas recibirán."
        },
        "TypeVariable": {
            "name": "variable de tipo",
            "emotion": "curious",
            "doc": "Soy un tipo misterioso en @FunctionDefinition o @StructureDefinition, proporcionado por @TypeInputs cuando se evalúa cualquiera de ellos. @Set, @List y @Map me utilizan.",
            "conflict": {
                "DuplicateTypeVariable": {
                    "primary": "Tengo el mismo nombre que $1",
                    "secondary": "Tengo el mismo nombre que $1"
                }
            }
        },
        "TypeVariables": {
            "name": "variables de tipo",
            "emotion": "curious",
            "doc": "Soy una lista de @TypeVariable."
        },
        "UnparsableType": {
            "name": "tipo no interpretable",
            "emotion": "curious",
            "doc": "Represento el tipo de una expresión desconocida. Aparezco cuando intentas usar esa expresión para algo."
        },
        "VariableType": {
            "name": "tipo de variable",
            "emotion": "curious",
            "doc": "¿Conoces a @TypeVariable y cómo representan algún tipo desconocido de valor? Los represento en todas las negociaciones entre valores."
        },
        "CycleType": {
            "name": "tipo de ciclo",
            "description": "depende de sí mismo",
            "emotion": "curious",
            "doc": "A veces los valores dependen de sí mismos, y así no sabemos qué tipo de valor son. Represento esa situación."
        },
        "UnknownVariableType": {
            "name": "tipo de variable desconocida",
            "emotion": "curious",
            "doc": "A veces intentamos adivinar qué tipo de valor es algo; aparezco cuando no lo sabemos."
        },
        "NotAType": {
            "name": "tipo inesperado",
            "description": "no es un $1",
            "emotion": "curious",
            "doc": "A veces sabemos qué tipo de valor debería ser algo. Como @ListAccess necesita un @Number. Si no lo obtenemos, represento que algo es un tipo diferente al esperado."
        },
        "NoExpressionType": {
            "name": "tipo sin expresión",
            "emotion": "angry",
            "doc": "¿Sabes cómo @Block necesita al menos una expresión? Soy lo que obtienes cuando no das una. ¡Así que da una!"
        },
        "NotEnclosedType": {
            "name": "fuera de estructura, conversión o reacción",
            "emotion": "curious",
            "doc": "@This, por geniales que sean, solo pertenecen a lugares particulares. Aparezco cuando se pierden, y así nadie sabe qué valor representan."
        },
        "NotImplementedType": {
            "name": "no implementado",
            "emotion": "curious",
            "doc": "Cuando usas @ExpressionPlaceholder, pero no dices de qué tipo son, soy el tipo que obtienes. ¡Lídia con ello!"
        },
        "UnknownNameType": {
            "name": "nombre desconocido",
            "description": "$1[$1 no está definido | no se dio un nombre]",
            "emotion": "curious",
            "doc": "¿Sabes cómo a veces @Reference y @PropertyReference no conocen el nombre del que estás hablando? Estoy presente cuando eso sucede, para representar que no sabemos de quién estás hablando."
        },
        "NonFunctionType": {
            "name": "no es una función",
            "description": "no es una función",
            "emotion": "confused",
            "doc": "Algunos de nosotros esperábamos funciones; aparezco cuando no obtenemos una."
        }
    },
    "basis": {
        "Boolean": {
            "doc": [
                "Nosotros somos \\T\\ y \\⊥\\. \\T\\ es verdadero. \\⊥\\ is falso. \\T\\ no es \\⊥\\; \\⊥\\ no es \\T\\. Asi funcionamos"
            ],
            "name": ["T⊥", "Booleano"],
            "function": {
                "and": {
                    "doc": [
                        "Yo evaluo a \\T\\ *solo* cuando los dos valors son \\T\\.Útil para determinar si muchas cosas son verdadero. Solo hay cuatro resultados posibles",
                        "\\T & T\\",
                        "\\T & ⊥\\",
                        "\\⊥ & T\\",
                        "\\⊥ & ⊥\\"
                    ],
                    "names": ["y", "&"],
                    "inputs": [
                        {
                            "doc": "El otro @Boolean a evaluar. Si el primer valor es \\⊥\\, no importa el resto de valores, la funcion siempre va a evaluar a \\⊥]\\.",
                            "names": "valor"
                        }
                    ]
                },
                "or": {
                    "doc": [
                        "Yo evaluo a \\T\\ cuando *cualquier* valor es \\T\\. Útil para determinar si one de muchas cosas es verdadero. Solo hay cuatro resultados posibles",
                        "\\T & T\\",
                        "\\T & ⊥\\",
                        "\\⊥ & T\\",
                        "\\⊥ & ⊥\\"
                    ],
                    "names": ["o", "|"],
                    "inputs": [
                        {
                            "doc": "El otro @Boolean a evaluar. Si el primer valor es \\⊥\\, la funcion solo evaluara a \\T\\ si esto es \\T\\.",
                            "names": "valor"
                        }
                    ]
                },
                "not": {
                    "doc": "Yo devuelvo lo opuesto a mi: si \\T\\, devuelvo \\⊥\\, si \\⊥\\, devuelvo \\T\\",
                    "names": ["no", "~"],
                    "inputs": []
                },
                "equals": {
                    "doc": "\\T\\ si los dos son \\T\\ or los dos son \\⊥\\.",
                    "names": ["=", "igual"],
                    "inputs": [
                        {
                            "doc": "El otro valor para evaluar",
                            "names": "value"
                        }
                    ]
                },
                "notequal": {
                    "doc": "\\T\\ si los dos son opuestos",
                    "names": "noIgual",
                    "inputs": [
                        {
                            "doc": "El otro valor para evalar.",
                            "names": "valor"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "Convierte un @Boolean a el equivalente valor de @Text \\'⊤'\\ and \\'⊥'\\"
            }
        },
        "None": {
            "doc": [
                "/Hi, @FunctionDefinition  aqui. @None no le gusta hablar mucho, so interpretare./",
                "Yo soy @None. Invocame con \\ø\\. Yo soy util cuando quieres representar al ausencia de algo."
            ],
            "name": ["ø", "none"],
            "function": {
                "equals": {
                    "doc": "Es otro valor tambien nada? Mas vale, de otra manera, \\⊥\\.",
                    "names": ["=", "igual"],
                    "inputs": [
                        {
                            "doc": "El otro valor",
                            "names": "valor"
                        }
                    ]
                },
                "notequals": {
                    "doc": "Es el otro valor /no/ nada?",
                    "names": ["≠", "noIgual"],
                    "inputs": [
                        {
                            "doc": "El otro valor",
                            "names": "valor"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "Queres hacer \\ø\\ a '\\ø\\'? Esta es tu oportunidad."
            }
        },
        "Text": {
            "doc": [
                "Yo puedo ser cualquier texto que tu quieras, en cualquier idioma, y usando cualquiera de estos simbolos de abrir y cerra: \\\"\"\\, \\“”\\, \\„“\\, \\''\\, \\‘’\\, \\‹›\\, \\«»\\, \\「」\\, or \\『』\\.",
                "Para ilustrar, considera una de estas bonitas frases.",
                "\\“Solo hay dos maneras de vivir la vidad. Una es como si nada fuera un milagro. La otra es como si todo fuera un milagro.”\\",
                "Solo recuerada de cerrarme si me abres, y usa el simbolo coincidente. Si no es asi, no sabre que has terminado con tus palabras.",
                "\\'hola' /es-MX 'hello' /en\\",
                "Tambine me puedes etiquetar con idiomas, y tambien me puedes pasar multiples traducciones. Yo evaluare a cualquier idioma que este actualmente seleccionado.",
                "Si tu quieres crearme con otro tipo de valores, puedes utilizar un simbolo",
                "Por ejemplo:",
                "\\\"Mira estas sumas \\1 + 2\\, \\2 + 3\\, \\3 + 4\\\"\\",
                "Mira que elegante yo evaluo esas sumas, y la pongo adentro del @Text",
                "De cual quier manera, hay muchas funciones gloriosas que @FunctionDefinition a hecho para mi, para poder hacer todo tipo de cosas con palabras!"
            ],
            "name": ["''", "Texto"],
            "function": {
                "length": {
                    "doc": [
                        "Yo evaluo el numero de caracteres legibles en el texo; una letra es un caracter, un emotico es un caracter, etx. Por ejemplo:",
                        "\\'hola'.longitud()\\",
                        "\\'🐈📚'.longitud()"
                    ],
                    "names": ["📏", "longitud"],
                    "inputs": []
                },
                "equals": {
                    "doc": "\\T\\ so yo soy la misma sequencia de caracteres en el @Text dado",
                    "names": ["=", "igual"],
                    "inputs": [
                        {
                            "doc": "El @Text para comparar",
                            "names": "valor"
                        }
                    ]
                },
                "notequals": {
                    "doc": "\\T\\ si /no/ soy la misma sequencia de caracteres en el @Text dado",
                    "names": "≠",
                    "inputs": [
                        {
                            "doc": "El @Text para comparar",
                            "names": "valor"
                        }
                    ]
                },
                "repeat": {
                    "doc": [
                        "Creo un nuevo @Text que soy yo, repetido el número de veces de \\count\\:",
                        "\\('hola ' · 5\\)",
                        "Si me das un @Number fraccionario, ignoro la fracción:",
                        "\\('hola ' · 5.5\\)",
                        "Si me das un @Number negativo o cero, doy un @Text vacío.",
                        "\\('hola ' · -5\\)"
                    ],
                    "names": ["·", "🔁", "repetir"],
                    "inputs": [
                        {
                            "doc": "El número de veces que debo repetirme en el nuevo texto.",
                            "names": "contar"
                        }
                    ]
                },
                "segment": {
                    "doc": [
                        "Yo mismo de divido en una @List de @Text, usando el @Text dado como un separador, y removiendo el separador. Por ejemplo:",
                        "\\'manzanas, naranjas, uvas' ÷ ','\\",
                        "Si el separador esta vacio, yo me dividere en caracteres:",
                        "\\'🖌️🏠🥸' ÷ ''\\"
                    ],
                    "names": ["÷", "segmento"],
                    "inputs": [
                        {
                            "doc": "El @Text para usar como separador",
                            "names": "delimitador"
                        }
                    ]
                },
                "has": {
                    "doc": [
                        "\\T\\ si el @Text dado aperence dentro de mi.",
                        "\\'podiste encontras lo que estabas buscando?'.tiene('podiste')\\"
                    ],
                    "names": ["⊆", "tiene"],
                    "inputs": [
                        {
                            "doc": "El @Text para buscarme",
                            "names": "texto"
                        }
                    ]
                },
                "starts": {
                    "doc": "\\T\\ si yo comienzo con el @Text dado.",
                    "names": ["comienza"],
                    "inputs": [
                        {
                            "doc": "El @Text para verificar que comienzo con el",
                            "names": "texto"
                        }
                    ]
                },
                "ends": {
                    "doc": "\\T\\ si el yo termino con el @Text dado",
                    "names": ["termina"],
                    "inputs": [
                        {
                            "doc": "El @Text para verificar si esta al final de mi",
                            "names": "texto"
                        }
                    ]
                },
                "combine": {
                    "doc": [
                        "Hay veces que es util combinar @Text(s) en uno, Dame otro @Text y creare un nuevo texto con nos junte",
                        "\\'hola ' + 'verso'"
                    ],
                    "names": ["+", "combinar"],
                    "inputs": [
                        {
                            "doc": "El texto para adjuntar",
                            "names": "texto"
                        }
                    ]
                }
            },
            "conversion": {
                "list": "Divide el @Text en una isto con los caracteres individuales",
                "number": "Convierte el @Text en un @Number, y si no es un numero, resultara en un valor no numeral"
            }
        },
        "Number": {
            "doc": [
                "Yo creo un @Number, con cualquier numero de unidades que tu te puedas imaginar",
                "Aqui estan mis top 5:",
                "\\0\\",
                "\\1historia\\",
                "\\πtartas\\",
                "\\∞rocas\\",
                "\\10000000abrazos\\",
                "Eso es basicamenete una cantidad infinita de numeros.",
                "Y una cantidad infinita de unidades",
                "Y una cantidad infinita de pares numero/unidad…",
                "Yo puedo ser enteros, numeros reales, negativo, positivo, fraccional, decimal, incluso no un numero",
                "Y me puedes con muchos diferentes systemas de numeros, uncluyendo arabe \\123\\, Romano \\ⅩⅩⅩⅠⅩ\\, Japones \\二十\\, y mas:",
                "\\1 + Ⅰ + 一\\",
                "Tu tambien me puedes escribir en bases 2 a 16 poniendo un numero baso asi:",
                "\\2;11111111\\",
                "\\10;255\\",
                "16;FF\\",
                "Hay un numero especial llamado NaN, que es posible cuando escribes algo que no es un numero:",
                "\\2;22\\",
                "Noy hay un digito '2' en base de 2, entonces no es un numero valido. NaN va a aparecer si tratas de covertir algo que no es un numero a texto",
                "\\'hola'→#\\"
            ],
            "name": ["#", "Numero"],
            "function": {
                "add": {
                    "doc": [
                        "Yo sumo un @Number con mi misma @Unit, creando un nuevo @Number de la misma @Unit",
                        "Por ejemplo:",
                        "\\1 + 1\\",
                        "\\3gatos + 5gatos\\",
                        "Si las unidads no coinciden, yo parare a mostrar \\3gatos + 5gaots\\"
                    ],
                    "names": ["+", "sumar"],
                    "inputs": [
                        {
                            "doc": "El @Number a sumar",
                            "names": "number"
                        }
                    ]
                },
                "subtract": {
                    "doc": [
                        "Yo resto el @Number que me das de yo mismo, creando un nuevo @Number de la mismo @Unit:",
                        "Por ejemplo:",
                        "\\1 - 1\\",
                        "\\3gatos - 5gatos\\",
                        "Si las unidades no coinciden, parare a monstrar.",
                        "\\3gatos - 5perros\\"
                    ],
                    "names": ["-", "subtract"],
                    "inputs": [
                        {
                            "doc": "El @Number a restar",
                            "names": "numero"
                        }
                    ]
                },
                "multiply": {
                    "doc": [
                        "Yo me multiplico por el @Number dado, creando un producto de mi @Unit y la @Unit del numero dado:",
                        "\\5 · 5\\",
                        "5m · 5m\\",
                        "\\5m · 1/s\\"
                    ],
                    "names": ["·", "multiplicar"],
                    "inputs": [
                        {
                            "doc": "El @Number a multiplicar",
                            "names": "numero"
                        }
                    ]
                },
                "divide": {
                    "doc": [
                        "Yo me divido por el @Number dado, creando una cociente de mi @Unit y la unidad del numero dado:",
                        "\\5 ÷ 5\\",
                        "\\5m ÷ 5m\\",
                        "\\5m ÷ 5s\\"
                    ],
                    "names": ["÷", "divide"],
                    "inputs": [
                        {
                            "doc": "El @Number a dividir por",
                            "names": "numero"
                        }
                    ]
                },
                "remainder": {
                    "doc": [
                        "Yo me divido por le @Number dado, pero devuelvo los restante:",
                        "\\10 % 2\\",
                        "\\10m % 2\\",
                        "\\10m/s % 3\\"
                    ],
                    "names": ["%", "resto"],
                    "inputs": [
                        {
                            "doc": "Ell @Number a dividir por",
                            "names": "numero"
                        }
                    ]
                },
                "positive": {
                    "doc": [
                        "Yo creo un @Number nuevo que me hace positivo, si es negativo.",
                        "\\-200.positivo()\\"
                    ],
                    "names": ["positivo"],
                    "inputs": []
                },
                "round": {
                    "doc": [
                        "Yo creo un @Number nuevo que me rondea a el intero mas cercano",
                        "\\9.4.rondear()\\",
                        "\\9.5.rondear()\\",
                        "\\9.6.rondear()\\"
                    ],
                    "names": ["rondear"],
                    "inputs": []
                },
                "roundDown": {
                    "doc": [
                        "Yo creo un nuevo @Number que rondea a entero mas pequeño que yo.",
                        "\\10.5.rondearBajo()\\",
                        "\\10.1.rondearBajo()\\",
                        "\\10.01.rondearBajo()\\"
                    ],
                    "names": ["rondearBajo"],
                    "inputs": []
                },
                "roundUp": {
                    "doc": [
                        "Yo creo un nuevo @Number que rondea a el entero mas grande que yo",
                        "\\10.5.rondearArriba()\\",
                        "\\10.9.rondearArriba()\\",
                        "\\10.99.rondearArriba()\\"
                    ],
                    "names": ["rondearArriba"],
                    "inputs": []
                },
                "power": {
                    "doc": [
                        "Yo me elevo a el poder del @Number dado. Exponentes fracionales son acceptados",
                        "\\2 ^ 8\\",
                        "\\10 ^ -2\\",
                        "\\5 ^ -.5\\"
                    ],
                    "names": ["^", "elevado"],
                    "inputs": [
                        {
                            "doc": "El exponente a elevarme a",
                            "names": "numero"
                        }
                    ]
                },
                "root": {
                    "doc": [
                        "Yo creo la raiz de yo mismo usando la raiz dada.",
                        "\\4 √ 2\\",
                        "\\1000 √ 3\\"
                    ],
                    "names": ["√", "root"],
                    "inputs": [
                        {
                            "doc": "La raiz a computar",
                            "names": "numero"
                        }
                    ]
                },
                "lessThan": {
                    "doc": [
                        "\\T\\ si yo soy menor a @Number dado:",
                        "\\1 < 2\\",
                        "\\2 < 1\\"
                    ],
                    "names": ["<", "menorQue"],
                    "inputs": [
                        {
                            "doc": "El @Number a comparar",
                            "names": "numero"
                        }
                    ]
                },
                "lessOrEqual": {
                    "doc": [
                        "\\T\\ si yo soy menor o igual a el @Number dado:",
                        "\\1 ≤ 2\\",
                        "\\2 ≤ 1\\",
                        "\\2 ≤ 2\\"
                    ],
                    "names": ["≤", "lessorequal"],
                    "inputs": [
                        {
                            "doc": "El @Number a comparar",
                            "names": "numero"
                        }
                    ]
                },
                "greaterThan": {
                    "doc": [
                        "\\T\\ si yo soy mayor a el @Number dado:",
                        "\\1 > 2\\",
                        "\\2 > 1\\"
                    ],
                    "names": [">", "greaterthan"],
                    "inputs": [
                        {
                            "doc": "El @Number a comparar",
                            "names": "number"
                        }
                    ]
                },
                "greaterOrEqual": {
                    "doc": [
                        "\\T\\ si yo soy mayor a igual a el @Number dado:",
                        "\\1 ≥ 2\\",
                        "\\2 ≥ 1\\",
                        "\\2 ≥ 2\\"
                    ],
                    "names": ["≥", "greaterorequal"],
                    "inputs": [
                        {
                            "doc": "El @Number a comparar",
                            "names": "numero"
                        }
                    ]
                },
                "equal": {
                    "doc": "\\T\\ si soy igual al @Number dado",
                    "names": "igual",
                    "inputs": [
                        {
                            "doc": "El @Number a comparar",
                            "names": "numero"
                        }
                    ]
                },
                "notequal": {
                    "doc": "\\T\\ si /no/ soy igual al el @Number dado",
                    "names": "≠",
                    "inputs": [
                        {
                            "doc": "El @Number a compara",
                            "names": "numero"
                        }
                    ]
                },
                "cos": {
                    "doc": ["Calcula el coseno", "\\π.cos()\\"],
                    "names": ["cos", "coseno"],
                    "inputs": []
                },
                "sin": {
                    "doc": ["Calcula el seno", "\\π.sin()\\"],
                    "names": ["sin", "seno"],
                    "inputs": []
                },
                "min": {
                    "doc": [
                        "Encuentra el número más pequeño entre yo y otros.",
                        "\\1.min(2 3 -1)\\"
                    ],
                    "names": "mínimo",
                    "inputs": [
                        {
                            "doc": "¡Tantos números como quieras darme!",
                            "names": "números"
                        }
                    ]
                },
                "max": {
                    "doc": [
                        "Encuentra el número más grande entre yo y otros.",
                        "\\1.max(2 3 4)\\"
                    ],
                    "names": "máximo",
                    "inputs": [
                        {
                            "doc": "¡Tantos números como quieras darme!",
                            "names": "números"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "Una representacion Arabe de mis digitos en @Text",
                "list": "Una lista the numeros de 1 a cualquier nomero dado, por ejemplo \n\\10→[]\\.",
                "s2m": "Segundos a minutos",
                "s2h": "Segunados a horas",
                "s2day": "Segundos a dias",
                "s2wk": "Segundos a semanas",
                "s2year": "Segundos a años",
                "s2ms": "Segundos a milisegundos",
                "ms2s": "Millisegundos a segundos",
                "min2s": "Minutos a segundos",
                "h2s": "Horas a segundos",
                "day2s": "Dias a segundos",
                "wk2s": "Semanas a segundos",
                "yr2s": "Años a segundos",
                "m2pm": "Metros a picometros",
                "m2nm": "Metros a nanometros",
                "m2micro": "Metros a micrometers",
                "m2mm": "Metros a milimetros",
                "m2cm": "Metros a centimetros",
                "m2dm": "Metros a decimetros",
                "m2km": "Metros a kilometros",
                "m2Mm": "Metros a megametros",
                "m2Gm": "Metros a gigametros",
                "m2Tm": "Metros a terametros",
                "pm2m": "Picometros a metros",
                "nm2m": "Nanometros a metros",
                "micro2m": "Micrometros a metros",
                "mm2m": "Milimetros a metros",
                "cm2m": "Centimetros a metros",
                "dm2m": "Decimetros a metros",
                "km2m": "Kilometros a metros",
                "Mm2m": "Megametros a metros",
                "Gm2m": "Gigametros a metros",
                "Tm2m": "Terametros a metros",
                "km2mi": "Kilometros a millas",
                "mi2km": "Millas a kilometros",
                "cm2in": "Centimetros a pulgadas",
                "in2cm": "Pulgadas a centimetros",
                "m2ft": "Metros a pies",
                "ft2m": "Pies a metros",
                "g2mg": "Gramos a miligramos",
                "mg2g": "Miligramos a gramos",
                "g2kg": "Gramos a kilogramos",
                "kg2g": "Kilogramos a gramos",
                "g2oz": "Gramos a onzas",
                "oz2g": "Onzas a gramos",
                "oz2lb": "Onzas a libras",
                "lb2oz": "Libras a onzas"
            }
        },
        "List": {
            "doc": [
                "Yo soy una sequencia de valores, de cualquier tipo!",
                "Puedes ponder lo que quieras adentro de mi: @Boolean, @Number, @Text, @None, incluso @List, @Set, @Map, or cualquier otra expresión. Asi seria una simple:",
                "\\['manzana' 'platano' 'mango']\\",
                "Lo que me hace espcial es que yo mantengo las cosas en orden, y yo enumero todo desde el 1 hasta la canditad de elementos que yo tenga",
                "Mis elementos son enumerados, comenzando por el 1. Tu puedes obtener que to tengo con @ListAccess, usando su numero:",
                "Por ejemplo, el segundo valor en esta lista es \\['platano']\\",
                "\\['manzana' 'platano' 'mango'][2]\\",
                "Puedo tener lo que sea adentro de mi. Mira a esta lista con @Text, @Number y @Time",
                "\\['manzana' 10 + 10 Time()]\\",
                "Yo puedo hacer un monton de cosas interesantes con mi @FunctionDefinition"
            ],
            "name": ["[]", "Lista"],
            "kind": "Kind",
            "out": "Result",
            "outofbounds": "outofbounds",
            "function": {
                "add": {
                    "doc": [
                        "Yo puedo crear una nueva @List con el elemento dado"
                    ],
                    "names": "agregar",
                    "inputs": [
                        {
                            "doc": "El valor que tu quiera agregar",
                            "names": "elemento"
                        }
                    ]
                },
                "append": {
                    "doc": [
                        "Creo una nueva @List con mis valores, y luego todos los valores de la @List dada después de mí.",
                        "\\['manzana' 'plátano' 'mango'].append(['sandía' 'carambola'])\\",
                        "Es un poco más fácil usar @Spread, así:",
                        "\\['manzana' 'plátano' 'mango' :['sandía' 'carambola']]\\"
                    ],
                    "names": "adjuntar",
                    "inputs": [
                        {
                            "doc": "La lista de valores para adjuntar",
                            "names": "lista"
                        }
                    ]
                },
                "replace": {
                    "doc": [
                        "Yo creo una nueva listo que reemplaza el value en el índice dado.",
                        "\\['manzana' 'platano' 'mango'].reemplazar(1, 'kiwi')\\"
                    ],
                    "names": ["reemplazar"],
                    "inputs": [
                        {
                            "doc": "El valor del índice a reemplazar",
                            "names": "índice"
                        },
                        {
                            "doc": "El valor de reemplazo",
                            "names": "valor"
                        }
                    ]
                },
                "length": {
                    "doc": "El @Number de elemento adentro de mi.",
                    "names": "longitud",
                    "inputs": []
                },
                "random": {
                    "doc": [
                        "Aleatoriamente seleciona uno de mis elementos, o @None si estoy vacia.",
                        "\\['manzana' 'platano' 'mango'].azar()"
                    ],
                    "names": "azar",
                    "inputs": []
                },
                "shuffled": {
                    "doc": [
                        "$~Haz una nueva lista con los elementos del último ordenados aleatoriamente.",
                        "$~\\['manzana' 'plátano' 'mango'].shuffled()\\"
                    ],
                    "names": "$~barajado",
                    "inputs": []
                },
                "first": {
                    "doc": [
                        "Mi primer valor, o @None si estoy vacia.",
                        "\\['manzana' 'platano' 'mango'].primera()\\"
                    ],
                    "names": "primera",
                    "inputs": []
                },
                "last": {
                    "doc": [
                        "Mi ultimo valor, o @None si estoy vacia.",
                        "\\['manzana' 'platano' 'mango'].ultima()"
                    ],
                    "names": "última",
                    "inputs": []
                },
                "has": {
                    "doc": [
                        "\\T\\ si yo tengo un elemento igual a el elemento dado.",
                        "\\['apple' 'platano' 'mango'].tiene('platano')\\"
                    ],
                    "names": "tiene",
                    "inputs": [
                        {
                            "doc": "El valor a buscar",
                            "names": "elemento"
                        }
                    ]
                },
                "join": {
                    "doc": [
                        "I combino los elemento en mi listo a @Text, separado por el separador dado @Text.",
                        "\\['manzana' 'platano' 'mango'].unirse(', ')\\"
                    ],
                    "names": "unirse",
                    "inputs": [
                        {
                            "doc": "El texto para separar los elemntos, lo puede dejar basio",
                            "names": "separador"
                        }
                    ]
                },
                "subsequence": {
                    "doc": [
                        "Yo obtengo una listo adentro de una listo, comenzando con el indice proveeido, y terminado con el ultimo elmento o con un elemento particula si es proveido.",
                        "\\['manzana' 'platano' 'mango'].subsecuencia(2)\\",
                        "\\['manzana' 'platano' 'mango'].subsecuencia(1 2)\\",
                        "Mira que cuando to provees numero en orden invertido, Yo te doy eso ordern invertido.",
                        "\\['manzana' 'platano' 'mango'].subsecuencia(3 1)\\",
                        "Si me das algo menor 1 una yo voy a asumir que querras decir 1.",
                        "\\['manzana' 'platano' 'mango'].subsecuencia(-1123123234)\\",
                        "Y si me das algo mayor a el indice mas grande, yo voy a asumer que querras decir el final.",
                        "\\['manzana' 'platano' 'mango'].subsecuencia(234234234234)\\"
                    ],
                    "names": "subsecuencia",
                    "inputs": [
                        {
                            "doc": "El indice del primero elemento de la subsecuencia que tu quieras.",
                            "names": "comienzo"
                        },
                        {
                            "doc": "La indice opcional de el ultimo elemento de la subsecuencia que tu quieras. Si me das algo, tu lista va a terminar con el ultimo valor en la lista original",
                            "names": "final"
                        }
                    ]
                },
                "sansFirst": {
                    "doc": [
                        "Yo creo una listo sin mi primer elemento",
                        "\\['manzana' 'platano' 'mango'].sinPrimero()\\"
                    ],
                    "names": "sinPrimero",
                    "inputs": []
                },
                "sansLast": {
                    "doc": [
                        "Yo creo una listo sin mi ultimo elemento",
                        "\\['manzana' 'platano' 'mango'].sinUltimo()\\"
                    ],
                    "names": "sinÚltimo",
                    "inputs": []
                },
                "sans": {
                    "doc": [
                        "Yo, pero sin la primer ocurrencia del el valor dado.",
                        "\\['manzana' 'platano' 'mango' 'manzana'].sin('manzana')"
                    ],
                    "names": "sin",
                    "inputs": [
                        {
                            "doc": "El valor a eliminar en la primara occurencia",
                            "names": "valor"
                        }
                    ]
                },
                "sansAll": {
                    "doc": [
                        "Yo, pero sin todas la occurencias del valor dado.",
                        "\\['manzana' 'platano' 'mango' 'manzana'].sinTodo('manzana')\\"
                    ],
                    "names": "sinTodo",
                    "inputs": [
                        {
                            "doc": "El valor a eliminar todas la occurencias de las lista",
                            "names": "valor"
                        }
                    ]
                },
                "reverse": {
                    "doc": [
                        "Yo, pero en inverso",
                        "\\['manzana' 'platano' 'mango'].inverso()"
                    ],
                    "names": "inverso",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "\\T\\ si mi elementos y order son exactamento los mismo a la @List dada",
                        "\\['manzana' 'platano' 'mango'] = ['manzana' 'platano' 'mango']\\"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "La @List a comparar",
                            "names": "lista"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "\\T\\ si mi elmento y orden /no/ so exactamento los mismo a la @List dada.",
                        "\\['manzana' 'platano' 'mango'] ≠ ['manzana' 'platano' 'mango']\\"
                    ],
                    "names": "≠",
                    "inputs": [
                        {
                            "doc": "La @List a comparar",
                            "names": "lista"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "Dame una @FunctionDefinition que reciva un valor y opcionalmente un indice como entradas, y produce un valor, y yo evaluare esa funcion en cada de mis elementos.",
                        "Por ejemplo, imagina que so soy una lista de @Number y quieres duplicar el valor de cada uno de los elementos:",
                        "\\[2 4 6 8].traducir(ƒ(num•#) num · 2)\\"
                    ],
                    "names": "traducir",
                    "inputs": [
                        {
                            "doc": "Una @FunctionDefinition que a va traducir cada elemento",
                            "names": "tranductor"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "El elemento que se va traducir",
                            "names": "elemento"
                        },
                        {
                            "doc": "El indice del elemento que va a traducir",
                            "names": "indice"
                        },
                        {
                            "doc": "La lista que se va a traducir",
                            "names": "lista"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "Dame una @FunctionDefinition que reciva un valor y opcionalmente un indice come entradas y produce un @Boolean, Yo creare una nueva lista que solo incluye elementos con el resultado \\T\\.",
                        "Por ejemplo, imagina yo soy una @List de @Number y solo quieres los numeros positivos:",
                        "\\[2 -4 8 -16].filtro(ƒ(num•#) num ≥ 0)\\"
                    ],
                    "names": "filtro",
                    "inputs": [
                        {
                            "doc": "Una @FunctionDefinition que chequea cada elemento, produciendo \\T\\ si deberia ser conservado en la list",
                            "names": "verificador"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "El elemento siendo verificado",
                            "names": "Elemento"
                        },
                        {
                            "doc": "El indice del el elemento siendo verificado",
                            "names": "indice"
                        },
                        {
                            "doc": "La lista siendo filtrada ",
                            "names": "lista "
                        }
                    ]
                },
                "all": {
                    "doc": [
                        "Dame una @FunctionDefinition que recive un valor con entrada y produce un @Boolean si el valor coincide con la condicion. Yo creare \\T\\ si todos los elementos coinciden con la condicion.",
                        "Por ejemplo, imagina que yo soy una @List de @Number y quieres saber si todos los numeros son positivos:",
                        "\\[2 -4 8 -16].todos(ƒ(num•#) num ≥ 0)\\"
                    ],
                    "names": "todos",
                    "inputs": [
                        {
                            "doc": "La @FunctionDefinition que produce \\T\\ si el elementon satisface yu condicion",
                            "names": "verificador"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "El elemento siendo verificado",
                            "names": "Elemento"
                        },
                        {
                            "doc": "El indice del el elemento siendo verificado",
                            "names": "indice"
                        },
                        {
                            "doc": "La lista siendo filtrada ",
                            "names": "lista "
                        }
                    ]
                },
                "until": {
                    "doc": [
                        "Dame una @FunctionDefinition que recive un valor como entrada y produce un @Boolean si el valor coincide con la condicion. Yo creare una nueva @List que contiene todos los elementos hasta que la condicion no sea satisfecha.",
                        "Por ejemplo, imagina que yo soy una @List de @Text de animales, y quieres todos los animals que \\'rata'\\ sea encontrado:",
                        "\\['gato' 'perro' 'rata' 'caballo' 'pony']hasta(ƒ(animal•'') animal = 'rata')\\"
                    ],
                    "names": "hasta",
                    "inputs": [
                        {
                            "doc": "La @FunctionDefinition que produce \\T\\ si yo deberia de parar de incluir elementos",
                            "names": "verificador"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "El elemento siendo verificado",
                            "names": "Elemento"
                        },
                        {
                            "doc": "El indice del el elemento siendo verificado",
                            "names": "indice"
                        },
                        {
                            "doc": "La lista siendo filtrada ",
                            "names": "lista "
                        }
                    ]
                },
                "find": {
                    "doc": [
                        "Dame una @FunctionDefinition  que recive un valor como entrada y porduce un @Boolean si coincide con una criteria, y yo evaluare a el elemento que coincide con esa criteria.",
                        "Por ejemplo, imagina que tu quieres encontrar el primer animal con la vocal \\'e'\\:",
                        "['gato' 'perro' 'rata' 'raton' 'pony'].encontrar(ƒ(animal•'') animal.tiene('e'))"
                    ],
                    "names": "encontrar",
                    "inputs": [
                        {
                            "doc": "La @FunctionDefinition que proudce \\T\\ si coincide con tu criteria de busquedad",
                            "names": "verificador"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "El elemento siendo verificado",
                            "names": "Elemento"
                        },
                        {
                            "doc": "El indice del el elemento siendo verificado",
                            "names": "indice"
                        },
                        {
                            "doc": "La lista siendo filtrada ",
                            "names": "lista "
                        }
                    ]
                },
                "combine": {
                    "doc": [
                        "Dame una @FunctionDefinition que recive el combinacion mas reciente y el valor que sigue, y crea la siguiente combinacion. Yo me movere desde mi primer hasta mi ultimo elemento, creando una combinacion subsesiva, y evaluando la combinacion final a lo que tu @FunctionDefinition  evalua",
                        "Estoy es muy util para combinar todos los elementos dentro de mi en un solo valor. Por ejemplo, imagina que tu quiere sumar una @List de @Number:",
                        "\\[3 9 2 8 1 4].combinar(0 ƒ(sum•# num•#) sum + num)\\"
                    ],
                    "names": "combinar",
                    "inputs": [
                        {
                            "doc": "La combinacion inicial",
                            "names": "inicial"
                        },
                        {
                            "doc": "El siguiento elemento a combinar",
                            "names": "combinador"
                        }
                    ],
                    "combiner": [
                        {
                            "doc": "La combinacion actual",
                            "names": "combinación"
                        },
                        {
                            "doc": "El siguiente elemento a combinar",
                            "names": "siguiente"
                        },
                        {
                            "doc": "El indice del siguiente elemento",
                            "names": "índice"
                        },
                        {
                            "doc": "La lista a combinar",
                            "names": "lista"
                        }
                    ]
                },
                "sorted": {
                    "doc": [
                        "Puedo tomar una lista y crear una nueva lista con sus valores ordenados. Como esto:",
                        "\\[1 5 8 0 2].ordenado()\\",
                        "También puedo hacerlo para valores de @Text",
                        "\\['naranja' 'kiwi' 'plátano' 'manzana'].ordenado()\\",
                        "Y si tienes una lista de valores que no son @Number o @Text, puedes darme una @FunctionDefinition que convierta cada elemento en un @Number para que pueda ordenarlo. Por ejemplo, aquí tenemos una lista de listas de diferentes longitudes; si me das una función que convierta cada lista en su longitud, puedo ordenarlas por su longitud.",
                        "\\[[1] [2 3] [4 8 12] [8]].ordenado(ƒ(lista) lista.longitud())\\"
                    ],
                    "names": "ordenado",
                    "inputs": [
                        {
                            "doc": "La @FunctionDefinition opcionla para ordenar elementos en la listo. La definicion deberia de combertir el elemento a un @Number que puede ser usado para ordenar una lista",
                            "names": "sequenciador"
                        }
                    ],
                    "sequencer": [
                        {
                            "doc": "El valor a combertir en un @Number",
                            "names": "valor"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "A una representacion de @Text de una lista",
                "set": "A un @Set, util para remover valores duplicados"
            }
        },
        "Set": {
            "doc": [
                "Yo soy una conjunto de valores! Eso significa que yo cualquier valor de valores, incluyendo valores sin valor. Tu me puedes crear asi:",
                "\\{1 2 3 }\\",
                "Yo soy muy util si quieres tener una coleccion de cosas sin valores duplicados",
                "Eso significa pasas valores que yo ya tengo, simplemente los ignorare.",
                "Por ejempo, este conjunto tiene muchos duplicados:",
                "\\{1 1 2 2 3 3}\\.",
                "Si quieres ver si yo tengo una valor adentro de mi, @SetOrMapAccess puede ser de ayuda:",
                "\\{'frasco' 'botella' 'vaso'}{'copa'}\\",
                "Por lo general, si me das un montón de valores del mismo tipo, asumiré que son una lista de ese tipo. Como este conjunto es \\{''}\\, porque todos son @Text.",
                "\\{'hey' 'hi' 'hello'}\\",
                "Pero tal vez quieras indicar que soy un conjunto de /solo/ esos valores, para que pueda decirte cuando estás intentando usar uno que no está permitido. Si es así, solo agrega un ! al final de mí.",
                "\\{'hey' 'hi' 'hello'}!{'yo'}\\",
                "¿Hay algo más que quieras hacer conmigo? ¡Mira todas las geniales @FunctionDefinition que tengo!"
            ],
            "name": ["{}", "Conjunto"],
            "kind": "Kind",
            "out": "Result",
            "function": {
                "size": {
                    "doc": "Yo te dire cuanots valores yo tengo",
                    "names": "tamaño",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "\\T\\ si me das un @Set y temenemos los mismo valores:",
                        "\\{1 2 3} = {2 3 4}\\"
                    ],
                    "names": ["=", "igual"],
                    "inputs": [
                        {
                            "doc": "El @Set a ser comparado",
                            "names": "conjunto"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "Yo soy \\T\\ si me pasas un @Set y yo /no/ tengo los mismos valores:",
                        "\\{1 2 3} ≠ {2 3 4}\\"
                    ],
                    "names": "≠",
                    "inputs": [
                        {
                            "doc": "El @Set a ser comparado",
                            "names": "conjunto"
                        }
                    ]
                },
                "add": {
                    "doc": [
                        "Dame un elemento para sumar y yo creare un nuevo @Set con mis elementos y el elemento dado.",
                        "\\{1 2 3} + 4\\"
                    ],
                    "names": ["sumar", "+"],
                    "inputs": [
                        {
                            "doc": "El elemento a sumar",
                            "names": "elemento"
                        }
                    ]
                },
                "remove": {
                    "doc": [
                        "Dame un elemento para remover y yo creare un nuevo @Set sin ese elemento"
                    ],
                    "names": ["remove", "-"],
                    "inputs": [
                        {
                            "doc": "El elemento a remover",
                            "names": "elemento"
                        }
                    ]
                },
                "union": {
                    "doc": [
                        "Dame un @Set y yo creare un nuevo @Set que tiene mis elementos y tambien los elementos del otro @Set",
                        "\\{1 2 3} ∪ {3 5 6}"
                    ],
                    "names": ["union", "∪"],
                    "inputs": [
                        {
                            "doc": "El @Set a combinar",
                            "names": "set"
                        }
                    ]
                },
                "intersection": {
                    "doc": [
                        "Dame un @Set y yo creare un nuevo @Set que solo tiene los elemento que los dos conjuntos tienen en comun",
                        "\\{1 2 3} ∩ {3 4 5}\\"
                    ],
                    "names": ["interseccion", "∩"],
                    "inputs": [
                        {
                            "doc": "El @Set a comparar",
                            "names": "conjunto"
                        }
                    ]
                },
                "difference": {
                    "doc": [
                        "Dame un @Set y yo creare un nuevo @Set que tiene los valores que son unicos en cada @Set",
                        "\\{1 2 3}.diferencia({3 4 5})\\"
                    ],
                    "names": "diferencia",
                    "inputs": [
                        {
                            "doc": "El conjunto a comparar",
                            "names": "conjuton"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "Dame una @FunctionDefinition  que recive un elemento y produce \\T\\ si deberia de ser convervado, y yo creare un @Set que solo contiene elementes que cumpla con tu criteria.",
                        "Por ejemplo, vamos a encontrar todos los numeros impares adentro de mi:",
                        "\\{1 2 3 4 5 6 7 8 9}.filtro(ƒ(num•#) (num % 2) = 1)\\"
                    ],
                    "names": "filtro",
                    "inputs": [
                        {
                            "doc": "La @FunctionDefinition que verifica un elemento para ver si deberia ser conservado",
                            "names": "verificador"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "El elemento siendo verificado",
                            "names": "valor"
                        },
                        {
                            "doc": "El conjunto siendo filtrado",
                            "names": "conjunto"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "Dame una @FunctionDefinition  que recive un elemento y produce un nuevo elemento basado en el mismo, depues yo voy a traducir todos mis elementos a un nuevo @Set (removiendo duplicados).",
                        "Por ejemplo, vamos a combertir todos los @Number(s)a @Text:",
                        "\\{1 2 3 4 5 6 7 8 9}.traducir(ƒ(num•#) num→'')\\"
                    ],
                    "names": "traducir",
                    "inputs": [
                        {
                            "doc": "La @FunctionDefinition que traduce uno de mis elementos a un nuevo elemento que tu desees",
                            "names": "traductor"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "El elemento siendo traducido",
                            "names": "valor"
                        },
                        {
                            "doc": "El conjunto siendo traducido",
                            "names": "conjunto"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "Una representacion de @Text de un @Set",
                "list": "Una representacion de los elementos en un @conjunto en una @List"
            }
        },
        "Map": {
            "doc": [
                "Yo emparejo valores, mapeando *llaves* a *valores*. Por ejemplo:",
                "\\{'rosa': 6puntos 'tony':3puntos 'isabela':8puntos}\\",
                "Mis llaves pueden ser de cualquier tipo de valor, y tambien mis valores",
                "Personas piensan de mi como si yo fuera un indice o un diccionario, donde tu me das una llave, y yo te doy a lo que esta mapeado.",
                "Si quieres ver a lo algo esta mapeado a. tu le puedes pasar a @SetOrMapAccess, una llave y ellos de daran el valor:",
                "\\{'rosa': 6puntos 'tony':3puntos 'isabela':8puntos}{'tony'}\\",
                "Si noy hay una llave que coincida, yo te dare @None.",
                "\\{'rosa': 6puntos 'tony':3puntos 'isabela':8puntos}{'juan'}\\",
                "Tu tambien puedes crear un mapa vacio asi:",
                "\\{:}\\",
                "Yo se hacer muchas cosas maravillosas con mis emparejamientos."
            ],
            "name": ["{:}", "Mapa"],
            "key": "Key",
            "value": "Value",
            "result": "Result",
            "function": {
                "size": {
                    "doc": "Yo te devuelvo cuantos valores yo tengo",
                    "names": "tamaño",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "\\{T}\\ si mi emparejamientos son exactamente los mismos a el @Map dado.",
                        "\\{1:1 2:2} = {1:1 2:3}\\"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "El @Map a comparar",
                            "names": "valor"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "\\{T}\\ si mis emparejamientos /no/ son exactamente los mismo a el @Map dado.",
                        "\\{1:1 2:2} ≠ {1:1 2:3}\\"
                    ],
                    "names": "≠",
                    "inputs": [
                        {
                            "doc": "El @Map a comparar",
                            "names": "valor"
                        }
                    ]
                },
                "set": {
                    "doc": [
                        "Yo creare un nuevo @Map con los mismos emparejamientos, pero con el neuvo emparejamiento que tu me das. Si yo tengo la llave, con los emparejare con el nuevo valor.",
                        "\\{'rosa': 6puntos 'tony':3puntos 'isabela':8puntos}.emparejar('juan' 0puntos)\\"
                    ],
                    "names": "emparejar",
                    "inputs": [
                        {
                            "doc": "La llave para emparejar con el valor",
                            "names": "llave"
                        },
                        {
                            "doc": "El valor para empajar con la llave",
                            "names": "valor"
                        }
                    ]
                },
                "unset": {
                    "doc": [
                        "Yo creare un nuevo @Map sin la llave que tu me das, removiendo su emparejamiento.",
                        "\\{'rosa': 6puntos 'tony':3puntos 'isabela':8puntos}.desemparejar('rosa')\\"
                    ],
                    "names": "desemparejar",
                    "inputs": [
                        {
                            "doc": "La llave a remover",
                            "names": "llave"
                        }
                    ]
                },
                "remove": {
                    "doc": [
                        "Yo creare un nuevo @Map sin la llaves que tenga el valor que tu me des.",
                        "\\{'rosa': 6puntos 'tony':3puntos 'isabela':3puntos}.remover(3puntos)\\"
                    ],
                    "names": "remover",
                    "inputs": [
                        {
                            "doc": "El valor a remover, junto a las llaves con las que estan emparejadas",
                            "names": "valor"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "Pasame una @FunctionDefinition  que recive una llave y un valor y evalua a \\T\\ si la pareja deberia de ser conservada. Yo creare un nuevo @Map que cumple tu criteria.",
                        "Por ejemplo, aqui queres mantener las parejas que tiene la llave 'juan' o tengo un valor de mas de cero puntos",
                        "\\{'juan': 0points 'ana': 0points 'tony':3points}.filtro(ƒ(llave•'' valor•#puntos) (llave = 'amy') | (valor > 0puntos))\\"
                    ],
                    "names": "filtro",
                    "inputs": [
                        {
                            "doc": "La @FunctionDefinition que decide mantener una pareja o no",
                            "names": "verificador"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "La llave siendo verificada",
                            "names": "llave"
                        },
                        {
                            "doc": "El valor siendo verificado",
                            "names": "valor"
                        },
                        {
                            "doc": "El mapa siendo verificado",
                            "names": "mapa"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "Dame una @FunctionDefinition que recive una llave y un valor y evalua el valor a un nuevo valor. Yo creare un nuevo @Map con las misma llaves pero con los valores nuevos.",
                        "Por ejemplo, vamos a darle un punto a todos, porque se an comportado muy bien",
                        "\\{'juan': 0points 'ana': 0points 'tony':3points}.traducir(ƒ(llave•'' valor•#points) valor + 1puntos)"
                    ],
                    "names": "traducir",
                    "inputs": [
                        {
                            "doc": "La @FunctionDefinition  que traduce cada valor",
                            "names": "traductor"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "La llave siendo traducida",
                            "names": "llave"
                        },
                        {
                            "doc": "El valor siendo traducido",
                            "names": "valor"
                        },
                        {
                            "doc": "El mapa siendo traducido",
                            "names": "mapa"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "Una representacion de un mapa a @Text",
                "set": "La llaves de un @Map",
                "list": "una listo con los valores de un @mapa"
            }
        },
        "Table": {
            "doc": [
                "Yo soy un conjunto de filas de tablas! Yo puedo te puedo ayudar a mantener al corriente de colleciones grandes de valores que tienen la misma estructura.",
                "Por ejemplo, imaginemos que queremos una almacenar los nombres de muchos tipos de rocas:",
                "\\⎡nombre•'' color•''⎦\n⎡'obsidiano' 'negro'⎦\n⎡'pomez' 'gris'⎦\n⎡'citrino' 'amarillo'⎦\\",
                "@Bind nos puede ayudar a nombrar la tabla, y tambien puedes hacer cosas, como actualizar la tabla con una nuevo fila con @Insert:",
                "\\rocas: ⎡nombre•'' color•''⎦\n⎡'obsidiano' 'negro'⎦\n⎡'pomez' 'griz'⎦\n⎡'citrino' 'amarillo'⎦\nrocas ⎡+ 'cuarzo' 'blanco'⎦\\",
                "Si queres encontrar una fila que coince con alguna condicion, tu puede @Select filas con esa condicion:",
                "\\rocas: ⎡nombre•'' color•''⎦\n⎡'obsidiano' 'negro'⎦\n⎡'pomez' 'griz'⎦\n⎡'citrino' 'amarillo'⎦\n\nrocas ⎡?⎦ color = 'gris'\\",
                "O talves tu queres crear una tabla con valores actualizados, con filas que complen una condicion:",
                "\\rocas: ⎡nombre•'' color•''⎦\n⎡'obsidiano' 'negro'⎦\n⎡'pomez' 'gris'⎦\n⎡'citrino' 'amarillo'⎦\nrocas ⎡: color: 'black' ⎦ name = 'pomez'\\",
                "Tambine puedes borrar filas que cumplen una condicion:",
                "\\rocas: ⎡nombre•'' color•''⎦\n⎡'obsidiano' 'negro'⎦\n⎡'pomez' 'gris'⎦\n⎡'citrino' 'amarillo'⎦\nrocas ⎡- nombre.tiene('i')\\",
                "Y si quieres consultar valores especificos que to tengo, tu puedes convertir cualquier tabla a una lista y acceder filas individualmento con @PropertyReference",
                "\\rocas: ⎡nombre•'' color•''⎦\n⎡'obsidiano' 'negro'⎦\n⎡'pomez' 'gris'⎦\n⎡'citrino' 'amarillo'⎦\n(rocas → [])[1].nombre\\"
            ],
            "name": ["⎡⎦", "Tabla"],
            "row": "Fila",
            "function": {
                "equals": {
                    "doc": "Yo compruevo que yo tengo las mismas celdas en el orden exacto de la otra @Table",
                    "names": ["=", "igual"],
                    "inputs": [
                        {
                            "doc": "La otra tabla a verificar",
                            "names": "tabla"
                        }
                    ]
                },
                "notequal": {
                    "doc": "Yo compruevo que yo las celdas de la otra @Table sean distintas o que esten en orden diferente",
                    "names": ["≠", "noIgual"],
                    "inputs": [
                        {
                            "doc": "La otra tabla a verificar",
                            "names": "tabla"
                        }
                    ]
                }
            },
            "conversion": {
                "list": "Yo convierto una @Table a una lista de filas, donde cada fila es una @Estructura con sus nombre de columna como una propiedad.",
                "text": "Yo simplemento converito una @Table a @Text"
            }
        },
        "Structure": {
            "doc": "Mira @StructureDefinition ",
            "name": "Estructura",
            "function": {
                "equals": {
                    "doc": "Yo verifico que mi propiedas tengas los mismos nombre y valores a la otra estructura.",
                    "names": ["=", "igual"],
                    "inputs": [
                        {
                            "doc": "La otra estructura a verificar",
                            "names": "valor"
                        }
                    ]
                },
                "notequal": {
                    "doc": "Yo verifico que mis propiedas sean differentes de cualquier manera a la otra esctructura",
                    "names": ["≠", "notEquals"],
                    "inputs": [
                        {
                            "doc": "La otra estructura a verificar",
                            "names": "valor"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "Yo me convierto a @Text"
            }
        }
    },
    "input": {
        "Random": {
            "doc": [
                "23!",
                "/DeficionDeFuncion aqui, yo te lo explicare./",
                "@Random is a curious function that creates numbers randomly. It's curious because every time you evaluate it, it creates something different.",
                "This creates a marvelous chaos that plays well with something unpredictable.",
                "By default, it gives you values of @Number between \\0\\ and \\1\\:",
                "\\Random()\\",
                "But you can also pass a value, and it will generate values between \\0\\ and the value:",
                "\\Random(20)\\",
                "And if you pass two values, it will generate values between and including the two values:",
                "\\Random(=20 20)\\",
                "If the numbers have units, the units will be preserved (and if they are not even, the unit of the minimum value will be used):",
                "\\Random(-20m 20m\\",
                "And if you pass numbers with a particular number of significant digits after the decimal, that precision will be preserved.",
                "\\Random(2.00, 20.00)\\"
            ],
            "names": ["🎲", "Random"],
            "inputs": [
                {
                    "names": "mínimo",
                    "doc": "El valor mínimo que será creado, si no es mayor a 0, entonces será el valor máximo. Si @None es proveído, entonces el mínimo es \\0\\."
                },
                {
                    "names": "máximo",
                    "doc": "El valor máximo que será creado, o si es menor al mínimo proveído, este será el mínimo. Si @None es proveído, entonces el valor máximo es \\1\\."
                }
            ]
        },
        "Choice": {
            "doc": [
                "/click y tap!/",
                "/@FunctionDefinition aqui, yo te la explicare./",
                "Piensa en @Choice como un río de @Phrase/name que es seleccionada por su audiencia. Si alguien hace click, tap o selecciona con su teclado, presionando /Enter/ en una @Phrase con un nombre -- @Choice tendrá un nuevo valor, emparejada con su nombre.",
                "La mejor manera de usarlos es creando una actuación con frases de selección nombradas @Phrase, después usa @Reaction para decidir qué hacer con el nombre elegido",
                "Este es un ejemplo simple.",
                "\\Group(\nStack() \n[\nPhrase('uno' seleccion:T nombre: '1'1) \nPhrase('dos' seleccion:T nombre: '2') \nPhrase(Choice())\n]\n)\\",
                "Copia esto en tu editor, después selecciona una de las dos @Phrase. Podrás ver que la tercera @Phrase muestra el nombre que fue seleccionado."
            ],
            "names": ["🔘", "Elección"]
        },
        "Button": {
            "doc": [
                "/click click click/",
                "/@FunctionDefinition aquí, explicaré esto./",
                "@Button es una excelente manera de escuchar a un ratón o panel táctil. Por supuesto, un ratón o panel táctil no es la elección ideal para escuchar a una audiencia, ya que no todos pueden usarlo. La opción más accesible es @Choice.",
                "Pero si /realmente/ necesitas escuchar un botón de ratón, esta es la manera de hacerlo. Proporcionará un flujo de @Boolean, que representa si el botón principal está arriba \\⊥\\ o abajo \\⊤\\.",
                "Aquí tienes un ejemplo simple:",
                "\\Phrase(Button() → '')\\",
                "Esto simplemente crea un @Phrase que es el valor del flujo como texto. Si lo copias en el editor y haces clic, verás que alterna entre \\⊥\\ y \\⊤\\."
            ],
            "names": ["🖱️", "Botón"],
            "down": {
                "names": "abajo",
                "doc": "Si es @None, el flujo proporcionará tanto valores hacia arriba como hacia abajo. Si es @Boolean, solo proporcionará el valor dado por el valor @Boolean."
            }
        },
        "Pointer": {
            "doc": [
                "/aquí/",
                "/@FunctionDefinition aqui, yo te la explicare./",
                "¿Tú conoces sobre ratones, paneles táctiles y pantallas táctiles? Hay veces que quieres saber en dónde tu puntero de la audiencia está. Esta es la funcionalidad de @Pointer.",
                "Por supuesto, esta no es una opción accesible: no todo el mundo puede ver u apuntar fácilmente, asegúrate de que no estés excluyendo a nadie usando este stream.",
                "Si estás seguro de que nadie va a ser excluido, usar @Pointer es tan simple como hacer un stream:",
                "\\Puntero()\\",
                "El @Place que provee va a corresponder a dónde el puntero en el @Stage está apuntando."
            ],
            "names": ["Puntero"]
        },
        "Key": {
            "doc": [
                "/clickety/",
                "/@FunctionDefinition aquí, yo te le explicaré./",
                "Los teclados tienen muchas teclas, ¿no? @Key te dirá cuál es la que alguien está presionando y soltando.",
                "Prueba esto",
                "\\Tecla()\\",
                "Mira cómo cuando presionas una tecla, aparece en el @Stage. Cada vez que se presiona una tecla, se agrega un nuevo texto a la secuencia, describiendo la tecla que se presionó.",
                "Para una tecla que representa un personaje, el valor será el personaje en @Text.",
                "Para teclas especiales, como la tecla de /Escapar/, será @Text que describe la tecla, usando un <pre-defined name@https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values>, lamentablemente solo disponible en inglés.",
                "Si quieres saber de una tecla en particular, puedes proporcionarlo:",
                "\\Tecla('a')\\",
                "Y si solo quieres saber cuando una @Key está soltada, puedes proporcionarlo usando @Boolean:",
                "\\Tecla('a' ⊥)\\"
            ],
            "names": ["⌨️", "Tecla"],
            "key": {
                "names": "tecla",
                "doc": "Si @None, entonces se proporcionan todas las teclas. Si es una @Text específica, entonces solo esa tecla está proporcionada."
            },
            "down": {
                "names": "abajo",
                "doc": "Si @None, entonces la tecla presionada genera aporte. Si \\T\\, entonces solo teclas presionadas están proporcionadas, y si \\⊥\\, entonces solo teclas soltadas están proporcionadas."
            }
        },
        "Time": {
            "doc": [
                "/tick tick tick/",
                "@FunctionDefinition aquí, te explicaré @Time porque no puede hablar.",
                "Tiempo es una secuencia que avanza con una cierta frecuencia.",
                "Cada vez que avanza, @Program reevalúa con el nuevo valor del tiempo.",
                "Por ejemplo:",
                "\\Tiempo()\\",
                "Si proporcionas un @Time/frequency, avanzará a ese ritmo. Por ejemplo:",
                "\\Tiempo(1000ms)\\",
                "Sin embargo, la frecuencia tiene límites en lo pequeño que puede ser porque @Program necesita tiempo para evaluar antes de que pueda avanzar.",
                "Lo más pequeño que puede ser es alrededor de \\20ms\\."
            ],
            "names": "Tiempo",
            "frequency": {
                "names": ["frecuencia"],
                "doc": "Esta es la frecuencia con que el tiempo avanza. Por defecto es \\33ms\\, que es alrededor de 30 veces por segundo."
            },
            "relative": {
                "names": ["pariente"],
                "doc": "Si \\⊤\\, el tiempo comienza en 0, cuando el programa se evalúa por primera vez. Si no, comienza en el número de milisegundos desde el inicio de hoy, UTC (Tiempo Universal Coordinado), lo que te permite llevar un registro de la hora del día."
            }
        },
        "Volume": {
            "doc": [
                "/bzzzzzzz",
                "@FunctionDefinition aquí, tomaré el micrófono.",
                "Esta secuencia es una serie de volumen entre 0 y 1, muestreado a la frecuencia de tu elección. Por defecto, la frecuencia es \\30hz\\, o 30 veces por segundo, pero puedes cambiarlo a algo menos.",
                "\\Volume()\\",
                "Esto es ideal para escuchar qué tan fuerte está la audiencia."
            ],
            "names": ["🎤", "Volumen"],
            "frequency": {
                "names": ["frecuencia"],
                "doc": "El tiempo entre muestreos."
            }
        },
        "Pitch": {
            "doc": [
                "/hummmmm/",
                "@FunctionDefinition aquí, hablemos de tonos.",
                "Esta secuencia es una serie de tonos en hertz, indicando el tono del sonido, muestreado a la frecuencia de tu elección. Encontramos que las voces de los humanos están entre 20Hz y 5000Hz, así que planea en números entre ese rango.",
                "\\Tono()\\",
                "Esto es ideal para escuchar el tono en el que alguien habla o canta."
            ],
            "names": ["🎵", "Tono"],
            "frequency": {
                "names": ["frecuencia"],
                "doc": "El tiempo entre muestreos."
            }
        },
        "Camera": {
            "doc": [
                "/bzzzzzzz/",
                "@FunctionDefinition aquí, puedo explicar @Camera.",
                "@Camera proporciona una @List de @Color de tu mundo. Esa lista esencialmente representa una imagen, pero tú decides qué hacer con ella.",
                "Puedes intentar representar la imagen con un montón de @Phrase, ¡se vería muy bonito! Intenta copiar esto...",
                "\\colores: Cámara(32px 24px 33ms)\n\nStage(\ncolores.combine(\n[] \nƒ(frases•[Phrase] fila•[Color] y•#) \nfrases.append(\nfila.translate(\nƒ(color•Color x•#)\nPhrase('o' place: Place((x - 1) · 0.5m y · -0.5m) color: color duration: 0s\n)\n)\n)\n)\n)\\",
                "Pero también puedes analizar los colores para decidir si una luz estaba encendida o apagada, o si un color en particular era común, dejando que la audiencia influya en la actuación con los colores que muestran."
            ],
            "names": ["🎥", "Cámara"],
            "width": {
                "names": ["ancho"],
                "doc": "El número de @Color para mostrar en una fila."
            },
            "height": {
                "names": ["altura"],
                "doc": "El número de @Color para mostrar en una columna."
            },
            "frequency": {
                "names": ["frecuencia"],
                "doc": "El tiempo entre muestras de @Color."
            }
        },
        "Scene": {
            "doc": [
                "$~/boop boop boop/",
                "$~/¡Hola, @FunctionDefinition aquí! Veo que encontraste @Scene.",
                "$~Creo que @Scene es particularmente interesante. La idea básica es que le proporciones una lista de @Phrase o @Group y luego los mostrará en secuencia y se detendrá en el último.",
                "$~Para controlar el tiempo, puede configurar @Phrase/duration en cada salida, y la mostrará durante ese tiempo antes de pasar a la siguiente, y usar cualquier transición @Phrase/entering o @Phrase/exiting que haya configurado. . Si los configura en @Sequence, usará su duración.",
                "$~Todo eso te permite hacer cosas como esta pequeña @Scene, que muestra estas tres frases en secuencia:",
                "$~\\Escena([\n\tFrase (duración de 'Hola': 1 s)\n\tFrase('¿Cómo estás?' duración: 2s rotación: 5° entrando: Pose(rotación: 0°))\n\tFrase('Estoy bien')\n])\\",
                "$~¿Ves cómo la primera salida se muestra durante un segundo, luego la siguiente durante dos segundos, pero animada con una rotación de cinco grados, y luego muestra la última?",
                "$~Puedes crear secuencias muy elaboradas de resultados y animaciones con @Scene, e incluso hacer que partes de ellas sean dinámicas o interactivas, como con cualquier otro @Phrase o @Group.",
                "$~Si tiene una salida animada anidada (un @Group con una @Phrase animada dentro), @Scene esperará a que finalice todo el contenido animado del @Group.",
                "$~¡Ah, y un último pequeño secreto! Incluso puedes poner @Boolean en la lista, y si son \\⊥\\, @Scene se detendrá y esperará a que se haga realidad.",
                "$~Por ejemplo, si quisieras hacer una secuencia de @Phrase y solo avanzar cuando @Button cambie, podrías hacer esto:",
                "$~\\hacer clic: Botón ∆()\nEscena([\n\tFrase('Hola')\n\thacer clic\n\tFrase('¿Cómo estás?' duración: 0.25s rotación: 5° entrando: Pose(rotación: 0°))\n\thacer clic\n\tFrase('Estoy bien')\n])\\",
                "$~¿Ves cómo se detiene después de cada @Phrase y espera a que @Button cambie antes de avanzar?"
            ],
            "names": ["$~🎬", "$~Escena"],
            "outputs": {
                "names": "$~salidas",
                "doc": "$~La lista de salidas que se mostrarán en secuencia."
            }
        },
        "Motion": {
            "doc": [
                "/boing boing boing/",
                "/¡Hola! Aquí @FunctionDefinition. ¿Qué tal si explico @Motion?",
                "Básicamente, @Motion es un flujo de @Phrase. Le das una @Phrase inicial y luego la perfecciona con un nuevo lugar y rotación basado en la gravedad.",
                "Esto te permite hacer cosas realmente simples, como crear emojis que rebotan:",
                "\\Motion(Frase('o') startplace: Lugar(0m 10m))\\",
                "¿Ves cómo rebota la 'o'? En la primera evaluación, le damos un lugar alto en @Stage, pero después obtiene @None, lo que permite que @Motion lo cambie a la posición que la gravedad le asignaría.",
                "Consulta las muchas otras formas de configurarlo a continuación."
            ],
            "names": ["⚽️", "Movimiento"],
            "place": {
                "doc": "El lugar de inicio.",
                "names": "lugar"
            },
            "velocity": {
                "doc": "La velocidad inicial",
                "names": "velocidad"
            },
            "nextplace": {
                "doc": "El próximo lugar, anulando la física.",
                "names": "siguientelugar"
            },
            "nextvelocity": {
                "doc": "El próximo lugar, anulando la velocidad.",
                "names": "siguientevelocidad"
            }
        },
        "Chat": {
            "doc": [
                "/¡Hola! @FunctionDefinition aquí. ¿Entonces quieres chatear?",
                "La idea básica de un flujo de chat es que la audiencia escribe un mensaje y luego el programa responde.",
                "Por ejemplo, este programa simple verifica si el mensaje es 'hola' y, si es así, el programa evalúa a '¡hola!'. De lo contrario, evalúa a '¿eh?'",
                "\\Chat().tiene('hola') ? '¡hola!' '¿eh?'\\",
                "¡Eso es todo! Puedes realizar todo tipo de actuaciones con esto, como chatbots, aventuras de texto o esquemas de control basados en texto para otros tipos de actuaciones."
            ],
            "names": ["🗣️", "Charlar"]
        },
        "Placement": {
            "doc": [
                "/Hola, @FunctionDefinition aquí. ¡Hablemos sobre cómo movernos!",
                "Hay muchas formas de colocarnos en el @Stage. Puedes darnos un @Place explícito. También podrías usar @Motion y dejar que la gravedad haga su trabajo. También puedes colocarnos en un @Group y dejar que nos organicen de una manera particular.",
                "Pero a veces quieres darle al /público/ control sobre dónde estamos en el @Stage. Para eso está @Placement.",
                "Así es como funciona: simplemente crea una @Placement y dásela a nuestro @Place:",
                "\\Frase('hola' lugar: Ubicación())\\",
                "Entonces, cada vez que la audiencia use una tecla de flecha o haga clic o toque en el escenario, la @Placement creará un nuevo @Place que se mueva en la dirección deseada.",
                "Intenta copiar esto en tu programa y muévenos con la flecha o el teclado.",
                "Puedes personalizar la @Placement, habilitando y deshabilitando el movimiento en ciertas dimensiones, cambiando cuánto se mueve un @Place y el @Place inicial con el que comienza el flujo."
            ],
            "names": ["✥", "Ubicación"],
            "inputs": [
                {
                    "doc": "El lugar inicial para comenzar.",
                    "names": "comienzo"
                },
                {
                    "doc": "Cuántos metros debería moverse el lugar cuando la audiencia solicita un movimiento.",
                    "names": "distancia"
                },
                {
                    "doc": "Si es verdadero, permite el movimiento en el eje horizontal. Activado por defecto.",
                    "names": "horizontal"
                },
                {
                    "doc": "Si es verdadero, permite el movimiento en el eje vertical. Activado por defecto.",
                    "names": "vertical"
                },
                {
                    "doc": "Si es verdadero, permite el movimiento en el eje z, con las teclas + y -.",
                    "names": "profundidad"
                }
            ]
        },
        "Webpage": {
            "doc": [
                "/Hola, @FunctionDefinition aquí. ¡Hablemos sobre cómo obtener páginas web de internet!",
                "Cuando nos enteramos por primera vez de su internet, nos pareció fascinante. ¿Un mundo entero lleno de computadoras conectadas compartiendo documentos entre sí? ¡Es asombroso!",
                "Así que hicimos un flujo que se conecta a él. Nos das una URL y obtendremos todo el texto. Así:",
                "\\PáginaWeb('https://wordplay.dev')\\",
                "Y aparentemente hay algo llamado <CSS@https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/What_is_CSS>, ¿que le gusta consultar cosas en una página web? Danos una consulta de selección de CSS y obtendremos solo el texto que coincida con esa consulta. Como este ejemplo, que obtiene los encabezados de nivel uno.",
                "\\PáginaWeb('https://wordplay.dev' 'h1')\\",
                "Muchas cosas pueden salir mal con esto. Si pierdes la conexión a internet, o la URL no se resuelve en nada, o la URL no es pública, o la URL no es una página HTML… Todas estas pueden provocar una excepción. Si encuentras una página que funcione, obtendrás un @Number que indica un porcentaje completo y luego una @List de las palabras en la página."
            ],
            "names": ["🔗", "PáginaWeb"],
            "url": {
                "doc": "La URL de la página web HTML a obtener.",
                "names": "url"
            },
            "query": {
                "doc": "La consulta de selección de CSS para evaluar en el HTML",
                "names": "consulta"
            },
            "frequency": {
                "doc": "La cantidad de minutos que deben pasar antes de que la página se vuelva a obtener.",
                "names": "frecuencia"
            },
            "error": {
                "invalid": "esto no es una URL válida",
                "unvailable": "esta URL no es accesible",
                "notHTML": "la respuesta no fue HTML",
                "noConnection": "sin conexión a Wordplay",
                "limit": "demasiadas solicitudes a este dominio"
            }
        },
        "Collision": {
            "names": "Colisión",
            "doc": [
                "/¡Hola! Soy @FunctionDefinition. Echa un vistazo a esta entrada genial./",
                "¡Puede ayudarte a descubrir cuándo se encuentran @Output! Esta es una excelente manera de hacer algo cuando nos encontramos, además de simplemente rebotar entre sí como podría hacer @Output.",
                "Solo dame el nombre de @Output y crearé un nuevo valor de @Rebound cada vez que se encuentre con otro nombre. Un @Rebound tiene información sobre los nombres que chocaron y la dirección de su colisión.",
                "Y si me das dos nombres, solo crearé un nuevo valor cuando los dos nombres se encuentren entre sí.",
                "Justo después de crear un nuevo valor, haré un \\ø\\ ya que la colisión ha terminado después de que ocurre. Esto indica que ya no hay más colisión.",
                ""
            ],
            "subject": {
                "names": "sujeto",
                "doc": "El nombre de @Output en el que debería buscar colisiones."
            },
            "object": {
                "names": "otro",
                "doc": "El nombre del otro @Output en el que debería buscar colisiones."
            }
        },
        "Rebound": {
            "names": "Rebote",
            "doc": "Vengo de @Collision y represento quién chocó y en qué dirección ocurrió la colisión. Úsame para decidir si reaccionar de alguna manera especial a una colisión, que no sea la física normal.",
            "direction": {
                "names": "dirección",
                "doc": "La dirección y magnitud de la colisión, en relación con el sujeto de la colisión."
            },
            "subject": {
                "names": "sujeto",
                "doc": "El nombre de la salida que fue golpeada por el sujeto."
            },
            "object": {
                "names": "objeto",
                "doc": "El nombre de la salida que golpeó al sujeto."
            }
        },
        "Direction": {
            "names": "Dirección",
            "doc": "Soy una dirección y magnitud, a lo largo de los ejes x e y.",
            "x": {
                "names": "x",
                "doc": "La dirección y magnitud de la dirección a lo largo del eje x."
            },
            "y": {
                "names": "y",
                "doc": "La dirección y magnitud de la dirección a lo largo del eje y."
            }
        }
    },
    "output": {
        "Output": {
            "names": "Salida",
            "doc": [
                "No soy una @StructureDefinition que puedas crear realmente. Pero soy uno muy importante, ya que inspiro los elementos más importantes de nuestra danza: @Phrase, @Group y @Stage.",
                "Ve a conocerlos para aprender más sobre cómo usarlos."
            ]
        },
        "Group": {
            "doc": [
                "Ah hola ¿como estas? Yo siempre estoy bien cunado hay otros cerca, ¡así que es maravilloso de verte!",
                "Yo agrupo @Phrase y @Group en el @Stage y los pongo en un @Arrangement para que haya cierto orden en el lugar donde se colocan.",
                "Para trabajar necesito que me des un @Arrangement y despues una @List de @Output para arreglar.",
                "Por ejemplo, aqui estoy con una @Stack arreglo y unas @Phrase para colocar verticalmente:",
                "\\Grupo(Pila() [Frase('primera') Frase('segunda')])\\",
                "Cómo los organizo depende del @Arrangement que tu me das."
            ],
            "names": ["🔳", "Grupo"],
            "content": {
                "doc": "La lista de @Output para arreglar",
                "names": "content"
            },
            "matter": {
                "doc": "Cómo debería reaccionar si chocara con algo más con materia.",
                "names": "materia"
            },
            "layout": {
                "doc": "El arreglo para poner @Output en su lugar",
                "names": "layout"
            },
            "size": {
                "doc": "Qué tan alto debe ser el maravilloso contenido dentro de mí, a menos que ya tiene un su tamaño propio!",
                "names": "tamaño"
            },
            "face": {
                "doc": "El nombre de la fuente que el contenido debe tener dentro de mí, a menos que tengan su cara propia.",
                "names": "fuente"
            },
            "place": {
                "doc": "El lugar que debo de estar. El contenido dentro de mí se organizará en relación con allí.",
                "names": "lugar"
            },
            "name": {
                "doc": ["Lo mismo que @Phrase/name"],
                "names": "nombre"
            },
            "description": {
                "doc": [
                    "$~Una descripción para utilizar por parte de los miembros de la audiencia que no pueden ver la salida visual."
                ],
                "names": "$~descripción"
            },
            "selectable": {
                "doc": "Lo mismo que @Phrase/selectable",
                "names": "seleccionable"
            },
            "color": {
                "doc": "El @Color que el contenido debe tener dentro de mí, a menos que tengan su color propio.",
                "names": "color"
            },
            "background": {
                "doc": "El @Color para proyectar detrás de mí ",
                "names": "fondo"
            },
            "opacity": {
                "doc": "Qué tan transparent debe ser el contenido dentro de mí, entre \\0\\ y \\1\\, a menos que fuera anulado por una @Pose diferente.",
                "names": "opacidad"
            },
            "offset": {
                "doc": "Un @Place que indica qué tan alejado debe estar de mi @Place normal, a menos que lo anule un @Pose diferente. Útil para moverse en su lugar.",
                "names": "desplazamiento"
            },
            "rotation": {
                "doc": "Qué tan inclinado debería estar alrededor de mi centro, mi @Pose tiene uno diferente.",
                "names": "rotación"
            },
            "scale": {
                "doc": "Qué tan grande debería ser en relación con mi tamaño original.",
                "names": "escala"
            },
            "flipx": {
                "doc": "¡Igual que @Phrase/flipx!",
                "names": "voltearx"
            },
            "flipy": {
                "doc": "¡Igual que @Phrase/flipy!",
                "names": "volteary"
            },
            "entering": {
                "doc": "¡Igual que @Group/entering!",
                "names": "entrando"
            },
            "resting": {
                "doc": "¡Igual que @Group/resting!",
                "names": "inmóvil"
            },
            "moving": {
                "doc": "¡Igual que @Group/moving!",
                "names": "moviendo"
            },
            "exiting": {
                "doc": "¡Igual que @Group/exiting!",
                "names": "saliendo"
            },
            "duration": {
                "doc": "¡Igual que @Phrase/duration!",
                "names": "duración"
            },
            "style": {
                "doc": "¡Igual queE @Phrase/style!",
                "names": "estilo"
            },
            "defaultDescription": "$1[$1|] $2 $3"
        },
        "Phrase": {
            "names": ["💬", "Frase"],
            "doc": [
                "¡Hola, hola! ¿Me recuerdas? ¿Cómo podría alguien olvidarse de /mí/? Eso es correcto, yo soy la frase maravillosa, lista para representar el @Text hermoso en el @Stage.",
                "Solo hazme así, y aparecerá en el @Stage:",
                "\\Frase('¡magnífico!')\\",
                "Necesito @Text obviamente, pero de otro modo, yo puedo aser todo que un @Output puedo hacer, incluyendo cambiando mi tamaño, fuente, rotacion, y todo los bailes con @Pose y @Sequence.",
                "Tambien puedes seleccionarme en el @Stage y editarme con la paleta cerca de la puerta."
            ],
            "defaultDescription": "$3[$3 metro |]frase $1 $2[llamdo $2|] $4[$4|] $5",
            "text": {
                "doc": "Los personajes a mostrar en el @Stage",
                "names": "texto"
            },
            "size": {
                "doc": "¡Qué tan alto debo ser en metros!",
                "names": "tamaño"
            },
            "face": {
                "doc": "El nombre de la fuente que yo debo ponerme.",
                "names": "fuente"
            },
            "place": {
                "doc": "El lugar en el escenario que debo estar.",
                "names": "lugar"
            },
            "wrap": {
                "doc": "La orilla que debo envolver simbolos o \\ø\\ si no debo de envolverlos.",
                "names": ["↵", "envolver"]
            },
            "alignment": {
                "doc": "Si hay una límite de @Phrase/wrap límite establecido, si debo de alinear los simbolos al principo, en medio, or al final.",
                "names": "alineación"
            },
            "direction": {
                "doc": "Si los símbolos se escriben horizontal o verticalmente, y si se establece vertical y @Phrase/wrap, si el texto se ajusta hacia la izquierda o hacia la derecha.",
                "names": "dirección"
            },
            "matter": {
                "doc": "¡Las propiedades a usar si choco con cosas!",
                "names": "materia"
            },
            "aura": {
                "doc": "$~El @Aura opcional para mostrar detrás de mí. ¡Hazme brillar!",
                "names": "$~aura"
            },
            "name": {
                "doc": [
                    "¡Un nombre que me das! Esto es muy útil para muchas cosas.",
                    "Primero, si tengo un nombre, yo lo usare para describirme en descripciones de lectoras de pantalla.",
                    "Segundo, cuando animas, puedes tener muchas expresiones que representan el mismo contenido en el escenario; darles el mismo nombre y ellos animarán como uno.",
                    "Finalmente, yo soy útil con @Choice: los nombres que me das aparecen en esa sequencia.",
                    "Puedes darme mucho nombres diferentes, cada uno en una idioma diferente, si es útil. Yo siempre usara el nombre en la idioma seleccionada primero."
                ],
                "names": "nombre"
            },
            "description": {
                "doc": [
                    "$~Una descripción personalizada para usar por parte de los miembros de la audiencia que no pueden ver la salida visual."
                ],
                "names": "$~descripción"
            },
            "selectable": {
                "doc": "Si \\T\\, indica que yo puedo hacer seleccionabo usando un puntero o tecla",
                "names": "seleccionable"
            },
            "color": {
                "doc": "El @Color que debo hacer por defecto, a menos que sea anulado por una @Pose diferente.",
                "names": "color"
            },
            "background": {
                "doc": "El @Color que va proyecte detras de mi",
                "names": "fondo"
            },
            "opacity": {
                "doc": "Qué tan transparente deberia ser por defecto, entre \\0\\ and \\1\\, a menos que fuera anulado por una @Pose diferente.",
                "names": "opacidad"
            },
            "offset": {
                "doc": "Un @Place indicando qué tan compensado debe estar de mi @Place, a menos que fuera anulado por una @Pose diferente.",
                "names": "desplazamiento"
            },
            "rotation": {
                "doc": "La cantidad en grados que debo rotar alrededor del centro, a menos que fuera anulado por una @Pose diferente.",
                "names": "rotación"
            },
            "scale": {
                "doc": "Qué magnificado debo ser en relación a el tamaño original, a menos que fuera anulado por una @Pose diferente.",
                "names": "escala"
            },
            "flipx": {
                "doc": "Si debería reflejarme en el eje x, a menos que fuera anulado por una @Pose diferente. ",
                "names": "voltearx"
            },
            "flipy": {
                "doc": "Si debería reflejarme en el eje y, a menos que fuera anulado por una @Pose diferente.",
                "names": "volteary"
            },
            "entering": {
                "doc": "La @Pose o @Sequence que debo de hacer cuando entro el escenario",
                "names": "entrando"
            },
            "resting": {
                "doc": "La @Pose o @Sequence que debo de hacer después que entro en el escenario, antes que salgo, y cuando mi @Place no esta cambiando. Si no me quieres dar uno, usaré el predeterminado.",
                "names": "inmóvil"
            },
            "moving": {
                "doc": "La @Pose o @Sequence que debo de hacer cuando cambio de lugar en el escenario en lugar de mi defecto.",
                "names": "moviendo"
            },
            "exiting": {
                "doc": "La @Pose o @Sequence que debo de hacer antes de salir del escenario",
                "names": "saliendo"
            },
            "duration": {
                "doc": "La duración que applicar cuando se mueve a otro lugar en el escenario.",
                "names": ["⏳", "duración"]
            },
            "style": {
                "doc": "El estilo de animación que applicar cuando se mueve a otro lugar en el escenario.",
                "names": "estilo"
            }
        },
        "Arrangement": {
            "names": ["⠿", "Arreglo"],
            "doc": "Soy una inspiración para muchos otros tipos de arreglos en Verse, incluidos @Row, @Stack, @Grid y @Free. Trabajo estrechamente con @Group."
        },
        "Row": {
            "names": ["➡", "Fila"],
            "doc": "Soy @Row, un @Arrangement horizontal de @Output, con relleno opcional. Has conocido a mi gemelo @Stack?",
            "description": "fila de $1 frases y grupos",
            "alignment": {
                "doc": "Si alinear el texto al inicio, al centro o al final de cada columna.",
                "names": "alineación"
            },
            "padding": {
                "doc": "La cantidad de relleno que se colocará entre la salida.",
                "names": "relleno"
            }
        },
        "Stack": {
            "names": ["⬇", "Pila"],
            "doc": "Soy @Stack, un @Arrangement vertical de @Output, con relleno opcional. Has conocido a mi gemelo @Row",
            "description": "pila de $1 frases y grupos",
            "alignment": {
                "doc": "Si alinear el texto al inicio, al centro o al final de cada columna.",
                "names": "alineación"
            },
            "padding": {
                "doc": "La cantidad de relleno que se colocará entre la salida.",
                "names": "relleno"
            }
        },
        "Grid": {
            "names": ["▦", "Cuadrícula"],
            "doc": "Soy cuadrícula de @Output. Dame un recuento de filas y columnas y haré un arreglo ordenado con relleno y tamaños de celda opcionales. ",
            "description": "cuadrícula de $1 fila, $2 columnas",
            "rows": {
                "doc": "Cuantas filas hacer en la cuadrícula.",
                "names": "fila"
            },
            "columns": {
                "doc": "Cuantas columnas para hacer en la cuadrícula.",
                "names": "columnas"
            },
            "padding": {
                "doc": "Cuanto relleno en medio de las celdas",
                "names": "relleno"
            },
            "cellWidth": {
                "doc": "Qué tan ancho son las celdas",
                "names": "anchodecelda"
            },
            "cellHeight": {
                "doc": "Qué tan alto son las celdas",
                "names": "alturadecelda"
            }
        },
        "Free": {
            "names": ["Suelto"],
            "doc": [
                "Soy como lo que sea. Sientate donde quieras. ¡Simplemente sientate! Asegúrate que todos los @Output que me das tiene un @Place, si no no van a saber a donde ir.",
                "Oh, ¡y recuerda que el @Place que le das a cada @Output es relativo all @Group's @Place! Entonces, si te preguntas por qué las cosas no estan apareciendo donde deben, intenta darle al @Group un lugar tambien."
            ],
            "description": "forma libre, $1 salidas"
        },
        "Shape": {
            "doc": "Soy una inspiración para todas las formas. Soy útil para decirle a @Stage qué forma tener.",
            "names": ["⬟", "Forma"],
            "form": {
                "doc": "Soy el tipo de forma para mostrar. Cada forma requiere información diferente para definir su disposición.",
                "names": "forma"
            },
            "name": {
                "doc": "Soy el nombre que puedes usar, para animaciones y @Collision . Por ejemplo, si represento el suelo, es posible que desees llamarme 'suelo'.",
                "names": "nombre"
            },
            "description": {
                "doc": [
                    "$~Una descripción para utilizar por parte de los miembros de la audiencia que no pueden ver la salida visual."
                ],
                "names": "$~descripción"
            },
            "selectable": {
                "doc": "Si puedo ser seleccionado como parte de @Choice.",
                "names": "seleccionable"
            },
            "color": {
                "doc": "El color de mis bordes.",
                "names": "color"
            },
            "background": {
                "doc": "El color de mi fondo.",
                "names": "fondo"
            },
            "opacity": {
                "doc": "Qué tan transparente debería ser.",
                "names": "opacidad"
            },
            "offset": {
                "doc": "Qué tan lejos de mi lugar debería aparecer, manteniéndome en el lugar.",
                "names": "desplazamiento"
            },
            "rotation": {
                "doc": "Cuánto girado debería estar. Esto afecta a @Collision .",
                "names": "rotación"
            },
            "scale": {
                "doc": "Cuánto ampliado debería estar, sin cambiar mi tamaño real.",
                "names": "escala"
            },
            "flipx": {
                "doc": "Si debo reflejarme en mi eje x.",
                "names": "voltearx"
            },
            "flipy": {
                "doc": "Si debo reflejarme en mi eje y.",
                "names": "volteary"
            },
            "entering": {
                "doc": "La @Pose o @Sequence  que debería hacer al entrar a @Stage.",
                "names": "entrando"
            },
            "resting": {
                "doc": "La @Pose o @Sequence  que debería hacer después de entrar y mientras no me estoy moviendo.",
                "names": "inmóvil"
            },
            "moving": {
                "doc": "La @Pose o @Sequence  que debería hacer al moverme de lugar.",
                "names": "movimiento"
            },
            "exiting": {
                "doc": "La @Pose o @Sequence  que debería hacer al salir de @Stage.",
                "names": "saliendo"
            },
            "duration": {
                "doc": "Cuánto deben durar mis animaciones si son una única @Pose.",
                "names": "duración"
            },
            "style": {
                "doc": "El estilo de animación que debería usar.",
                "names": "estilo"
            }
        },
        "Form": {
            "doc": "$~Soy una forma abstracta, como @Rectangle o @Circle.",
            "names": ["$~Forma"]
        },
        "Rectangle": {
            "names": "Rectángulo",
            "doc": "Soy un @Rectangle, útil para hacer un border de tu elección para el @Stage.",
            "left": {
                "doc": "Soy la orilla izquierda del escenario en el eje x.",
                "names": "izquierda"
            },
            "top": {
                "doc": "Soy la orilla masalta del escenario en el eje y.",
                "names": "masalta"
            },
            "right": {
                "doc": "Soy la orilla derecha del escenario en el eje x.",
                "names": "derecha"
            },
            "bottom": {
                "doc": "Soy la orilla abajo del escenarion en el eje y.",
                "names": "abajo"
            },
            "z": {
                "doc": "La posición de profundidad del rectángulo.",
                "names": "z"
            }
        },
        "Circle": {
            "doc": "$~Soy un círculo, útil para hacer formas en @Stage.",
            "names": ["$~Círculo"],
            "radius": {
                "doc": "$~El radio del circulo",
                "names": "$~radio"
            },
            "x": {
                "doc": "$~El centro horizontal del círculo.",
                "names": "$~X"
            },
            "y": {
                "doc": "$~El centro vertical del círculo.",
                "names": "$~y"
            },
            "z": {
                "doc": "$~La posición de profundidad del círculo.",
                "names": "$~z"
            }
        },
        "Polygon": {
            "doc": "$~Soy un polígono 'regular' con lados y ángulos de igual longitud, útil para crear formas en @Stage.",
            "names": ["$~Polígono"],
            "radius": {
                "doc": "$~El radio del polígono.",
                "names": "$~radio"
            },
            "sides": {
                "doc": "$~El número de lados del polígono.",
                "names": "$~lados"
            },
            "x": {
                "doc": "$~El centro horizontal del polígono.",
                "names": "$~X"
            },
            "y": {
                "doc": "$~El centro vertical del polígono.",
                "names": "$~y"
            },
            "z": {
                "doc": "$~La posición de profundidad del polígono.",
                "names": "$~z"
            }
        },
        "Pose": {
            "names": ["🤪", "Pose"],
            "doc": [
                "Sabes cuando alguien adopta la forma más maravilloso de pararse, hace una pausa y todos miran? Ese soy yo. Capturo una pose para @Output y soy el componente básico de sus movimientos.",
                "Muchas cosas entran en una pose. ¡Mira mis muchas aportaciones para ver qué tipo de poses puedes hacer!"
            ],
            "style": {
                "doc": "El estilo de animación que se utilizará al pasar a esta pose.",
                "names": "estilo"
            },
            "color": {
                "doc": "El @Color un @Output debe de hacer en esta pose, en lugar de la pose predeterminada.",
                "names": "color"
            },
            "opacity": {
                "doc": "Qué tan transparente debe ser un @Output, entre \\0\\ y \\1\\, en lugar de su valor predeterminado. Útil para desvanecerse y desaparecer.",
                "names": "opacidad"
            },
            "offset": {
                "doc": "Un @Place que indica qué tan alejado debe estar del lugar de un @Output, en lugar de su valor predeterminado. Útil para moverse en su lugar.",
                "names": "desplazamiento"
            },
            "rotation": {
                "doc": "Qué tan girado debe estar un @Output, en lugar de su valor predeterminado.",
                "names": "rotación"
            },
            "scale": {
                "doc": "Qué tan ampliado debe estar un @Output en relación con su tamaño original, en lugar de su tamaño predeterminado.",
                "names": "escala"
            },
            "flipx": {
                "doc": "Si un @Output debe reflejarse en el eje x, en lugar de su valor predeterminado.",
                "names": "voltearx"
            },
            "flipy": {
                "doc": "Si un @Output debe reflejarse en el eje y, en lugar de su valor predeterminado.",
                "names": "volteary"
            },
            "description": "$1[transparente $1|] $2[girado $2 degrees|] $3[magnificado $3|] $4[volteado horizontalmente|] $5[volteado verticalmente|]"
        },
        "Color": {
            "doc": [
                "Soy un color visible, compuesto por tres dimensiones esenciales.",
                "Aquí hay algunos colores comunes alrededor de la rueda de colores, con brillo medio y alta croma:",
                "\\Color(50% 100 0°)\\",
                "\\Color(50% 100 30°)\\",
                "\\Color(50% 100 60°)\\",
                "\\Color(50% 100 90°)\\",
                "\\Color(50% 100 120°)\\",
                "\\Color(50% 100 150°)\\",
                "\\Color(50% 100 180°)\\",
                "\\Color(50% 100 210°)\\",
                "\\Color(50% 100 240°)\\",
                "\\Color(50% 100 270°)\\",
                "\\Color(50% 100 300°)\\",
                "\\Color(50% 100 330°)\\"
            ],
            "names": ["🌈", "Color"],
            "lightness": {
                "doc": "Qué tan claro debería ser, desde \\0\\ hasta \\1\\, desde negro en \\0\\, hasta gris en \\0.5\\, hasta blanco en \\1\\.",
                "names": ["luminosidad", "l"]
            },
            "chroma": {
                "doc": "Cuánto color debería tener, desde \\0\\ hasta \\∞\\. Sin color significa gris, números más altos significan más color.",
                "names": ["croma", "c"]
            },
            "hue": {
                "doc": "De qué color debería ser, en una rueda de colores, desde magenta \\0\\, rojo \\30\\, verde \\120\\, hasta azul \\270\\.",
                "names": ["tono", "h"]
            }
        },
        "Sequence": {
            "doc": [
                "¡Oh. Mi. Dios. Director, te ves increíble hoy! ¿Quieres bailar conmigo? Es fácil.",
                "Solo necesitas darme un @Map, donde cada clave representa qué porcentaje estamos en la danza, y cada valor de esas claves es un @Pose a ser.",
                "¡Hay /tantas/ formas diferentes en las que puedes animar con esto! Por ejemplo, aquí hay uno simple:",
                "\\Frase('hola' reposo:Secuencia({0%: Pose(rotación: 360°) 100%: Pose(rotación: 0°)})\\",
                "Esto dice, /al principio (0%), comienza con inclinación 360, y termina con inclinación 0/. ¡Eso nos hará dar vueltas en círculos para siempre, ya que estoy configurado como la pose de reposo de @Phrase!",
                "Prueba tus propios bailes creativos jugando con otros inputs."
            ],
            "names": ["💃", "Secuencia"],
            "poses": {
                "doc": "Un @Map de porcentajes entre 0% y 100%, cada uno emparejado con un @Pose. No tienes que proporcionar todos los porcentajes; moveré suavemente un @Output entre los que me des.",
                "names": "poses"
            },
            "duration": {
                "doc": "¿Cuánto tiempo debería durar este baile? Si debo repetirlo, no agregaré tiempo a la duración, ¡simplemente bailaré más rápido!",
                "names": ["⏳", "duración"]
            },
            "style": {
                "doc": "El estilo que debería usar para el baile.",
                "names": "estilo"
            },
            "count": {
                "doc": "Cuántas veces debe repetirse la secuencia antes de que termine. Esto es realmente útil cuando entro en escena, me muevo en escena o salgo del escenario, pero cuando es una secuencia de descanso, se ignora, ¡ya que puedo descansar para siempre!",
                "names": "cuenta"
            }
        },
        "Place": {
            "doc": "Soy una ubicación en @Stage. Todos mis insumos son opcionales, porque estoy en el centro por defecto.",
            "names": ["📍", "Lugar"],
            "x": {
                "doc": "Una posición en el eje x.",
                "names": "x"
            },
            "y": {
                "doc": "Una posición en el eje y",
                "names": "y"
            },
            "z": {
                "doc": "Una posición en el eje z",
                "names": "z"
            },
            "rotation": {
                "doc": "Rotación en esta posición",
                "names": ["📐", "rotación"]
            }
        },
        "Velocity": {
            "doc": "Soy una ubicación en @Stage. Todos mis insumos son opcionales, porque estoy en el centro por defecto.",
            "names": ["💨", "Velocidad"],
            "x": {
                "doc": "Cuántos metros moverme cada segundo en el eje x.",
                "names": "x"
            },
            "y": {
                "doc": "Cuántos metros moverme cada segundo en el eje y.",
                "names": "y"
            },
            "angle": {
                "doc": "Cuántos grados rotar cada segundo",
                "names": ["ángulo", "°"]
            }
        },
        "Matter": {
            "doc": "Soy propiedades físicas de salida, que influyen en cómo interactúo con otras salidas en el escenario.",
            "names": ["⚛️", "Materia"],
            "mass": {
                "doc": "Un peso, en kilogramos",
                "names": "masa"
            },
            "bounciness": {
                "doc": "Cuánta de mi energía mantener en la colisión, 0 significa ninguna, 1 significa toda.",
                "names": "elasticidad"
            },
            "friction": {
                "doc": "Cuánto mantenerme deslizándome; 0 significa ninguno, 1 significa para siempre.",
                "names": "fricción"
            },
            "roundedness": {
                "doc": "Cuánto redondear las esquinas de la salida; 0 significa ninguna y 1 significa 100% de su tamaño, haciendo que los tamaños sean circulares.",
                "names": "redondez"
            },
            "text": {
                "doc": "Si puede chocar con otra salida.",
                "names": "texto"
            },
            "shapes": {
                "doc": "Si puede chocar con otras formas.",
                "names": "formas"
            }
        },
        "Aura": {
            "doc": [
                "$~Soy un AURA. ¡Hago que @Phrase BRILLAR! Como esto:",
                "$~\\Frase(\n\t'¡Estoy BRILLANDO!' \n\taura: Aura(Color(50% 100 118°) 0.1m 0m 0.1m\n)\\"
            ],
            "names": ["$~🔮", "$~Aura"],
            "color": {
                "doc": "$~El @Color que debería ser el @Aura.",
                "names": "$~color"
            },
            "blur": {
                "doc": "$~Qué borrosa debería estar la @Aura. \\0m\\ significa que no está nada borroso.",
                "names": "$~difuminar"
            },
            "offsetX": {
                "doc": "$~Qué tan lejos a la izquierda o a la derecha debería aparecer. \\0m\\ está directamente debajo.",
                "names": "$~compensaciónX"
            },
            "offsetY": {
                "doc": "How far down the @Aura should go",
                "names": "$~compensaciónY"
            }
        },
        "Stage": {
            "doc": [
                "HI. ESCENARIO AQUÍ. DIME QUÉ MOSTRAR Y LO MOSTRARÉ.",
                "\\Stage([Frase('cosas')])\\",
                "SI QUIERES, DAME UN @Color DE FONDO Y ILUMINARÉ EL ESCENARIO EN CONSECUENCIA.",
                "\\Stage([Frase('cosas')] Color(0% 0 0°) color: Color(100% 0 0°))\\",
                "TAMBIÉN PUEDES DARME UN BORDE DE MARCO Y RECORTARÉ.",
                "\\Stage([Frase('cosas')] Color(0% 0 0°) Rectángulo(-1m -1m 1m 1m) color: Color(100% 0 0°))\\"
            ],
            "names": ["🎭", "Escenario"],
            "content": {
                "doc": "La lista de @Output para mostrar en el escenario.",
                "names": "contenido"
            },
            "frame": {
                "doc": "La forma y tamaño del marco para colocar alrededor del escenario, ocultando todo lo que está fuera de él.",
                "names": "marco"
            },
            "size": {
                "doc": "COMO @Group/size",
                "names": "tamaño"
            },
            "face": {
                "doc": "COMO @Group/face",
                "names": "cara"
            },
            "place": {
                "doc": "SI FUERA UNA CÁMARA, AQUÍ ES DONDE ESTOY MIRANDO",
                "names": "lugar"
            },
            "name": {
                "doc": ["IGUAL QUE @Phrase/name!"],
                "names": "nombre"
            },
            "description": {
                "doc": [
                    "$~Una descripción para utilizar por parte de los miembros de la audiencia que no pueden ver la salida visual."
                ],
                "names": "$~descripción"
            },
            "selectable": {
                "doc": "IGUAL QUE @Phrase/selectable!",
                "names": "seleccionable"
            },
            "color": {
                "doc": "IGUAL QUE @Group/color",
                "names": "color"
            },
            "background": {
                "doc": "IGUAL QUE @Group/background",
                "names": "fondo"
            },
            "opacity": {
                "doc": "IGUAL QUE @Group/opacity",
                "names": "opacidad"
            },
            "offset": {
                "doc": "IGUAL QUE @Group/offset",
                "names": "desplazamiento"
            },
            "rotation": {
                "doc": "IGUAL QUE @Group/rotation",
                "names": ["📐", "rotación"]
            },
            "scale": {
                "doc": "IGUAL QUE @Group/scale",
                "names": "escala"
            },
            "flipx": {
                "doc": "IGUAL QUE @Group/flipx",
                "names": "voltearx"
            },
            "flipy": {
                "doc": "IGUAL QUE @Group/flipy",
                "names": "volteary"
            },
            "entering": {
                "doc": "IGUAL QUE @Group/entering",
                "names": "entrando"
            },
            "resting": {
                "doc": "IGUAL QUE @Group/resting!",
                "names": "inmóvil"
            },
            "moving": {
                "doc": "IGUAL QUE @Group/moving!",
                "names": "movimiento"
            },
            "exiting": {
                "doc": "IGUAL QUE @Group/exiting!",
                "names": "saliendo"
            },
            "duration": {
                "doc": "IGUAL QUE @Phrase/duration!",
                "names": ["⏳", "duracion"]
            },
            "style": {
                "doc": "IGUAL QUE @Phrase/style!",
                "names": "estilo"
            },
            "gravity": {
                "doc": "La gravedad a aplicar a la salida cuyo lugar está en @Motion.",
                "names": "gravedad"
            },
            "defaultDescription": "escenario $1[$1|] de $2[$2|] frases $3[$3 marco|] $4"
        },
        "Easing": {
            "straight": "recto",
            "cautious": "cauteloso",
            "pokey": "lento",
            "zippy": "rápido"
        },
        "sequence": {
            "sway": {
                "doc": "Creo una @Sequence que se balancea hacia adelante y hacia atrás alrededor del centro de un @Output.",
                "names": ["vaivén"],
                "angle": {
                    "doc": "Cuánto inclinarse en el vaivén.",
                    "names": ["ángulo"]
                }
            },
            "bounce": {
                "doc": "Creo una @Sequence  que hace que un @Output rebote a una altura dada.",
                "names": ["rebote"],
                "height": {
                    "doc": "Qué tan alto rebotar.",
                    "names": ["altura"]
                }
            },
            "spin": {
                "doc": "Creo una @Sequence que rota un @Output alrededor de su centro.",
                "names": ["girar"]
            },
            "fadein": {
                "doc": "Creo una @Sequence que hace que un @Output aparezca gradualmente de invisible a visible.",
                "names": ["aparecer"]
            },
            "fadeout": {
                "doc": "$~Creo una @Sequence que desvanece @Output de visible a invisible. ¡Pruébame en una @Sequence emocionante!",
                "names": ["$~desvanecimiento"]
            },
            "popup": {
                "doc": "Creo una @Sequence que hace que un @Output se agrande rápidamente y luego vuelva a su tamaño normal.",
                "names": ["aparecer"]
            },
            "shake": {
                "doc": "Creo una @Sequence que hace que parezca que un @Output está asustado.",
                "names": ["temblor"]
            }
        },
        "Source": {
            "names": "$~Fuente",
            "doc": [
                "$~¿Sabes que los proyectos pueden tener más de un archivo @Source? Te dejo crear un @Source basado en la lógica de tu proyecto. Esto es realmente útil si desea guardar algunos datos entre diferentes evaluaciones de su proyecto.",
                "$~Por ejemplo, imagina que quieres hacer un contador simple que cuente de uno en uno cada vez que presionas un botón del mouse. Puedes usar esto para recordar cuántas veces hiciste algo.",
                "$~\\↓ contar\n[\n\tFrase(`\\count\\ veces!`)\n\tFuente('cuenta' cuenta... ∆ Botón()... cuenta + 1)\n]\\",
                "$~Intente copiarlo, cree un nuevo @Source llamado /count/ y escriba 0 en él para comenzar el conteo en 0. Este pequeño proyecto obtendrá el valor en el /count/ source y cada vez que se presione el botón del mouse, editará el /count/ @Source debe ser el valor actual de /count/ más /1/."
            ],
            "name": {
                "names": "$~nombre",
                "doc": "$~El nombre del archivo fuente que se creará o actualizará."
            },
            "value": {
                "names": "$~valor",
                "doc": "$~El valor de datos con el que se debe crear o actualizar el archivo de origen."
            },
            "DynamicEditLimitException": {
                "description": "$~límite de edición de fuente dinámica",
                "explanation": "$~Este proyecto guardó datos en archivos @Source demasiadas veces y demasiado rápido. Asegúrese de que solo actualice @Source en respuesta a una entrada y no demasiado rápido."
            },
            "ReadOnlyEditException": {
                "description": "$~edición de fuente de solo lectura",
                "explanation": "$~Este proyecto recuerda datos, pero no tienes derechos para editarlos. Cópialo si quieres probarlo."
            },
            "EmptySourceNameException": {
                "description": "$~nombre de fuente vacío",
                "explanation": "$~El @Source proporcionado tenía un nombre vacío, por lo que no pudimos guardarlo."
            },
            "ProjectSizeLimitException": {
                "description": "$~límite de tamaño del proyecto",
                "explanation": "$~Este proyecto tiene demasiado texto, por lo que no podemos guardarlo."
            }
        }
    },
    "ui": {
        "font": {
            "app": "Noto Sans",
            "code": "Noto Sans Mono"
        },
        "phrases": {
            "welcome": "hola"
        },
        "widget": {
            "confirm": {
                "cancel": "cancelar"
            },
            "dialog": {
                "close": "cerrar"
            },
            "loading": {
                "message": "Cargando fuentes y texto, ¡gracias por esperar! "
            },
            "home": "ir a la página de inicio",
            "table": {
                "cell": {
                    "description": "$~editar esta celda",
                    "placeholder": "$~valor"
                },
                "addcolumn": "$~Añade una columna antes de esta columna.",
                "removecolumn": "$~eliminar esta columna"
            }
        },
        "tile": {
            "toggle": {
                "fullscreen": {
                    "on": "salir de pantalla completa",
                    "off": "exapandir teja a pantalla completa"
                },
                "show": {
                    "on": "esconder esta teja",
                    "off": "mostrar esta teja"
                }
            },
            "label": {
                "output": "escenario",
                "palette": "paleta",
                "docs": "guía",
                "source": "$source",
                "collaborate": "$~colaborar"
            },
            "button": {
                "collapse": "colapsar esta ventana"
            }
        },
        "project": {
            "error": {
                "unknown": "Esta actuación no existe o no es pública.",
                "translate": "$~Hubo un problema al traducir tu proyecto.",
                "tile": "$~Ups, hubo un error.",
                "reset": "$~Intentar reiniciar..."
            },
            "button": {
                "removeCollaborator": "quitar colaboradora",
                "copy": "copiar proyecto como texto",
                "addSource": "crear una nueva $source",
                "duplicate": "copia este proyecto",
                "revert": "volver al código original ",
                "focusOutput": "enfoque el teclado en el escenario",
                "focusSource": "enfoque en la siguiente fuente ",
                "focusDocs": "enfoque en la documentación",
                "focusPalette": "enfoque en la paleta",
                "focusCycle": "enfoque en la siguiente teja ",
                "unsaved": "mostrar error de guardado",
                "translate": "$~editar los idiomas de este proyecto y traducirlo a otros idiomas.",
                "primary": "$~establecido como la ubicación principal de este proyecto",
                "share": {
                    "tip": "$~Mostrar opciones para compartir proyectos",
                    "label": "$~compartir"
                },
                "history": {
                    "on": "$~mostrar código de proyecto reciente",
                    "redo": "$~mostrar el código del proyecto actual"
                }
            },
            "field": {
                "name": {
                    "description": "editar el nobmre del proyecto",
                    "placeholder": "nombre"
                }
            },
            "help": "mostrar atajos de teclado",
            "collapsed": "$~¡Todas tus ventanas están colapsadas! Puedes encontrarlos en la barra de herramientas a continuación.",
            "save": {
                "projectsNotSavedLocally": "Hubo un problema al guardar proyectos en tu navegador.",
                "projectsCannotNotSaveLocally": "Tu navegador no admite guardar proyectos.",
                "projectContainedPII": "Para proteger tu privacidad, un proyecto con información potencialmente identificable personalmente no se guardó en línea. Verifica el proyecto para ver si la información es identificativa.",
                "projectsNotLoadingOnline": "No se pueden cargar proyectos en línea.",
                "projectNotSavedOnline": "No se pueden guardar proyectos en línea.",
                "settingsUnsaved": "No se pueden guardar las configuraciones en línea."
            },
            "dialog": {
                "unsaved": "Trabajo no salvado...",
                "translate": {
                    "header": "$~Idiomas",
                    "explanation": [
                        "$~Estos son los idiomas que utiliza su proyecto.",
                        "$~Para intentar traducir su proyecto a otros idiomas, elija un idioma de origen principal y luego elija un nuevo idioma.",
                        "$~/No todos los idiomas son compatibles y las traducciones serán imperfectas, ¡así que revise los resultados!/"
                    ]
                }
            },
            "subheader": {
                "source": "$~Fuente",
                "destination": "$~Destino"
            }
        },
        "gallery": {
            "untitled": "Intitulada",
            "undescribed": "$~Sin descripción",
            "subheader": {
                "curators": {
                    "header": "Curadoras",
                    "explanation": "Creadoras que gestionan esta galería."
                },
                "creators": {
                    "header": "Creadoras",
                    "explanation": "Creadoras que contribuyen a esta galería."
                },
                "delete": {
                    "header": "Borrar",
                    "explanation": "Borrar esta galería no borrará sus proyectos. La galería se borrará para siempre."
                },
                "classes": {
                    "header": "$~Clases",
                    "explanation": "$~Clases asociadas a esta galería."
                }
            },
            "confirm": {
                "delete": {
                    "description": "borrar galería",
                    "prompt": "borrar"
                },
                "remove": {
                    "description": "quitar proyecto de la galería",
                    "prompt": "quitar"
                }
            },
            "error": {
                "unknown": "Esta galería no existe o no es pública"
            },
            "field": {
                "name": {
                    "description": "Nombre de la galería",
                    "placeholder": "nombre"
                },
                "description": {
                    "description": "Descripción de la galería",
                    "placeholder": "Describe tu galería. ¿Cuál es su tema, objetivos o comunidad?"
                }
            }
        },
        "source": {
            "label": "editora de programas",
            "empty": [
                "¡Empecemos! Puedes …",
                "• Abre 📕 y arrástranos 🖱️ a este programa.",
                "• Escribe $1 y elígenos del menú.",
                "• Si nos conoces bien, empieza a escribir.",
                "• Explora la galería en busca de inspiración.",
                "Si estas atascada, <aprende más@://learn>."
            ],
            "overwritten": "¡Recibí una versión más reciente!",
            "confirm": {
                "delete": {
                    "description": "borra esta $source",
                    "prompt": "borrar"
                }
            },
            "toggle": {
                "blocks": {
                    "on": "esconder los fondos de los bloques",
                    "off": "mostrar los fondos de los bloques"
                },
                "glyphs": {
                    "on": "colapsar los glifos coincidentes",
                    "off": "expandir los glifos coincidentes"
                }
            },
            "button": {
                "selectOutput": "mostrar este resultado en el escenario",
                "expandSequence": "expandir este código colapsado"
            },
            "field": {
                "name": {
                    "description": "editar nombre de fuente",
                    "placeholder": "nombre"
                }
            },
            "menu": {
                "label": "menú de autocompletar",
                "show": "mostrar menú de autocompletar",
                "back": "salir del submenú"
            },
            "cursor": {
                "priorLine": "mover el cursor a la línea anterior",
                "nextLine": "mover el cursor a la línea después",
                "priorInline": "mover el cursor a la posición anterior",
                "nextInline": "mover el cursor a la posición después",
                "lineStart": "mover el cursor al inicio de la línea",
                "lineEnd": "mover el cursor al final de la línea",
                "sourceStart": "$~mover el cursor al inicio de la fuente",
                "sourceEnd": "$~mover el cursor al final de la fuente",
                "priorNode": "seleccionar vecina antes",
                "nextNode": "seleccionar vecina después",
                "parent": "seleccionar contenedor",
                "selectAll": "seleccionar programa",
                "incrementLiteral": "aumentar número, texto o booleano",
                "decrementLiteral": "disminuir número, texto o booleano",
                "insertSymbol": "insertar $1",
                "insertTab": "insertar tabulación",
                "insertTrue": "insertar verdadera",
                "insertFalse": "insertar falsa",
                "insertNone": "insertar ningún símbolo",
                "insertNotEqual": "insertar no igual",
                "insertProduct": "insertar símbolo de multiplicación",
                "insertQuotient": "insertar símbolo de cociente",
                "insertDegree": "insertar símbolo de grado",
                "insertFunction": "insertar una función",
                "insertLessOrEqual": "insertar inferior o igual a",
                "insertGreaterOrEqual": "insertar superior o igual a",
                "insertStream": "insertar símbolo de flujo",
                "insertChange": "insertar símbolo de cambiar",
                "insertConvert": "insertar símbolo de conversión",
                "insertPrevious": "insertar símbolo de anterior",
                "insertType": "insertar símbolo de tipo",
                "insertTable": "insertar símbolo de tabla",
                "insertTableClose": "insertar cierre de tabla",
                "insertBorrow": "insertar préstamo",
                "insertShare": "insertar compartir",
                "insertLine": "insertar salto de línea",
                "backspace": "borrar selección o carácter anterior",
                "delete": "eliminar selección o carácter siguiente",
                "cut": "corte lo que esté seleccionado",
                "copy": "copiar lo que esté  seleccionado",
                "paste": "pegar el contenido del teclado",
                "parenthesize": "poner entre paréntesis lo que esté seleccionado",
                "enumerate": "enumerar selección",
                "type": "escribir caracteres",
                "undo": "deshacer edición anterior",
                "redo": "rehacer edición deshecha",
                "search": "buscar caracteres especiales para insertar",
                "tidy": "espaciado ordenado",
                "elide": "$~alternar elisión",
                "insertDocs": "$~Insertar símbolo de explicación"
            }
        },
        "annotations": {
            "label": "conflictos y ayuda",
            "cursor": "Esto es *$1*$2[ y son de tipo $2|].",
            "cursorParent": "$~Están dentro de un *$1*$2[ de tipo $2|].",
            "learn": "¿Quieres aprender más?",
            "evaluating": "¡Oh, qué divertido, evaluemos!",
            "space": "¡Esto es espacio! ¿Quién sabía que nada podría decir tanto?",
            "button": {
                "resolution": "Resolver este conflicto"
            }
        },
        "output": {
            "label": "salida del programa",
            "toggle": {
                "grid": {
                    "on": "esconder líneas de cuadrícula ",
                    "off": "mostrar líneas de cuadrícula"
                },
                "fit": {
                    "on": "controlar zoom manualmente",
                    "off": "ajustar zoom al contenido"
                },
                "paint": {
                    "off": "colocar salida",
                    "on": "pintar salida"
                }
            },
            "field": {
                "key": {
                    "description": "escuchando pulsaciones de teclas",
                    "placeholder": "mensaje"
                }
            },
            "button": {
                "submit": "enviar este mensaje de chat"
            },
            "options": {
                "locale": "$~elegir el idioma de salida"
            }
        },
        "timeline": {
            "label": "línea de tiempo",
            "slider": "deslizador de tiempo",
            "button": {
                "play": "evaluar el programa hasta el final, respondiendo a las entradas en tiempo real",
                "pause": "pausar el programa, permitiendo avanzar y retroceder paso a paso",
                "backStep": "retroceder uno",
                "backNode": "retroceder a la evaluación del nodo anterior",
                "backInput": "retroceder una entrada",
                "out": "salir de esta función",
                "forwardStep": "avanzar uno",
                "forwardNode": "avanzar a la siguiente evaluación del nodo",
                "forwardInput": "avanzar a la siguiente entrada del flujo",
                "present": "al presente",
                "start": "al principio",
                "reset": "reiniciar la actuación"
            }
        },
        "docs": {
            "label": "navegador de documentación",
            "link": "mostrar concepto $1 en la documentación",
            "learn": "saber más …",
            "nodoc": "¿Quién soy? ¿Qué soy? ¿Cuál es mi propósito?",
            "button": {
                "home": "volver a casa",
                "back": "regresar al anterior"
            },
            "field": {
                "search": "buscar conceptos con palabras"
            },
            "header": {
                "inputs": "Entradas",
                "interfaces": "Interfaces",
                "properties": "Propiedades",
                "functions": "Funciones",
                "conversions": "Conversiones"
            }
        },
        "dialog": {
            "share": {
                "header": "Compartir",
                "explanation": "Controla quién puede editar y ver este proyecto.",
                "subheader": {
                    "gallery": {
                        "header": "Galería",
                        "explanation": "Agrega este proyecto a una galería junto con otros creadores, o crea una galería en tu página de <projects@://projects>. Si añades un proyecto a una galería pública, tu proyecto se volverá público."
                    },
                    "public": {
                        "header": "Público/Privado",
                        "explanation": "Proyectos y galerías públicas pueden ser vistos por cualquier persona en el mundo. Nuestra meta es que este contenido traiga afirmación y alegría, y compartir públicamente es una manera de lograrlo. Pero también implica seguir algunas reglas. Prometes que tu proyecto no:"
                    },
                    "pii": {
                        "header": "$~Informacion personal",
                        "explanation": "$~Compartir información de identificación personal (PII) públicamente puede poner en riesgo a los creadores, por lo que detectamos posibles PII y advertimos a los creadores que eliminen los datos confidenciales o los marquen como no confidenciales.\n\nA continuación se muestra una lista de posibles PII en este proyecto que ha marcado como no confidencial. Puedes hacer clic en el botón al lado para volver a marcarlo como confidencial, pero hacerlo significa que tu proyecto ya no se guardará en línea."
                    }
                },
                "field": {
                    "emailOrUsername": {
                        "placeholder": "correo electrónico o nombre de usuario",
                        "description": "correo electrónico o nombre de usuario de la persona a la que desea darle acceso de edición"
                    }
                },
                "mode": {
                    "public": {
                        "label": "visibilidad",
                        "modes": ["privado", "público"]
                    }
                },
                "error": {
                    "unknown": "No conocemos a una creadora con este correo electrónico.",
                    "anonymous": "Debes iniciar sesión para compartir."
                },
                "button": {
                    "submit": "Compartir el proyecto con esta dirección de correo electrónico",
                    "sensitive": {
                        "tip": "$~Marcar este texto como sensible nuevamente",
                        "label": "$~sensible"
                    }
                },
                "options": {
                    "gallery": "celector de la galería"
                }
            },
            "settings": {
                "header": "Configuración",
                "explanation": "Cambia la configuración de diseño, dispositivo y tema.",
                "button": {
                    "show": "mostrar cuadro de diálogo de configuración"
                },
                "mode": {
                    "layout": {
                        "label": "diseño",
                        "modes": [
                            "automático",
                            "horizontal",
                            "vertical",
                            "libre"
                        ]
                    },
                    "animate": {
                        "label": "animaciones",
                        "modes": [
                            "apagadas",
                            "encendidas",
                            "a la mitad de velocidad",
                            "a un tercio de velocidad",
                            "a un cuarto de velocidad"
                        ]
                    },
                    "dark": {
                        "label": "tema",
                        "modes": [
                            "colores claros",
                            "colores oscuros",
                            "usar configuración del dispositivo"
                        ]
                    },
                    "space": {
                        "label": "$! indicador de espacio",
                        "modes": ["$! abierto", "$! cerrado"]
                    },
                    "writing": {
                        "label": "diseño de escritura",
                        "modes": [
                            "horizontal, de izquierda a derecha",
                            "vertical, de derecha a izquierda",
                            "vertical, de izquierda a derecha"
                        ]
                    },
                    "localized": {
                        "label": "localización de código",
                        "modes": [
                            "no localizar el código",
                            "localizar el código cuando esté disponible",
                            "localizar el código pero preferir símbolos"
                        ]
                    },
                    "lines": {
                        "label": "$~Línea de números",
                        "modes": [
                            "$~mostrar números de línea en modo texto",
                            "$~no mostrar números de línea en modo texto"
                        ]
                    }
                },
                "options": {
                    "mic": "micrófono seleccionado",
                    "camera": "cámara seleccionada ",
                    "face": "$~tipo de fuente"
                }
            },
            "locale": {
                "header": "Idioma",
                "explanation": "Elige tus idiomas y regiones.",
                "subheader": {
                    "selected": "Seleccionado",
                    "supported": "Disponible",
                    "coming": "Muy pronto",
                    "help": "Ayúdanos a traducir …"
                },
                "button": {
                    "show": "cambiar idiomas",
                    "replace": "reemplazar idomas",
                    "add": "añadir idioma",
                    "remove": "quitar idioma"
                }
            },
            "help": {
                "header": "Atajos",
                "explanation": "Utiliza estos comandos de teclado para una edición más eficiente.",
                "subheader": {
                    "moveCursor": "Mover",
                    "editCode": "Editar",
                    "insertCode": "Insertar",
                    "debug": "Depurar"
                }
            }
        },
        "palette": {
            "label": "paleta",
            "labels": {
                "mixed": "mezclado",
                "computed": "calculado",
                "default": "por defecto",
                "inherited": "heredado",
                "notSequence": "no es una secuencia",
                "notContent": "no es una lista de contenido",
                "format": "formato",
                "weight": "peso",
                "light": "ligera",
                "normal": "normal",
                "bold": "negrita",
                "extra": "extra",
                "italic": "itálica",
                "underline": "subrayar"
            },
            "button": {
                "revert": "volver a por defecto",
                "set": "editar esta propiedad",
                "addPhrase": "añadir una frase después de esta",
                "addGroup": "añadir un grupo después de esta",
                "addShape": "añadir una forma después de esta",
                "addMotion": "establecer lugar en flujo de Movimiento",
                "addPlacement": "establecer lugar en flujo de Colocación",
                "remove": "quitar este contenido",
                "up": "mover este contenido hacia arriba",
                "down": "mover este contenido hacia abajo",
                "edit": "editar este contenido",
                "sequence": "convertir en una secuencia",
                "createPhrase": "crear una Frase, mostrando el valor existente como texto",
                "createGroup": "crear un Grupo, envolviendo cualquier Frase existente",
                "createStage": "crear un Escenario, envolviendo cualquier Grupo o Frase existente"
            },
            "prompt": {
                "offerPhrase": "¡Qué valor tan hermoso has creado! ¿Debería mostrarlo en @Stage?",
                "offerGroup": "¡Qué maravillosa @Phrase has creado! ¿Quieres juntarlas en un @Group para organizarlas?",
                "offerStage": "MUY BIEN @Program. AGRÉGAME PARA CONTROLAR ILUMINACIÓN. COLORES. CUADROS.",
                "pauseToEdit": "Si ⏸️ el escenario, puedes seleccionar una 💬, 🔳 o 🎭 para editar.",
                "editing": "¡Edítame!"
            },
            "field": {
                "coordinate": "editar coordenada",
                "text": "editar texto"
            },
            "sequence": {
                "button": {
                    "add": "añadir pose",
                    "remove": "quitar pose",
                    "up": "mover pose hacia arriba",
                    "down": "mover pose hacia abajo"
                },
                "field": {
                    "percent": "editar porcentaje"
                }
            }
        },
        "save": {
            "saving": "guardando",
            "saved": "guardado en línea",
            "local": "guardado localmente",
            "unsaved": "no guardado"
        },
        "page": {
            "unknown": {
                "header": "¡Ups!",
                "message": "¿Dónde estamos? ¿Podemos ir a casa?"
            },
            "landing": {
                "value": "¡Crea historias interactivas con palabras, símbolos, emojis y codifica con nosotros!",
                "description": [
                    "Wordplay es un lenguaje de programación que te permite:",
                    "• Anima palabras y emojis de forma divertida 🤪︎",
                    "• Utilice el tiempo 🕦︎, el sonido 🎤︎, los sitios web 🔗︎ y la física 🌎︎",
                    "• Comparte 🤝︎ con amigos, grupos o cualquier persona",
                    "• Código en cualquier idioma del mundo 🌐︎",
                    "• Edite con mouse 🖱︎️, toque 👆︎ y teclados ⌨︎️",
                    "• Depurar hacia adelante ⏩︎ y hacia atrás ⏪︎",
                    "• Ver con pantallas 🖥︎️ y lectores de pantalla 🔊",
                    "• Gratis para siempre de la Universidad de Washington↗."
                ],
                "beta": [
                    "Wordplay está en *beta*. Esto significa que la funcionalidad puede cambiar o no funcionar como se espera."
                ],
                "link": {
                    "about": "¿Por qué existe este lugar?",
                    "learn": "Un tutorial dramático de elenco de personajes ",
                    "guide": "$~Buscar y explorar la referencia del idioma.",
                    "projects": "Crea y comparte actuaciones",
                    "galleries": "Experimenta actuaciones de otros",
                    "rights": "Responsabilidades, las nuestras y las tuyas",
                    "community": {
                        "label": "Comunidad",
                        "subtitle": "Chatea con nosotras en Discord."
                    },
                    "contribute": {
                        "label": "Contribuir",
                        "subtitle": "Ayúdanos a hacer Wordplay."
                    },
                    "teach": "$~Gestionar clases de estudiantes y sus proyectos"
                }
            },
            "learn": {
                "header": "Aprender",
                "error": "No pudimos encontrar un tutorial para este idioma.",
                "button": {
                    "next": "siguiente pausa en el diálogo",
                    "previous": "anterior pausa en el diálogo"
                },
                "options": {
                    "lesson": "lección presente"
                }
            },
            "guide": {
                "header": "$~Guía",
                "description": "$~Esta es una referencia para cada parte del lenguaje de programación Wordplay. Busque un concepto o explore la lista para obtener más información."
            },
            "projects": {
                "header": "Proyectos",
                "projectprompt": "¿Listo para decir algo? Crea un proyecto o trabaja en uno. Si te quedas atascado, sigue <learning@://learn>.",
                "archiveheader": "Archivados",
                "archiveprompt": "Estos son proyectos que has archivado. Solo los propietarios pueden eliminarlos permanentemente o desarchivarlos. Los proyectos archivados se eliminarán permanentemente 30 días después de su última edición.",
                "galleriesheader": "Galerías",
                "galleryprompt": "Crea y cura galerías para compartir una colección de proyectos con otros.",
                "add": {
                    "header": "$~Nuevo proyecto",
                    "explanation": "$~Elija una plantilla para crear un nuevo proyecto."
                },
                "button": {
                    "newproject": "nuevo proyecto",
                    "editproject": "editar este proyecto",
                    "viewcode": "$~ver el código de este proyecto",
                    "newgallery": "nueva galería",
                    "unarchive": "desarchivar este proyecto"
                },
                "confirm": {
                    "archive": {
                        "description": "archivar esta actuación",
                        "prompt": "archivar"
                    },
                    "delete": {
                        "description": "eliminar permanentemente esta actuación",
                        "prompt": "eliminar para siempre"
                    }
                },
                "error": {
                    "noaccess": "No pudimos conectarnos a internet.",
                    "nogalleryedits": "Debes iniciar sesión para crear y cambiar galerías.",
                    "newgallery": "No pudimos crear una nueva galería.",
                    "nodeletes": "Debes iniciar sesión para eliminar proyectos archivados.",
                    "delete": "Oops, no pudimos eliminar el proyecto."
                }
            },
            "galleries": {
                "header": "Galerías",
                "prompt": "Estas son actuaciones que otros han creado. Exprímentalas, estúdialas o adáptalas para hacer tu propia declaración.",
                "examples": "Ejemplos"
            },
            "about": {
                "header": "Acerca de",
                "content": [
                    "¿Alguna vez has sentido que la programación era sólo para occidentales sin discapacidades que hablan inglés y que esten obsesionados con las computadoras?",
                    "Sí, nosotros también.",
                    "Esto no es casualidad. Desde los inicios de la computación, los lenguajes de programación han sido diseñados y construidos principalmente por el mismo grupo de personas: hombres blancos, cisgénero, de habla inglesa, en el ámbito académico e industrial de Estados Unidos y Europa, y algunas mujeres matemáticas increíbles. Hicieron su trabajo en una época poscolonial en la que el ganador se llevaba todo el poder, y los lenguajes de programación fueron una herramienta clave para asegurar ese poder.",
                    "Ya sea intencional o no, esta historia ha llevado a una visión de la computación que se centra principalmente en la velocidad, la lógica, la ganancia y la dominación.",
                    "Esto es una injusticia. Porque la computación, para bien y para mal, ahora sustenta la vida diaria de formas visibles e invisibles, y las personas que tienen acceso para crear con ella son las que más se parecen a sus creadores. El resto de la humanidad sigue siendo endeudado de este poder, porque imaginar algo diferente requiere acceso, obstaculizado por barreras de idioma, barreras de accesibilidad, barreras económicas y desigualdades en la educación pública.",
                    "*Wordplay* aspira a ser algo diferente. Una plataforma de programación diseñada para ser global, que admita /todos/ los idiomas del mundo, pero también que sea /sobre/ los idiomas del mundo. Una plataforma en la que todas puedan crear, con las habilidades que tengan, para compartir contenido interactivo que cualquiera pueda experimentar, con cualquier habilidad que tenga. Para jóvenes y adultas jóvenes que deseen expresarse de manera *juguetona*, *artística* e *interactiva*. No con el objetivo de aprovechar el poder, sino de crear una comunidad diversa que reconozca la increíble fuerza que proviene de nuestras hermosas diferencias.",
                    "Somos una comunidad de diseñadoras, educadoras y desarrolladoras que intentan dar vida a esta visión. Somos personas de color, somos transgénero, somos queer, somos discapacitadas y venimos de todo el mundo. Estamos centradas en la <University of Washington@https://washington.edu> <Information School@https://ischool.uw.edu/> en Seattle, Washington, USA, un lugar que aspira a dar la bienvenida a todas y deshacer los estragos del colonialismo que continúan hoy. Crear este lenguaje de programación y plataforma es parte de esa misión.",
                    "Consulta nuestros <milestones@https://github.com/amyjko/wordplay/milestones> para ver en qué estamos trabajando, y si deseas ayudar, aprende <cómo contribuir@https://github.com/amyjko/wordplay/blob/main/CONTRIBUTING.md>. O escribe a nuestra organizadora comunitaria <Amy@https://amyjko.phd> con preguntas."
                ]
            },
            "login": {
                "header": "Iniciar sesión",
                "anonymous": "iniciar sesión",
                "prompt": {
                    "forgot": "*¿Olvidaste tu contraseña?* Desafortunadamente, no podemos recuperar tu cuenta ya que no recopilamos información de contacto.",
                    "enter": "Parece que tu enlace de inicio de sesión vino de un navegador o dispositivo diferente. ¿Puedes ingresar tu correo electrónico nuevamente, solo para estar seguros de que eres tú?",
                    "play": "Estás conectado, ¡podemos guardar tus proyectos en línea ahora! ¿Quieres crear algo?",
                    "tooyoung": "Debes tener 13 años o más para iniciar sesión con un correo electrónico.",
                    "passwordrule": "Las contraseñas deben tener al menos 10 caracteres de longitud; si no estás utilizando un administrador de contraseñas, elige tres palabras largas que recuerdes.",
                    "passwordreminder": "Parece que estás creando una cuenta. Verifica tu contraseña, asegúrate de haberla almacenado de manera segura y correctamente, luego envía nuevamente para crear tu cuenta.",
                    "changeEmail": "¿Quieres cambiar tu correo electrónico? Envía uno nuevo y te enviaremos una confirmación al antiguo.",
                    "changePassword": "¿Quieres cambiar tu contraseña? Envía una nueva y repítela.",
                    "email": "$! ¿Tiene una cuenta heredada solo de correo electrónico? Envíe su correo electrónico y le enviaremos un enlace de inicio de sesión",
                    "sent": "$! Si este correo electrónico está asociado con una cuenta, recibirá un enlace de inicio de sesión.",
                    "logout": "¿Estás saliendo de un dispositivo compartido y quieres mantener tus proyectos privados? Cierra la sesión y borraremos tus proyectos de este dispositivo. Todavía se almacenarán en línea.",
                    "success": "¡Cuenta creada!",
                    "confirm": "Revisa tu antigua dirección de correo electrónico para confirmar tu nueva dirección.",
                    "delete": "¿Quieres que olvidemos todo lo que has creado aquí? Esto no se puede deshacer.",
                    "reallyDelete": "¿Estás segura? Tu cuenta y configuraciones se eliminarán inmediatamente, y tus proyectos se programarán para su eliminación. Las colaboradoras en tus proyectos perderán de inmediato el acceso a ellos. Escribe tu correo electrónico o nombre de usuario para confirmar que esto es lo que deseas.",
                    "name": "Elige un emoji para representarte a ti mismo ante los demás.",
                    "login": "$~Inicie sesión para guardar sus proyectos, colaborar y compartir:",
                    "join": "$~O bien, <crear una cuenta@://unirse> para comenzar."
                },
                "error": {
                    "expired": "Este enlace ha expirado.",
                    "invalid": "Este enlace no es válido.",
                    "email": "Este correo electrónico no era válido.",
                    "failure": "No se puede iniciar sesión :(",
                    "offline": "Pareces estar desconectada.",
                    "unchanged": "No pudimos cambiar tu dirección de correo electrónico, pero no sabemos por qué.",
                    "delete": "No pudimos borrar tu cuenta, pero no sabemos por qué.",
                    "wrongPassword": "Nombre de usuario y contraseña no son válidos. O bien tu contraseña es incorrecta o alguien más tiene este nombre de usuario.",
                    "tooMany": "$~Has intentado y no has podido iniciar sesión demasiadas veces. Tendrás que esperar para volver a intentarlo."
                },
                "feedback": {
                    "changing": "Enviando nuevo correo electrónico...",
                    "deleting": "Vale, borrando tus proyectos y configuraciones...",
                    "updatedPassword": "Tu contraseña se ha actualizada.",
                    "match": "Esto debe coincidir con el nombre de usuario de su cuenta."
                },
                "field": {
                    "email": {
                        "description": "editar correo electrónico de inicio de sesión",
                        "placeholder": "correo electrónico"
                    },
                    "username": {
                        "description": "nombre de usuario para iniciar sesión, no uses información personal identificable",
                        "placeholder": "nombre de usuario"
                    },
                    "password": {
                        "description": "contraseña para iniciar sesión, al menos 10 caracteres",
                        "placeholder": "contraseña"
                    },
                    "currentPassword": {
                        "description": "su contraseña de inicio de sesión actual",
                        "placeholder": "contraseña actual"
                    },
                    "newPassword": {
                        "description": "tu nueva contraseña",
                        "placeholder": "nueva contraseña"
                    }
                },
                "button": {
                    "logout": {
                        "tip": "cerrar sesión de tu cuenta",
                        "label": "cerrar sesión"
                    },
                    "login": "iniciar sesión con este correo electrónico, enviando un enlace de inicio de sesión",
                    "updateEmail": "cambiar tu correo electrónico",
                    "delete": {
                        "tip": "borrar tu cuenta",
                        "label": "borrar mis datos…"
                    },
                    "reallyDelete": {
                        "tip": "borrar tu cuenta para siempre",
                        "label": "¡¡¡bórralo!!!"
                    },
                    "updatePassword": "enviar nueva contraseña"
                },
                "toggle": {
                    "reveal": {
                        "on": "Mostrar contraseña",
                        "off": "Ocultar contraseña"
                    }
                },
                "subtitle": "$~Guardar, colaborar y compartir"
            },
            "join": {
                "header": "Unirse",
                "prompt": {
                    "create": "$~Crea una cuenta para guardar tus proyectos, colaborar con otros y compartir tu trabajo.",
                    "username": "$~Los nombres de usuario deben tener al menos /5 caracteres/, no pueden ser un correo electrónico y no deben contener su nombre u otra información de identificación.",
                    "password": "$~Las contraseñas deben tener al menos 10 caracteres. Escríbalas dos veces y anótelas en un lugar seguro, como un administrador de contraseñas. *No hay forma de recuperar su cuenta* si la pierde, ya que no recopilamos información de contacto."
                }
            },
            "rights": {
                "header": "Derechos",
                "content": [
                    "¡Hola!",
                    "Aquí establecemos algunas expectativas sobre tus derechos y los nuestros (también en vista de políticas como el <COPPA@https://www.ecfr.gov/current/title-16/chapter-I/subchapter-C/part-312> y <GDPR@https://gdpr.eu/compliance-checklist-us-companies/>)",
                    "Lo primero que debes saber es que no somos una entidad comercial. Somos un proyecto de investigación basado en la comunidad alojado en una universidad sin fines de lucro. Nuestro objetivo es crear una plataforma que te brinde alegría y nos ayude a hacer descubrimientos sobre un mundo de computación más equitativo y justo. No tenemos interés en ganar dinero con esta plataforma; cualquier dinero que recolectemos (generalmente a través de financiamiento público) se utiliza para sostener la plataforma, no para enriquecer a nadie que trabaje en ella (o contribuya a ella).",
                    "Como no buscamos obtener ganancias, esto también significa que no podemos hacer ninguna promesa sobre la confiabilidad, disponibilidad o longevidad de esta plataforma. Dicho esto, <Amy@https://amyjko.phd> está comprometida a largo plazo con su sostenibilidad, y como profesora titular, tiene un trabajo bastante estable.",
                    "Eso nos lleva a *datos*. Esto es lo que recopilamos y almacenamos en la nube:",
                    "• Tus *proyectos*. Almacenamos cualquier proyecto que contribuyas. Esto incluye cualquier información personal identificable que pongas en tus proyectos (¡que podría ser cualquier cosa, ya que todo es texto!)",
                    "• Tus *configuraciones*. Esto incluye los idiomas que elijas, tus preferencias de animación y el progreso en los tutoriales. Todo lo demás se almacena en tu dispositivo.",
                    "• *Tráfico*. Usamos <Google Analytics@https://en.wikipedia.org/wiki/Google_Analytics> básico para recopilar datos agregados y anónimos sobre qué páginas y proyectos visita la gente y cuántas veces. Usamos esto para ayudar a recaudar fondos para sostener la plataforma.",
                    "No almacenamos nada más. Ninguna 'cookie' que no sea la utilizada por Google Analytics, ningún identificador de seguimiento, ninguna grabación de entrada de cámara o micrófono. Nuestro <código fuente@https://github.com/amyjko/wordplay/tree/main/src> es público, así que puedes verificar esto en cualquier momento si lo deseas.",
                    "*Tú* eres dueño de tus datos, no nosotros. Eso significa:",
                    "• Tú controlas quién puede acceder a tus proyectos. Son privados por defecto, pero puedes compartirlos con individuos, grupos o hacerlos completamente públicos.",
                    "• Puedes eliminar completamente cualquier proyecto o tu propia cuenta en cualquier momento.",
                    "• Puedes obtener una exportación de cualquier proyecto o de toda tu cuenta en cualquier momento.",
                    "Así es como usaremos y no usaremos tus datos:",
                    "• No compartiremos tus datos con nadie, a menos que la ley lo requiera explícitamente. Siempre es posible que tus datos se tomen sin nuestro permiso (una 'violación de datos'). Si descubrimos que esto ha sucedido, te notificaremos que esto ha sucedido mediante el correo electrónico que has compartido con nosotros.",
                    "• No te contactaremos a través de tu dirección de correo electrónico a menos que 1) realices un cambio en la cuenta que lo requiera, 2) nos des consentimiento explícito para comunicarnos, o 3) en el caso de la violación de datos anterior.",
                    "• Podemos analizar proyectos en la plataforma para entender qué están haciendo todos y cómo lo están haciendo. Podemos compartir estas ideas agregadas y anonimizadas en publicaciones académicas. Solo haremos esto bajo la supervisión de una junta de revisión institucional, según lo exige la ley federal de EE. UU.",
                    "Finalmente, una nota sobre el discurso. Puedes decir lo que quieras en esta plataforma en *privado*. Los proyectos son privados por defecto, y si los compartes con direcciones de correo electrónico específicas, aún se consideran privados. No moderaremos nada en proyectos privados.",
                    "Pero hacer un proyecto *público*, o incluirlo en una galería pública, es un privilegio. Esta es una plataforma hecha por amor, afirmación, respeto y dignidad. Por lo tanto, esperamos que ninguno de su *público*::"
                ],
                "consequences": [
                    "Si encontramos un proyecto o galería que viola estas reglas, advertiremos a los creadores antes de que lo vean o bloquearemos su visualización. Si violas repetidamente estas reglas, perderás el privilegio de publicar públicamente."
                ]
            },
            "donate": {
                "header": "Donar",
                "prompt": "Habilita una programación más accesible y global",
                "content": [
                    "Wordplay es un proyecto gratuito basado en la comunidad y respaldado por la <University of Washington@https://washington.edu>. Dependemos de donaciones de personas que creen en nuestra misión de lenguajes de programación educativos que son accesibles, y inclusivos del lenguaje.",
                    "Estos son nuestros costos actuales:",
                    "• Compensamos a estudiantes universitarios de la Universidad de Washington, especialmente a aquellos que tienen discapacidades o cuyo primer idioma no fue el inglés, para evolucionar y mantener el proyecto. Esto representa aproximadamente el 90% de nuestros costos.",
                    "• Ofrecemos estipendios a profesores con los que colaboramos para desarrollar planes de estudio multilingües y accesibles.",
                    "• Pagamos a Google por el ancho de banda y almacenamiento de <Firebase@https://firebase.google.com/>, y los servicios de <Workspace@https://workspace.google.com/>.",
                    "• Pagamos anualmente a <Squarespace@https://www.squarespace.com/> por el dominio.",
                    "Nuestros costos actuales, asumiendo 5 estudiantes universitarios a $$20 USD//hora, 10 horas//semana durante el año académico (36 semanas) y 2 estudiantes universitarios durante el verano (12 semanas), más servicios en la nube, son aproximadamente $$60,000 USD por año.",
                    "Si 2,400 personas donaran $$25 USD al año, eso cubriría nuestros costos actuales, y cualquier excedente se destinaría a compensar a más estudiantes y profesores.",
                    "¿Puedes ser una de esas 2,400 personas? Si es así, aquí está nuestro enlace de donación de la Universidad de Washington:"
                ]
            },
            "teach": {
                "header": "$~Enseñar",
                "prompt": {
                    "none": "$~¡Bienvenido, profesor! Crea una clase para configurar y administrar cuentas de estudiantes y galerías de proyectos.",
                    "some": "$~¡Bienvenido profesor! Gestiona tus clases o crea una nueva."
                },
                "error": {
                    "offline": "$~No podemos verificar tu estado de profesor.",
                    "login": "$~Debes iniciar sesión para administrar clases.",
                    "teacher": "$~Necesitas privilegios de profesor para crear y administrar clases. ¡Completa este formulario y conozcámonos!"
                },
                "link": {
                    "request": "$~Solicitar privilegios de profesor",
                    "new": "$~Crear una clase"
                }
            },
            "newclass": {
                "header": "$~Nueva clase",
                "subheader": {
                    "class": "$~Tu clase",
                    "students": "$~Tus estudiantes",
                    "credentials": "$~Nombres de usuario y contraseñas",
                    "submit": "$~Entregar"
                },
                "prompt": {
                    "start": "$~Crea una clase con cuentas generadas para todos los estudiantes de tu clase y te permite crear galerías a las que todos tus estudiantes pueden agregar proyectos. Si los estudiantes tienen cuentas existentes, puedes agregarlas más tarde.",
                    "review": "$~Revisa los nombres de usuario y las contraseñas que creamos. ¿Quieres *editarlos* antes de continuar? Si lo haces, no podrás editar la información del estudiante que aparece arriba.",
                    "ready": "$~Avísanos cuando estés listo para generar las credenciales que aparecen arriba. Puedes editarlas después de hacerlo.",
                    "pending": "$~Generando nombres de usuario y contraseñas...",
                    "submit": "$~¿Está listo para enviar su solicitud? En cuanto la envíe correctamente, recibirá una descarga de esta información. Las contraseñas *no se pueden recuperar*, así que guárdelas en un lugar seguro.",
                    "submitting": "$~Solicitando nuevas cuentas con los nombres de usuario y contraseñas anteriores...",
                    "download": "$~¡Tu clase está lista! Deberías ver una descarga de los datos de tus estudiantes en tu carpeta de descargas. *Las contraseñas no se pueden recuperar*, así que guarda este archivo en un lugar seguro."
                },
                "field": {
                    "name": {
                        "description": "$~nombre de la clase",
                        "placeholder": "$~un nombre corto"
                    },
                    "description": {
                        "description": "$~descripción",
                        "placeholder": "$~una descripción de tu clase, para ti y tus estudiantes."
                    },
                    "existing": {
                        "label": "$~estudiantes con cuentas",
                        "prompt": "$~¿Alguno de tus alumnos ya tiene cuenta en Wordplay? Inclúyelos aquí."
                    },
                    "metadata": {
                        "description": "$~Información del estudiante",
                        "placeholder": "$~p. ej., identificación de estudiante, apellido, nombre de pila",
                        "prompt": "$~¿Quieres crear nuevas cuentas para estudiantes? Proporciona *cualquier información* sobre los estudiantes, una por línea, separada por comas. Puede tratarse de apellidos, nombres de pila, números de estudiante u otros detalles distintivos. Los utilizaremos para generar nombres de usuario que puedes editar a continuación, lo que te ayudará a asociar nombres de usuario con estudiantes."
                    },
                    "words": {
                        "description": "$~Palabras para usar en contraseñas",
                        "placeholder": "$~p. ej., gato punto rata...",
                        "prompt": "$~Proporcione al menos *25 palabras* y genere contraseñas de 2 a 3 palabras que puedan recordarse al azar. Elija palabras que sus alumnos conozcan o pídales que hagan una lluvia de ideas. ¡Cuanto más aleatorias, más seguras!"
                    },
                    "generate": {
                        "label": "$~generar",
                        "tip": "$~Cree nombres de usuario y contraseñas basados en la información anterior."
                    },
                    "edit": {
                        "label": "$~editar",
                        "tip": "$~Editar la información del estudiante generada"
                    },
                    "submit": {
                        "label": "$~crear clase",
                        "tip": "$~Crea una nueva clase con esta información."
                    }
                },
                "error": {
                    "duplicates": "$~Hay entradas duplicadas en la información del estudiante.",
                    "columns": "$~Asegúrese de que cada estudiante tenga el mismo número de columnas.",
                    "generate": "$~No se pueden crear nombres de usuario únicos.",
                    "taken": "$~Uno o más de los nombres de usuario anteriores ya están en uso",
                    "limit": "$~No puedes crear una clase de más de 35 estudiantes a la vez.",
                    "words": "$~Proporcionar al menos 25 palabras.",
                    "account": "$~No se pueden crear algunas de las cuentas.",
                    "generic": "$~No pudimos crear la clase. Aquí hay información para ayudar a los desarrolladores a descubrir qué salió mal."
                }
            },
            "class": {
                "header": "$~Clase",
                "subheader": {
                    "teachers": "$~Profesores",
                    "students": "$~Estudiantes",
                    "galleries": "$~Galerías"
                },
                "prompt": {
                    "gallery": "$~Crea una galería para tu clase para organizar una tarea o un proyecto. Todos los profesores del proyecto serán los curadores de la galería y todos los estudiantes, los creadores de la galería.",
                    "delete": "$~Eliminar esta clase eliminará permanentemente la información sobre la clase, pero también sus proyectos, galerías o cuentas de estudiantes."
                },
                "field": {
                    "name": {
                        "description": "$~nombre de la clase",
                        "placeholder": "$~nombre"
                    },
                    "description": {
                        "description": "$~Descripción de la clase",
                        "placeholder": "$~descripción"
                    },
                    "newteacher": {
                        "placeholder": "$~correo electrónico o nombre de usuario",
                        "description": "$~Correo electrónico o nombre de usuario del creador a quien desea darle acceso docente a esta clase"
                    },
                    "addteacher": "$~Agregar un profesor a esta clase",
                    "delete": {
                        "tip": "$~Eliminar esta clase para siempre.",
                        "label": "$~Eliminar esta clase"
                    }
                },
                "error": {
                    "notfound": "$~No pudimos encontrar esta clase o no tienes permiso para verla."
                }
            }
        },
        "edit": {
            "node": "$1$2[, tipo $2|]",
            "before": "antes de $1[$1|final]",
            "inside": "dentro de $1, entre $2[$2|inicio] y $3[$3|final]",
            "between": "entre $1 y $2",
            "line": "línea vacía entre $1[$1|inicio] y $2[$2|final]",
            "conflicts": "$1 conflictos",
            "assign": "/$2[Con ganas de unirse|Considera irse]…/",
            "append": "/Con ganas de insertar…/",
            "remove": "/Considera irse…/",
            "replace": "/Quiere intervenir…/",
            "wrap": "poner paréntesis",
            "unwrap": "desenvolver",
            "bind": "nombrar esta expresión"
        },
        "template": {
            "unwritten": "Por determinar",
            "unparsable": "Plantilla no analizable: $1"
        },
        "collaborate": {
            "label": "$~colaborar",
            "role": {
                "owner": "$~dueño",
                "collaborators": "$~colaboradores",
                "curators": "$~curadores"
            },
            "field": {
                "message": {
                    "description": "$~El mensaje de chat para enviar",
                    "placeholder": "$~Escribe un mensaje"
                }
            },
            "button": {
                "submit": {
                    "label": "$~Enviar",
                    "tip": "$~Envía un mensaje a tus colaboradores"
                },
                "start": {
                    "label": "$~Iniciar un chat",
                    "tip": "$~Inicie una discusión con usted mismo o con otros."
                },
                "delete": "$~eliminar este mensaje"
            },
            "error": {
                "unowned": "$~Este proyecto no tiene propietario, por lo que no puede tener un chat.",
                "offline": "$~No se puede cargar este chat.",
                "empty": "$~No hay mensajes.",
                "deleted": "$~Este mensaje fue eliminado."
            },
            "prompt": {
                "solo": "$~Chatea contigo mismo o agrega un colaborador, que pueda editar y chatear.",
                "owner": "$~Los colaboradores pueden editar este proyecto y chatear sobre él.",
                "collaborator": "$~Eres colaborador. Puedes editar este proyecto y conversar sobre él.",
                "curator": "$~Eres el curador de la galería de este proyecto. Puedes editarlo y conversar sobre él."
            }
        },
        "checkpoints": {
            "label": {
                "now": "$~ahora",
                "history": "$~restaurar",
                "restore": "$~Esta es una versión anterior de este proyecto.",
                "ago": "$~Hace 1 $2 $"
            },
            "button": {
                "clear": "$~borrar historial",
                "select": "$~Ver esta versión",
                "checkpoint": "$~guardar esta versión del proyecto",
                "back": "$~volver a la versión anterior",
                "forward": "$~volver a la siguiente versión",
                "restore": "$~restaurar esta versión",
                "now": "$~volver a la versión actual"
            }
        }
    },
    "moderation": {
        "warning": {
            "header": "Advertencia",
            "explanation": "Un moderador determinó que este contenido podría:"
        },
        "blocked": {
            "header": "Bloqueado",
            "explanation": "Un moderador determinó que este contenido podría:"
        },
        "unmoderated": {
            "header": "Nota",
            "explanation": "Este contenido aún no ha sido moderado. Podría:"
        },
        "moderate": {
            "header": "Moderar",
            "explanation": "Revisa este proyecto y decide si su contenido hace alguna de las siguientes cosas. Si lo hace, el contenido será advertido o bloqueado. Puedes omitirlo si no estás seguro."
        },
        "flags": {
            "violence": "Incitar, fomentar o celebrar violencia, daño o autolesiones hacia cualquier persona.",
            "dehumanization": "Deshumanizar a individuos o grupos basándose en su raza, etnia, origen nacional, casta, orientación sexual, género, religión, edad, habilidad o apariencia.",
            "disclosure": "Revelar información privada sobre otras personas, como nombres, información de contacto o direcciones físicas",
            "misinformation": "Contener información falsa, engañosa, manipuladora o manipulativa"
        },
        "progress": "*$1* moderado, *$2* restante",
        "button": {
            "submit": {
                "tip": "Guardar estas configuraciones de moderación",
                "label": "guardar"
            },
            "skip": {
                "tip": "Omitir este proyecto",
                "label": "omitir"
            }
        }
    },
    "gallery": {
        "games": {
            "name": "Juegos",
            "description": "Juegos interactivos con palabras y símbolos."
        },
        "visualizations": {
            "name": "Visualizaciones",
            "description": "Visualizaciones de y a través de texto."
        },
        "motion": {
            "name": "Movimiento",
            "description": "Ejemplos de movimiento y colisiones."
        },
        "av": {
            "name": "Audio/Video",
            "description": "Uso de volumen, tono y video como entrada."
        },
        "tools": {
            "name": "Herramientas",
            "description": "Utilidades y aplicaciones simples."
        }
    }
}
