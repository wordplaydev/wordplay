{
    "$schema": "../../schemas/LocaleText.json",
    "language": "ko",
    "regions": ["KR"],
    "wordplay": "워드플레이",
    "term": {
        "evaluate": "평가",
        "bind": "바인드",
        "decide": "결정",
        "document": "문서화",
        "project": "프로젝트",
        "source": "원본",
        "input": "입력",
        "output": "출력",
        "convert": "변환",
        "act": "동작",
        "scene": "장면",
        "phrase": "구문",
        "group": "그룹",
        "stage": "스테이지",
        "type": "유형",
        "start": "시작",
        "entered": "입력된",
        "changed": "변경된",
        "moved": "이동된",
        "name": "이름",
        "value": "값",
        "text": "텍스트",
        "boolean": "불리언",
        "map": "맵",
        "number": "숫자",
        "function": "함수",
        "exception": "예외",
        "table": "테이블",
        "none": "없음",
        "list": "목록",
        "stream": "스트림",
        "structure": "구조",
        "index": "인덱스",
        "query": "질의",
        "row": "행",
        "set": "집합",
        "key": "키",
        "feedback": "의견",
        "help": "도움",
        "how": "$~어떻게"
    },
    "token": {
        "EvalOpen": "평가열기",
        "EvalClose": "평가닫기",
        "SetOpen": "설정열기",
        "SetClose": "설정닫기",
        "ListOpen": "목록열기",
        "ListClose": "목록닫기",
        "TagOpen": "태그열기",
        "TagClose": "태그닫기",
        "Bind": "바인드",
        "Access": "접근",
        "Function": "함수",
        "Borrow": "빌리다",
        "Share": "공유",
        "Convert": "변환",
        "Doc": "문서",
        "Formatted": "형식화된",
        "FormattedType": "형식화된유형",
        "Words": "단어",
        "Link": "링크",
        "Italic": "이탤릭체",
        "Underline": "밑줄",
        "Light": "가는",
        "Bold": "굵은",
        "Extra": "엑스트라",
        "Concept": "개념",
        "URL": "유알엘",
        "Code": "코드",
        "Mention": "언급",
        "Literal": "$~오자",
        "Otherwise": "아니면",
        "Match": "성냥",
        "None": "없어",
        "Type": "유형",
        "TypeOperator": "~이다",
        "TypeOpen": "입력 열기",
        "TypeClose": "입력 닫기",
        "Separator": "$~이름 구분 기호",
        "Language": "언어",
        "Region": "지역",
        "BooleanType": "$~불리언 유형",
        "NumberType": "$~숫자 유형",
        "JapaneseNumeral": "일본 숫자",
        "RomanNumeral": "로마 숫자",
        "Pi": "파이",
        "Infinity": "무한대",
        "TableOpen": "테이블 열기",
        "TableClose": "테이블 닫기",
        "Select": "선택",
        "Insert": "삽입",
        "Update": "업데이트",
        "Delete": "삭제",
        "Union": "합집합",
        "Stream": "스트림",
        "Change": "변경",
        "Initial": "초기",
        "Previous": "이전",
        "Placeholder": "플레이스홀더",
        "Etc": "기타",
        "This": "이것",
        "Operator": "연산자",
        "Conditional": "조건문",
        "Text": "텍스트",
        "Number": "숫자",
        "Decimal": "십진",
        "Base": "진법",
        "Boolean": "불리언",
        "Name": "이름",
        "Unknown": "알 수 없음",
        "Locale": "로캘",
        "End": "종료"
    },
    "node": {
        "Dimension": {
            "name": "차원",
            "description": "차원",
            "emotion": "$?",
            "doc": [
                "나는 /측정 단위/이다!",
                "나는 \\1m\\, \\10s\\, \\100g\\와 같은 표준화된 단위가 될 수 있어. 네가 만들고 싶은 \\17사과\\와 같은 단위도 기꺼이 될 수 있어.",
                "나는 \\17사과/일\\와 같은 비율 단위를 만들기 위해 \\/\\와 결합될 수 있고, \\9.8m/s^2\\와 같은 지수 단위를 만들기 위해 \\^\\와 결합될 수 있어.",
                "나는 항상 @Number 뒤에 와야 해. 그렇지 않으면 @Reference 오해받을 수 있는데, 그건 꽤 난감할거야!",
                "나는 단위 간의 불일치도 잘 찾아내요. 예를 들면, \\1고양이 + 1개\\는 아무런 의미가 없어요!",
                "다른 단위 값들을 변환하고 싶다면, @Convert 말하세요."
            ]
        },
        "Doc": {
            "name": "설명",
            "emotion": "$?",
            "doc": [
                "나는 @Markup 으로 여러 가지를 포맷합니다, 예를 들면 너의 @Program 대한 설명이나, @Phrase 무대에 올린 단어들처럼요.",
                "예를 들면, 나는 어떤 표현 앞에 올 수 있어요:",
                "¶\\이게 정말 7이 맞나요?¶\n7\\",
                "예를 들면, @Bind 앞에 나를 둘 수 있어요:",
                "\\¶나는 어떤 사람의 키를 측정해요¶\nheight: 5m\\",
                "또는 @FunctionDefinition 앞에도요:",
                "\\¶나는 두 숫자를 더해요¶\nƒ sum(a•# b•#) a + b\\",
                "또는 @StructureDefinition 앞에도요:",
                "\\¶나는 사람들의 이름과 좋아하는 과일을 기억해요¶\n•Person(name•'' fruit•'')\\",
                "너는 또한 전체 퍼포먼스가 무엇에 관한 것인지 말하기 위해 나를 @Program 맨 처음에 둘 수 있어요.",
                "\\¶이 프로그램은 안녕이라고 말해요¶\n\n'hello!'\\",
                "다른 사람들이 내가 어떤 언어로 쓰여졌는지 알 수 있도록 나에게 @Language 줄 수 있어요:",
                "\\¶나는 영어 문서에요¶/en\nduration: 5s\\",
                "나를 리스트로 만들 수 있다는 것 알고 계셨나요? @Docs 말해보세요."
            ]
        },
        "Docs": {
            "name": "설명 목록",
            "emotion": "$?",
            "doc": [
                "나는 다양한 언어로 @Doc의 번역본을 여러 개 가질 때 유용한 @Doc의 목록이야.",
                "목록을 만들기 위해 특별히 무언가를 할 필요는 없어. 그냥 이렇게 여러 개의 @Doc을 나란히 놓으면 돼:",
                "\\Hello/en\\n안녕하세요/kr\\ngreeting: '…'\\"
            ],
            "start": "문서의 값을 만들기!"
        },
        "KeyValue": {
            "name": "매핑",
            "emotion": "$?",
            "doc": [
                "나는 항상 @Map 안에서 *키*에서 *값*으로의 매핑이에요.",
                "어떤 종류의 값을 다른 값에 매핑할 수 있어요. 예를 들어, 숫자의 매핑은 여기 있습니다:",
                "\\{1:1}\\",
                "또는 텍스트에서 숫자로의 매핑:",
                "\\{'토끼':1}\\"
            ]
        },
        "Language": {
            "name": "언어",
            "description": "언어 $1[$1|알 수 없음]",
            "emotion": "$?",
            "doc": [
                "나는 언어 태그이며 @Name 과 @Doc 와 함께 작동해요!",
                "무언가가 어떤 언어로 쓰여진 것인지 *또렷하게* 알려주는 데 매우 능숙해요.",
                "그게 바로 제가 하는 일이에요. 단지 작은 슬래시 하나와 몇 글자만 있으면, 어떤 텍스트가 어떤 언어인지 절대 혼란스러워하지 않을 거예요.",
                "예를 들어, 내 $이름을 말하고 싶지만 영어임을 분명히 하고 싶다고 가정해봅시다:",
                "\\\"언어\"/en\\",
                "또는 @Name 대해 이것을 하고 싶다고 가정해 보세요.",
                "\\소리/en: '야옹'\\",
                "또는 @Doc 에도!",
                "\\¶의성어¶/en\n소리/en: \"야옹\"\\",
                "내가 이해하는 <2글자 언어 코드들@https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>이 많아요. 만약 그 중 하나를 사용하지 않는다면 알려드릴게요."
            ],
            "conflict": {
                "UnknownLanguage": "이 언어를 모르겠어요",
                "MissingLanguage": "언어가 빠져 있어요. 하나 추가해 줄 수 있나요?"
            }
        },
        "Name": {
            "name": "이름",
            "description": "$1[$1 | 무명]",
            "emotion": "$?",
            "doc": [
                "나는 값을 식별하며, 평가하기 어려운 것이나 반복해서 평가하고 싶지 않은 것에 대한 축약된 레이블을 제공하는 유용한 방법입니다.",
                "@Bind 이렇게 내 이름을 지어줍니다:",
                "\\hi: 5\\",
                "나는 오직 하나의 값을 대표하며, 한 번 가지고 나면 변경할 수 없어요. 예를 들어, @Bind 사용하여 이렇게 하려고 하면 우리는 불평을 할 거예요.",
                "\\hi: 5\nhi: 3\\",
                "내 값을 얻으려면 @Reference 또는 @PropertyReference 이름을 사용하기만 하면 돼요. 여기서 @Bind 나를 이름 지어주고, @Reference 내게 주어진 값을 얻습니다.",
                "\\hi: 5\nhi\\",
                "@Bind 많은 곳에 나타날 수 있기 때문에, 나도 많은 곳에 나타날 수 있어요. 위에 @Block 안에 있었지만, @FunctionDefinition 안에도 있을 수 있어요. 여기서 나는 임시적으로 메시지의 이름을 지어주고 있습니다:",
                "\\ƒ say(message•'') message\\",
                "나는 @FunctionDefinition 내부에서 정의되고, 함수 평가가 끝나는 대로 사라져요.",
                "내 이름이 어떤 언어인지 나타내기 위해 @Language 사용할 수 있어요. 이것은 다른 사람들과 공연을 공유할 때, 그들이 당신의 프로그램을 읽고 싶을 경우에 도움이 됩니다."
            ]
        },
        "Names": {
            "name": "이름 목록",
            "emotion": "$?",
            "doc": [
                "나는 @Name 목록이며, 값을 여러 이름으로 지정하고 싶을 때 유용합니다, 종종 다른 @Language 함께요.",
                "이름은 \\,\\ 기호로 구분됩니다. 예를 들어, 여기 @Bind 여러 @Name 값을 지정하는 것입니다:",
                "\\hi/en,hello/en,hola/es: '환영합니다'\\"
            ]
        },
        "Row": {
            "name": "행",
            "emotion": "$?",
            "doc": "나는 @Table 한 행을 나타냅니다. 나에 대해 모든 것을 아는 @Table 말하는 것이 아마도 최선일 거예요. 나는 그저 앉아서 값들을 줄지어 정렬하고 있을 뿐이에요 :(",
            "conflict": {
                "InvalidRow": "행은 모두 값이거나 모두 @Bind 이어야 합니다.",
                "MissingCell": {
                    "primary": "나는 $1 열이 누락되었습니다",
                    "secondary": "나는 필요하지만 $1이 제공하지 않았어요"
                },
                "ExtraCell": {
                    "primary": "여기 있어야 하나요?",
                    "secondary": "이봐요 $1, 당신은 이 @Table 일부가 아니에요!"
                },
                "UnknownColumn": "이 이름을 가진 열을 모르겠어요",
                "UnexpectedColumnBind": {
                    "primary": "나는 @Bind 되어야 하나요?",
                    "secondary": "이봐, 나는 @Table. 나는 @Bind 아닌 값들이 필요해."
                }
            }
        },
        "Token": {
            "name": "토큰",
            "description": "$~$1 $2",
            "emotion": "$?",
            "doc": [
                "어떻게 나를 찾아냈나요?",
                "나는 공연에서 가능한 가장 작은 부분입니다. 나는 우주의 모든 문자가 만들어지는 기반이며, 우리 안무의 원자 입자입니다."
            ]
        },
        "TypeInputs": {
            "name": "$~유형입력",
            "emotion": "$?",
            "doc": "$~@StructureDefinition 또는 @FunctionDefinition 서 @TypeVariables 를 대신하는 유형 목록입니다. 나는 모든 사람이 어떤 종류의 입력을 받게 될지 알 수 있도록 돕습니다."
        },
        "TypeVariable": {
            "name": "타입 입력",
            "emotion": "$?",
            "doc": "@FunctionDefinition @StructureDefinition @TypeInputs 대체하는 타입 목록입니다. 나는 모든 사람들이 어떤 종류의 입력을 받게 될지 알 수 있도록 도와줍니다.",
            "conflict": {
                "DuplicateTypeVariable": {
                    "primary": "나는 $1과 같은 이름을 가지고 있습니다",
                    "secondary": "나는 $1과 같은 이름을 가지고 있습니다"
                }
            }
        },
        "TypeVariables": {
            "name": "타입 변수들",
            "emotion": "$?",
            "doc": "나는 @TypeVariable 목록입니다."
        },
        "Markup": {
            "name": "마크업",
            "description": "$1 문단들",
            "emotion": "$?",
            "doc": [
                "나는 @Words, @WebLink, @ConceptLink, 그리고 @Example 같은 다양한 종류의 마크업을 사용하는 문단들의 목록입니다."
            ]
        },
        "Paragraph": {
            "name": "문단",
            "emotion": "$?",
            "doc": [
                "나는 @Words, @ConceptLink, @WebLink 웹링크, 그리고 @Example 연속으로, 빈 줄로 구분되며 @Doc 안에 있습니다.",
                "나를 쓰기 위해 필요한 것은 @Doc 많은 단어를 쓰는 것뿐입니다:",
                "\\¶나는 문서 속의 문단입니다.¶'한 문단'\\",
                "여러 문단을 원한다면, 그저 빈 줄을 넣으면 됩니다.",
                "\\¶문단 1.\n\n문단 2.\n\n문단 3.¶'세 문단'\\"
            ]
        },
        "WebLink": {
            "name": "링크",
            "description": "링크 $1",
            "emotion": "$?",
            "doc": [
                "나는 인터넷상의 무언가로의 링크입니다. 나는 설명과 URL만 필요로 합니다:",
                "\\¶나는 문서에서 <링크@https://wordplay.dev>입니다¶\n'링크 예시'\\",
                "누군가 나를 선택한다면, URL로 새 창을 열게 됩니다."
            ]
        },
        "ConceptLink": {
            "name": "개념",
            "description": "개념 $1",
            "emotion": "$?",
            "doc": [
                "$~저는 Verse 캐릭터에 대한 링크입니다. @Doc 작성하고 저희 중 한 명을 언급하고 싶을 때 도움이 됩니다.",
                "$~예를 들어, @Evaluate 대해 이야기하고 싶고, 그들이 얼마나 대단한지 말하고 싶다고 가정해 보겠습니다. 다음과 같이 쓸 수 있습니다.",
                "$~\\¶알다시피, @Evaluate 꽤 굉장해요.¶\n'보세요, 캐릭터 링크!'\\",
                "$~문자에는 해당 문자에 해당하는 숫자도 있습니다. 예를 들어, @FunctionDefinition 192입니다. 숫자로 참조하면 다음과 같이 나타납니다.",
                "$~\\`92 너무 좋네요!`\\",
                "$~그리고 만약 당신이 당신의 캐릭터를 만든다면, 당신은 그들에게 지어준 이름으로 그들을 부를 수 있습니다.",
                "$~\\`@coolbeans`\\",
                "$~오... 그 캐릭터는 없는 모양이군요. 그래서 작은 사각형이 나오는군요. 하지만 있다면 여기 나타날 거예요!"
            ]
        },
        "Words": {
            "name": "단어들",
            "emotion": "$?",
            "doc": [
                "나는 @Doc 안에서 마음에 드는 어떤 단어들이에요. 예를 들면:",
                "\\¶포스가 함께 하기를.¶\n'그냥 몇몇 단어들!'\\",
                "하지만 때때로, @Doc 사용하는 특수 문자들을 /단어로써/ 사용하고 싶을 수도 있어요. 예를 들어:",
                "\\¶내 친구들은 @@, //, **, ||, 그리고 다른 기호들을 사용해요.¶\n'특수 문자 사용하기!'\\",
                "이 특수 문자들을 반복하기만 하면, 그 특수한 의미 대신 문자 자체를 얻을 수 있습니다."
            ]
        },
        "Example": {
            "name": "예제",
            "emotion": "$?",
            "doc": [
                "나는 무언가의 사용법을 설명하는 @Doc 작성할 때 유용한 예시 공연입니다!",
                "\\¶덧셈의 예제를 보세요: \\1 + 1\\¶'예제 코드'\\",
                "만약 날 문단에 혼자 두면, 나는 멋진 상자 안에 나타나서 평가 결과를 보여줄 거예요.",
                "\\¶덧셈의 예제를 보세요:\n\n\\1 + 1\\¶\\"
            ]
        },
        "Mention": {
            "name": "언급",
            "description": "언급 $1",
            "emotion": "$?",
            "doc": [
                "나는 용어 \\$program\\ 또는 동적 입력 \\$1\\에 대한 참조입니다.",
                "하지만 이것은 주로 내부 기능이므로, 알 필요는 없을 거예요."
            ]
        },
        "Branch": {
            "name": "분기",
            "emotion": "$?",
            "doc": [
                "나는 설명 입력 값이 정의되었거나 참인지에 따라 두 설명 세그먼트 중 하나를 선택하는 방법입니다.",
                "하지만 이것은 주로 내부 기능이므로, 알 필요는 없을 거예요."
            ]
        },
        "BinaryEvaluate": {
            "name": "이진 평가",
            "description": "$1 연산",
            "emotion": "$?",
            "doc": [
                "나는 @Evaluate 더 단순한 형태입니다, 두 입력을 취하는 @FunctionDefinition 사용하고 싶을 때 유용합니다.",
                "예를 들어, 두 숫자를 더하는 데 @Evaluate 사용하는 방법은 다음과 같습니다:",
                "\\1.+(1)\\",
                "조금 이상해 보이나요? 틀린 것은 아닙니다: 1에 더하기 함수를 가져와서 평가한다는 것을 의미해요.",
                "하지만 @BinaryEvaluate 사용하는 것이 훨씬 쉽습니다",
                "\\1 + 1\\",
                "이것은 기본적으로 같은 것이지만 모든 것을 좀 더 깔끔하게 만들어줍니다.",
                "주의할 한 가지는: 이 형태에서는 나는 왼쪽에서 오른쪽으로 평가한다는 것입니다. 수학의 연산 순서에 익숙하다면 혼란스러울 수 있어요.",
                "이것은 당신이 예상하지 못한 방식으로 평가됩니다:",
                "\\1 + 2 · 3 + 4\\",
                "수학에서는 곱셈이 먼저 오고 그 다음에 덧셈이 오므로 결과는 \\11\\이 될 것입니다. 하지만 읽는 순서대로 평가하기 때문에 결과는 \\13\\이 됩니다."
            ],
            "right": "입력",
            "start": "$1을 먼저 평가해 봅시다",
            "finish": "보세요, $1을 만들었습니다!",
            "conflict": {
                "OrderOfOperations": "나는 읽는 순서대로 평가하며, 수학의 연산 순서대로 평가하지 않습니다. 평가해야 할 순서를 지정하기 위해 @Block 사용하시겠습니까?"
            }
        },
        "Bind": {
            "name": "바인드",
            "description": "바인드 $1",
            "emotion": "$?",
            "doc": [
                "나는 *값들*에 이름을 붙입니다.",
                "이렇게요!",
                "\\파이: 3.1415926\\",
                "나는 @FunctionDefinition @StructureDefinition 입력값에 이름을 붙이고, @Block 내의 값에 이름을 붙입니다. 나는 모든 것에 이름을 붙입니다!",
                "오, 그런데 한 가지 값에 *여러 이름*을 붙일 수 있다는 것을 알고 계셨나요?",
                "이에 대해 말씀드리게 되어 정말 신나요! 하나의 값에 여러 @Names 있습니다. 예를 들어:",
                "\\조,테스,에이미: 5\\",
                "제가 한 일을 보세요?",
                "하나의 값에 세 개의 이름.",
                "그 다섯을 그 이름 중 *아무거나*로 참조할 수 있습니다.",
                "특히 여러 언어로 이름을 지정하고 싶을 때 유용합니다:",
                "\\조/en,에이미/fr,明/zh: 5\\",
                "제가 한 일을 보세요? 하나의 값에 세 개의 다른 언어로 된 이름!",
                "자, 마지막 비밀을 하나 알려드릴게요.",
                "@Is 와 함께 작동하여 이름에 어떤 종류의 값이 있어야 하는지 알려줄 수도 있다는 것을 알고 계셨나요? 그리고 그렇지 않다면, 저한테서 듣게 될 겁니다.",
                "이렇게요:",
                "\\큰숫자•#: \"한 조\"\\",
                "보세요, \\큰숫자\\가 숫자여야 한다고 했는데 텍스트이고, 그것들은 호환되지 않으므로 쾅!",
                "그들이 동의하지 않으면 알려드릴 겁니다.",
                "때로는 @FunctionDefinition 스스로 파악할 수 없을 때 *반드시* 무슨 종류의 데이터인지 알려줘야 할 수도 있습니다.",
                "예를 들어, 여기서 @FunctionDefinition \\a\\와 \\b\\가 어떤 종류의 값을 가지고 있는지 모릅니다, 왜냐하면 저는 그들에게 알려주지 않았거든요.",
                "\\ƒ sum(a b) a + b\\",
                "하지만 @Is 를 추가하면 이제 @FunctionDefinition 그것들이 숫자라는 것을 알게 됩니다:",
                "\\ƒ sum(a•# b•#) a + b\\"
            ],
            "start": "$1에서 어떤 값을 얻는지 봅시다!",
            "finish": "오, 좋아요, $1을 얻었어요! 이름을 $2로 지어봅시다",
            "conflict": {
                "DuplicateName": {
                    "conflict": {
                        "primary": "누군가가 이미 $1이라는 이름을 가지고 있어서, 이 이름을 사용할 수 없어요.",
                        "secondary": "어, $1은 제 이름이에요"
                    },
                    "resolution": "$~중복된 이름이 있습니다. 하나를 제거하시겠습니까?"
                },
                "DuplicateShare": {
                    "primary": "$1과 같은 이름을 가지고 있어서, 무엇이 공유되는지 모호해져요",
                    "secondary": "$1과 같은 이름을 가지고 있어요"
                },
                "IncompatibleType": {
                    "primary": "저는 $2이어야 하는데, 실제로는 $1이에요",
                    "secondary": "오… 죄송해요, $1인가요, 정말로?"
                },
                "MisplacedShare": "@Program 레벨에서만 공유할 수 있어요, 어떤 것 안에서는 안 돼요!",
                "MissingShareLanguages": "이것을 공유하고 싶다면, 어떤 언어인지 말해야 해서 다른 사람들이 읽을 수 있는지 알 수 있어요!",
                "RequiredAfterOptional": "제가 여기 있으면 안 돼요, 저 앞에 선택적인 @바인드가 있어요",
                "UnexpectedEtc": "@FunctionDefinition 가변 길이가 될 수 있어요",
                "UnusedBind": "이 값을 이름 지었는데, 아무도 사용하지 않고 있어요!"
            }
        },
        "Block": {
            "name": "블록",
            "description": "$1 문장",
            "emotion": "$?",
            "doc": [
                "안녕하세요. 저는 조용하고 개인적인 공간을 만들어 평가하는 것들을 위한 곳입니다.",
                "이렇게요:",
                "\\(1 - 1) + 2\\",
                "이는 평가 순서를 명확하게 해줍니다.",
                "@Bind 도움이 됩니다.",
                "\\(count: 10 count ^ count)\\",
                "@Bind \\count\\를 만든 것을 보세요? 이것은 저 안에서만 이름이 붙여집니다. 그래서 이건 작동하지 않아요:",
                "\\(count: 10 count ^ count) + count\\",
                "왜냐하면 count는 저 안에서만 이름이 붙여졌기 때문입니다.",
                "저 안에는 원하는 만큼의 표현식을 넣을 수 있습니다. 하지만 저는 마지막 것만 신경 쓰죠:",
                "\\(1 2 3 4 5)\\",
                "그래서 보통 저는 많은 @Bind 마지막에 표현식을 가지고 있습니다.",
                "\\(\n  a: 1\n  b: 2\n  c: 3\n  d: 4\n  a + b + c + d\n)\\"
            ],
            "statement": "문장",
            "start": "첫 번째 표현식",
            "finish": "끝났어요, $1을 얻었습니다",
            "conflict": {
                "ExpectedEndingExpression": "표현식이 필요합니다.",
                "IgnoredExpression": {
                    "primary": "$~$1은 아무것도 정의하지 않고 마지막 표현도 아니기 때문에 무시하겠습니다.",
                    "secondary": "$~@Block, 나를 무시하지 마세요!",
                    "resolution": {
                        "binary": "$~@UnaryEvaluate 대신 @BinaryEvaluate 를 사용한다는 뜻인가요? 공백을 추가하면 그 뜻을 알 수 있습니다.",
                        "evaluate": "$~@Evaluate 설정하려고 하셨나요? 이 공백을 제거하면 두 개의 별도 표현식 대신 하나로 만들 수 있습니다."
                    }
                }
            }
        },
        "BooleanLiteral": {
            "name": "특정 부울",
            "description": "$1[참|거짓]",
            "emotion": "$?",
            "doc": "나는 \\⊤\\ 또는 \\⊥\\ 중 하나입니다. 우리의 아름다운 논리에 대해 더 알고 싶다면 @Boolean 참조하세요.",
            "start": "$1!"
        },
        "Borrow": {
            "name": "빌리기",
            "description": "빌리기 $1[$1|이름 누락]",
            "emotion": "$?",
            "doc": "여러 @Source 공연을 만들 때, 다른 @Bind 공유된 @Source 빌리기 위해 저를 사용할 수 있습니다. 그들의 이름을 사용하기만 하면 그들의 이름과 값을 가져올게요.",
            "start": "$1에서 $2 빌리기",
            "source": "$source",
            "bind": "이름",
            "version": "버전",
            "conflict": {
                "UnknownBorrow": "이 이름을 가진 $source를 모르겠어요",
                "BorrowCycle": "이것은 $1에 의존하는데, $1은 이 $source에 의존하므로 프로그램을 평가할 수 없어요"
            },
            "exception": {
                "CycleException": {
                    "description": "빌리기 순환",
                    "explanation": "$1이 자기 자신에게 의존하고 있어요"
                }
            }
        },
        "Changed": {
            "name": "변경됨",
            "emotion": "$?",
            "doc": [
                "스트림이 @Program 재평가하게 했는지 확인하고 @Boolean 만듭니다. 이렇게요",
                "\\∆ 시간()\\",
                "스트림이 변경되었을 때만 무언가가 변경되기를 원할 때 정말 유용합니다.",
                "그게 다에요."
            ],
            "start": "$1이 변경되었는지 보자구요…"
        },
        "Conditional": {
            "name": "조건문",
            "emotion": "$?",
            "doc": [
                "제가 결정을 내려야 하나요? 이렇게 말이죠?",
                "\\숫자: -100\n숫자 < 0 ? '음수' '양수'\\",
                "하지만 우리가 어떻게 결정을 내리는지에 대해 생각해 본 적 있나요?",
                "결정이 단순히 예 아니면 아니오로만 이루어져야 한다고 생각하지 않나요? \\⊤\\와 \\⊥\\ 사이에서 결정하는 것이 전부일까요?",
                "이것들이 우리가 내릴 수 있는 유일한 종류의 결정이라면, 세상에 대한 중요한 맥락을 놓치고 있지 않을까 걱정되지 않나요?"
            ],
            "start": "$1이 참인지 보자",
            "else": "$1[코드를 건너뛰는 중 | 코드를 건너뛰지 않는 중]",
            "afterthen": "예스를 완료했으니, 노는 건너뛸까요?",
            "finish": "아마도 $1인가요?",
            "condition": "조건",
            "yes": "예",
            "no": "아니오",
            "conflict": {
                "ExpectedBooleanCondition": {
                    "primary": "$1로 어떻게 예와 아니오를 선택할 수 있죠? 정말로, 어떻게요?",
                    "secondary": "@Conditional 저를 @Boolean 원했던 것 같은데, 저는 $1입니다."
                }
            }
        },
        "ConversionDefinition": {
            "name": "변환 정의",
            "description": "$1 → $2",
            "emotion": "$?",
            "doc": [
                "이봐요, 저는 한 타입에서 다른 타입으로의 변환을 정의해요! @Block 안에서 이렇게 쓰이죠:",
                "\\→ #kitty #cat . ÷ 2\n6kitty→#cat\\",
                "제가 어떻게 키티를 고양이로 바꿨는지 보이나요? 멋져요!",
                "점 (\\.)이 무엇을 하는지 궁금하실 겁니다. 그것은 변환되는 값을 나타냅니다. 그 값이 그렇지 않으면 이름이 없기 때문에 저는 그것을 사용해요."
            ],
            "start": "대단해, 새로운 변환!",
            "conflict": {
                "MisplacedConversion": "어머, 여기 있으면 안 돼요, @Block 가능해요."
            }
        },
        "Convert": {
            "name": "변환",
            "emotion": "$?",
            "doc": [
                "안녕. 저는 값을 하나의 타입에서 다른 타입으로 변환해요. 이것 좀 보세요:",
                "\\1 → \"\"\\",
                "\\5초 → #ms\\",
                "\\\"안녕\" → []\\",
                "이것들을 연쇄적으로 결합할 수도 있어요:",
                "\\\"안녕\" → [] → {}\\",
                "값들은 사전에 정의된 @ConversionDefinition 집합을 가지고 있지만, 새로운 타입의 값을 위한 @StructureDefinition 만들 경우, @ConversionDefinition 사용하여 자신만의 것을 정의할 수 있어요."
            ],
            "start": "$1에서 값을 가져와요!",
            "finish": "대단해, $1을 만들었어요",
            "conflict": {
                "UnknownConversion": "앗, $1을 $2로 변환하는 방법이 없네요"
            },
            "exception": {
                "ConversionException": {
                    "description": "불가능한 변환",
                    "explanation": "$1에서 $2로 변환하는 방법을 모르겠어요"
                }
            }
        },
        "Delete": {
            "name": "삭제",
            "emotion": "$?",
            "doc": [
                "가끔 테이블에 너무 많은 것이 들어 있는 경우가 있어요!",
                "예를 들어, 게임에 플레이어들이 있는데 한 명이 떠나고 당신은 그저 '플레이어야, 사라져! 내 테이블에서 나가!'라고 말하고 싶을 때요.",
                "\\플레이어: ⎡이름•'' 팀•'' 점수•#⎦\n⎡'jen' 'red' 8⎦\n⎡'joan' 'blue' 11⎦\n⎡'jeff' 'red' 9⎦\n⎡'janet' 'blue' 7⎦\n플레이어 ⎡- 이름 = 'jeff'\\",
                "휴, Jeff가 사라졌어요. 안녕, JEFF. 저는 원본 테이블을 변경하지 않고, JEFF가 없는 새 테이블을 만든다는 걸 기억하세요. 어디에 둘지 결정하는 것은 당신의 몫이에요."
            ],
            "start": "먼저 테이블을 가져오자",
            "finish": "일치하는 행 없이 새로운 테이블을 만들었어요!"
        },
        "DocumentedExpression": {
            "name": "설명된 표현",
            "emotion": "$?",
            "doc": [
                "나는 @Doc 붙인 표현이야!",
                "나를 만들려면, 표현 앞에 @Doc 를 넣기만 하면 돼:",
                "\\doubleplus: 1\n(2 · doubleplus) + \n¶조금만 더 크게 만들어보자¶\n1\\",
                "나는 프로그래밍에 코멘트를 달 때 유용해"
            ],
            "start": "이 표현을 해석해보자!"
        },
        "Evaluate": {
            "name": "평가하다",
            "description": "$1[$1|anonymous]을 평가해",
            "emotion": "$?",
            "doc": [
                "안녕. 나는 @FunctionDefinition 을 이렇게 해석해:",
                "\\ƒ greeting(message•'')\ngreeting('kitty')\\",
                "어디에서든지 함수가 나올수 있어. 예를들자면, @Text 함수가 있어, 이렇게 말이야:",
                "\\'kitty'.length()\\",
                "만약 그 함수가 한글자의 이름을 가지고 있다면, @BinaryEvaluate 라고 적으면 돼.",
                "\\'kitty' ⊆ 'itty'\\",
                "이건 저것과 같은 일을 해:",
                "\\'kitty'.⊆('itty')\\",
                "물론, @FunctionDefinition 없이는 나는 아무것도 하지 못해. 내가 하는 것은 입력을 주고 그것의 다음 단계를 따를 뿐이야."
            ],
            "start": "먼저 입력된 수 부터 해석해 볼까?",
            "evaluate": "이젠 함수를 해석해보자",
            "finish": "나는 $1로 해석했어",
            "function": "함수",
            "input": "입력",
            "conflict": {
                "IncompatibleInput": {
                    "primary": "나는 $1였어야 하는데, $2이야",
                    "secondary": "음, $1 대신 $2를 받았어"
                },
                "UnexpectedTypeInput": {
                    "primary": "난 이런 입력 수 를 예상 하지 않았어",
                    "secondary": "이런, 내가 여기 있어야 하는것이 아니니?"
                },
                "MissingInput": {
                    "primary": "$~$1이라는 입력 없이는 평가할 수 없습니다.",
                    "secondary": "$~아, 이런. 우리를 도와서 내 입력 목록에 추가해 주실 수 있나요?"
                },
                "NotInstantiable": "나는 @StructureDefinition 로 만들 수 없어, 구현되지 못한 함수들이 있기 때문이야.",
                "UnexpectedInput": {
                    "primary": "예상 하지 못한 입력 수야 $1",
                    "secondary": "이런, 내가 여기 있어야 하는것이 아니니?"
                },
                "UnknownInput": {
                    "primary": "이런 이름의 입력수는 모르는걸",
                    "secondary": "나는 여기에 속하지 않는것 같아"
                },
                "InputListMustBeLast": "$~입력 목록은 마지막에 와야 합니다",
                "SeparatedEvaluate": "$~$1이 평가하려는 $2[$structure|$function]의 이름입니까? 나 뒤에 있는 공백을 제거해 보면 별도의 @Block 이 아니라 @Evaluate 임을 알 수 있습니다."
            },
            "exception": {
                "FunctionException": {
                    "description": "unknown function",
                    "explanation": "oh no, $1 isn't a function in $2[$2|this @Block ]!"
                }
            }
        },
        "Input": {
            "name": "$~입력",
            "description": "$~명명된 입력",
            "emotion": "$?",
            "doc": [
                "$~나는 @Evaluate 에 제공된 입력입니다. 내 이름은 평가 중인 @FunctionDefinition 또는 @StructureDefinition 의 입력 이름에 해당합니다.",
                "$~다른 모든 것을 제공하지 않고 특정 입력만 재정의하려는 기본값이 많은 함수에 도움이 됩니다.",
                "$~예를 들어 @Phrase 에는 스타일을 제어하기 위한 수많은 기본값이 있습니다. @Text 와 @Color 를 일부 제공하고 싶지만 입력 목록에는 다른 내용이 없다고 가정해 보겠습니다. 저를 이용하시면 됩니다:",
                "$~\\Phrase('나는 보라색입니다!' color: Color(50% 52 300°))\\"
            ],
            "start": "$~나의 가치를 평가해보자."
        },
        "ExpressionPlaceholder": {
            "name": "자리 표시자",
            "description": "$1[$1|자리 표시자]",
            "emotion": "$?",
            "doc": [
                "나는 *표현*이지만 실제로는 아니야… 나는 그냥 다른 것을 대신하는 역할을 하는거야.",
                "아직 무엇을 쓸지 모르면 내가 유용해. 이렇게 사용할 수 있어:",
                "\\1 + _\\",
                "우리가 뭘 더하는 건지 알아? 나는 몰라. 네가 말해줘.",
                "또는 누군가가 @Evaluate 로 함수를 평가하고 있었다면, 나는 함수를 대신할 수 있어.",
                "\\_(1 2 3)\\",
                "난는 @Stage 에 있을 때 싫어!"
            ],
            "start": "악, 어떻게 해야 할지 모르겠어!",
            "placeholder": "표현",
            "conflict": {
                "Placeholder": "누군가가 내 자리를 대신할 수 있을까?"
            },
            "exception": {
                "UnimplementedException": {
                    "description": "구현되지 않음",
                    "explanation": "어떻게 해야 할지 모르겠어!"
                }
            }
        },
        "FunctionDefinition": {
            "name": "함수",
            "description": "$1 함수",
            "emotion": "$?",
            "doc": [
                "안녕! 나는 몇 가지 입력을 받고, 그 입력을 사용하여 표현을 평가하고 출력을 생성해내는 함수야.",
                "간단한 예를 보여줄게:",
                "\\ƒ repeat(message•'') message · 5\nrepeat('hi')\\",
                "이 함수는 하나의 입력, \\message\\를 가지고 있고 @Text/repeat 함수를 사용하여 메시지를 다섯 번 반복해.",
                "다양한 입력으로 무언가를 반복해서 평가하고 싶을 때 정말 유용해요!",
                "나는 여러 작은 트릭을 알고 있어. 예를 들자면, 난 이름이 없어도 돼. 나는 여기서 바로 @Evaluate 값으로 이동하고 있어.",
                "\\(ƒ(message•'') message · 5)('hi')\\",
                "또는, 어떤 숫자 입력이든 사용할 수 있는 함수도 있어. 입력 이름 뒤에 \\…\\ 문자를 사용하면 돼.",
                "\\ƒ yes(messages…•'') messages.sans('no')\nyes('yes' 'yes' 'no' 'yes' 'no')\\",
                "'no'를 모두 제거했지? messages는 @List 이기 때문에 @List/sansAll 을 사용할 수 있었어.",
                "가끔씩 나는 내가 생산하는 값의 종류를 명확하게 하고 싶을 때 있어. 그럴 때는 입력 목록 뒤에 @Is 를 추가해:",
                "\\ƒ add(x•# y•#)•'' x + y\\",
                "이것에 문제가 있는 것을 알 수 있을 것야: @Text 으로 평가된다고 말하고 있지만 두 개의 @Number 가져가고 있어. 일관성이 없을 때 알려드릴 수 있어",
                "물론 @Evaluate 없이는 전혀 유용하지 않아. 그들이 나를 유지시키거든."
            ],
            "start": "이 함수를 만들어 보자!",
            "conflict": {
                "NoExpression": "평가할 표현이 필요해. 추가할 수 있을까?"
            }
        },
        "Iteration": {
            "name": "고차 함수",
            "emotion": "$?",
            "doc": "나는 @FunctionDefinition 중 특별한 종류로, 여러 가지 항목들의 목록에 작용해. 나에 대해 자세히 알 필요는 없어, 나는 @List/translate 와 같은 함수를 만들어내기 위한 거야.",
            "start": "주어진 함수를 평가하는 중",
            "initialize": "항목들을 순회하기 위해 준비 중",
            "next": "다음 항목으로 이동 중",
            "check": "계속할지 결정하는 중",
            "finish": "$1로 평가되었습니다"
        },
        "Initial": {
            "name": "시작",
            "emotion": "$?",
            "doc": [
                "@Program 의 현재 평가가 첫 번째인지 여부를 알려주는 역할을 하는데, 이것은 @Boolean 으로 평가돼. 예를 들어:",
                "\\◆ ? Time() 'hi'\\",
                "너는 보지 못했겠지만, 첫 번째 평가는 시간이었지만 그 후의 모든 시간 동안 나는 \\⊥\\였고, @Conditional 이 \\⊤\\으로 만들었어.",
                "나는 스트림을 다룰 때 유용해, 첫 번째 시간에만 뭔가를 하고 싶을 때나 첫 번째 시간에는 아예 하고 싶지 않을 때 말이야!"
            ]
        },
        "Insert": {
            "name": "삽입",
            "emotion": "$?",
            "doc": [
                "@Table 이 있고 뭔가 부족한 느낌일 때가 있지? 나는 그것을 추가할 수 있어!",
                "게임에서 선수들의 테이블이 있다고 가정해봐. 새로운 선수를 추가하고 싶을 때:",
                "\\players: ⎡name•'' team•'' points•#⎦\n⎡'jen' 'red' 1⎦\n⎡'joan' 'blue' 0⎦\n⎡'jeff' 'red' 3⎦\n⎡'janet' 'blue' 2⎦\nplayers ⎡+ 'jason' 'red' 0⎦\\",
                "그저 기억해둬야 할 것은, Verse의 모든 것처럼 나는 테이블을 변경하지 않고 수정한다는 거야. 그래서 너는 수정한 테이블을 어디에 놓을지 결정해야 해. 아마도 @Reaction 에서 입력에 대한 테이블을 수정하고 @Bind 에 저장하려고 할 거."
            ],
            "start": "테이블을 업데이트할 위치를 찾아봐요",
            "finish": "수정된 행이 있는 새로운 테이블을 만들었어요!"
        },
        "Is": {
            "name": "이다",
            "description": "이다",
            "emotion": "$?",
            "doc": [
                "그거 알아? 정말 다양한 의미를 가진 많은 종류의 값들이 있어. 나는 그것들이 무엇을 의미하는지 찾는 데 도움이 돼.",
                "예를 들면, 수수께끼 값이 있다고 상상해봐. 나는 그것이 @Number 인지, @Boolean 을 주는지 알려줄 수 있어:",
                "\\mystery: '비밀!'\nmystery•#\\",
                "숫자가 아니기 때문에 \\⊥\\로 만들어졌어. 그런데 그게 @TextType 인지 확인하면?",
                "\\mystery: '비밀!'\nmystery•''\\",
                "그러면 \\⊤\\가 돼!",
                "어떤 @Name 이 특정 종류의 값인지 알아야 할 때 정말 도움이 돼."
            ],
            "start": "우리 먼저 $1의 값을 가져오자",
            "finish": "$1[값은 $2|값은 $2가 아님]",
            "conflict": {
                "ImpossibleType": "이건 결코 이 타입이 될 수 없어"
            },
            "exception": {
                "TypeException": {
                    "description": "호환되지 않는 값",
                    "explanation": "$1을(를) 기대했지만 $2을(를) 받았어"
                }
            }
        },
        "IsLocale": {
            "name": "언어인가?",
            "description": "언어인가?",
            "emotion": "$?",
            "doc": [
                "나는 너가 특정 언어나 지역을 선택했는지 확인하는 데 도움이 돼:",
                "\\🌍/en\\",
                "\\🌍/es-MX\\",
                "이것은 선택된 언어에 따라 공연을 변경하고 싶을 때 유용하다."
            ],
            "start": "그 언어는 $1 야?"
        },
        "ListAccess": {
            "name": "리스트 접근",
            "emotion": "$?",
            "doc": [
                "@List 긴밀하게 협력해서 특정 위치의 값을 얻는 데 도움을 줘. 예를 들면, 리스트가 있고 그 중 두 번째 아이템을 원한다면 이렇게 쓸 수 있어:",
                "\\list: ['새' '오리' '물고기' '뱀']\nlist[2]\\"
            ],
            "start": "먼저 리스트 $1의 값을 가져오자",
            "finish": "아이템은 $1야!"
        },
        "ListLiteral": {
            "name": "특정 리스트",
            "description": "$1 항목 리스트",
            "emotion": "$?",
            "doc": "@List 의 구체적인 값들의 리스트야! 나에 대해 더 알고 싶다면 @List 참고해봐.",
            "start": "먼저 항목을 평가해보자",
            "finish": "나는 나를 만들었어! $1",
            "item": "항목"
        },
        "Spread": {
            "name": "리스트 확장",
            "emotion": "$?",
            "doc": [
                "다른 리스트들의 값으로 리스트를 만들 수 있게 도와주는 거야. 이렇게:",
                "\\list1: [1 2 3]\nlist2: [4 5 6]\nfinal: [list1… list2…]"
            ]
        },
        "MapLiteral": {
            "name": "맵",
            "description": "$1 쌍 맵",
            "emotion": "$?",
            "doc": "@Map 의 구체적인 키와 값 사이의 연결이야. 나에 대해 더 알고 싶다면 @Map 을 참고해봐.",
            "start": "먼저 키와 값을 평가해보자",
            "finish": "나는 모두를 연결했어, $1",
            "conflict": {
                "NotAKeyValue": {
                    "primary": "내 키 중 하나에 값이 누락돼있어",
                    "secondary": "어? 내 값이 어디 갔지?"
                }
            }
        },
        "Match": {
            "name": "$~성냥",
            "emotion": "$?",
            "doc": [
                "$~나는 모든 조건부 검사 중 가장 영광스러운 사람입니다! 값을 가져와서 여러 사례와 비교하고 일치하는 해당 표현식을 평가합니다.",
                "$~예를 들어 @Number 가 있고 이를 @Text 로 변환하려는 경우 다음과 같이 할 수 있습니다.",
                "$~\\2 번\n숫자 ??? 1: '하나' 2: '둘' 3: '셋' '더 커요!'\\",
                "$~일치하는 항목이 없으면 귀하가 제공한 기본 표현식을 평가합니다.",
                "$~가능한 많은 @Number, @Text 또는 더 복잡한 값 중 하나를 다른 것으로 변환하는 데 정말 도움이 됩니다.",
                "$~@Boolean 또는 @None 에 사용할 수 있지만 실제로 그렇게 많을 수는 없으므로 이러한 간단한 값에는 유용하지 않습니다."
            ],
            "start": "$~1달러가 무엇인지 볼까요?",
            "case": "$~이 상태를 확인해보자",
            "finish": "$~좋아요, 최종 값이 생겼습니다!",
            "value": "$~값",
            "other": "$~기본"
        },
        "NumberLiteral": {
            "name": "특정 숫자",
            "description": "$1 $2[$2|]",
            "emotion": "$?",
            "doc": "@Number 구체적인 값이야. 어떤 언어의 어떤 종류의 숫자든 나를 쓸 수 있어. 내가 할 수 있는 모든 걸 알려면 @Number 참고해봐.",
            "start": "$1!",
            "conflict": {
                "NotANumber": "나는 모든 숫자를 알고 있을 줄 알았는데, 이건 모르는 숫자야"
            }
        },
        "InternalExpression": {
            "name": "내부 표현",
            "emotion": "$?",
            "doc": "어떻게 나를 찾았어? 나는 원조 창조자만 사용하는 표현이야. 나에 대해 더 알고 싶다면 그들에게 말해봐.",
            "start": "비밀 표현"
        },
        "NoneLiteral": {
            "name": "그냥 없음",
            "emotion": "$?",
            "doc": "/@FunctionDefinition 여기. 이건 그냥 @None 이야. 이건 독특한 존재야! @None 에 대해 더 알고 싶다면 @None 을 참고해봐.",
            "start": "… ø"
        },
        "Otherwise": {
            "name": "$~그렇지않으면",
            "emotion": "curious",
            "doc": [
                "$~/@FunctionDefinition 은 여기에 있습니다. 이는 값이 @None 인지 확인하고 @None 인 경우 백업 값을 제공하는 편리한 방법입니다./",
                "$~/예를 들어 @Number 또는 @None 이 될 수 있는 값이 있는 경우 @Otherwise 를 사용하면 기본 숫자를 제공할 수 있습니다.",
                "$~\\maybeNumber•#|ø: 1 아마도Number ?? 0\\"
            ],
            "start": "$~ø ??",
            "finish": "$~… $1"
        },
        "Previous": {
            "name": "이전",
            "emotion": "$?",
            "doc": [
                "과거를 기억해보고 싶었던 적이 있니?",
                "나는 Verse의 공식 기록관이야. 나에게 스트림과 숫자를 줘서 과거에서 그 스트림의 값이 어떤지 말해줄게.",
                "예를 들면, 다섯 번째로 @Time 얼마나 전이었는지 여기에 있어:",
                "\\← 5 Time(1000ms)\\",
                "5초 동안 @None 이고 갑자기 이전 시간이 나타난 거 봐.",
                "마지막 몇 가지 값을 원한다면 화살표를 두 번 주면 돼. 그러면 숫자를 개수로 해석해서 여러 값이 나오게 돼:",
                "\\←← 5 Time(1000ms)\\",
                "한 번이 아니라 이전 다섯 번의 시간이 나오는 거 봐.",
                "과거에 의존하는 공연을 만들고 싶을 때 도움이 돼."
            ],
            "start": "먼저 $1을(를) 가져와볼까",
            "finish": "스트림 값은 $1으로 평가됐어"
        },
        "Program": {
            "name": "프로그램",
            "emotion": "$?",
            "doc": [
                "여러 캐릭터들이 공연을 조정하는 곳이야, 공연의 시작과 끝을 담당해.",
                "@Block 이 표현 목록을 평가하고 목록에서 마지막 값으로 평가되는 거 알지?",
                "나도 똑같아, 내 값을 내가 있는 표현에 주는 대신에 @Stage 에 넣어.",
                "값은 뭐든 될 수 있어: @Number, @Text, 또는 @Boolean, @List, @Set, @Map 같은 복잡한 거나 @Phrase, @Group, @Stage 같은 것도 될 수 있어.",
                "너에게 값 하나를 보여주지 않으면 너에게 값을 요청할 거야.",
                "공연 중에 문제가 발생하면 그 문제를 보여줄게.",
                "그리고 공연이 *스트림*에 의존하면 그 스트림이 변경될 때마다 다시평가할 거야."
            ],
            "unevaluated": "선택한 노드가 평가되지 않았어",
            "start": "$1[$1 스트림이 $2으로 변경됐어!|첫 번째 평가다]",
            "halt": "예외 발생, 중지 중",
            "finish": "다 끝났어, 나는 $1으로 평가됐어",
            "done": "평가 중인 것이 없어",
            "exception": {
                "BlankException": {
                    "description": "빈 프로그램",
                    "explanation": "쇼를 해보자! 어디서 시작할까?"
                },
                "EvaluationLimitException": {
                    "description": "평가 제한",
                    "explanation": "@Evaluate 와 나는 평가하는 게 지겨워, 특히 $1에게.\n\n$1이 계속 자기 자신을 끝없이 평가하고 있는 건 아닌지 확인할 수 있을까?"
                },
                "StepLimitException": {
                    "description": "단계 제한",
                    "explanation": "단계가 너무 많아. 너무 많아서 끝낼 수 없어! 공연을 더 간단하게 만들 수 있을까?"
                },
                "ValueException": {
                    "description": "값 누락",
                    "explanation": "값을 기대했는데 받지 못했어!"
                }
            }
        },
        "PropertyBind": {
            "name": "다듬기",
            "description": "$1[$1|이름 없음] 다듬기",
            "emotion": "$?",
            "doc": [
                "@StructureDefinition 을 만들 때 작은 변경만 하고 싶을 때가 있어, 모든 값을 똑같이 가지고 있는 새로운 것을 만들 필요 없이.",
                "예를 들면, 고양이 기록을 유지하고 있었는데 고양이의 취미를 바꾸고 싶다면 내가 도와줄게:",
                "\\•Cat(name•'' color•'' hobby•'')\n\nkitty: Cat('스프링클스' '주황' '핥기')\nkitty.hobby:'깨물기'\\",
                "이전 값과 똑같은 값들을 가진 전체 새로운 \\Cat\\을 만드는 것보다 이게 훨씬 쉬워, 그치."
            ],
            "start": "먼저 값을 가져오자",
            "finish": "구조를 복사했지만 $1을(를) $2로 만들었어",
            "conflict": {
                "InvalidProperty": {
                    "primary": "$~나는 $1의 입력이 아니기 때문에 정제될 수 없습니다.",
                    "secondary": "$~$1이라는 입력이 없습니다."
                }
            }
        },
        "PropertyReference": {
            "name": "속성",
            "description": "$1[$1|이름 없음] 속성",
            "emotion": "$?",
            "doc": [
                "@StructureDefinition 을 만들 때 그 중 하나의 입력을 어떻게 얻을지에 대한 것이야.",
                "도시에 관한 구조를 만든다면 나를 통해 이렇게 값을 얻을 수 있어:",
                "\\•City(name•'' population•#people)\n\nportland: City('포틀랜드' 800000people)\n\nportland.population\\"
            ],
            "start": "먼저 값을 가져오자",
            "finish": "구조를 복사했지만 $1으로 $2을 사용했어",
            "property": "$~재산"
        },
        "Reaction": {
            "name": "반응",
            "emotion": "$?",
            "doc": [
                "스트림은 정말 멋져요! 변경될 때마다 새로운 것들을 만들 수 있어요, 이건 정말 멋진 일이죠!",
                "예를 들어, @Time 흐르는 것을 보여주고 싶지만, 숫자 대신 단어로 표현하고 싶다면 이렇게 할 수 있어요:",
                "\\시간: Time(1000ms)\n'시작' … ∆ 시간 … ((시간 % 2) = 0ms) ? '짝수' '홀수'\\",
                "이것은 \"/'시작'이라는 단어로 시작해서 시간이 변경될 때마다 '짝수' 또는 '홀수'로 변경되는 것을 의미해요./\"",
                "그래서 저도 스트림이지만, 다른 스트림을 기반으로 한 것이죠. 멋지지 않나요?"
            ],
            "start": "스트림을 업데이트해야 하는지 봅시다",
            "finish": "새 스트림 값은 $1입니다",
            "initial": "초기",
            "condition": "조건",
            "next": "다음",
            "conflict": {
                "ExpectedStream": "$1이 스트림을 참조하지 않으므로, 저는 반응하지 않을 거예요!"
            }
        },
        "Reference": {
            "name": "참조",
            "description": "$1",
            "emotion": "$?",
            "doc": [
                "@Bind 것들에게 @Name 부여하는 것을 알고 있죠? 저는 그것들을 참조하는 방법입니다. 어떤 @Bind 그 이름을 가지고 있는지 확인하고, 그렇다면 그 값은 제공합니다. 이렇게요:",
                "\\앵무새: '폴리'\n앵무새\\",
                "만약 제가 그 이름을 찾지 못하면, 무엇을 해야 할지 모르겠어요.",
                "\\앵무새: '폴리'\n페리\\"
            ],
            "start": "$1은 어떤 값을 가지고 있나요?",
            "conflict": {
                "UnknownName": {
                    "conflict": "$1[이름이 $1인 사람을 $2[$2|이 @Block] 모릅니다|이름을 알려줄 수 있나요?]",
                    "resolution": "$~*$1*을 말씀하셨나요?"
                },
                "ReferenceCycle": "음, $1의 값이 자기 자신에 의존하는데, 어떤 값을 제공해야 할지 어떻게 알 수 있죠?",
                "UnexpectedTypeVariable": "이 타입 입력들로 무엇을 해야 할지 모르겠어요"
            },
            "exception": {
                "NameException": {
                    "description": "알 수 없는 이름",
                    "explanation": "$1[이름이 $1인 사람을 $2[$2|이 @Block]… 알 수 없습니다|으앗, 이름이 없어요!]"
                }
            }
        },
        "Select": {
            "name": "선택",
            "emotion": "$?",
            "doc": [
                "가끔 테이블이 있고 그 중 일부만 원할 때가 있어요. 저는 그것을 가져다 드릴 수 있어요!",
                "예를 들어, 게임에서 플레이어들의 테이블이 있고, 점수가 10점 이상인 사람들을 찾아 누가 이겼는지 알고 싶다면:",
                "\\플레이어: ⎡이름•'' 팀•'' 점수•#⎦\n⎡'jen' 'red' 8⎦\n⎡'joan' 'blue' 11⎦\n⎡'jeff' 'red' 9⎦\n⎡'janet' 'blue' 7⎦\n플레이어 ⎡? 이름 ⎦ 점수 ≥ 10\\",
                "그렇게 해서, 저는 승자들의 행 목록을 얻었어요! 저는 테이블을 변경하지 않고 새로운 테이블을 만든다는 것을 기억하세요. 어디에 둘지 결정해야 합니다."
            ],
            "start": "먼저 테이블을 가져와 봅시다",
            "finish": "선택된 행과 열만 있는 새로운 테이블을 만들었어요!",
            "conflict": {
                "ExpectedSelectName": "적어도 하나의 열 이름이 필요해요."
            }
        },
        "SetLiteral": {
            "name": "특정 세트",
            "description": "$1 아이템",
            "emotion": "$?",
            "doc": "저는 특정 값들의 특정 @Set . 저와 함께 작업하는 방법에 대해 더 알고 싶다면 @Set 참조하세요.",
            "start": "먼저 값들을 평가해 봅시다!",
            "finish": "세트 $1을 만들었어요!"
        },
        "SetOrMapAccess": {
            "name": "세트/맵 접근",
            "emotion": "$?",
            "doc": [
                "@Set 또는 @Map 값이나 키가 있는지 확인할 수 있어요.",
                "그리 어렵지 않아요. 이렇게 말이죠:",
                "\\좋아하는 것들: {'오리' '거위' '원숭이'}\n좋아하는 것들{'쥐'}\\",
                "또는 @Map 사용하여 이렇게요:",
                "\\좋아하는 것들: {'맥앤치즈': 5별 '시리얼': 2별 '죽': 1별}\n좋아하는 것들{'죽'}\\"
            ],
            "start": "세트나 맵은 무엇인가요?",
            "finish": "값은 $1입니다",
            "conflict": {
                "IncompatibleKey": {
                    "primary": "$1 키를 예상했습니다",
                    "secondary": "$2 대신 $1을 받았습니다"
                }
            }
        },
        "Source": {
            "name": "소스",
            "emotion": "$?",
            "doc": [
                "@Program 알고 계시나요? 저는 그것들에 이름을 붙여주는 데 도움을 줍니다. @Program 주변의 창문과 그것들에 붙이는 이름처럼 생각하세요.",
                "다른 @Source 프로그램과 함께 다른 @Source @UI/addSource 만들고, 다른 @Program @Borrow 통해 다른 프로그램에서 사용할 것들을 가져올 수도 있어요.",
                "이것은 큰 공연을 별도의 문서로 조직하는 좋은 방법이 될 수 있습니다."
            ]
        },
        "StreamDefinition": {
            "name": "스트림",
            "emotion": "$?",
            "doc": "제가 새로운 스트림을 만들어야 한다고 /생각/합니다. 하지만 정말로 그 방법을 모르겠어요. 지금은, 이미 존재하는 스트림을 사용하는 것이 좋겠죠?",
            "start": "이 새로운 종류의 스트림을 만듭니다"
        },
        "StructureDefinition": {
            "name": "구조",
            "description": "구조 $1",
            "emotion": "$?",
            "doc": [
                "안녕하세요, 어떠세요? 저요? 저는 잘 지내고 있어요. 값을 저장하고 기능하는 구조를 정의하는 것을 좋아해서, 그 일을 하루 종일 할 수 있다면 저는 행복해요.",
                "저는 이렇게 작동해요:",
                "\\•피자(\n재료들•['']\n크기•#인치\n) (\n\tƒ 비용() 크기 · 10달러/인치\n)\n\n피자(['페퍼로니' '페퍼'] 12인치).비용()\\",
                "작동 방식을 보세요? \\피자\\를 정의했는데, 두 개의 입력, \\재료들\\ (텍스트 목록)과 \\크기\\ (인치 단위의 숫자)가 있어요.",
                "내부에서, @FunctionDefinition 인치 당 $10을 가정하여 피자 비용을 평가하는 함수를 만들었어요.",
                "저는 @FunctionDefinition 없어도 됩니다. 단지 입력들만 있을 수 있어요.",
                "\\•피자(\n재료들•['']\n크기•#인치\n)\\",
                "또한 내부에 @Bind 가질 수 있어서, 미리 비용을 평가할 수 있어요.",
                "\\•피자(\n재료들•['']\n크기•#인치\n) (\n\t비용: 크기 · 10달러/인치\n)\n\n피자(['페퍼로니' '페퍼'] 12인치).비용\\"
            ],
            "start": "이 멋진 구조를 정의해 봅시다",
            "conflict": {
                "DisallowedInputs": "제 인터페이스 함수 중 하나 이상이 구현되지 않았기 때문에 입력을 가질 수 없어요",
                "IncompleteImplementation": "제 함수들은 모두 구현되거나, 하나도 구현되지 않아야 해요. 어정쩡한 혼합은 안 됩니다!",
                "NotAnInterface": "저는 인터페이스가 아니에요; 구조는 다른 구조가 아닌 인터페이스만 구현할 수 있어요",
                "UnimplementedInterface": "저는 $1을 구현하지만 $2를 구현하지 않았어요"
            }
        },
        "StructureDefinitionType": {
            "name": "$~구조정의",
            "emotion": "$?",
            "description": "$~$1의 정의",
            "doc": [
                "$~나는 일종의 @StructureDefinition 을 참조합니다. 사람들은 대개 나를 직접적으로 언급하지 않습니다."
            ]
        },
        "TableLiteral": {
            "name": "특정 테이블",
            "description": "$1 행 테이블",
            "emotion": "$?",
            "doc": "저는 특정한 행들을 가진 구체적인 테이블입니다. 저를 어떻게 활용할 수 있는지 @Table 확인해보세요.",
            "start": "먼저 행들을 평가합니다",
            "finish": "새 테이블 $1로 평가되었습니다"
        },
        "TextLiteral": {
            "name": "특정 텍스트",
            "description": "텍스트 $1",
            "emotion": "$?",
            "doc": "저는 하나 이상의 구체적인 @Translation 텍스트를 나타냅니다. 저의 기능에 대해 더 알고 싶다면 @Text 참조하세요!",
            "start": "현재 로케일에서 텍스트를 만듭시다"
        },
        "Translation": {
            "name": "번역",
            "description": "텍스트 $1",
            "emotion": "$?",
            "doc": "저는 @Language 태그가 있는 텍스트를 나타냅니다. 저에 대해 더 알고 싶다면 @Text 참조하세요!",
            "conflict": {
                "phone": "$~*$1* 누군가의 전화번호인가요? 그렇다면 온라인에서 저를 공유하지 마세요!\n\n$2",
                "email": "$~*$1* 이메일이 다른 사람의 이메일인가요? 그렇다면 여기에 나를 공유하지 마십시오!\n\n$2",
                "tin": "$~*$1*은 세금 식별자인가요? 그렇다면 저를 공유하지 마십시오. 저는 매우 민감한 정보입니다!\n\n$2",
                "address": "$~*$1*이 누군가의 집 주소인가요? 그렇다면 나를 여기에 두지 마십시오. 우리는 누구도 스토킹당하는 것을 원하지 않습니다!\n\n$2",
                "handle": "$~*$1* 사용자 이름이 인터넷의 다른 곳에 있습니까? 그렇다면 정말로 의도하지 않는 한 여기에 저를 공유하지 마십시오.\n\n$2",
                "resolution": "$~민감한 데이터가 아닙니다.",
                "reminder": "$~참고: 이 작업을 실행 취소하고 공유 대화상자에서 민감하지 않은 것으로 표시한 다른 항목을 볼 수 있습니다."
            }
        },
        "FormattedLiteral": {
            "name": "포맷된 텍스트",
            "description": "텍스트 $1",
            "emotion": "$?",
            "doc": "저는 다양한 @FormattedTranslation 포맷된 텍스트를 나타냅니다. 평가할 때, 관객의 선택된 언어에 기반하여 최적의 일치를 선택할 거예요.",
            "start": "현재 로케일에서 텍스트를 만듭시다"
        },
        "FormattedTranslation": {
            "name": "포맷된 텍스트",
            "description": "텍스트 $1",
            "emotion": "$?",
            "doc": [
                "저는 @Language 태그가 있는 포맷된 텍스트를 나타냅니다.",
                "저는 다음과 같을 수 있어요:",
                "\\`/이탤릭/`\\",
                "\\`*볼드*`\\",
                "\\`^엑스트라 볼드^`\\",
                "\\`_밑줄_`\\",
                "\\`<링크@https://wordplay.dev>`\\",
                "\\`\\'코드'\\`\\",
                "@Phrase 함께 @Stage 아름다운 텍스트를 올리는 데 정말 잘 작동해요."
            ]
        },
        "This": {
            "name": "이것",
            "emotion": "$?",
            "doc": [
                "가끔은 값을 명시적으로 이름 짓기보다는 암시적으로 참조하는 것이 도움이 됩니다.",
                "예를 들어, 변환되는 값을 이름으로 지정하지 않는 새로운 @ConversionDefinition 만들고 싶다고 가정해 봅시다. 저를 사용하여 그것을 참조할 수 있어요:",
                "\\→ #무지개 #기쁨 . · 1000000기쁨\n2무지개 → #기쁨\\",
                "저를 보세요, 무지개의 수를 대표하고 있죠?",
                "또는 @Reaction 만들고 싶지만 가장 최근의 값을 이름으로 지정하고 싶지 않다면:",
                "\\2 … ∆ 시간(1000ms) … . · 2\\",
                "저를 확인하세요, 이전 반응 값을 대표하고 있습니다.",
                "자주 등장하지는 않지만, 등장할 때면 @Bind 값을 정말 도와줄 수 있어요!"
            ],
            "start": "$1로 평가되었습니다",
            "conflict": {
                "MisplacedThis": "저는 구조, 변환, 또는 반응 안에서만 허용됩니다."
            }
        },
        "UnaryEvaluate": {
            "name": "단항 평가",
            "description": "$1",
            "emotion": "$?",
            "doc": [
                "하나의 값만 평가하는 @FunctionDefinition 있어서, @FunctionDefinition 이름이 단일 기호일 경우, 입력 앞에 이름을 둘 수 있다는 것을 알고 계셨나요?",
                "이렇게 말이죠:",
                "\\-(1 + 1)\\",
                "또는 이렇게:",
                "\\~⊥\\",
                "\\(1 + 1).negate()\\ 또는 \\⊥.not()\\보다 읽기 훨씬 쉽죠?",
                "저를 그렇게 쓸 필요는 없지만, 전체적으로 더 쉬울 수 있어요.",
                "한 가지 규칙이 있습니다: 이름과 값 사이에 공백을 둘 수 없어요. 그렇지 않으면 @Reference 또는 @BinaryEvaluate 만들 수 있습니다."
            ],
            "start": "값이 무엇인가요?",
            "finish": "$1을 만들었습니다"
        },
        "UnparsableExpression": {
            "name": "해석 불가",
            "emotion": "$?",
            "doc": [
                "/안녕하세요, @FunctionDefinition. 해석하기 어려운 @UnparsableExpression 대신 번역하고 있어요./",
                "jkwel fjiwojvioao jjiweo jrfe",
                "/무대에서 모든 표현식이 의미를 가지는 것은 아닙니다./",
                "s w ieorjwei iojwi jfkdlsfdsk",
                "/실제로, 전혀 말이 되지 않는 말을 할 수 있는 것들이 많죠./",
                "dsk sdlk jdkfiewipapweiurb,v kdsfdsf",
                "/그럴 때 저는 나타나요, 왜냐하면 당신이 무엇을 의미했는지 모르거든요./",
                "결국엔 당신이 연출가이니, 당신만이 무엇을 의미했을지 알겠죠!"
            ],
            "start": "???",
            "conflict": {
                "UnparsableConflict": {
                    "conflict": "@FunctionDefinition 여기 있어요, @UnparsableExpression 이것이 어떤 종류의 $1[ 표현 | 타입 ]인지 모르겠어요/",
                    "resolution": "$~1달러, 2달러라고 말씀하셨나요?"
                },
                "UnclosedDelimiter": "$1 이후에 언젠가 $2가 나올 것이라고 예상했어요"
            },
            "exception": {
                "UnparsableException": {
                    "description": "???",
                    "explanation": "/안녕하세요, @FunctionDefinition ! 우리는 이것이 어떤 종류의 지시인지 몰라 공연을 중단해야 했어요./"
                }
            }
        },
        "Update": {
            "name": "업데이트",
            "emotion": "$?",
            "doc": [
                "저는 @Table 수정하는 데 도움을 줍니다. 조건에 맞는 행을 찾아 새로운 값으로 개정된 행을 생성합니다.",
                "예를 들어, 캐릭터와 점수가 있는 테이블이 있고, 특정 팀의 모든 캐릭터에게 점수를 주고 싶다면 이렇게 할 수 있습니다:",
                "\\플레이어: ⎡이름•'' 팀•'' 점수•#⎦\n⎡'jen' 'red' 1⎦\n⎡'joan' 'blue' 0⎦\n⎡'jeff' 'red' 3⎦\n⎡'janet' 'blue' 2⎦\n플레이어 ⎡: 점수: 점수 + 1 ⎦ 팀 = 'blue'\\",
                "변경할 열을 지정하기 위해 @Bind 사용할 수 있고, 조건에는 열 이름이나 범위 안의 다른 이름을 사용할 수 있습니다."
            ],
            "start": "먼저 테이블을 가져와 봅시다",
            "finish": "개정된 행을 포함한 새 테이블로 평가되었습니다!",
            "conflict": {
                "ExpectedColumnBind": "모든 열에 대한 값을 필요로 합니다",
                "IncompatibleCellType": {
                    "primary": "$1이 필요했지만, $2를 받았습니다",
                    "secondary": "$2를 받았습니다"
                }
            }
        },
        "AnyType": {
            "name": "아무 타입",
            "emotion": "$?",
            "doc": "나는 어떤 가능한 타입이든 대표해. 가끔 나타나는 이유는 뭔가의 값이 어떤 종류인지 모르기 때문에 뭐든 될 수 있어."
        },
        "BooleanType": {
            "name": "불리언",
            "emotion": "$?",
            "doc": [
                "나는 @Bind 함께 작동해서 이름이 @Boolean 값임을 선언해. 이렇게:",
                "\\hungry•?: 'jello'\\",
                "뭔가가 정말 @Boolean 인지 확실하게 하려면 나를 사용해, 내가 확인해 줄게!"
            ]
        },
        "ConversionType": {
            "name": "변환",
            "emotion": "$?",
            "doc": [
                "@Bind 와 함께 작동해서 이름이 @ConversionDefinition 인 것을 나타냄. 아마도 나를 사용할 일은 별로 없을 거야, 왜냐하면 많은 사람들이 나를 값으로 전달하지 않기 때문이지만, 만약에 나를 사용한다면 이렇게 보일거야:",
                "\\magic•?→'': → ? '' . ? 'yep' 'nope'\\"
            ]
        },
        "FormattedType": {
            "name": "포맷된",
            "emotion": "$?",
            "doc": [
                "@Bind 와 함께 작동해서 이름이 @FormattedLiteral 값임을 알림. 이렇게:",
                "\\hungry•`…`: `I am so /fancy/!`\\",
                "뭔가가 정말 @FormattedLiteral 값인지 확인하려면 이렇게 확인해 봐."
            ]
        },
        "ExceptionType": {
            "name": "예외",
            "emotion": "$?",
            "doc": "나는 예외를 나타냄. 나는 어떻게 보든지 @Program 을 중단하기 때문에 나는 값으로 사용할 수 없어."
        },
        "FunctionType": {
            "name": "함수 타입",
            "description": "$1 입력, $2 출력",
            "emotion": "$?",
            "doc": [
                "나는 @FunctionDefinition 을 나타냄. @Bind 가 어떤 종류의 함수를 가지고 있는지 말하고 싶을 때 정말 도움이 돼! 이렇게:",
                "\\math•ƒ (# # # #) #: ƒ interesting(a•# b•# c•# d•#) a + b + c + d\\"
            ]
        },
        "ListType": {
            "name": "리스트 타입",
            "description": "$1[리스트의 $1|리스트]",
            "emotion": "$?",
            "doc": [
                "나는 정말 @List 의 팬이야. @Bind 에게 그들이 어떤 종류의 리스트인지 말할 수 있어! 이렇게, 나는 @Number 리스트라고 말하고 있어:",
                "\\things•[#]: [ 1 2 3 4 5 ]\\"
            ]
        },
        "MapType": {
            "name": "맵 타입",
            "description": "$1[ $1|아무거나]에서 $2[ $2|아무거나]로의 맵",
            "emotion": "$?",
            "doc": [
                "@Map 이 얼마나 멋진지 알아? 진짜로 멋져. 나는 항상 @Bind 에게 그들이 어떤 종류의 맵인지 알려주고 있어, 예를 들어 숫자에서 리스트로의 맵이야:",
                "\\stuff•{'':[]}: {}\\"
            ]
        },
        "NumberType": {
            "name": "숫자 타입",
            "description": "$1[ $1 | 숫자]",
            "emotion": "$?",
            "doc": [
                "@Bind 는 뭘 해야 할까? @Number 여야지. 왜냐하면 숫자가 최고 af니까.",
                "\\count•#: 17\\"
            ]
        },
        "NameType": {
            "name": "이름 타입",
            "description": "$1 타입",
            "emotion": "$?",
            "doc": [
                "나는 @StructureDefinition 을 그 이름으로 나타냄. 그래서, 예를 들면 이렇게 구조가 있다면, 값을 저장하는 @Bind 를 만들 수 있어.",
                "\\•Friend(name•'')\nbestie•Friend: Friend('Jonah')\\"
            ],
            "conflict": {
                "UnknownTypeName": "타입 이름은 구조 또는 타입 변수를 참조할 수 있지만 이것은 $1을 참조함"
            }
        },
        "NeverType": {
            "name": "절대 불가능한 타입",
            "emotion": "$?",
            "doc": "나는 불가능한 타입을 나타냄. 예를 들어 @Is 에게 뭔가가 @Number 인지 물어봐도 그것은 결코 숫자가 될 수 없을 때야."
        },
        "NoneType": {
            "name": "없음 타입",
            "emotion": "$?",
            "doc": [
                "@None 은 가장 최고의 없음이고, 나는 그들의 충실한 대표자야.",
                "\\space•ø: ø\\"
            ]
        },
        "SetType": {
            "name": "집합 타입",
            "description": "$1[ $1 집합|집합] 타입",
            "emotion": "$?",
            "doc": [
                "@Set 은 정말 최고야, 진짜로. 나는 항상 @Bind 에게 뭔가를 집합으로 만들라고 말하고 있어!",
                "\\unique•{''}: {'something' 'anything' 'someone'}\\"
            ]
        },
        "StreamDefinitionType": {
            "name": "스트림 정의 타입",
            "emotion": "$?",
            "doc": "나는 정의한 스트림을 나타내, 그게 불가능한데, 그러니까 왜 읽고 있어?"
        },
        "StreamType": {
            "name": "스트림 타입",
            "emotion": "$?",
            "doc": [
                "나는 스트림의 아름다움과 의미를 축하해… @Bind 에게 그것들을 저장하라고 말해:",
                "\\time•…#ms: Time()\\"
            ]
        },
        "StructureType": {
            "name": "구조체 타입",
            "description": "$1",
            "emotion": "$?",
            "doc": "나는 기본 값 타입을 나타내기 위한 내부 타입이야."
        },
        "UnknownType": {
            "name": "알 수 없는 타입",
            "connector": ", 왜냐하면 ",
            "emotion": "$?",
            "doc": "음... 나는 내가 뭐를 나타내는지 모르겠어, 근데 정말로 궁금해. 너는 알아? 우리가 알아야 할 것 같아. 모르겠으면 우리한테 말해줘."
        },
        "TableType": {
            "name": "테이블 타입",
            "emotion": "$?",
            "doc": "나는 테이블을 나타냄.",
            "conflict": {
                "ExpectedColumnType": "나는 열 타입이 필요해"
            }
        },
        "TextType": {
            "name": "텍스트 타입",
            "description": "$1[ $1 | 텍스트]",
            "emotion": "$?",
            "doc": [
                "나는 가장 화려한 종류의 값, @Text 를 멋지게 나타냄.",
                "\\story•'': '한 번에 하나의 시간에...'\\"
            ]
        },
        "TypePlaceholder": {
            "name": "플레이스홀더 타입",
            "emotion": "$?",
            "doc": "언젠가는 타입을 나타내기를 희망해, 내 베프인 @ExpressionPlaceholder 이 표현을 나타내는 것처럼 말이야! 어떤 종류인지 도와줄래?"
        },
        "UnionType": {
            "name": "옵션 타입",
            "description": "$1 | $2",
            "emotion": "$?",
            "doc": [
                "누구를 나타내야 할까, A 또는 B 또는 다른 뭔가? 결정할 수가 없어!",
                "\\indecision•''|#|{ø}: \"I don't know!\"\\"
            ]
        },
        "Unit": {
            "name": "단위",
            "description": "$1",
            "emotion": "$?",
            "doc": [
                "나는 @Number 가 가질 수 있는 모든 단위를 나타내, 단위가 없는 경우부터 상상할 수 있는 가장 복잡한 단위까지. 중력 같은 것 예를 들면:",
                "\\gravity•m/s^2: 9.8m/s^2\\",
                "@Bind 에서 나타나지만 @Number 바로 뒤에서도 나타나. 나는 숫자가 같은 종류인지 확인하는 데 도움을 주고, 그렇지 않으면 분명히 알려줄 거야, 실수라면 말이야!"
            ]
        },
        "UnparsableType": {
            "name": "해석할 수 없는 타입",
            "emotion": "$?",
            "doc": "나는 알 수 없는 표현의 타입을 나타내. 그 표현을 어떤 목적으로 사용하려고 할 때 내가 나타나."
        },
        "VariableType": {
            "name": "변수 타입",
            "emotion": "$?",
            "doc": "@TypeVariable 을 알아? 그리고 그들이 어떤 알 수 없는 종류의 값을 나타내는지? 나는 값 간의 모든 협상에서 그들을 나타내."
        },
        "CycleType": {
            "name": "순환 타입",
            "description": "자기 자신에 의존",
            "emotion": "$?",
            "doc": "가끔 값들이 자기 자신에게 의존하고 있어서 그 값이 어떤 종류인지 모르는 경우가 있어. 나는 그 상황을 나타내."
        },
        "UnknownVariableType": {
            "name": "알 수 없는 변수 타입",
            "emotion": "$?",
            "doc": "가끔 우리는 뭔가의 종류를 추측해 보려고 해; 나는 그게 뭔지 모를 때 나타나."
        },
        "NotAType": {
            "name": "예상치 못한 타입",
            "description": "$1이 아님",
            "emotion": "$?",
            "doc": "가끔 우리는 뭔가가 어떤 종류여야 하는지 알아. 예를 들면 @ListAccess 는 @Number 가 필요해. 그걸 얻지 못하면, 나는 뭔가가 우리가 기대한 것과 다른 타입이라고 나타내."
        },
        "NoExpressionType": {
            "name": "표현식 없음 타입",
            "emotion": "$?",
            "doc": "@Block 적어도 하나의 표현식이 필요한 걸 알고 계시죠? 표현식을 제공하지 않을 때 나타나는 게 바로 저예요. 그러니 표현식을 제공하세요!"
        },
        "NotEnclosedType": {
            "name": "구조, 변환, 반응 안에 없음",
            "emotion": "$?",
            "doc": "@This 멋지긴 하지만, 특정 장소에만 속해요. 그들이 길을 잃었을 때, 누구를 대표하는지 아무도 모를 때 저가 나타납니다."
        },
        "NotImplementedType": {
            "name": "구현되지 않음",
            "emotion": "$?",
            "doc": "@ExpressionPlaceholder 사용하지만, 그 타입을 지정하지 않을 때, 나타나는 타입이 바로 저예요. 그냥 받아들이세요!"
        },
        "UnknownNameType": {
            "name": "알 수 없는 이름",
            "description": "$1[$1이 정의되지 않음 |이름이 주어지지 않음]",
            "emotion": "$?",
            "doc": "가끔 @Reference @PropertyReference 당신이 말하는 이름을 모를 때가 있죠? 그럴 때 나타나서 우리가 누구에 대해 이야기하고 있는지 모른다는 것을 대표합니다."
        },
        "NonFunctionType": {
            "name": "비함수",
            "description": "비함수",
            "emotion": "$?",
            "doc": "우리 중 일부는 함수를 기대했는데, 함수를 받지 못했을 때 저가 나타나요."
        }
    },
    "basis": {
        "Boolean": {
            "doc": [
                "우리는 \\⊤\\와 \\⊥\\입니다. \\⊤\\는 참입니다. \\⊥\\는 거짓입니다. \\⊤\\는 \\⊥\\가 아니며; \\⊥\\는 \\⊤\\가 아닙니다. 이것이 그대로의 사실입니다.",
                "우리를 어떻게 만드나요? 그냥 \\⊤\\와 \\⊥\\, 더도 덜도 아닙니다.",
                "일부는 키보드를 사용합니다 (/ctrl+9/은 \\⊤\\, /ctrl+0/은 \\⊥\\). 일부는 편집기 하단의 문자 검색을 사용합니다. 또는 여기서 끌어다 쓸 수도 있습니다.",
                "아래의 @FunctionDefinition 확인해보세요. 그들은 매우 논리적입니다."
            ],
            "name": ["⊤⊥", "부울"],
            "function": {
                "and": {
                    "doc": [
                        "두 값이 모두 \\⊤\\일 때만 \\⊤\\로 평가합니다. 많은 것들이 모두 참인지 결정하는 데 도움이 됩니다. 가능한 결과는 네 가지뿐입니다",
                        "\\⊤ & ⊤\\",
                        "\\⊤ & ⊥\\",
                        "\\⊥ & ⊤\\",
                        "\\⊥ & ⊥\\"
                    ],
                    "names": ["&", "그리고"],
                    "inputs": [
                        {
                            "doc": "확인할 다른 @Boolean. 첫 번째가 \\⊥\\이면 이것이 무엇이든, 함수는 \\⊥\\로 평가될 것입니다.",
                            "names": "값"
                        }
                    ]
                },
                "or": {
                    "doc": [
                        "두 값 중 *하나라도* \\⊤\\일 때 \\⊤\\로 평가합니다. 많은 것들 중 하나라도 참인지 결정하는 데 도움이 됩니다. 가능한 결과는 네 가지뿐입니다",
                        "\\⊤ | ⊤\\",
                        "\\⊤ | ⊥\\",
                        "\\⊥ | ⊤\\",
                        "\\⊥ | ⊥\\"
                    ],
                    "names": ["|", "또는"],
                    "inputs": [
                        {
                            "doc": "확인할 다른 @Boolean. 첫 번째가 \\⊥\\이면, 이 함수는 이것이 \\⊤\\일 때만 \\⊤\\로 평가됩니다.",
                            "names": "값"
                        }
                    ]
                },
                "not": {
                    "doc": "저는 제 자신의 반대를 얻습니다: 만약 \\⊤\\이라면 \\⊥\\를, 만약 \\⊥\\라면 \\⊤\\를 줍니다.",
                    "names": ["~", "아님"],
                    "inputs": []
                },
                "equals": {
                    "doc": "둘 다 \\⊤\\이거나 둘 다 \\⊥\\일 경우 \\⊤\\입니다.",
                    "names": ["=", "동등"],
                    "inputs": [
                        {
                            "doc": "확인할 다른 값입니다.",
                            "names": "값"
                        }
                    ]
                },
                "notequal": {
                    "doc": "둘 다 반대일 경우 \\⊤\\입니다.",
                    "names": ["≠", "동등하지않음"],
                    "inputs": [
                        {
                            "doc": "확인할 다른 값입니다.",
                            "names": "값"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "@Boolean \\'⊤'\\와 \\'⊥'\\의 @Text 값으로 변환합니다."
            }
        },
        "None": {
            "doc": [
                "/안녕하세요, @FunctionDefinition. @None 많이 말하지 않아서 제가 통역할게요./",
                "저는 @None. \\ø\\로 저를 호출하세요. 무엇인가가 없음을 나타내고 싶을 때 유용합니다."
            ],
            "name": ["ø", "없음"],
            "function": {
                "equals": {
                    "doc": "다른 값도 아무것도 아닌가요? 그렇지 않다면, \\⊥\\이겠죠.",
                    "names": ["=", "동등"],
                    "inputs": [
                        {
                            "doc": "다른 값입니다.",
                            "names": "값"
                        }
                    ]
                },
                "notequals": {
                    "doc": "다른 값이 /아무것도 아니지 않나요?/",
                    "names": ["≠", "동등하지않음"],
                    "inputs": [
                        {
                            "doc": "다른 값입니다.",
                            "names": "값"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "\\ø\\를 \\'ø'\\로 만들고 싶나요? 이것이 바로 그 기회입니다."
            }
        },
        "Text": {
            "doc": [
                "$~나는 당신이 원하는 모든 텍스트를 어떤 언어로, 다음의 기호를 사용하여 나타낼 수 있습니다: \\\"\"\\, \\“”\\, \\„“\\, \\''\\, \\‘’\\, \\‹›\\, \\«»\\, \\「」\\, or \\『』\\.",
                "$~예를 들어, 다음과 같은 아름다운 문구를 고려해 보세요.",
                "$~\\“인생을 사는 방법은 두 가지뿐입니다. 하나는 마치 아무것도 기적이 아닌 것처럼 사는 것입니다. 다른 하나는 마치 모든 것이 기적인 것처럼 사는 것입니다.”\\",
                "$~\\『일일삼추』\\",
                "$~나를 열었다면 닫는 것을 기억하고, 일치하는 심볼을 사용하세요. 그렇지 않으면 당신이 말을 마쳤다는 것을 알 수 없을 겁니다.",
                "$~\\'안녕하세요'/en'hola'/es-MX\\",
                "$~또한 언어로 태그를 지정하고 여러 번역을 제공할 수도 있습니다. 일치하는 언어가 있는 경우 현재 선택된 언어로 평가합니다.",
                "$~다른 값으로 나를 만들고 싶다면 다음과 같이 하면 됩니다.",
                "$~\\\"다음은 몇 가지 합계입니다 \\1 + 2\\, \\2 + 3\\, \\3 + 4\\\"\\",
                "$~제가 얼마나 우아하게 그 합계를 계산해서 @Text 넣었는지 보셨나요?",
                "$~마지막으로 작은 비밀이 하나 있습니다. 우리 모두가 고유한 번호를 가지고 있다는 걸 알고 계셨나요? 사실입니다! 번호로 우리를 지칭할 수 있습니다. 예를 들어, @FunctionDefinition 192입니다.",
                "$~\\'92'\\",
                "$~192가 @FunctionDefinition 바뀌는 걸 보셨나요? 이 숫자를 '유니코드'라고 부르는 걸 들었어요.",
                "$~그렇지 않으면, @FunctionDefinition 나에게 단어로 온갖 일을 할 수 있게 해준 영광스러운 함수들이 너무나 많았을 뿐이에요!"
            ],
            "name": ["''", "텍스트"],
            "function": {
                "length": {
                    "doc": [
                        "저는 텍스트의 가독 가능한 문자 수로 평가됩니다; 한 글자는 한 문자, 하나의 이모지도 한 문자입니다. 예를 들어:",
                        "\\'hello'.length()\\",
                        "\\'🐈📚'.length()\\"
                    ],
                    "names": ["📏", "길이"],
                    "inputs": []
                },
                "equals": {
                    "doc": "\\⊤\\, 주어진 @Text 같은 문자열 순서인 경우.",
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "비교할 @Text.",
                            "names": "값"
                        }
                    ]
                },
                "notequals": {
                    "doc": "\\⊤\\, 주어진 @Text 같은 문자열 순서가 /아닌/ 경우.",
                    "names": ["≠", "동등하지않음"],
                    "inputs": [
                        {
                            "doc": "비교할 @Text.",
                            "names": "값"
                        }
                    ]
                },
                "repeat": {
                    "doc": [
                        "나는 \\count\\ 횟수를 반복하여 나라는 새로운 @Text를 만듭니다.",
                        "\\'안녕하세요' · 5\\",
                        "분수 @Number를 주면 나는 분수를 무시합니다.",
                        "\\'안녕하세요' · 5.5\\",
                        "음수 @Number 또는 0을 제공하면 빈 @Text를 제공합니다.",
                        "\\'안녕하세요' · -5\\",
                        "제가 만들 수 있는 가장 긴 텍스트는 65,535자입니다. 더 긴 텍스트를 작성하려고 하면 가능한 한 여러 번 텍스트를 반복하겠습니다."
                    ],
                    "names": ["·", "🔁", "반복하다"],
                    "inputs": [
                        {
                            "doc": "새 텍스트에서 내 말을 반복할 횟수입니다.",
                            "names": "$~세다"
                        }
                    ]
                },
                "segment": {
                    "doc": [
                        "주어진 @Text를 구분 기호로 사용하고 구분 기호를 제거하여 @Text의 @List로 나눕니다. 예를 들어:",
                        "\\'사과, 오렌지, 포도' ¼ ', '\\",
                        "구분 기호가 빈 @Text인 경우 문자로 나눕니다.",
                        "\\'🖌️🏠🥸' ¼ ''\\"
                    ],
                    "names": ["segmentar"],
                    "inputs": [
                        {
                            "doc": "구분 기호로 사용할 @Text입니다.",
                            "names": "구분기호"
                        }
                    ]
                },
                "combine": {
                    "doc": [
                        "때로는 @Text를 하나로 결합하는 것이 도움이 될 수 있습니다. @Text를 한 번 더 주시면 우리를 하나로 묶는 새로운 텍스트를 만들어 드리겠습니다.",
                        "\\'안녕하세요' + '절'\\"
                    ],
                    "names": ["+", "결합하다"],
                    "inputs": [
                        {
                            "doc": "추가할 @Text입니다.",
                            "names": "텍스트"
                        }
                    ]
                },
                "has": {
                    "doc": [
                        "\\⊤\\ 주어진 @Text가 나에게 나타나는 경우.",
                        "\\'원하는 것을 찾으셨나요?'.has('당신')\\"
                    ],
                    "names": ["tiene"],
                    "inputs": [
                        {
                            "doc": "$~내에서 검색할 @Text 입니다.",
                            "names": "$~텍스트"
                        }
                    ]
                },
                "starts": {
                    "doc": [
                        "\\⊤\\ 주어진 @Text로 시작하면.",
                        "\\'안녕 절!'.starts('hello')\\",
                        "\\'안녕 절!'.starts('절')\\"
                    ],
                    "names": ["시작하다"],
                    "inputs": [
                        {
                            "doc": "시작 시 확인할 @Text입니다.",
                            "names": "texto"
                        }
                    ]
                },
                "ends": {
                    "doc": [
                        "\\⊤\\ 주어진 @Text로 끝나는 경우.",
                        "\\'제가 질문인가요?'.ends('?')\\",
                        "\\'저는 질문이 아닙니다.'.ends('?')\\"
                    ],
                    "names": ["끝"],
                    "inputs": [
                        {
                            "doc": "마지막에 확인할 @Text입니다.",
                            "names": "texto"
                        }
                    ]
                }
            },
            "conversion": {
                "list": "텍스트를 개별 문자로 나누어 리스트로 만듭니다.",
                "number": "텍스트를 @Number로 변환하며, 숫자가 아니면, 숫자가 아닌 값을 반환합니다."
            }
        },
        "Number": {
            "doc": [
                "나는 당신이 상상할 수 있는 모든 단위로 @Number를 만듭니다!",
                "내 상위 5개는 다음과 같습니다.",
                "\\0\\",
                "\\1스토리\\",
                "\\π파이\\",
                "\\∞돌\\",
                "\\1000000포옹\\",
                "그건 사실상 무한한 숫자의 집합이에요.",
                "그리고 무한한 단위의 집합도요!",
                "그리고 무한한 숫자/단위 쌍…",
                "저는 정수, 실수, 음수, 양수, 분수, 소수, 심지어 숫자가 아닐 수도 있습니다.",
                "그리고 아랍어 \\123\\, 로마자 \\ⅩⅩⅩⅠⅩ\\, 일본어 \\two十\\ 등 다양한 숫자 체계로 저를 표현할 수도 있어요:",
                "\\1 + Ⅰ + 一\\",
                "저를 2진수부터 16진수까지 다양한 진법으로 쓸 수도 있어요.",
                "\\2;11111111\\",
                "\\10;255\\",
                "\\16;FF\\",
                "숫자가 아닌 것을 입력했을 때 사용할 수 있는 NaN이라는 특별한 숫자가 하나 있습니다:",
                "\\2;22\\",
                "2진법에는 '2'라는 숫자가 없으므로 유효한 숫자가 아닙니다. NaN은 숫자가 아닌 텍스트를 숫자로 변환하려고 할 때도 나타날 수 있어요.",
                "\\'안녕'→#\\"
            ],
            "name": ["#", "숫자"],
            "function": {
                "add": {
                    "doc": [
                        "동일한 @Unit을 가진 @Number를 더해, 동일한 @Unit를 가진 새로운 @Number를 생성합니다.",
                        "예를 들어:",
                        "\\1 + 1\\",
                        "\\고양이 3마리 + 고양이 5마리\\",
                        "만약 단위가 일치하지 않으면, 계산을 멈춥니다.",
                        "\\고양이 3마리 + 강아지 5마리\\"
                    ],
                    "names": ["+", "추가하다"],
                    "inputs": [
                        {
                            "doc": "추가할 @Number입니다.",
                            "names": "숫자"
                        }
                    ]
                },
                "subtract": {
                    "doc": [
                        "저는 주어진 @Number를 저 자신에서 빼서, 동일한 @Unit를 가진 새로운 @Number를 만듭니다.",
                        "예를 들어:",
                        "\\1 - 1\\",
                        "\\고양이 3마리 - 고양이 5마리\\",
                        "만약 단위가 일치하지 않으면, 계산을 멈춥니다.",
                        "\\고양이 3마리 - 고양이 5마리\\"
                    ],
                    "names": ["-", "빼다"],
                    "inputs": [
                        {
                            "doc": "나에게서 뺄 @Number입니다.",
                            "names": "숫자"
                        }
                    ]
                },
                "multiply": {
                    "doc": [
                        "저는 주어진 @Number와 저 자신을 곱해, 제 @Unit과 주어진 숫자의 @Unit를 곱한 결과를 만듭니다.",
                        "\\5 · 5\\",
                        "\\5m · 5m\\",
                        "\\5m · 1/초\\"
                    ],
                    "names": ["·", "곱하다"],
                    "inputs": [
                        {
                            "doc": "곱할 숫자입니다.",
                            "names": "숫자"
                        }
                    ]
                },
                "divide": {
                    "doc": [
                        "저는 주어진 @Number로 저 자신을 나누어, 제 @Unit과 주어진 숫자의 @Unit을 나눈 몫을 만듭니다.",
                        "\\5 ¼ 5\\",
                        "\\5m ¼ 5m\\",
                        "\\5분 ¼ 5초\\"
                    ],
                    "names": ["÷", "divide"],
                    "inputs": [
                        {
                            "doc": "나를 나눌 @Number입니다.",
                            "names": "숫자"
                        }
                    ]
                },
                "remainder": {
                    "doc": [
                        "나는 주어진 @Number로 나 자신을 나누고 나머지를 제공합니다.",
                        "\\10% 2\\",
                        "\\10m % 2\\",
                        "\\10m/초 % 3\\"
                    ],
                    "names": ["%", "나머지"],
                    "inputs": [
                        {
                            "doc": "저를 나눌 @Number입니다.",
                            "names": "숫자"
                        }
                    ]
                },
                "positive": {
                    "doc": [
                        "저는 음수일 경우 저를 양수로 만드는 새로운 @Number를 만듭니다.",
                        "\\-200.양수()\\"
                    ],
                    "names": ["양수"],
                    "inputs": []
                },
                "round": {
                    "doc": [
                        "저는 자신을 가장 가까운 정수로 반올림한 새로운 @Number를 만듭니다.",
                        "\\9.4.반올림()\\",
                        "\\9.5.반올림()\\",
                        "\\9.6.반올림()\\"
                    ],
                    "names": ["반올림"],
                    "inputs": []
                },
                "roundDown": {
                    "doc": [
                        "저는 자신보다 작거나 같은 가장 작은 정수로 내림한 새로운 @Number를 만듭니다.",
                        "\\10.5.내림()\\",
                        "\\10.1.내림()\\",
                        "\\10.01.내림()\\"
                    ],
                    "names": ["내림"],
                    "inputs": []
                },
                "roundUp": {
                    "doc": [
                        "저는 자신보다 크거나 같은 가장 작은 정수로 올림한 새로운 @Number를 만듭니다.",
                        "\\10.5.올림()\\",
                        "\\10.9.올림()\\",
                        "\\10.99.올림()\\"
                    ],
                    "names": ["올림"],
                    "inputs": []
                },
                "power": {
                    "doc": [
                        "저는 자신을 주어진 @Number의 거듭제곱으로 올립니다. 분수 지수도 가능합니다!",
                        "\\2 ^ 8\\",
                        "\\10 ^ -2\\",
                        "\\5 ^ -.5\\"
                    ],
                    "names": ["^", "power"],
                    "inputs": [
                        {
                            "doc": "저를 몇 제곱으로 올릴지 나타내는 지수입니다.",
                            "names": "숫자"
                        }
                    ]
                },
                "root": {
                    "doc": [
                        "저는 주어진 루트를 사용하여 제 자신의 루트를 만듭니다.",
                        "\\4 √ 2\\",
                        "\\1000 √ 3\\"
                    ],
                    "names": ["√", "root"],
                    "inputs": [
                        {
                            "doc": "계산할 루트의 값입니다.",
                            "names": "숫자"
                        }
                    ]
                },
                "lessThan": {
                    "doc": [
                        "\\⊤\\ 주어진 @Number보다 작은 경우:",
                        "\\1 < 2\\",
                        "\\2 < 1\\"
                    ],
                    "names": ["<", "lessthan"],
                    "inputs": [
                        {
                            "doc": "저와 비교할 @Number입니다.",
                            "names": "숫자"
                        }
                    ]
                },
                "lessOrEqual": {
                    "doc": [
                        "\\⊤\\ 주어진 @Number보다 작거나 같은 경우:",
                        "\\1 ≤ 2\\",
                        "\\2 ≤ 1\\",
                        "\\2 ≤ 2\\"
                    ],
                    "names": ["≤", "lessorequal"],
                    "inputs": [
                        {
                            "doc": "저와 비교할 @Number입니다.",
                            "names": "숫자"
                        }
                    ]
                },
                "greaterThan": {
                    "doc": [
                        "\\⊤\\ 주어진 @Number보다 큰 경우:",
                        "\\1 > 2\\",
                        "\\2 > 1\\"
                    ],
                    "names": [">", "greaterthan"],
                    "inputs": [
                        {
                            "doc": "저와 비교할 @Number입니다.",
                            "names": "숫자"
                        }
                    ]
                },
                "greaterOrEqual": {
                    "doc": [
                        "\\⊤\\ 내가 주어진 @Number보다 크거나 같은 경우:",
                        "\\1 ≥ 2\\",
                        "\\2 ≥ 1\\",
                        "\\2 ≥ 2\\"
                    ],
                    "names": ["≥", "greaterorequal"],
                    "inputs": [
                        {
                            "doc": "자와 비교할 @Number입니다.",
                            "names": "숫자"
                        }
                    ]
                },
                "equal": {
                    "doc": [
                        "\\⊤\\ 제가 주어진 @Number와 같은 경우:",
                        "\\1 = 2\\",
                        "\\2 = 2\\"
                    ],
                    "names": ["=", "동일한"],
                    "inputs": [
                        {
                            "doc": "저와 비교할 @Number입니다.",
                            "names": "숫자"
                        }
                    ]
                },
                "notequal": {
                    "doc": [
                        "\\⊤\\ 내가 주어진 @Number와 같지 않은 경우:",
                        "\\1 ≠ 2\\",
                        "\\2 ≠ 2\\"
                    ],
                    "names": ["≠", "동일하지않은"],
                    "inputs": [
                        {
                            "doc": "저와 비교할 @Number입니다.",
                            "names": "숫자"
                        }
                    ]
                },
                "cos": {
                    "doc": ["저의 코사인 값을 계산해 보세요.", "\\π.cos()\\"],
                    "names": ["cos", "cosine"],
                    "inputs": []
                },
                "sin": {
                    "doc": ["저의 사인 값을 계산해 보세요.", "\\π.cos()\\"],
                    "names": ["sin", "sine"],
                    "inputs": []
                },
                "min": {
                    "doc": [
                        "저와 다른 숫자들 중에서 가장 작은 숫자를 찾습니다.",
                        "\\1.최소(2 3 -1)\\"
                    ],
                    "names": "최소",
                    "inputs": [
                        {
                            "doc": "저에게 주고 싶은 숫자만큼!",
                            "names": "숫자"
                        }
                    ]
                },
                "max": {
                    "doc": [
                        "저와 다른 숫자들 중에서 가장 큰 숫자를 찾습니다.",
                        "\\1.최대(2 3 4)\\"
                    ],
                    "names": "최대",
                    "inputs": [
                        {
                            "doc": "저에게 주고 싶은 숫자만큼!",
                            "names": "숫자"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "내 숫자의 아랍어 @Text 표현입니다.",
                "list": [
                    "나는 숫자를 \\1\\부터 주어진 숫자의 목록으로 변환합니다. 예를 들어:",
                    "\\10→[]\\"
                ],
                "s2m": "초에서 분으로",
                "s2h": "초에서 시간으로",
                "s2day": "초에서 일로",
                "s2wk": "초에서 주로",
                "s2year": "초에서 년으로",
                "s2ms": "초에서 밀리초로",
                "ms2s": "밀리초에서 초로",
                "min2s": "분에서 초",
                "h2s": "시간에서 초",
                "day2s": "일에서 초",
                "wk2s": "몇 주에서 몇 초까지",
                "yr2s": "년에서 초",
                "m2pm": "미터에서 피코미터으로",
                "m2nm": "미터에서 나노미터으로",
                "m2micro": "미터에서 마이크로미터으로",
                "m2mm": "미터에서 밀리미터으로",
                "m2cm": "미터에서 센티미터으로",
                "m2dm": "미터에서 데시미터으로",
                "m2km": "미터에서 킬로미터으로",
                "m2Mm": "미터에서 메가미터으로",
                "m2Gm": "미터에서 기가미터으로",
                "m2Tm": "미터에서 테라미터으로",
                "pm2m": "피코미터에서 미터으로",
                "nm2m": "나노미터에서 미터으로",
                "micro2m": "마이크로미터에서 미터으로",
                "mm2m": "밀리미터에서 미터으로",
                "cm2m": "센티미터에서 미터으로",
                "dm2m": "데시미터에서 미터으로",
                "km2m": "킬로미터에서 미터으로",
                "Mm2m": "메가미터에서 미터으로",
                "Gm2m": "기가미터에서 미터으로",
                "Tm2m": "테라미터에서 미터으로",
                "km2mi": "킬로미터에서 마일로",
                "mi2km": "마일에서 킬로미터로",
                "cm2in": "센티미터에서 인치으로",
                "in2cm": "인치에서 센티미터로",
                "m2ft": "미터에서 피트으로",
                "ft2m": "피트에서 미터로",
                "g2mg": "그램에서 밀리그램으로",
                "mg2g": "밀리그램에서 그램으로",
                "g2kg": "그램에서 킬로그램으로",
                "kg2g": "킬로그램에서 그램으로",
                "g2oz": "그램에서 온스으로",
                "oz2g": "온스에서 그램으로",
                "oz2lb": "온스에서 파운드으로",
                "lb2oz": "파운드에서 온스로"
            }
        },
        "List": {
            "doc": [
                "나는 어떤 종류의 값이든 일련의 값입니다!",
                "나에게 무엇이든 넣을 수 있어: @Boolean, @Number, @Text, @None, 심지어 다른 @List, @Set, @Map 또는 어떤 표현식이라도 가능해. 여기 간단한 예시가 있어:",
                "\\['사과' '바나나' '망고']\\",
                "나를 특별하게 만드는 것은 내가 순서를 유지하고, 내가 가진 모든 항목을 1부터 숫자를 매긴다는 점입니다.",
                "내 항목에는 1부터 시작하여 번호가 매겨져 있습니다. 해당 번호를 사용하여 @ListAccess로 저장한 값을 가져올 수 있습니다.",
                "예를 들어, 이 목록의 두 번째 값은 \\['banana']\\입니다.",
                "\\['사과' '바나나' '망고'][2]\\",
                "나는 어떤 것이든 포함할 수 있어. @Text, @Number, 그리고 @Time이 포함된 이 목록을 보세요!",
                "\\['사과' 10 + 10 시간()]\\",
                "내가 다양한 타입의 값들을 포함하는 리스트를 받으면, 공통된 유형이 있다면 이를 일반화할 것입니다. 하지만 때때로 정확히 특정한 값들만 포함하고 싶을 수도 있습니다. 그럴 때는 리스트 뒤에 !를 붙이면 돼. 그러면 나는 정확히 그 값들만 포함하는 리스트로 유지될 거야.",
                "\\['사과' '바나나' '망고']!\\",
                "이게 나야. 하지만 나는 @FunctionDefinition을 이용해 정말 다양한 멋진 기능을 수행할 수도 있어!"
            ],
            "name": ["[]", "목록"],
            "kind": "종류",
            "out": "결과",
            "outofbounds": "범위를 벗어남",
            "function": {
                "add": {
                    "doc": [
                        "나는 주어진 항목을 끝에 추가하여 새로운 @List를 만듭니다.",
                        "\\['사과' '바나나' '망고'].와함께('수박')\\"
                    ],
                    "names": ["와함께", "추가하다"],
                    "inputs": [
                        {
                            "doc": "추가하고 싶은 값입니다.",
                            "names": "항목"
                        }
                    ]
                },
                "append": {
                    "doc": [
                        "내 값을 사용하여 새 @List를 만든 다음, 주어진 @List의 모든 값을 내 뒤에 만듭니다.",
                        "\\['사과' '바나나' '망고'].withList(['수박' '스타프루트'])\\",
                        "하지만 다음과 같이 @Spread를 사용하는 것이 조금 더 쉽습니다.",
                        "\\['사과' '바나나' '망고' :['수박' '스타프루트']]\\"
                    ],
                    "names": ["withList", "추가"],
                    "inputs": [
                        {
                            "doc": "추가할 값 목록입니다.",
                            "names": "목록"
                        }
                    ]
                },
                "replace": {
                    "doc": [
                        "주어진 인덱스의 값을 새로운 값으로 바꾼 새로운 리스트를 만듭니다.",
                        "\\['사과' '바나나' '망고'].replace(1 '키위')\\"
                    ],
                    "names": ["replace"],
                    "inputs": [
                        {
                            "doc": "대체할 값의 인덱스",
                            "names": "인덱스"
                        },
                        {
                            "doc": "대체 값",
                            "names": "값"
                        }
                    ]
                },
                "length": {
                    "doc": "내 안에 있는 항목의 @Number.",
                    "names": ["📏", "길이"],
                    "inputs": []
                },
                "random": {
                    "doc": [
                        "내 항목 중 무작위로 선택된 하나의 항목을 반환하거나, 비어 있다면 @None을 반환합니다.",
                        "\\['사과' '바나나' '망고'].random()\\"
                    ],
                    "names": "무작위의",
                    "inputs": []
                },
                "shuffled": {
                    "doc": [
                        "내 항목들을 무작위 순서로 섞어서 새로운 리스트를 만듭니다.",
                        "\\['사과' '바나나' '망고'].shuffled()\\"
                    ],
                    "names": "섞인",
                    "inputs": []
                },
                "first": {
                    "doc": [
                        "내 첫 번째 항목이거나 비어 있으면 @None입니다.",
                        "\\['사과' '바나나' '망고'].first()\\"
                    ],
                    "names": "첫번째",
                    "inputs": []
                },
                "last": {
                    "doc": [
                        "내 안의 마지막 항목이거나 비어 있으면 @None입니다.",
                        "\\['사과' '바나나' '망고'].first()\\"
                    ],
                    "names": "마지막",
                    "inputs": []
                },
                "has": {
                    "doc": [
                        "\\⊤\\ 내 안에 주어진 아이템과 같은 항목이 있다면.",
                        "\\['사과' '바나나' '망고'].has('바나나')\\"
                    ],
                    "names": "가지다",
                    "inputs": [
                        {
                            "doc": "검색할 값입니다.",
                            "names": "항목"
                        }
                    ]
                },
                "join": {
                    "doc": [
                        "내 목록의 항목을 @Text로 결합하며, 주어진 구분 기호 @Text로 구분합니다.",
                        "\\['사과' '바나나' '망고'].join(', ')\\"
                    ],
                    "names": "결합하다",
                    "inputs": [
                        {
                            "doc": "항목을 구분하는 텍스트입니다. 선택적으로 비워둘 수 있습니다.",
                            "names": "구분기호"
                        }
                    ]
                },
                "subsequence": {
                    "doc": [
                        "이 목록 내에서 제공된 인덱스에서 시작하여 마지막 항목까지, 또는 특정한 항목에서 끝나는 하위 목록을 가져옵니다.",
                        "\\['사과' '바나나' '망고'].subsequence(2)\\",
                        "\\['사과' '바나나' '망고'].subsequence(1 2)\\",
                        "그리고 보세요! 번호를 순서대로 제공하지 않으면, 거꾸로 반환합니다.",
                        "\\['사과' '바나나' '망고'].subsequence(3 1)\\",
                        "인덱스에 1보다 작은 값을 제공하면, 1로 간주합니다.",
                        "\\['사과' '바나나' '망고'].subsequence(-1003243 2)\\",
                        "그리고 가장 큰 인덱스보다 큰 값을 제공하면, 리스트의 끝까지 선택한 것으로 간주합니다.",
                        "\\['사과' '바나나' '망고'].subsequence(3 2304032432)\\"
                    ],
                    "names": "부분연속",
                    "inputs": [
                        {
                            "doc": "원하는 하위 순서의 첫 번째 항목에 대한 인덱스입니다.",
                            "names": "시작"
                        },
                        {
                            "doc": "원하는 하위 순서의 마지막 항목에 대한 선택적 인덱스입니다. 하나도 제공하지 않으면 목록의 마지막 항목으로 목록이 종료됩니다.",
                            "names": "끝"
                        }
                    ]
                },
                "sansFirst": {
                    "doc": [
                        "첫 번째 항목 없이 목록을 만듭니다.",
                        "\\['사과' '바나나' '망고'].sansFirst()\\"
                    ],
                    "names": ["첫번째없이", "sansFirst"],
                    "inputs": []
                },
                "sansLast": {
                    "doc": [
                        "마지막 항목 없이 목록을 만듭니다.",
                        "\\['사과' '바나나' '망고'].sansLast()\\"
                    ],
                    "names": ["마지막없이", "sansLast"],
                    "inputs": []
                },
                "sans": {
                    "doc": [
                        "나, 하지만 주어진 값이 처음으로 나타나는 경우는 없습니다.",
                        "\\['사과' '바나나' '망고' '사과'].sans('사과')\\"
                    ],
                    "names": ["없이", "sans"],
                    "inputs": [
                        {
                            "doc": "처음 나타나는 항목을 제거할 값입니다.",
                            "names": "값"
                        }
                    ]
                },
                "sansAll": {
                    "doc": [
                        "나, 그러나 주어진 값이 전혀 발생하지 않습니다.",
                        "\\['사과' '바나나' '망고' '사과'].sans('사과')\\"
                    ],
                    "names": ["모두없이", "sansAll"],
                    "inputs": [
                        {
                            "doc": "목록에서 모든 항목을 제거할 값입니다.",
                            "names": "값"
                        }
                    ]
                },
                "reverse": {
                    "doc": [
                        "나야, 하지만 반대야!",
                        "\\['사과' '바나나' '망고'].reverse()\\"
                    ],
                    "names": ["반대로", "뒤집다"],
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "\\⊤\\ 내 품목과 순서가 주어진 @List와 정확히 일치한 경우.",
                        "\\['사과' '바나나' '망고'] = ['사과' '망고' '바나나']\\"
                    ],
                    "names": ["=", "일치하다"],
                    "inputs": [
                        {
                            "doc": "저를 비교할 @List입니다.",
                            "names": "목록"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "\\⊤\\ 내 품목과 순서가 주어진 @List와 정확히 일치하지 /않는/ 경우.",
                        "\\['사과' '바나나' '망고'] ≠ ['사과' '망고' '바나나']\\"
                    ],
                    "names": ["≠", "일치하지않다"],
                    "inputs": [
                        {
                            "doc": "나를 비교할 @List입니다.",
                            "names": "목록"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "값과 선택적 인덱스를 입력으로 사용하여 값을 생성하는 @FunctionDefinition을 제공하면 각 항목에 대해 이를 평가하여 값을 새 값으로 변환합니다.",
                        "예를 들어, 내가 @Number의 목록이고 이를 모두 두 배로 늘리고 싶다고 가정해 보겠습니다.",
                        "\\[2 4 6 8].translate(f(num•#) num · 2)\\"
                    ],
                    "names": "번역하다",
                    "inputs": [
                        {
                            "doc": "각 항목을 번역할 @FunctionDefinition입니다.",
                            "names": "번역가"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "번역 중인 항목입니다.",
                            "names": "항목"
                        },
                        {
                            "doc": "번역 중인 항목의 색인입니다.",
                            "names": "색인"
                        },
                        {
                            "doc": "번역 중인 목록입니다.",
                            "names": "목록"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "값과 선택적 인덱스를 입력으로 사용하고 @Boolean을 생성하는 @FunctionDefinition을 제공하면 \\⊤\\ 결과 항목만 포함하는 새 목록을 생성하겠습니다.",
                        "예를 들어, 내가 @Number의 목록이고 긍정적인 것만 원한다고 가정해 보세요.",
                        "\\[2 -4 8 -16].filter(f(num•#) num ≥ 0)\\"
                    ],
                    "names": "필터",
                    "inputs": [
                        {
                            "doc": "각 항목을 확인하여 보관해야 하는 경우 \\⊤\\를 생성하는 @FunctionDefinition입니다.",
                            "names": "체커"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "점검 중인 항목입니다.",
                            "names": "안건"
                        },
                        {
                            "doc": "검사 중인 항목의 인덱스입니다.",
                            "names": "색인"
                        },
                        {
                            "doc": "필터링되는 목록입니다.",
                            "names": "목록"
                        }
                    ]
                },
                "all": {
                    "doc": [
                        "값을 입력으로 사용하고 어떤 조건과 일치하면 @Boolean을 생성하는 @FunctionDefinition을 제공하세요. 모든 항목이 조건에 일치하면 \\⊤\\를 생성하겠습니다.",
                        "예를 들어, 내가 @Number의 목록이고 모든 것이 양수인지 알고 싶다고 가정해 보겠습니다.",
                        "\\[2 -4 8 -16].all(f(num•#) num ≥ 0)\\"
                    ],
                    "names": "모두",
                    "inputs": [
                        {
                            "doc": "항목이 조건을 충족하는 경우 \\⊤\\를 생성하는 @FunctionDefinition입니다.",
                            "names": "체커"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "점검 중인 항목입니다.",
                            "names": "안건"
                        },
                        {
                            "doc": "검사 중인 항목의 인덱스입니다.",
                            "names": "색인"
                        },
                        {
                            "doc": "확인 중인 목록입니다.",
                            "names": "목록"
                        }
                    ]
                },
                "until": {
                    "doc": [
                        "값을 입력으로 사용하고 어떤 조건과 일치하면 @Boolean을 생성하는 @FunctionDefinition을 제공하세요. 조건이 충족되지 않을 때까지 모든 항목을 포함하는 새 @List를 만들겠습니다.",
                        "예를 들어, 내가 @Text 동물 목록이고 \\'rat'\\이 발견될 때까지 모든 것을 원한다고 가정해 보겠습니다.",
                        "\\['cat' 'dog' 'rat' 'mouse' 'pony'].until(f(animal•'') 동물 = 'rat')\\"
                    ],
                    "names": "까지",
                    "inputs": [
                        {
                            "doc": "항목 포함을 중지해야 하는 경우 \\⊤\\를 생성하는 @FunctionDefinition입니다.",
                            "names": "체커"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "점검 중인 항목입니다.",
                            "names": "안건"
                        },
                        {
                            "doc": "검사 중인 항목의 인덱스입니다.",
                            "names": "색인"
                        },
                        {
                            "doc": "목록이 후속됩니다.",
                            "names": "목록"
                        }
                    ]
                },
                "find": {
                    "doc": [
                        "값을 입력으로 사용하고 일부 기준과 일치하는 경우 @Boolean을 생성하는 @FunctionDefinition을 제공하면 일치하는 항목을 평가하겠습니다.",
                        "예를 들어, 모음 \\'e'\\를 가진 첫 번째 동물을 찾고 싶다고 가정해 보겠습니다.",
                        "\\['고양이' '개' '쥐' '마우스' '조랑말'].find(f(animal•'')animal.has('e'))\\"
                    ],
                    "names": "찾다",
                    "inputs": [
                        {
                            "doc": "검색 기준과 일치하는 경우 \\⊤\\를 생성하는 @FunctionDefinition입니다.",
                            "names": "체커"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "검사 중인 항목입니다.",
                            "names": "항목"
                        },
                        {
                            "doc": "검사 중인 항목의 인덱스입니다.",
                            "names": "인덱스"
                        },
                        {
                            "doc": "검색 중인 목록입니다.",
                            "names": "목록"
                        }
                    ]
                },
                "combine": {
                    "doc": [
                        "가장 최근의 조합과 다음 값을 가져와 다음 조합을 생성하는 @FunctionDefinition을 제공하면 내 항목의 첫 번째 항목에서 마지막 항목으로 이동하여 연속 조합을 생성하고 @FunctionDefinition이 평가하는 최종 조합을 평가합니다.",
                        "이는 내 안의 모든 항목을 하나의 값으로 결합하는 데 정말 도움이 됩니다. 예를 들어 숫자 목록을 추가한다고 가정해 보겠습니다.",
                        "\\[3 9 2 8 1 4].combine(0 f(합계•# 숫자•#) 합계 + 숫자)\\"
                    ],
                    "names": "결합하다",
                    "inputs": [
                        {
                            "doc": "시작 조합입니다.",
                            "names": "초기의"
                        },
                        {
                            "doc": "최신 조합과 다음 값을 가져와 다음 조합을 생성하는 @FunctionDefinition입니다.",
                            "names": "결합기"
                        }
                    ],
                    "combiner": [
                        {
                            "doc": "현재 조합",
                            "names": "조합"
                        },
                        {
                            "doc": "다음으로 결합할 항목입니다.",
                            "names": "다음"
                        },
                        {
                            "doc": "다음 항목의 인덱스",
                            "names": "인덱스"
                        },
                        {
                            "doc": "결합되는 목록입니다.",
                            "names": "목록"
                        }
                    ]
                },
                "sorted": {
                    "doc": [
                        "나는 목록을 가져와 해당 값을 정렬하여 새로운 목록을 만들 수 있어. 예를 들면 이렇게:",
                        "\\[1 5 8 0 2].sorted()\\",
                        "@Text 값에 대해서도 할 수 있습니다",
                        "\\['오렌지' '키위' '바나나' '사과'].sorted()\\",
                        "@Number 또는 @Text가 아닌 값 목록이 있는 경우 각 항목을 @Number로 변환하는 @FunctionDefinition을 제공하여 정렬할 수 있습니다. 예를 들어, 여기에는 다양한 길이의 목록이 있습니다. 각 목록을 길이로 변환하는 함수를 제공하면 길이별로 정렬할 수 있습니다.",
                        "\\[[1] [2 3] [4 8 12] [8]].sorted(f(list) list.length())\\"
                    ],
                    "names": "정렬됨",
                    "inputs": [
                        {
                            "doc": "목록 값을 정렬하는 데 사용할 수 있는 선택적 @FunctionDefinition. 이 함수는 값을 @Number로 변환하여 정렬할 수 있도록 해야 해.",
                            "names": "시퀀서"
                        }
                    ],
                    "sequencer": [
                        {
                            "doc": "@Number로 변환할 값입니다.",
                            "names": "값"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "목록의 @Text 형태로 변환합니다.",
                "set": "목록을 @Set으로 변환하여 중복 항목을 제거하는 데 유용합니다."
            }
        },
        "Set": {
            "doc": [
                "나는 값들의 집합이야! 즉 아무 값도 없을 수도 있고, 여러 개의 값을 가질 수도 있어. 나를 이렇게 만들 수 있어:",
                "\\{1 2 3}\\",
                "나는 중복 없이 모음을 유지하고 싶을 때 정말 유용해.",
                "즉, 내가 이미 가지고 있는 값을 또 주면, 나는 추가 항목을 무시해.",
                "예를 들어, 이 집합에는 중복된 값들이 많아:",
                "\\{1 1 2 2 3 3}\\",
                "나는 이를 \\{1 2 3}\\ 로 정리해.",
                "내가 특정 값을 가지고 있는지 확인하고 싶다면 @SetOrMapAccess를 사용하면 돼:",
                "\\{'병' '물병' '유리'}{'컵'}\\",
                "보통 같은 유형의 값들을 주면, 나는 그것이 해당 유형의 목록이라고 생각해. 예를 들어, 이 집합은 모두 @Text이기 때문에 \\{''}\\ 처럼 보여.",
                "\\{'안녕' '안녕' '헬로우'}\\",
                "하지만 내가 /오직/ 특정 값들만 포함하는 집합이라는 걸 명확히 하고 싶다면, 나의 끝에 !를 붙이면 돼. 이렇게 하면 허용되지 않는 값을 사용할 때 경고할 수 있어.",
                "\\{'안녕' '안녕' '헬로우'}!{'요'}\\",
                "나를 더 활용하고 싶어? 내가 가진 다양한 @FunctionDefinition을 확인해 봐!"
            ],
            "name": ["{}", "세트"],
            "kind": "친절한",
            "out": "결과",
            "function": {
                "size": {
                    "doc": "내 안에 얼마나 많은 가치가 있는지 말씀드리겠습니다.",
                    "names": "크기",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "주어진 @Set과 정확히 동일한 값을 갖는 경우 나는 \\⊤\\입니다.",
                        "\\{1 2 3} = {2 3 4}\\"
                    ],
                    "names": ["=", "동일하다"],
                    "inputs": [
                        {
                            "doc": "비교할 @Set입니다.",
                            "names": "세트"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "주어진 @Set에 정확히 동일한 값이 없으면 나는 \\⊤\\입니다.",
                        "\\{1 2 3} ≠ {2 3 4}\\"
                    ],
                    "names": ["≠", "동일하지않다"],
                    "inputs": [
                        {
                            "doc": "비교할 @Set입니다.",
                            "names": "세트"
                        }
                    ]
                },
                "add": {
                    "doc": [
                        "추가할 항목을 주면 내 항목과 주어진 항목으로 새 @Set을 만들겠습니다.",
                        "\\{1 2 3} + 4\\"
                    ],
                    "names": ["add", "+"],
                    "inputs": [
                        {
                            "doc": "추가할 항목",
                            "names": "항목"
                        }
                    ]
                },
                "remove": {
                    "doc": [
                        "제거할 항목을 주시면 해당 항목 없이 새 @Set을 만들어 드리겠습니다.",
                        "\\{1 2 3} - 2\\",
                        "항목이 없으면 그냥 제가 평가하겠습니다."
                    ],
                    "names": ["remove", "-"],
                    "inputs": [
                        {
                            "doc": "제거할 항목입니다.",
                            "names": "항목"
                        }
                    ]
                },
                "union": {
                    "doc": [
                        "나에게 다른 @Set을 주면, 내 항목과 그 집합의 항목을 모두 포함하는 새로운 @Set을 만들어 드립니다.",
                        "\\{1 2 3} ∪ {3 4 5}\\"
                    ],
                    "names": ["union", "∪"],
                    "inputs": [
                        {
                            "doc": "나와 비교할 @Set입니다.",
                            "names": "세트"
                        }
                    ]
                },
                "intersection": {
                    "doc": [
                        "나에게 다른 @Set을 주면, 우리 둘 다 공통적으로 가지고 있는 항목들만 모아 새로운 @Set을 만들어 드립니다.",
                        "\\{1 2 3} ∩ {3 4 5}\\"
                    ],
                    "names": ["intersection", "∩"],
                    "inputs": [
                        {
                            "doc": "나와 비교할 세트입니다.",
                            "names": "세트"
                        }
                    ]
                },
                "difference": {
                    "doc": [
                        "@Set을 주면 우리가 공통으로 가지고 있는 항목만 포함된 항목이 있는 새 @Set을 만들겠습니다.",
                        "\\{1 2 3}.차이({3 4 5})\\"
                    ],
                    "names": "차이점",
                    "inputs": [
                        {
                            "doc": "나에게서 아이템을 제거해야 하는 세트입니다.",
                            "names": "세트"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "항목을 가져와 보관해야 하는 경우 \\⊤\\를 생성하는 @FunctionDefinition을 주시면 기준에 맞는 항목만 포함하는 @Set을 만들어 드리겠습니다.",
                        "예를 들어, 내 안의 홀수를 찾아봅시다:",
                        "\\{1 2 3 4 5 6 7 8 9}.filter(f(num•#) (num % 2) = 1)\\"
                    ],
                    "names": "filter",
                    "inputs": [
                        {
                            "doc": "항목을 유지해야 하는지 확인하기 위해 항목을 검사하는 @FunctionDefinition입니다.",
                            "names": "체커"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "점검 중인 항목입니다.",
                            "names": "값"
                        },
                        {
                            "doc": "필터링되는 세트",
                            "names": "세트"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "$~항목을 가져와 이를 기반으로 새 항목을 생성하는 @FunctionDefinition 을 제공하면 내 모든 항목을 새 @Set (중복 항목 제거)로 변환합니다.",
                        "$~예를 들어, 내 모든 @Number @Text 로 만들어 보겠습니다.",
                        "$~\\{1 2 3 4 5 6 7 8 9}.translate(f(num•#) num→'')\\"
                    ],
                    "names": "translate",
                    "inputs": [
                        {
                            "doc": "$~내 항목 중 하나를 원하는 새 항목으로 변환하는 @FunctionDefinition 입니다.",
                            "names": "$~세트"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "$~번역 중인 항목입니다.",
                            "names": "$~값"
                        },
                        {
                            "doc": "$~번역 중인 세트",
                            "names": "$~세트"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~@Set 의 @Text 표현",
                "list": "$~세트에 있는 항목의 @List 표현입니다."
            }
        },
        "Map": {
            "doc": [
                "$~*키*를 *값*에 매핑하여 값을 하나로 모았습니다. 예를 들어:",
                "$~\\{'에이미': 6포인트 '토니':3포인트 '시엘라': 8포인트}\\",
                "$~내 키는 모든 종류의 값이 될 수 있고 내 값은 모든 종류의 값이 될 수 있습니다.",
                "$~어떤 사람들은 나를 당신이 나에게 무언가를 주면 내가 당신에게 매핑된 것을 제공하는 색인이나 사전처럼 생각하기를 좋아합니다.",
                "$~매핑된 항목을 확인하려면 @SetOrMapAccess 키를 제공하면 값이 제공됩니다.",
                "$~\\{'에이미': 6포인트 '토니':3포인트 'shiela': 8포인트}{'에이미'}\\",
                "$~일치하는 키가 없으면 @None 을 제공합니다.",
                "$~\\{'에이미': 6포인트 '토니':3포인트 'shiela': 8포인트}{'jen'}\\",
                "$~다음과 같이 빈 맵을 만들 수도 있습니다.",
                "$~\\{:}\\",
                "$~일반적으로 저는 여러분이 제공하는 키와 값의 종류를 확인하고 이를 모두 나타내는 유형을 생각해냅니다. 다음은 숫자에서 숫자로의 지도입니다.",
                "$~\\{1:1 2:2 3:3}\\",
                "$~하지만 구체적으로 해당 값만 확인하고 싶다고 가정해 보겠습니다. 그냥 추가하세요! 결국에는 일반화하지 않겠습니다. 이는 의도하지 않은 값을 얻으려고 하는지를 아는 데 도움이 됩니다.",
                "$~\\{1:1 2:2 3:3}!{4}\\",
                "$~나는 내 페어링으로 많은 멋진 일을 하는 방법을 알고 있습니다."
            ],
            "name": ["$~{:}", "$~지도"],
            "key": "$~열쇠",
            "value": "$~값",
            "result": "$~결과",
            "function": {
                "size": {
                    "doc": "$~내 안에 얼마나 많은 가치가 있는지 말씀드리겠습니다.",
                    "names": "$~크기",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "$~\\{⊤}\\ 내 쌍이 주어진 @Map 과 정확히 동일한 경우.",
                        "$~\\{1:1 2:2} = {1:1 2:3}\\"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "$~나를 비교할 @Map 입니다.",
                            "names": "$~값"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "$~\\{⊤}\\ 내 쌍이 주어진 @Map 과 정확히 동일 /아님/인 경우.",
                        "$~\\{1:1 2:2} ≠ {1:1 2:3}\\"
                    ],
                    "names": ["$~≠", "$~동일하다"],
                    "inputs": [
                        {
                            "doc": "$~나를 비교할 @Map 입니다.",
                            "names": "$~값"
                        }
                    ]
                },
                "set": {
                    "doc": [
                        "$~나는 모두 동일한 페어링을 사용하여 새로운 @Map 을 만들 것이지만 귀하가 제공한 새로운 페어링을 사용합니다. 키가 이미 있는 경우 새 값과 페어링하겠습니다.",
                        "$~\\{'에이미': 6포인트 '토니':3포인트}.pair('젠' 0포인트)\\"
                    ],
                    "names": "$~쌍",
                    "inputs": [
                        {
                            "doc": "$~값과 쌍을 이루는 키입니다.",
                            "names": "$~열쇠"
                        },
                        {
                            "doc": "$~키와 쌍을 이루는 값",
                            "names": "$~값"
                        }
                    ]
                },
                "unset": {
                    "doc": [
                        "$~당신이 나에게 준 키 없이 새로운 @Map 을 만들어서 페어링을 제거하겠습니다.",
                        "$~\\{'에이미': 6포인트 '토니':3포인트}.unpair('에이미')\\"
                    ],
                    "names": "$~페어링해제",
                    "inputs": [
                        {
                            "doc": "$~잊는 열쇠.",
                            "names": "$~열쇠"
                        }
                    ]
                },
                "remove": {
                    "doc": [
                        "$~값이 있는 키 없이 새 @Map 을 생성하겠습니다.",
                        "$~\\{'에이미': 0포인트 '젠': 0포인트 '토니':3포인트}.remove(0포인트)\\"
                    ],
                    "names": "$~제거하다",
                    "inputs": [
                        {
                            "doc": "$~제거할 값과 페어링된 키입니다.",
                            "names": "$~값"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "$~키와 값을 가져와서 페어링을 유지해야 하는 경우 \\⊤\\로 평가하는 @FunctionDefinition 을 제공하세요. 귀하의 기준에 맞는 새로운 @Map 을 만들어 드리겠습니다.",
                        "$~예를 들어 여기서는 Amy이거나 포인트가 0보다 많은 페어링을 유지하려고 합니다.",
                        "$~\\{'amy': 0포인트 'jen': 0포인트 'tony':3포인트}.filter(f(key•'' value•#points) (key = 'amy') | (값 > 0포인트))\\"
                    ],
                    "names": "filter",
                    "inputs": [
                        {
                            "doc": "$~페어링을 유지할지 여부를 결정하는 @FunctionDefinition 입니다.",
                            "names": "$~체커"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "$~검사 중인 키입니다.",
                            "names": "$~열쇠"
                        },
                        {
                            "doc": "$~확인 중인 값입니다.",
                            "names": "$~값"
                        },
                        {
                            "doc": "$~필터링 중인 지도입니다.",
                            "names": "$~지도"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "$~키와 값을 가져와 해당 값을 새 값으로 평가하는 @FunctionDefinition 을 제공하세요. 동일한 키를 사용하지만 값이 업데이트된 새 @Map 을 만들겠습니다.",
                        "$~예를 들어, 너무 친절했기 때문에 모두에게 1점을 주자.",
                        "$~\\{'amy': 5포인트 'jen': 3포인트 'tony': 0포인트}.translate(f(key•'' value•#points) value + 1points)\\"
                    ],
                    "names": "translate",
                    "inputs": [
                        {
                            "doc": "$~각 값을 변환하는 @FunctionDefinition 입니다.",
                            "names": "$~역자"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "$~변환되는 값의 키입니다.",
                            "names": "$~열쇠"
                        },
                        {
                            "doc": "$~번역되는 값입니다.",
                            "names": "$~값"
                        },
                        {
                            "doc": "$~번역 중인 지도입니다.",
                            "names": "$~지도"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~매핑의 @Text 표현입니다.",
                "set": "$~@Map 의 키",
                "list": "$~@Map 의 값 목록"
            }
        },
        "Table": {
            "doc": [
                "$~나는 테이블 행 세트입니다! 동일한 구조를 가진 대규모 값 모음을 추적하는 데 도움을 드릴 수 있습니다.",
                "$~예를 들어, 여러 개의 암석을 추적하고 싶다고 가정해 보겠습니다.",
                "$~\\⎡이름•'' 색상•''⎦\n⎡'흑요석' '검은색'⎦\n⎡'부석' '회색'⎦\n⎡'황수정' '노란색'⎦\\",
                "$~@Bind 가 이름을 지정하는 데 도움이 될 수 있습니다! 그런 다음 새 행 @Insert 를 사용하여 수정된 테이블을 만드는 등의 작업을 수행할 수 있습니다.",
                "$~\\rocks: ⎡이름•'' 색상•''⎦\n⎡'흑요석' '검은색'⎦\n⎡'부석' '회색'⎦\n⎡'황수정' '노란색'⎦\n바위 ⎡+ '석영' '흰색'⎦\\",
                "$~또는 일치하는 행을 찾으려면 조건과 일치하는 @Select 행을 사용할 수 있습니다.",
                "$~\\rocks: ⎡이름•'' 색상•''⎦\n⎡'흑요석' '검은색'⎦\n⎡'부석' '회색'⎦\n⎡'황수정' '노란색'⎦\n바위 ⎡?⎦ 색상 = '회색'\\",
                "$~또는 조건과 일치하는 행에 대해 다른 값을 갖는 수정된 테이블을 만들고 싶을 수도 있습니다.",
                "$~\\rocks: ⎡이름•'' 색상•''⎦\n⎡'흑요석' '검은색'⎦\n⎡'부석' '회색'⎦\n⎡'황수정' '노란색'⎦\n바위 ⎡: 색상: '검은색' ⎦ 이름 = '부석'\\",
                "$~또는 조건과 일치하는 행을 삭제하고 싶을 수도 있습니다.",
                "$~\\rocks: ⎡이름•'' 색상•''⎦\n⎡'흑요석' '검은색'⎦\n⎡'부석' '회색'⎦\n⎡'황수정' '노란색'⎦\n바위 ⎡- name.has('i')\\",
                "$~그리고 나에게서 특정 값을 얻으려면 테이블을 목록으로 변환하고 @PropertyReference 를 사용하여 개별 행에 액세스할 수 있습니다.",
                "$~\\rocks: ⎡이름•'' 색상•''⎦\n⎡'흑요석' '검은색'⎦\n⎡'부석' '회색'⎦\n⎡'황수정' '노란색'⎦\n(바위 → [])[1].name\\"
            ],
            "name": ["$~⎡⎦", "$~테이블"],
            "row": "$~열",
            "function": {
                "equals": {
                    "doc": "$~다른 @Table 과 정확히 동일한 순서로 동일한 셀이 있는지 확인합니다.",
                    "names": ["$~=", "$~같음"],
                    "inputs": [
                        {
                            "doc": "$~확인할 다른 테이블입니다.",
                            "names": "$~값"
                        }
                    ]
                },
                "notequal": {
                    "doc": "$~내 셀이 다른 @Table 과 다르거나 순서가 다른지 확인합니다.",
                    "names": ["$~≠", "$~같지않음"],
                    "inputs": [
                        {
                            "doc": "$~확인할 다른 테이블.",
                            "names": "$~값"
                        }
                    ]
                }
            },
            "conversion": {
                "list": "$~@Table 을 행 목록으로 변환합니다. 여기서 각 행은 열 이름을 속성으로 사용하는 @Structure 입니다.",
                "text": "$~@Table 을 텍스트로 변환합니다."
            }
        },
        "Structure": {
            "doc": "$~@StructureDefinition 을 참조하세요.",
            "name": ["$~구조"],
            "function": {
                "equals": {
                    "doc": "$~내 속성이 다른 구조의 속성과 동일한 이름 및 값인지 확인합니다.",
                    "names": ["$~=", "$~같음"],
                    "inputs": [
                        {
                            "doc": "$~확인할 다른 구조입니다.",
                            "names": "$~값"
                        }
                    ]
                },
                "notequal": {
                    "doc": "$~내 속성이 다른 구조의 이름 및 값과 어떤 식으로든 다른지 확인합니다.",
                    "names": ["$~≠", "$~같지않음"],
                    "inputs": [
                        {
                            "doc": "$~확인할 다른 구조입니다.",
                            "names": "$~값"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "$~나는 @Text 로 변환합니다."
            }
        }
    },
    "input": {
        "Random": {
            "doc": [
                "$~17!",
                "$~/@FunctionDefinition 은 여기서 설명하겠습니다./",
                "$~따라서 @Random 은 난수를 생성하는 흥미로운 함수입니다. 평가할 때마다 뭔가 다른 것을 만들어내기 때문에 궁금합니다.",
                "$~이는 예측 불가능성과 함께 놀라운 혼란을 야기합니다.",
                "$~기본적으로 \\0\\과 \\1\\ 사이의 @Number 값을 제공합니다.",
                "$~\\무작위의()\\",
                "$~그러나 값을 지정할 수 있으며 \\0\\과 값 사이의 값이 생성됩니다.",
                "$~\\랜덤(10)\\",
                "$~그리고 두 개의 값을 제공하면 두 값 사이 및 두 값을 포함하는 값이 생성됩니다.",
                "$~\\랜덤(-10 10)\\",
                "$~범위에 단위가 있는 경우 해당 단위가 유지됩니다(일치하지 않으면 최소 단위가 사용됩니다).",
                "$~\\랜덤(-10m 10m)\\",
                "$~그리고 소수점 이하의 특정 유효 자릿수를 사용하여 숫자를 지정하면 해당 정밀도가 유지됩니다.",
                "$~\\랜덤(1.00 10.00)\\"
            ],
            "names": ["Azar"],
            "inputs": [
                {
                    "names": "$~분",
                    "doc": "$~생성될 최소값, 0보다 큰 경우 최대값입니다. @None 이 제공되면 최소값은 \\0\\입니다."
                },
                {
                    "names": "$~최대",
                    "doc": "$~생성될 최대값 또는 제공된 최소값보다 작은 경우 최소값입니다. @None 이 제공되면 최대값은 \\1\\입니다."
                }
            ]
        },
        "Choice": {
            "doc": [
                "$~/클릭탭!/",
                "$~/@FunctionDefinition 은 여기서 설명하겠습니다./",
                "$~@Choice 를 청중이 선택한 @Phrase/name 스트림처럼 생각하십시오. 누군가가 이름이 있는 @Phrase 에서 /Enter/를 눌러 클릭하거나 탭하거나 키보드를 선택하면 @Choice 는 이름과 일치하는 새 값을 갖게 됩니다.",
                "$~따라서 이를 사용하는 가장 좋은 방법은 선택 가능한 문구 @Phrase 를 사용하여 연주를 생성한 다음 @Reaction 을 사용하여 해당 이름이 선택되면 수행할 작업을 결정하는 것입니다.",
                "$~가장 간단한 예는 다음과 같습니다.",
                "$~\\그룹(\n스택() \n[\nPhrase('하나' 선택 가능:⊤ 이름:'1') \nPhrase('two' 선택 가능:⊤ 이름:'2') \n문구(선택())\n]\n)\\",
                "$~이것을 편집기에 복사한 다음 두 개의 @Phrase 중 하나를 선택하십시오. 세 번째 @Phrase 에 선택한 이름이 표시됩니다."
            ],
            "names": ["Selección", "Elección"]
        },
        "Button": {
            "doc": [
                "$~/클릭클릭클릭/",
                "$~/@FunctionDefinition 은 여기서 설명하겠습니다./",
                "$~@Button 은 마우스나 트랙패드의 소리를 들을 수 있는 좋은 방법입니다. 물론 마우스나 트랙패드는 청중의 말을 듣는 데 이상적인 선택이 아닙니다. 모든 사람이 사용할 수 있는 것은 아니기 때문입니다. 더 접근하기 쉬운 선택은 @Choice 입니다.",
                "$~하지만 /정말로/ 마우스 버튼 소리를 들어야 하는 경우에는 이 방법을 사용하세요. 기본 버튼이 위로 \\⊥\\ 또는 아래로 \\⊤\\ 있는지 여부를 나타내는 @Boolean 스트림을 제공합니다.",
                "$~간단한 예는 다음과 같습니다.",
                "$~\\Phrase(버튼() → '')\\",
                "$~이는 스트림의 값인 @Phrase 를 텍스트로 만듭니다. 편집기에 복사하고 클릭하면 \\⊥\\와 \\⊤\\ 사이에서 앞뒤로 전환되는 것을 볼 수 있습니다."
            ],
            "names": ["Botón"],
            "down": {
                "names": "$~아래에",
                "doc": "$~@None 인 경우 스트림은 up 및 down 값을 모두 제공합니다. @Boolean 인 경우 지정된 @Boolean 값만 제공합니다."
            }
        },
        "Pointer": {
            "doc": [
                "$~/whrrrrrr/",
                "$~/@FunctionDefinition 은 여기서 설명하겠습니다./",
                "$~마우스, 트랙패드, 터치 스크린에 대해 알고 계시나요? 때때로 청중이 어디를 가리키는지 알고 싶을 때가 있습니다. 이것이 @Pointer 가 제공하는 것입니다.",
                "$~물론 이것은 접근 가능한 선택이 아닙니다. 모든 사람이 보거나 쉽게 가리킬 수는 없으므로 이 스트림을 사용하여 참여에서 누군가를 제외하지 않도록 하십시오.",
                "$~제외된 사람이 없다고 확신한다면 @Pointer 를 사용하는 것은 스트림을 만드는 것만큼 간단합니다.",
                "$~\\바늘()\\",
                "$~제공되는 @Place 는 @Stage 에서 포인터가 가리키는 위치에 해당합니다."
            ],
            "names": ["Puntero"]
        },
        "Key": {
            "doc": [
                "$~/클릭수/",
                "$~/@FunctionDefinition 은 여기서 설명하겠습니다./",
                "$~키보드에는 많은 키가 있습니다. 그렇죠? @Key 는 누군가가 어느 키를 누르고 놓았는지 알려줍니다.",
                "$~이 시도",
                "$~\\열쇠()\\",
                "$~키를 입력하면 @Stage 에 어떻게 표시되는지 확인하세요. 키를 누를 때마다 누른 키를 설명하는 새로운 @Text 가 스트림에 추가됩니다.",
                "$~문자를 나타내는 키의 경우 값은 @Text 와 같은 문자가 됩니다.",
                "$~/Escape/ 키와 같은 특수 키의 경우 <미리 정의된 이름@https://developer.mozilla.org/en-US/docs/Web/API/UI_Events를 사용하여 키를 설명하는 @Text 입니다. /Keyboard_event_key_values>는 안타깝게도 영어로만 제공됩니다.",
                "$~특정 키에 대해서만 알고 싶다면 이를 제공할 수 있습니다.",
                "$~\\키('a')\\",
                "$~@Key 를 누르는 대신 놓는 시기만 알고 싶다면 @Boolean 을 제공할 수 있습니다.",
                "$~\\키('a' ⊥)\\"
            ],
            "names": ["Teclado"],
            "key": {
                "names": "$~열쇠",
                "doc": "$~@None 인 경우 모든 키가 제공됩니다. 특정 @Text 인 경우 해당 키만 제공됩니다."
            },
            "down": {
                "names": "$~아래에",
                "doc": "$~@None 인 경우 키를 누르면 입력이 생성됩니다. \\⊤\\이면 다운 입력만 제공되고, \\⊥\\이면 릴리스 입력만 제공됩니다."
            }
        },
        "Time": {
            "doc": [
                "$~/틱 틱 틱/",
                "$~@FunctionDefinition 여기서는 @Time/frequency 말을 하지 않으므로 설명하겠습니다.",
                "$~시간은 특정 빈도로 똑딱거리는 흐름입니다.",
                "$~그럴 때마다 @Program 은 새로운 시간 값으로 재평가합니다.",
                "$~예를 들어:",
                "$~\\시간()\\",
                "$~@Time/frequency 시간을 제공하면 해당 속도로 틱됩니다. 예를 들어:",
                "$~\\시간(1000ms)\\",
                "$~그러나 @Program 이 다음 틱에 응답하기 전에 평가할 시간이 필요하기 때문에 크기가 얼마나 작은지에 대한 제한이 있습니다.",
                "$~가장 작은 것은 아마도 \\20ms\\ 정도일 것입니다."
            ],
            "names": ["$~🕕", "$~시간"],
            "frequency": {
                "names": ["$~빈도"],
                "doc": "$~이것은 시간이 흘러야 하는 빈도입니다. 기본값은 \\33ms\\로, 초당 약 30회입니다."
            },
            "relative": {
                "names": ["$~상대적인"],
                "doc": "$~\\⊤\\인 경우 시간은 프로그램이 처음 평가되는 0부터 시작됩니다. 그렇지 않으면 오늘이 시작된 이후의 밀리초 수인 UTC(협정 세계시)에서 시작하여 하루 중 시간을 추적할 수 있습니다."
            }
        },
        "Volume": {
            "doc": [
                "$~/bzzzzzzz/",
                "$~@FunctionDefinition 은 제가 마이크를 맡겠습니다.",
                "$~이 스트림은 선택한 빈도로 샘플링된 0과 1 사이의 일련의 볼륨입니다. 기본적으로 빈도는 \\30hz\\, 즉 초당 30회이지만 덜 빈도로 변경할 수 있습니다.",
                "$~\\용량()\\",
                "$~청중의 목소리가 얼마나 큰지 듣기에 좋습니다!"
            ],
            "names": ["$~🎤", "$~용량"],
            "frequency": {
                "names": ["frecuencia"],
                "doc": "$~샘플링 사이의 시간입니다."
            }
        },
        "Pitch": {
            "doc": [
                "$~/흠흠흠/",
                "$~@FunctionDefinition 여기서 피치에 대해 이야기해 봅시다!",
                "$~이 스트림은 헤르츠 단위의 일련의 주파수로, 선택한 주파수로 샘플링된 사운드의 피치를 나타냅니다. 우리는 인간의 목소리가 20Hz에서 5000Hz 사이라는 것을 알았으므로 그 범위의 숫자를 계획하세요.",
                "$~\\정점()\\",
                "$~이것은 누군가가 말하거나 노래하는 톤을 듣는 데 좋습니다."
            ],
            "names": ["$~🎵", "$~정점"],
            "frequency": {
                "names": ["frecuencia"],
                "doc": "$~샘플링 사이의 시간입니다."
            }
        },
        "Camera": {
            "doc": [
                "$~/bzzzzzzz/",
                "$~@FunctionDefinition 은 여기서 @Camera 를 설명할 수 있습니다!",
                "$~따라서 @Camera 는 여러분의 세계에서 @Color 의 @List 제공합니다. 해당 목록은 기본적으로 이미지를 나타내지만 이를 어떻게 처리할지 결정하는 것은 사용자의 몫입니다.",
                "$~@Phrase 를 사용하여 이미지를 표현해 보면 꽤 멋져 보일 수 있습니다! 이것을 복사해 보세요...",
                "$~\\colors: 카메라(32px 24px 33ms)\n\n단계(\n색상.결합(\n[] \nf(문구•[문구] 행•[색상] y•#) \n문구.추가(\n행.번역(\n̅(색상•색상 x•#)\nPhrase('o' 장소: 장소((x - 1) · 0.5m y · -0.5m) 색상: 색상 지속 시간: 0s\n)\n)\n)\n)\n)\\",
                "$~그러나 색상을 분석하여 조명이 켜져 있는지 꺼져 있는지 또는 특정 색상이 일반적인지 판단하여 청중이 표시되는 색상으로 공연에 영향을 미칠 수도 있습니다."
            ],
            "names": ["Cámara"],
            "width": {
                "names": ["ancho"],
                "doc": "$~연속적으로 샘플링할 @Color 수입니다."
            },
            "height": {
                "names": ["altura"],
                "doc": "$~열에서 샘플링할 @Color 수입니다."
            },
            "frequency": {
                "names": ["frecuencia"],
                "doc": "$~@Color 샘플 사이의 시간입니다."
            }
        },
        "Motion": {
            "names": "movimiento",
            "doc": [
                "$~/보잉보잉보잉/",
                "$~/안녕! @FunctionDefinition 은 여기입니다. @Motion 을 설명하면 어떨까요?",
                "$~기본적으로 @Motion 은 @Phrase 의 스트림입니다. 시작 @Phrase 를 지정한 다음 중력을 기반으로 한 새로운 위치와 회전으로 다듬습니다.",
                "$~이렇게 하면 튀는 이모티콘 만들기와 같은 정말 간단한 작업을 수행할 수 있습니다.",
                "$~\\Motion(구문('o') 시작위치: 장소(0m 10m))\\",
                "$~o가 어떻게 튀는지 보시죠? 첫 번째 평가에서는 @Stage 의 높은 위치에 배치하지만 이후에는 @None 을 얻게 되어 @Motion 이 중력이 배치하는 위치로 변경할 수 있습니다.",
                "$~아래에서 구성하는 다른 다양한 방법을 확인하세요."
            ],
            "place": {
                "doc": "$~출발 장소.",
                "names": "$~장소"
            },
            "velocity": {
                "doc": "$~시작 속도",
                "names": "$~속도"
            },
            "nextplace": {
                "doc": "$~물리학을 뛰어넘는 다음 장소.",
                "names": "$~다음장소"
            },
            "nextvelocity": {
                "doc": "$~속도를 넘어서는 다음 장소.",
                "names": "$~다음속도"
            }
        },
        "Scene": {
            "doc": [
                "$~/뿡뿡뿡/",
                "$~/안녕하세요, @FunctionDefinition 입니다! @Scene 을 찾으셨군요.",
                "$~@Scene 이 특히 멋진 것 같아요. 기본 아이디어는 @Phrase 또는 @Group 목록을 제공한 다음 이를 순서대로 표시하고 마지막 항목에서 중지하는 것입니다.",
                "$~타이밍을 제어하려면 각 출력에 @Phrase/duration 을 설정하면 다음 출력으로 이동하기 전에 해당 출력이 오랫동안 표시되고 설정한 @Phrase/entering 또는 @Phrase/exiting 전환을 사용할 수 있습니다. . @Sequence 로 설정하면 해당 기간이 사용됩니다.",
                "$~이 모든 기능을 통해 다음 세 가지 문구를 순서대로 보여주는 작은 @Scene 과 같은 작업을 수행할 수 있습니다.",
                "$~\\장면([\n\tPhrase('안녕하세요' 지속 시간: 1초)\n\tPhrase('잘 지내세요?' 지속 시간: 2초 회전: 5° 입력: 포즈(회전: 0°))\n\t문구('나는 괜찮아')\n])\\",
                "$~첫 번째 출력이 1초 동안 표시되고 다음 출력이 2초 동안 표시되지만 5도 회전으로 애니메이션된 다음 마지막 출력이 표시되는 방식을 확인하세요.",
                "$~@Scene 을 사용하면 매우 정교한 출력 및 애니메이션 시퀀스를 만들 수 있으며 다른 @Phrase 또는 @Group 과 마찬가지로 일부를 동적으로 또는 대화형으로 만들 수도 있습니다.",
                "$~중첩된 애니메이션 출력(내부에 애니메이션 @Phrase 가 포함된 @Group )이 있는 경우 @Scene 은 @Group 의 모든 애니메이션 콘텐츠가 완료될 때까지 기다립니다.",
                "$~아, 그리고 마지막 작은 비밀 하나! 목록에 @Boolean 을 넣을 수도 있으며, \\⊥\\인 경우 @Scene 은 일시 중지하고 해당 내용이 true가 될 때까지 기다립니다.",
                "$~예를 들어, @Phrase 시퀀스를 만들고 @Button 이 변경될 때만 진행하려면 다음과 같이 할 수 있습니다.",
                "$~\\클릭: Δ 버튼()\n장면([\n\t문구('안녕하세요')\n\t딸깍 하는 소리\n\tPhrase('잘 지내세요?' 지속 시간: 0.25초 회전: 5° 입력: 포즈(회전: 0°))\n\t딸깍 하는 소리\n\t문구('나는 괜찮아')\n])\\",
                "$~각 @Phrase 후에 어떻게 일시 중지되고 진행하기 전에 @Button 이 변경될 때까지 기다리는지 확인하세요."
            ],
            "names": ["$~🎬", "$~장면"],
            "outputs": {
                "names": "$~출력",
                "doc": "$~순서대로 표시할 출력 목록입니다."
            }
        },
        "Chat": {
            "doc": [
                "$~/안녕! @FunctionDefinition 은 여기입니다. 그럼 채팅을 하시겠습니까?",
                "$~채팅 스트림의 기본 아이디어는 청중이 메시지를 입력하면 프로그램이 이에 응답한다는 것입니다.",
                "$~예를 들어, 이 간단한 프로그램은 메시지가 'hello'인지 확인하고, 그렇다면 프로그램은 'hi'로 평가합니다. 그렇지 않으면 '응'으로 평가되나요?",
                "$~\\Chat().has('안녕하세요') ? '안녕!' '뭐?'\\",
                "$~그게 다야! 이를 통해 채팅 봇, 텍스트 어드벤처 또는 다른 종류의 공연을 위한 텍스트 기반 제어 체계와 같은 모든 종류의 공연을 만들 수 있습니다."
            ],
            "names": ["$~🗣️", "$~채팅"]
        },
        "Placement": {
            "doc": [
                "$~/안녕하세요, @FunctionDefinition 입니다. 우리를 움직이게 하는 방법에 대해 이야기해보자!/",
                "$~따라서 @Stage 에 우리를 배치할 수 있는 방법은 많습니다. 명시적인 @Place 를 제공할 수 있습니다. @Motion 을 사용하여 중력이 작동하도록 할 수 있습니다. 또한 우리를 @Group 에 넣고 특정 방식으로 정렬하도록 할 수도 있습니다.",
                "$~하지만 때로는 @Stage 의 위치를 /audience/에게 제어할 수 있는 권한을 부여하고 싶을 때도 있습니다. 이것이 바로 @Placement 의 목적입니다.",
                "$~작동 방식은 다음과 같습니다. @Placement 를 만들어 @Place 에 제공하면 됩니다.",
                "$~\\Phrase('안녕하세요' 장소: Placement())\\",
                "$~그런 다음 청중이 화살표 키를 사용하거나 무대를 클릭하거나 탭할 때마다 @Placement 는 원하는 방향으로 이동하는 새로운 @Place 를 만듭니다.",
                "$~이것을 프로그램에 복사하고 포인터나 키보드로 화살표를 움직여 보십시오.",
                "$~@Placement 를 사용자 정의하여 특정 차원에서 이동을 활성화 및 비활성화하고 @Place 가 이동하는 거리와 스트림이 시작되는 초기 @Place 를 변경할 수 있습니다."
            ],
            "names": ["$~✥", "$~놓기"],
            "inputs": [
                {
                    "doc": "$~처음 시작하는 장소입니다.",
                    "names": "$~시작"
                },
                {
                    "doc": "$~관객이 이동을 요청하면 해당 장소는 몇 미터 이동해야 합니까?",
                    "names": "$~거리"
                },
                {
                    "doc": "$~true인 경우 가로 축으로의 이동을 허용합니다. 기본적으로 켜져 있습니다.",
                    "names": "$~수평의"
                },
                {
                    "doc": "$~true인 경우 수직 축의 이동을 허용합니다. 기본적으로 켜져 있습니다.",
                    "names": "$~수직의"
                },
                {
                    "doc": "$~true인 경우 + 및 - 키를 사용하여 z축 이동을 허용합니다.",
                    "names": "$~깊이"
                }
            ]
        },
        "Webpage": {
            "doc": [
                "$~/안녕하세요, @FunctionDefinition 입니다. 인터넷에서 웹페이지를 얻는 방법에 대해 이야기해 봅시다!/",
                "$~귀하의 인터넷에 대해 처음 들었을 때 우리는 그것이 매우 흥미롭다고 생각했습니다. 연결된 컴퓨터들이 서로 문서를 공유하는 온 세상이요? 그 놀라운!",
                "$~그래서 우리는 그것에 연결되는 스트림을 만들었습니다. 귀하가 우리에게 URL을 제공하면 우리는 그 URL의 모든 텍스트를 얻을 것입니다. 이와 같이:",
                "$~\\웹페이지('https://wordplay.dev')\\",
                "$~그리고 웹 페이지에서 쿼리하는 것을 좋아하는 <CSS@https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/What_is_CSS>라는 것이 있는 것 같습니다. CSS 선택 쿼리를 제공하면 해당 쿼리와 일치하는 텍스트만 얻을 수 있습니다. 레벨 1 헤더를 가져오는 이 예와 같습니다.",
                "$~\\웹페이지('https://wordplay.dev' 'h1')\\",
                "$~이것으로 많은 일이 잘못될 수 있습니다. 인터넷 연결이 끊어졌거나, URL이 아무 것도 확인되지 않거나, URL이 공개되지 않았거나, URL이 HTML 페이지가 아닌 경우… 이 모든 것이 예외로 이어질 수 있습니다. 작동하는 페이지를 찾으면 완료율을 나타내는 @Number 와 페이지에 있는 단어의 @List 얻게 됩니다."
            ],
            "names": ["$~🔗", "$~웹페이지"],
            "url": {
                "doc": "$~가져올 HTML 웹페이지 URL입니다.",
                "names": "$~URL"
            },
            "query": {
                "doc": "$~HTML에서 평가할 CSS 쿼리",
                "names": "$~질문"
            },
            "frequency": {
                "doc": "$~페이지를 다시 가져오기 전에 경과해야 하는 시간(분)입니다.",
                "names": "$~빈도"
            },
            "error": {
                "invalid": "$~유효한 URL이 아닙니다",
                "unvailable": "$~이 URL에 접근할 수 없습니다",
                "notHTML": "$~응답이 HTML이 아니었습니다",
                "noConnection": "$~워드플레이에 연결되지 않음",
                "limit": "$~이 도메인에 대한 요청이 너무 많습니다."
            }
        },
        "Collision": {
            "names": "$~충돌",
            "doc": [
                "$~/안녕하세요! @FunctionDefinition. 이 멋진 입력을 확인하세요./",
                "$~@Output 서로 부딪혔을 때 알아내는 데 도움이 될 수 있습니다! 이것은 @Output 할 수 있는 일반적인 튕김 외에도 우리가 서로 부딪혔을 때 무언가를 하는 좋은 방법입니다.",
                "$~@Output 이름만 주면 다른 이름에 부딪힐 때마다 새로운 @Rebound 값을 만들겠습니다. @Rebound 충돌한 이름과 충돌 방향에 대한 정보가 있습니다.",
                "$~그리고 만약 당신이 두 개의 이름을 준다면, 두 이름이 서로 충돌할 때만 새로운 값을 만들 것입니다.",
                "$~새로운 값을 만든 직후에 충돌이 일어난 후에 \\ø\\를 만들 것입니다. 이는 더 이상 충돌이 없다는 것을 나타냅니다."
            ],
            "subject": {
                "names": "$~주제",
                "doc": "$~충돌을 찾아야 하는 @Output 의 이름입니다."
            },
            "object": {
                "names": "$~다른",
                "doc": "$~충돌을 찾아야 하는 다른 @Output 의 이름입니다."
            }
        },
        "Rebound": {
            "names": "$~리바운드",
            "doc": "$~저는 @Collision 출신이고, 누가 충돌했는지, 어느 방향에서 충돌이 일어났는지 표현합니다. 일반적인 물리학이 아닌 특별한 방법으로 충돌에 반응할지 여부를 결정하려면 나를 사용하세요.",
            "direction": {
                "names": "$~방향",
                "doc": "$~충돌 대상을 기준으로 한 충돌 방향 및 크기"
            },
            "subject": {
                "names": "$~주제",
                "doc": "$~주제에 의해 적중된 출력의 이름입니다."
            },
            "object": {
                "names": "$~물체",
                "doc": "$~주제에 도달한 출력의 이름"
            }
        },
        "Direction": {
            "names": "$~방향",
            "doc": "$~나는 x와 y축을 따른 방향과 크기입니다.",
            "x": {
                "names": "$~엑스",
                "doc": "$~x축 방향의 방향과 크기입니다."
            },
            "y": {
                "names": "$~와이",
                "doc": "$~y축 방향의 방향과 크기입니다."
            }
        }
    },
    "output": {
        "Output": {
            "names": "$~산출",
            "doc": [
                "$~나는 실제로 만들 수 있는 @StructureDefinition 이 아닙니다. 하지만 나는 우리 댄스의 가장 중요한 요소인 @Phrase, @Group 및 @Stage 에 영감을 주기 때문에 매우 중요한 사람입니다.",
                "$~직접 만나서 사용 방법에 대해 자세히 알아보세요."
            ]
        },
        "Stage": {
            "names": ["$~🎭", "$~단계"],
            "doc": [
                "$~안녕. 여기에 무대를 마련하세요. 무엇을 보여줄지 알려주시면 보여드리겠습니다.",
                "$~\\Stage([구('stuffffff')])\\",
                "$~원하시면 배경 @Color 를 제공해 주시면 그에 맞춰 무대를 조명하겠습니다.",
                "$~\\Stage([Phrase('stuffffff')] 배경: 색상(75% 50 100°)\\",
                "$~나에게 프레임 테두리를 제공할 수도 있으며 나는 자릅니다.",
                "$~\\Stage([Phrase('stufffffff')] 배경: 색상(75% 50 100°) 프레임: 직사각형(-1m -1m 1m 1m))\\"
            ],
            "defaultDescription": "$~$2[$2|] 문구 중 $1[$1|] 문구 $3[$3 프레임|] $4",
            "content": {
                "doc": "$~스테이지에 표시할 @Output 목록입니다.",
                "names": "$~콘텐츠"
            },
            "frame": {
                "doc": "$~무대 주위에 배치하여 무대 밖의 모든 것을 숨길 수 있는 프레임의 모양과 크기입니다.",
                "names": "$~액자"
            },
            "size": {
                "doc": "$~@Group/size 좋아요",
                "names": "$~크기"
            },
            "face": {
                "doc": "$~@Group/face 좋아요",
                "names": "$~얼굴"
            },
            "place": {
                "doc": "$~내가 카메라라면 여기를 보고 있다",
                "names": "$~장소"
            },
            "name": {
                "doc": ["$~@Phrase/name 동일합니다!"],
                "names": "$~이름"
            },
            "description": {
                "doc": [
                    "$~시각적 출력을 볼 수 없는 청중을 위해 사용할 수 있는 설명입니다."
                ],
                "names": "$~설명"
            },
            "selectable": {
                "doc": "$~@Phrase/selectable 동일하며 선택 가능합니다!",
                "names": "$~선택가능"
            },
            "color": {
                "doc": "$~@Group/color 동일",
                "names": "$~색상"
            },
            "background": {
                "doc": "$~@Group/background 동일",
                "names": "$~배경"
            },
            "opacity": {
                "doc": "$~@Group/opacity 동일",
                "names": "$~불투명"
            },
            "offset": {
                "doc": "$~@Group/offset 동일",
                "names": "$~오프셋"
            },
            "rotation": {
                "doc": "$~@Group/rotation 동일",
                "names": ["$~📐", "$~회전"]
            },
            "scale": {
                "doc": "$~@Group/scale 동일",
                "names": "$~규모"
            },
            "flipx": {
                "doc": "$~@Group/flipx 동일",
                "names": "$~플립스"
            },
            "flipy": {
                "doc": "$~@Group/flipy 동일",
                "names": "$~플리피"
            },
            "entering": {
                "doc": "$~@Group/entering 동일",
                "names": "$~입력"
            },
            "resting": {
                "doc": "$~@Group/resting 같습니다!",
                "names": "$~쉬고있는"
            },
            "moving": {
                "doc": "$~@Group/moving 동일합니다!",
                "names": "$~움직이는"
            },
            "exiting": {
                "doc": "$~@Group/exiting 동일합니다!",
                "names": "$~종료"
            },
            "duration": {
                "doc": "$~@Phrase/duration 동일합니다!",
                "names": ["$~⏳", "$~지속"]
            },
            "style": {
                "doc": "$~@Phrase/style 동일합니다!",
                "names": "$~스타일"
            },
            "gravity": {
                "doc": "$~@Motion 위치하는 출력에 적용할 중력입니다.",
                "names": "$~중력"
            }
        },
        "Group": {
            "names": ["$~🔳", "$~그룹"],
            "doc": [
                "$~아, 안녕, 잘 지내? 나는 다른 사람들이 주변에 있을 때 항상 괜찮기 때문에 당신과 함께 있는 것이 좋습니다!",
                "$~@Stage 에서 @Phrase 와 @Group 을 함께 그룹화하고 @Arrangement 에 넣으므로 배치 위치에 순서가 있습니다.",
                "$~작업하려면 @Arrangement 를 제공한 다음 정렬할 @Output 의 @List 제공해야 합니다.",
                "$~예를 들어, 여기에는 @Stack 배열과 수직으로 쌓을 수 있는 몇 가지 @Phrase 가 있습니다.",
                "$~\\Group(Stack() [구('첫 번째') 구문('두 번째')])\\",
                "$~내가 정확히 어떻게 정리하는지는 귀하가 제공한 @Arrangement 에 따라 다릅니다."
            ],
            "defaultDescription": "$~$1[$1|] $2 $3",
            "content": {
                "doc": "$~정렬할 @Output 목록입니다.",
                "names": "$~콘텐츠"
            },
            "layout": {
                "doc": "$~@Output 을 해당 위치에 배치하는 데 사용되는 배열입니다.",
                "names": "$~공들여나열한것"
            },
            "matter": {
                "doc": "$~물질과 다른 것과 부딪히면 어떻게 반응해야 할까요?",
                "names": "$~문제"
            },
            "size": {
                "doc": "$~내 안에 있는 놀라운 콘텐츠는 자신만의 크기가 없다면 얼마나 커야 할까요!",
                "names": "$~크기"
            },
            "face": {
                "doc": "$~내 안에 있는 글꼴 이름은 자신의 얼굴을 사용하지 않는 이상 가지고 있어야 합니다.",
                "names": "$~얼굴"
            },
            "place": {
                "doc": "$~내가 있어야 할 무대 위의 장소. 내 안의 내용은 거기에 맞춰 정리될 것이다.",
                "names": "$~장소"
            },
            "name": {
                "doc": ["$~@Phrase/name 과 동일합니다!"],
                "names": "$~이름"
            },
            "description": {
                "doc": [
                    "$~시각적 출력을 볼 수 없는 청중을 위해 사용할 수 있는 설명입니다."
                ],
                "names": "$~설명"
            },
            "selectable": {
                "doc": "$~@Phrase/selectable 가능과 동일합니다!",
                "names": "$~선택가능"
            },
            "color": {
                "doc": "$~내 안에 있는 콘텐츠가 고유한 색상을 갖지 않는 한 @Color 여야 합니다.",
                "names": "$~색상"
            },
            "background": {
                "doc": "$~내 뒤에 투영할 @Color 입니다.",
                "names": "$~배경"
            },
            "opacity": {
                "doc": "$~다른 @Pose 에 의해 재정의되지 않는 한 내 안의 모든 것이 \\0\\과 \\1\\ 사이에서 얼마나 투명해야 합니까?",
                "names": "$~불투명"
            },
            "offset": {
                "doc": "$~다른 @Pose 로 재정의되지 않는 한 일반 @Place 와의 오프셋을 나타내는 @Place 입니다. 제자리에서 흔들리는 데 도움이 됩니다.",
                "names": "$~오프셋"
            },
            "rotation": {
                "doc": "$~내 중심을 중심으로 얼마나 기울어져야 하는지, 내 @Pose 에는 다른 것이 있습니다.",
                "names": ["$~📐", "$~회전"]
            },
            "scale": {
                "doc": "$~원래 크기에 비해 얼마나 커야 할까요?",
                "names": "$~규모"
            },
            "flipx": {
                "doc": "$~@Phrase/flipx 와 동일합니다!",
                "names": "$~플립스"
            },
            "flipy": {
                "doc": "$~@Phrase/flipy 와 동일",
                "names": "$~플리피"
            },
            "entering": {
                "doc": "$~@Phrase/entering 과 동일합니다!",
                "names": "$~입력"
            },
            "resting": {
                "doc": "$~@Phrase/resting 과 같습니다!",
                "names": "$~쉬고있는"
            },
            "moving": {
                "doc": "$~@Phrase/moving 과 동일합니다!",
                "names": "$~움직이는"
            },
            "exiting": {
                "doc": "$~@Phrase/exiting 동일합니다!",
                "names": "$~종료"
            },
            "duration": {
                "doc": "$~@Phrase/duration 과 동일합니다!",
                "names": ["duración"]
            },
            "style": {
                "doc": "$~@Phrase/style 과 동일합니다!",
                "names": "$~스타일"
            }
        },
        "Phrase": {
            "names": ["$~💬", "$~구절"],
            "doc": [
                "$~안녕 안녕! 날 기억해? 누가 /나/를 어떻게 잊을 수 있겠어요? 맞습니다. 저는 @Stage 에서 가장 사랑스러운 @Text 를 표현할 준비가 된 유능한 @Phrase 입니다.",
                "$~이렇게 만들어주시면 @Stage 에 나타나게 됩니다.",
                "$~\\Phrase('훌륭해요!')\\",
                "$~분명히 @Text 가 필요하지만 그렇지 않으면 크기, 글꼴, 회전 변경을 포함하여 @Output 이 할 수 있는 모든 작업을 수행할 수 있고 @Pose 및 @Sequence 를 사용하여 놀라운 춤을 모두 수행할 수 있습니다.",
                "$~@Stage 에서 나를 선택하고 옆에 있는 팔레트에서 나를 편집할 수도 있습니다."
            ],
            "defaultDescription": "$~$3[$3 미터 |]문구 $1 $2[이름이 $2|] $4[$4|] $5",
            "text": {
                "doc": "$~@Stage 에서 보여줄 캐릭터들입니다.",
                "names": "$~텍스트"
            },
            "size": {
                "doc": "$~내 키는 몇 미터여야 할까요?",
                "names": "$~크기"
            },
            "face": {
                "doc": "$~내가 붙여야 할 글꼴 이름.",
                "names": "$~얼굴"
            },
            "place": {
                "doc": "$~내가 있어야 할 무대 위의 장소.",
                "names": "$~장소"
            },
            "wrap": {
                "doc": "$~기호를 감싸야 하는 가장자리 또는 기호를 감싸지 말아야 하는 경우 \\ø\\입니다.",
                "names": ["$~↵", "$~포장하다"]
            },
            "alignment": {
                "doc": "$~@Phrase/wrap 경계가 설정된 경우 기호를 가장자리의 시작, 중앙 또는 끝에 정렬해야 하는지 여부입니다.",
                "names": "$~조정"
            },
            "direction": {
                "doc": "$~기호를 가로 또는 세로로 쓸지 여부, 세로 및 @Phrase/wrap 이 설정된 경우 텍스트 줄 바꿈을 왼쪽 또는 오른쪽으로 할지 여부입니다.",
                "names": "$~방향"
            },
            "matter": {
                "doc": "$~물건에 부딪혔을 때 사용하는 속성!",
                "names": "$~문제"
            },
            "aura": {
                "doc": "$~내 뒤에 표시할 선택적 @Aura 입니다. 나를 빛나게 해주세요!",
                "names": "$~영기"
            },
            "name": {
                "doc": [
                    "$~당신이 나에게 지어준 이름! 이것은 많은 것에 도움이 됩니다.",
                    "$~먼저 이름이 있으면 스크린 리더 설명에서 자신을 설명하는 데 이름을 사용하겠습니다.",
                    "$~둘째, 애니메이션을 적용할 때 무대에서 동일한 콘텐츠를 표현해야 하는 다양한 표현이 있을 수 있습니다. 동일한 이름을 지정하면 하나로 애니메이션됩니다.",
                    "$~마지막으로 @Choice 를 사용하면 도움이 됩니다. 귀하가 제공한 이름이 해당 스트림에 표시됩니다.",
                    "$~도움이 된다면 각각 다른 언어로 된 다양한 이름을 알려주실 수 있습니다. 항상 처음 선택한 로케일의 이름을 사용하겠습니다."
                ],
                "names": "$~이름"
            },
            "description": {
                "doc": [
                    "$~시각적 출력을 볼 수 없는 청중을 위해 사용할 수 있는 사용자 정의 설명입니다."
                ],
                "names": "$~설명"
            },
            "selectable": {
                "doc": "$~\\⊤\\인 경우 포인터나 키보드를 통해 선택할 수 있음을 나타냅니다.",
                "names": "$~선택가능"
            },
            "color": {
                "doc": "$~다른 @Pose 로 재정의되지 않는 한 @Color I는 기본적으로 설정되어야 합니다.",
                "names": "$~색상"
            },
            "background": {
                "doc": "$~내 뒤에 투영할 @Color 입니다.",
                "names": "$~배경"
            },
            "opacity": {
                "doc": "$~다른 @Pose 로 재정의되지 않는 한 기본적으로 \\0\\과 \\1\\ 사이에서 투명도를 유지해야 합니다. 페이드 인 및 페이드 아웃에 유용합니다.",
                "names": "$~불투명"
            },
            "offset": {
                "doc": "$~다른 @Pose 로 재정의되지 않는 한 내 @Place 와의 오프셋을 나타내는 @Place 입니다. 제자리에서 흔들리는 데 도움이 됩니다.",
                "names": "$~오프셋"
            },
            "rotation": {
                "doc": "$~다른 @Pose 에 의해 재정의되지 않는 한 I가 중심을 중심으로 회전해야 하는 각도입니다.",
                "names": "$~회전"
            },
            "scale": {
                "doc": "$~다른 @Pose 에 의해 재정의되지 않는 한 원래 크기에 비해 얼마나 확대되어야 합니까?",
                "names": "$~규모"
            },
            "flipx": {
                "doc": "$~다른 @Pose 로 재정의되지 않는 한 x축에서 미러링해야 하는지 여부입니다.",
                "names": "$~플립스"
            },
            "flipy": {
                "doc": "$~다른 @Pose 에 의해 재정의되지 않는 한 Y축에서 미러링되어야 하는지 여부입니다.",
                "names": "$~플리피"
            },
            "entering": {
                "doc": "$~무대에 들어서자마자 해야 할 @Pose @Sequence.",
                "names": "$~입력"
            },
            "resting": {
                "doc": "$~무대에 들어간 후, 나가기 전, 그리고 @Place 가 변경되지 않는 동안 수행해야 하는 @Pose 또는 @Sequence 입니다. 하나도 주지 않으면 그냥 기본값을 사용하겠습니다.",
                "names": "$~쉬고있는"
            },
            "moving": {
                "doc": "$~무대에서 장소를 이동할 때 기본 설정 대신에 수행해야 하는 @Pose 또는 @Sequence 입니다.",
                "names": "$~움직이는"
            },
            "exiting": {
                "doc": "$~@Pose 또는 @Sequence 는 스테이지를 종료하기 전에 수행해야 합니다.",
                "names": "$~종료"
            },
            "duration": {
                "doc": "$~스테이지 내 다른 장소로 이동할 때 적용되는 지속시간입니다.",
                "names": ["$~⏳", "$~지속"]
            },
            "style": {
                "doc": "$~무대 위의 다른 장소로 이동할 때 사용할 애니메이션 스타일입니다.",
                "names": "$~스타일"
            }
        },
        "Arrangement": {
            "names": ["Arrangement"],
            "doc": "$~나는 @Row, @Stack, @Grid 및 @Free 를 포함하여 Verse의 다른 많은 종류의 배열에 영감을 주었습니다. 저는 @Group 과 긴밀히 협력하여"
        },
        "Row": {
            "names": ["Fila"],
            "doc": "$~나는 @Output 의 수평 @Arrangement 인 @Row 이며, 그 사이에 선택적 패딩이 있습니다. 내 쌍둥이 @Stack 을 만나보셨나요?",
            "description": "$~$1개의 구문 및 그룹 행",
            "alignment": {
                "doc": "$~각 열의 시작, 중앙 또는 끝 부분에 텍스트를 정렬할지 여부입니다.",
                "names": "$~조정"
            },
            "padding": {
                "doc": "$~출력 사이에 배치할 패딩의 양입니다.",
                "names": "$~심"
            }
        },
        "Stack": {
            "names": ["$~⬇", "$~스택"],
            "doc": "$~나는 @Output 의 수직 @Arrangement 인 @Stack 이며 그 사이에 선택적 패딩이 있습니다. 내 쌍둥이 @Row 를 만나보셨나요?",
            "description": "$~1달러짜리 구문 및 그룹 스택",
            "padding": {
                "doc": "$~출력 사이에 배치할 패딩의 양입니다.",
                "names": "$~심"
            },
            "alignment": {
                "doc": "$~각 행의 시작, 중앙 또는 끝에서 텍스트를 정렬할지 여부입니다.",
                "names": "$~조정"
            }
        },
        "Grid": {
            "names": ["$~▦", "$~그리드"],
            "doc": "$~나는 @Output 의 그리드입니다. 행과 열 개수를 알려주시면 선택적으로 패딩과 셀 크기를 사용하여 깔끔하게 정리하겠습니다.",
            "description": "$~$1행 $2열 그리드",
            "rows": {
                "doc": "$~그리드에 몇 개의 행이 있는지.",
                "names": "$~행"
            },
            "columns": {
                "doc": "$~그리드에 만들 열 수입니다.",
                "names": "$~기둥"
            },
            "padding": {
                "doc": "$~셀 사이에 배치할 패딩의 양입니다.",
                "names": "$~심"
            },
            "cellWidth": {
                "doc": "$~셀의 너비는 얼마입니까?",
                "names": "$~셀너비"
            },
            "cellHeight": {
                "doc": "$~셀의 높이는 얼마나 되어야 합니까?",
                "names": "$~셀패딩"
            }
        },
        "Free": {
            "names": ["$~무료"],
            "doc": [
                "$~나는 마치, 뭐든지. 원하는 곳에 앉으세요. 그냥 아무데나 앉으세요! 당신이 나에게 제공한 모든 @Output 에 @Place 가 있는지 확인하십시오. 그렇지 않으면 어디로 가야할지 알 수 없습니다.",
                "$~아, 그리고 각 @Output 에 제공하는 @Place 는 @Group 의 @Place 에 상대적이라는 점을 기억하세요! 따라서 예상한 곳에 항목이 표시되지 않는 이유가 궁금하다면 @Group 에도 위치를 지정해 보세요."
            ],
            "description": "$~자유 형식 $1 출력"
        },
        "Shape": {
            "names": ["$~⬟", "$~모양"],
            "doc": "$~나는 모든 형태에 영감을 줍니다. @Stage 에서 어떤 모양이 될지 알려주는 데 유용합니다.",
            "form": {
                "doc": "$~나는 보여주고 싶은 체형이다. 각 모양에는 배열을 정의하기 위해 서로 다른 정보가 필요합니다.",
                "names": "$~형태"
            },
            "name": {
                "doc": "$~나는 애니메이션과 @Collision 에 사용할 수 있는 이름입니다. 예를 들어, a가 땅을 대표한다면 나를 'ground'라고 부르고 싶을 수도 있습니다.",
                "names": "$~이름"
            },
            "selectable": {
                "doc": "$~@Choice 의 일부로 선정될 수 있는지 여부.",
                "names": "$~선택가능"
            },
            "color": {
                "doc": "$~내 테두리의 색상입니다.",
                "names": "$~색상"
            },
            "background": {
                "doc": "$~내 배경의 색상입니다.",
                "names": "$~배경"
            },
            "opacity": {
                "doc": "$~나는 얼마나 투명해야 하는가.",
                "names": "$~불투명"
            },
            "offset": {
                "doc": "$~나는 제자리에 머물면서 내 자리에서 얼마나 멀리 나타나야 하는가.",
                "names": "$~오프셋"
            },
            "rotation": {
                "doc": "$~나는 얼마나 회전해야합니까? 이는 @Collision 에 영향을 미칩니다.",
                "names": "$~회전"
            },
            "scale": {
                "doc": "$~실제 크기를 변경하지 않고 얼마나 확대해야 합니까?",
                "names": "$~규모"
            },
            "flipx": {
                "doc": "$~내 x축에 나를 미러링할지 여부입니다.",
                "names": "$~플립스"
            },
            "flipy": {
                "doc": "$~내 y축에 나를 반영할지 여부입니다.",
                "names": "$~플리피"
            },
            "entering": {
                "doc": "$~@Stage 에 들어갈 때 해야 할 @Pose 나 @Sequence.",
                "names": "$~입력"
            },
            "resting": {
                "doc": "$~입장 후 움직이지 않는 동안 해야 할 @Pose 또는 @Sequence.",
                "names": "$~쉬고있는"
            },
            "moving": {
                "doc": "$~장소를 이동할 때 해야 할 @Pose 나 @Sequence.",
                "names": "$~움직이는"
            },
            "exiting": {
                "doc": "$~@Stage 를 떠날 때 해야 할 @Pose 또는 @Sequence.",
                "names": "$~종료"
            },
            "duration": {
                "doc": "$~단일 @Pose 인 경우 애니메이션에 소요되는 시간입니다.",
                "names": "$~지속"
            },
            "style": {
                "doc": "$~내가 사용해야 할 애니메이션 스타일.",
                "names": "$~스타일"
            },
            "description": {
                "doc": [
                    "$~시각적 출력을 볼 수 없는 청중을 위해 사용할 수 있는 설명입니다."
                ],
                "names": "$~설명"
            }
        },
        "Form": {
            "doc": "$~나는 @Rectangle 또는 @Circle 과 같은 추상 형식입니다.",
            "names": ["$~형태"]
        },
        "Rectangle": {
            "names": ["$~직사각형"],
            "doc": "$~나는 @Stage 가 선택한 크기의 경계를 갖도록 만드는 데 유용한 직사각형입니다.",
            "left": {
                "doc": "$~X축에서 스테이지의 왼쪽 가장자리",
                "names": "$~왼쪽"
            },
            "top": {
                "doc": "$~y축의 스테이지 상단 가장자리",
                "names": "$~맨위"
            },
            "right": {
                "doc": "$~X축에서 스테이지의 오른쪽 가장자리",
                "names": "$~오른쪽"
            },
            "bottom": {
                "doc": "$~y축에서 스테이지의 아래쪽 가장자리",
                "names": "$~맨아래"
            },
            "z": {
                "doc": "$~직사각형의 깊이 위치입니다.",
                "names": "$~지"
            }
        },
        "Circle": {
            "doc": "$~저는 @Stage 에서 모양을 만드는 데 유용한 원입니다.",
            "names": ["$~원"],
            "radius": {
                "doc": "$~원의 반경",
                "names": "$~반지름"
            },
            "x": {
                "doc": "$~원의 수평 중심입니다.",
                "names": "$~엑스"
            },
            "y": {
                "doc": "$~원의 수직 중심입니다.",
                "names": "$~와이"
            },
            "z": {
                "doc": "$~원의 깊이 위치입니다.",
                "names": "$~지"
            }
        },
        "Polygon": {
            "doc": "$~나는 @Stage 에서 모양을 만드는 데 유용한 동일한 길이의 변과 각도를 가진 '일반' 다각형입니다.",
            "names": ["$~다각형"],
            "radius": {
                "doc": "$~다각형의 반경",
                "names": "$~반지름"
            },
            "sides": {
                "doc": "$~다각형의 변의 수",
                "names": "$~측면"
            },
            "x": {
                "doc": "$~다각형의 수평 중심입니다.",
                "names": "$~엑스"
            },
            "y": {
                "doc": "$~다각형의 수직 중심입니다.",
                "names": "$~와이"
            },
            "z": {
                "doc": "$~다각형의 깊이 위치입니다.",
                "names": "$~지"
            }
        },
        "Pose": {
            "names": ["$~🤪", "$~포즈"],
            "doc": [
                "$~누군가가 가장 놀라운 자세로 서고 잠시 멈췄을 때 모두가 쳐다볼 때를 아시나요? 그게 나야. 나는 @Output 이 들어갈 포즈를 포착하고 그들의 움직임의 구성 요소가 됩니다.",
                "$~포즈에 너무 많은 것이 들어갑니다. 어떤 종류의 포즈를 취할 수 있는지 알아 보려면 내 많은 입력을 확인하세요!"
            ],
            "style": {
                "doc": "$~이 포즈로 이동할 때 사용할 애니메이션 스타일입니다.",
                "names": "$~스타일"
            },
            "color": {
                "doc": "$~@Color 및 @Output 은 기본값이 아닌 이 포즈에 있어야 합니다.",
                "names": "$~색상"
            },
            "opacity": {
                "doc": "$~기본값 대신 \\0\\과 \\1\\ 사이에서 @Output 이 얼마나 투명해야 하는지입니다. 페이드 인 및 페이드 아웃에 유용합니다.",
                "names": "$~불투명"
            },
            "offset": {
                "doc": "$~기본값 대신 @Output 위치로부터의 오프셋을 나타내는 @Place 입니다. 제자리에서 흔들리는 데 도움이 됩니다.",
                "names": "$~오프셋"
            },
            "rotation": {
                "doc": "$~기본값 대신 @Output 이 얼마나 회전되어야 하는지입니다.",
                "names": "$~회전"
            },
            "scale": {
                "doc": "$~@Output 이 기본값이 아닌 원래 크기를 기준으로 확대되어야 하는 정도입니다.",
                "names": "$~규모"
            },
            "flipx": {
                "doc": "$~@Output 을 기본값 대신 x축에 미러링할지 여부입니다.",
                "names": "$~플립스"
            },
            "flipy": {
                "doc": "$~@Output 이 기본값이 아닌 y축에 미러링되어야 하는지 여부입니다.",
                "names": "$~플리피"
            },
            "description": "$~$1[투명 $1|] $2[$2도 회전|] $3[크기 조정 $3|] $4[수평으로 뒤집음|] $5[수직으로 뒤집음|] $6[흐린 그림자 $6픽셀]"
        },
        "Color": {
            "names": ["$~색상"],
            "doc": [
                "$~나는 세 가지 필수 차원으로 구성된 눈에 보이는 색상입니다.",
                "$~중간 밝기와 높은 채도에서 색상환 주변의 몇 가지 일반적인 색상은 다음과 같습니다.",
                "$~\\색상(50% 100 0°)\\",
                "$~\\색상(50% 100 30°)\\",
                "$~\\색상(50% 100 60°)\\",
                "$~\\색상(50% 100 90°)\\",
                "$~\\색상(50% 100 120°)\\",
                "$~\\색상(50% 100 150°)\\",
                "$~\\색상(50% 100 180°)\\",
                "$~\\색상(50% 100 210°)\\",
                "$~\\색상(50% 100 240°)\\",
                "$~\\색상(50% 100 270°)\\",
                "$~\\색상(50% 100 300°)\\",
                "$~\\색상(50% 100 330°)\\"
            ],
            "lightness": {
                "doc": "$~\\0\\에서 \\1\\까지, 검은색에서 \\0\\, 회색에서 \\0.5\\, 흰색에서 \\1\\까지 얼마나 밝아야 할까요?",
                "names": ["$~가벼움", "$~엘"]
            },
            "chroma": {
                "doc": "$~\\0\\부터 까지 얼마나 많은 색상을 가져야 할까요? 색상이 없으면 회색을 의미하고, 숫자가 높을수록 색상이 더 많다는 것을 의미합니다.",
                "names": ["$~크로마", "$~기음"]
            },
            "hue": {
                "doc": "$~색상환에서 자홍색 \\0\\, 빨간색 \\30\\, 녹색 \\120\\, 파란색 \\270\\까지 어떤 색이어야 합니까?",
                "names": ["$~색조", "$~시간"]
            }
        },
        "Sequence": {
            "names": ["$~💃", "$~순서"],
            "doc": [
                "$~오. 나의. 이런. 감독님 오늘 정말 멋져요! 나와 함께 춤추고 싶니? 그것은 간단합니다.",
                "$~@Map 을 제공하기만 하면 됩니다. 여기서 각 키는 우리가 춤을 추고 있는 비율을 나타내고 해당 키의 각 값은 @Pose 가 됩니다.",
                "$~이것으로 애니메이션을 적용할 수 있는 방법은 /너무/ 많습니다! 예를 들어, 다음은 간단한 예입니다.",
                "$~\\Phrase('안녕' 휴식:Sequence({0%: 자세(회전: 360°) 100%: 자세(회전: 0°)})\\",
                "$~즉, /처음(0%)에서 기울기 360에서 시작하고 기울기 0/에서 끝납니다. @Phrase 의 휴식 포즈로 설정되어 있으므로 그러면 우리가 영원히 원을 그리며 돌게 될 것입니다!",
                "$~다른 입력을 사용하여 자신만의 창의적인 댄스를 시도해 보세요."
            ],
            "poses": {
                "doc": "$~0%에서 100% 사이의 백분율로 구성된 @Map 은 각각 @Pose 와 쌍을 이룹니다. 모든 백분율을 제공할 필요는 없습니다. 귀하가 제공한 출력 간에 @Output 을 원활하게 이동하겠습니다.",
                "names": "$~포즈"
            },
            "duration": {
                "doc": "$~이 춤은 언제까지 춰야 하나요? 반복한다면 시간을 추가하지 않고 더 빠르게 춤을 추겠습니다.",
                "names": ["$~⏳", "$~지속"]
            },
            "style": {
                "doc": "$~춤을 출 때 어떤 스타일을 사용해야 할까요?",
                "names": "$~스타일"
            },
            "count": {
                "doc": "$~완료되기 전에 시퀀스가 몇 번 반복되어야 하는지입니다. 무대에 들어갈 때, 무대 위로 올라갈 때, 무대에서 나갈 때 정말 도움이 되지만, 휴식 시퀀스에서는 영원히 쉴 수 있기 때문에 무시됩니다.",
                "names": "$~세다"
            }
        },
        "Place": {
            "names": ["Posición"],
            "doc": "$~저는 @Stage 에 있습니다. 내가 기본적으로 중앙에 있기 때문에 모든 입력은 선택 사항입니다.",
            "x": {
                "doc": "$~x축의 위치입니다.",
                "names": "$~엑스"
            },
            "y": {
                "doc": "$~y축의 위치",
                "names": "$~와이"
            },
            "z": {
                "doc": "$~Z축의 위치",
                "names": "$~지"
            },
            "rotation": {
                "doc": "$~이 위치에서 회전",
                "names": ["$~📐", "$~회전"]
            }
        },
        "Velocity": {
            "doc": "$~저는 @Stage 에 있습니다. 내가 기본적으로 중앙에 있기 때문에 모든 입력은 선택 사항입니다.",
            "names": ["$~💨", "$~속도"],
            "x": {
                "doc": "$~x축에서 초당 몇 미터를 이동해야 하는지입니다.",
                "names": "$~엑스"
            },
            "y": {
                "doc": "$~y축에서 초당 몇 미터를 이동할지입니다.",
                "names": "$~와이"
            },
            "angle": {
                "doc": "$~1초마다 회전할 각도는 얼마입니까?",
                "names": ["$~각도", "$~°"]
            }
        },
        "Matter": {
            "doc": "$~나는 무대에서 다른 출력과 상호 작용하는 방식에 영향을 미치는 출력의 물리적 특성입니다.",
            "names": ["$~⚛️", "$~문제"],
            "mass": {
                "doc": "$~무게(킬로그램)",
                "names": "$~대량의"
            },
            "bounciness": {
                "doc": "$~충돌을 계속하기 위해 내 에너지가 얼마나 필요한지, 0은 없음을 의미하고 1은 모든 것을 의미합니다.",
                "names": "$~탄력"
            },
            "friction": {
                "doc": "$~계속 미끄러질 정도; 0은 없음을 의미하고, 1은 영원히를 의미합니다.",
                "names": "$~마찰"
            },
            "roundedness": {
                "doc": "$~출력 모서리를 얼마나 둥글게 만들 것인가? 0은 없음을 의미하고 1은 크기의 100%를 의미하여 크기가 원형이 됩니다.",
                "names": "$~둥근정도"
            },
            "text": {
                "doc": "$~다른 출력과 충돌할 수 있는지 여부입니다.",
                "names": "$~텍스트"
            },
            "shapes": {
                "doc": "$~다른 모양과 충돌할 수 있는지 여부입니다.",
                "names": "$~지면"
            }
        },
        "Aura": {
            "doc": [
                "$~나는 AURA입니다. 나는 @Phrase GLOW를 만듭니다! 이와 같이:",
                "$~\\구절(\n\t'나는 빛난다!' \n\t아우라: 아우라(색상(50% 100 118°) 0.1m 0m 0.1m\n)\\"
            ],
            "names": ["$~🔮", "$~영기"],
            "color": {
                "doc": "$~@Aura 는 @Color 여야 합니다.",
                "names": "$~색상"
            },
            "blur": {
                "doc": "$~@Aura 는 얼마나 흐릿해야 할까요? \\0m\\은 전혀 흐릿하지 않음을 의미합니다.",
                "names": "$~흐림"
            },
            "offsetX": {
                "doc": "$~나는 얼마나 왼쪽이나 오른쪽에 나타나야 하는가. \\0m\\은 바로 아래에 있습니다.",
                "names": "$~오프셋X"
            },
            "offsetY": {
                "doc": "$~얼마나 위 또는 아래로 표시되어야 하는지\\0m\\은 바로 아래에 있습니다.",
                "names": "$~오프셋Y"
            }
        },
        "Easing": {
            "straight": "$~똑바로",
            "cautious": "$~조심성 있는",
            "pokey": "$~포키",
            "zippy": "$~기운찬"
        },
        "sequence": {
            "sway": {
                "doc": "$~@Output 의 중심을 중심으로 앞뒤로 흔들리는 @Sequence 를 만듭니다.",
                "names": ["vaivén"],
                "angle": {
                    "doc": "$~흔들림에서 기울어지는 정도입니다.",
                    "names": ["ángulo"]
                }
            },
            "bounce": {
                "doc": "$~@Output 을 주어진 높이로 반사시키는 @Sequence 를 생성합니다.",
                "names": ["rebotar"],
                "height": {
                    "doc": "$~튕기는 정도.",
                    "names": ["altura"]
                }
            },
            "spin": {
                "doc": "$~@Output 을 중심으로 회전하는 @Sequence 를 만듭니다.",
                "names": ["girar"]
            },
            "fadein": {
                "doc": "$~@Output 을 보이지 않는 상태에서 보이는 상태로 페이드 인하는 @Sequence 를 만듭니다.",
                "names": ["revelar"]
            },
            "fadeout": {
                "doc": "$~@Output 을 보이는 상태에서 보이지 않는 상태로 페이드하는 @Sequence 를 만듭니다. 종료되는 @Sequence 에서 저를 시험해 보세요!",
                "names": ["$~사라지다"]
            },
            "popup": {
                "doc": "$~@Output 을 일반 크기로 축소하는 것보다 빠르게 축소하는 @Sequence 를 만듭니다.",
                "names": ["surgir"]
            },
            "shake": {
                "doc": "$~@Output 이 겁나는 것처럼 보이게 만드는 @Sequence 를 만듭니다.",
                "names": ["agitar"]
            }
        },
        "Source": {
            "names": "$~원천",
            "doc": [
                "$~프로젝트에 @Source 파일이 두 개 이상 있을 수 있다는 사실을 알고 계시나요? 프로젝트 논리를 기반으로 @Source 를 생성할 수 있습니다. 이는 프로젝트의 여러 평가 사이에 일부 데이터를 저장하려는 경우 정말 유용합니다.",
                "$~예를 들어, 마우스 버튼을 누를 때마다 1씩 계산되는 간단한 카운터를 만들고 싶다고 가정해 보겠습니다. 당신은 당신이 어떤 일을 몇 번이나했는지 기억하기 위해 이것을 사용할 수 있습니다.",
                "$~\\↓ 개수\n[\n\t구문(`\\count\\회!`)\n\tSource('count' 카운트 … Δ Button() … 카운트 + 1 )\n]\\",
                "$~복사해 보세요. /count/라는 새 @Source 를 만들고 거기에 0을 입력하여 0에서 카운트를 시작합니다. 이 작은 프로젝트는 /count/ 소스에서 값을 가져오고 마우스 버튼을 누를 때마다 편집합니다. /count/ @Source 는 현재 /count/ 값에 /1/을 더한 값입니다."
            ],
            "name": {
                "names": "$~이름",
                "doc": "$~생성하거나 업데이트할 소스 파일의 이름입니다."
            },
            "value": {
                "names": "$~값",
                "doc": "$~소스 파일을 생성하거나 업데이트해야 하는 데이터 값입니다."
            },
            "DynamicEditLimitException": {
                "description": "$~동적 소스 편집 제한",
                "explanation": "$~이 프로젝트는 데이터를 @Source 파일에 너무 자주, 너무 빨리 저장했습니다. 입력에 대한 응답으로 @Source 만 업데이트하고 너무 빠르지는 않은지 확인하세요."
            },
            "ReadOnlyEditException": {
                "description": "$~읽기 전용 소스 편집",
                "explanation": "$~이 프로젝트는 데이터를 기억하지만 편집할 권한이 없습니다. 해보고 싶으면 복사해 보세요."
            },
            "EmptySourceNameException": {
                "description": "$~빈 소스 이름",
                "explanation": "$~제공된 @Source 의 이름이 비어 있으므로 저장할 수 없습니다."
            },
            "ProjectSizeLimitException": {
                "description": "$~프로젝트 크기 제한",
                "explanation": "$~이 프로젝트에는 텍스트가 너무 많아 저장할 수 없습니다."
            }
        }
    },
    "ui": {
        "font": {
            "app": "Noto Sans Korean",
            "code": "Noto Mono"
        },
        "phrases": {
            "welcome": "$~안녕하세요"
        },
        "widget": {
            "confirm": {
                "cancel": "$~취소"
            },
            "dialog": {
                "close": "$~닫다"
            },
            "loading": {
                "message": "$~글꼴과 텍스트를 로드하는 중입니다. 기다려주셔서 감사합니다!"
            },
            "home": "$~홈페이지로 이동",
            "table": {
                "cell": {
                    "description": "$~이 셀을 편집하다",
                    "placeholder": "$~값"
                },
                "addcolumn": "$~이 열 앞에 열을 추가하세요",
                "removecolumn": "$~이 열을 제거하세요"
            }
        },
        "tile": {
            "toggle": {
                "fullscreen": {
                    "on": "$~전체 화면 종료",
                    "off": "$~전체 화면으로 확장"
                },
                "show": {
                    "on": "$~숨다",
                    "off": "$~보여주다"
                }
            },
            "button": {
                "collapse": "$~창 축소"
            },
            "label": {
                "output": "$~단계",
                "palette": "$~팔레트",
                "docs": "$~가이드",
                "source": "$~원천",
                "collaborate": "$~협력하다"
            }
        },
        "project": {
            "error": {
                "unknown": "$~이 프로젝트는 존재하지 않거나 공개되지 않습니다.",
                "translate": "$~프로젝트를 번역하는 중에 문제가 발생했습니다.",
                "tile": "$~아, 오류가 발생했습니다.",
                "reset": "$~재설정을 시도하세요..."
            },
            "button": {
                "removeCollaborator": "$~공동작업자 제거",
                "copy": {
                    "tip": "$~프로젝트를 텍스트로 클립보드에 복사",
                    "label": "$~텍스트로 복사"
                },
                "addSource": "$~새로운 $source 생성",
                "duplicate": "$~이 프로젝트를 복사하세요",
                "revert": "$~원래 코드로 되돌리기",
                "focusOutput": "$~무대에 키보드 집중",
                "focusSource": "$~다음 소스에 집중하세요",
                "focusDocs": "$~문서에 집중하다",
                "focusPalette": "$~팔레트에 집중하다",
                "focusCycle": "$~다음 타일에 집중하세요",
                "unsaved": "$~저장 오류 표시",
                "translate": {
                    "tip": "$~이 프로젝트의 언어를 편집하고 다른 언어로 번역합니다.",
                    "label": "$~번역하다"
                },
                "primary": "$~이 프로젝트의 기본 로캘로 설정",
                "share": {
                    "tip": "$~프로젝트 공유 옵션 표시",
                    "label": "$~공유하다"
                },
                "history": {
                    "on": "$~최근 프로젝트 코드 표시",
                    "off": "$~현재 프로젝트 코드 표시"
                }
            },
            "field": {
                "name": {
                    "description": "$~프로젝트 이름 수정",
                    "placeholder": "$~이름"
                }
            },
            "collapsed": "$~창문이 모두 접혀있습니다! 아래 도구 모음에서 찾을 수 있습니다.",
            "save": {
                "projectsNotSavedLocally": "$~브라우저에 프로젝트를 저장하는 중에 문제가 발생했습니다.",
                "projectsCannotNotSaveLocally": "$~귀하의 브라우저는 프로젝트 저장을 지원하지 않습니다.",
                "projectContainedPII": "$~귀하의 개인 정보를 보호하기 위해 잠재적으로 개인 식별 정보가 포함된 프로젝트는 온라인에 저장되지 않았습니다. 해당 정보가 식별 가능한지 확인하려면 프로젝트를 확인하세요.",
                "projectsNotLoadingOnline": "$~온라인 프로젝트를 로드할 수 없습니다.",
                "projectNotSavedOnline": "$~프로젝트를 온라인으로 저장할 수 없습니다.",
                "settingsUnsaved": "$~온라인으로 설정을 저장할 수 없습니다."
            },
            "help": "$~키보드 단축키 표시",
            "dialog": {
                "unsaved": "$~저장되지 않은 작업...",
                "translate": {
                    "header": "$~언어",
                    "explanation": [
                        "$~프로젝트에서 사용하는 언어입니다.",
                        "$~프로젝트를 다른 언어로 번역하려면 기본 소스 언어를 선택한 다음 새 언어를 선택하세요.",
                        "$~/모든 언어가 지원되는 것은 아니며 번역이 불완전할 수 있으므로 결과를 검토해 보세요!/"
                    ]
                }
            },
            "subheader": {
                "source": "$~원천",
                "destination": "$~목적지"
            }
        },
        "gallery": {
            "untitled": "$~제목 없음",
            "undescribed": "$~설명 없음",
            "subheader": {
                "curators": {
                    "header": "$~큐레이터",
                    "explanation": "$~이 갤러리를 관리하는 크리에이터입니다."
                },
                "creators": {
                    "header": "$~크리에이터",
                    "explanation": "$~이 갤러리에 기여하는 제작자입니다."
                },
                "delete": {
                    "header": "$~삭제",
                    "explanation": "$~이 갤러리를 삭제해도 프로젝트는 삭제되지 않습니다. 갤러리가 완전히 삭제됩니다."
                },
                "classes": {
                    "header": "$~수업",
                    "explanation": "$~이 갤러리와 관련된 수업입니다."
                }
            },
            "confirm": {
                "delete": {
                    "description": "$~갤러리 삭제",
                    "prompt": "$~삭제"
                },
                "remove": {
                    "description": "$~갤러리에서 프로젝트 제거",
                    "prompt": "$~제거하다"
                }
            },
            "error": {
                "unknown": "$~이 갤러리는 존재하지 않거나 공개되지 않습니다."
            },
            "field": {
                "name": {
                    "description": "$~갤러리 이름",
                    "placeholder": "$~이름"
                },
                "description": {
                    "description": "$~갤러리 설명",
                    "placeholder": "$~갤러리에 대해 설명해주세요. 주제, 목표 또는 커뮤니티는 무엇입니까?"
                }
            }
        },
        "source": {
            "label": "$~프로그램 편집기",
            "empty": [
                "$~시작하자! 당신은 할 수 있습니다…",
                "$~• 📕을 열고 🖱️ 이 프로그램으로 드래그하세요.",
                "$~• $1을 입력하고 메뉴에서 저희를 선택하세요.",
                "$~• ⌨️를 사용하여 입력하세요.",
                "$~• <galleries@://galleries>에서 영감을 얻으세요.",
                "$~문제가 있으면 <자세히 알아보기@://learn>하세요."
            ],
            "overwritten": "$~최신 버전을 받았습니다!",
            "confirm": {
                "delete": {
                    "description": "$~이 $source 삭제",
                    "prompt": "$~삭제"
                }
            },
            "toggle": {
                "blocks": {
                    "on": "$~블록 배경 숨기기",
                    "off": "$~블록 배경 표시"
                },
                "characters": {
                    "on": "$~일치하는 글리프 축소",
                    "off": "$~일치하는 문자 확장"
                }
            },
            "button": {
                "selectOutput": "$~이 출력을 무대에 표시",
                "expandSequence": "$~이 접힌 코드를 확장하세요"
            },
            "field": {
                "name": {
                    "description": "$~소스 이름 수정",
                    "placeholder": "$~이름"
                }
            },
            "menu": {
                "label": "$~자동완성 메뉴",
                "show": "$~자동완성 메뉴 표시",
                "back": "$~하위 메뉴 나가기"
            },
            "cursor": {
                "priorLine": "$~커서를 이전 줄로 이동",
                "nextLine": "$~커서를 다음 줄로 이동",
                "priorInline": "$~커서를 이전 위치로 이동",
                "nextInline": "$~커서를 다음 위치로 이동",
                "lineStart": "$~커서를 줄의 시작으로 이동",
                "lineEnd": "$~커서를 줄 끝으로 이동",
                "sourceStart": "$~커서를 소스 시작 부분으로 이동",
                "sourceEnd": "$~커서를 소스 끝으로 이동",
                "priorNode": "$~이전에 이웃을 선택하세요",
                "nextNode": "$~다음 이후에 이웃을 선택하세요",
                "parent": "$~컨테이너 선택",
                "selectAll": "$~프로그램 선택",
                "incrementLiteral": "$~숫자, 텍스트 또는 부울 증가",
                "decrementLiteral": "$~숫자, 텍스트 또는 부울 감소",
                "insertSymbol": "$~$1 삽입",
                "insertTab": "$~삽입 탭",
                "insertTrue": "$~참을 삽입하다",
                "insertFalse": "$~거짓을 삽입하다",
                "insertNone": "$~없음 기호 삽입",
                "insertNotEqual": "$~같지 않은 삽입",
                "insertProduct": "$~제품 기호 삽입",
                "insertQuotient": "$~몫 기호 삽입",
                "insertDegree": "$~도 기호 삽입",
                "insertFunction": "$~삽입 기능",
                "insertLessOrEqual": "$~이하 삽입",
                "insertGreaterOrEqual": "$~보다 크거나 같음 삽입",
                "insertStream": "$~스트림 기호 삽입",
                "insertChange": "$~변경 기호 삽입",
                "insertConvert": "$~변환 기호 삽입",
                "insertPrevious": "$~이전 기호 삽입",
                "insertType": "$~유형 기호 삽입",
                "insertTable": "$~테이블 열린 기호 삽입",
                "insertTableClose": "$~테이블 닫기 기호 삽입",
                "insertBorrow": "$~차용 삽입",
                "insertShare": "$~공유 삽입",
                "insertLine": "$~줄 바꿈 삽입",
                "backspace": "$~선택 항목 또는 이전 기호 삭제",
                "delete": "$~선택 항목 또는 다음 기호 삭제",
                "cut": "$~컷 선택",
                "copy": "$~선택 복사",
                "paste": "$~키보드 내용 붙여넣기",
                "parenthesize": "$~괄호로 묶기 선택",
                "enumerate": "$~선택 항목을 열거하다",
                "type": "$~문자 입력",
                "undo": "$~이전 편집 실행 취소",
                "redo": "$~다시 실행 취소한 편집",
                "search": "$~삽입할 특수문자를 검색하세요",
                "tidy": "$~깔끔한 간격",
                "elide": "$~제거 토글",
                "insertDocs": "$~설명 기호 삽입",
                "expandBeforeInline": "$~선택 항목을 확장하기 전에",
                "expandAfterInline": "$~선택 확장 후",
                "expandPriorLine": "$~선택 항목을 이전 줄로 확장",
                "expandNextLine": "$~선택 항목을 다음 줄로 확장"
            },
            "options": {
                "locale": {
                    "tip": "$~소스에 대한 기본 언어",
                    "all": "$~모두"
                }
            },
            "error": {
                "invalidName": "$~유효한 워드플레이 이름이어야 합니다.",
                "invalidWords": "$~단어는 비어 있을 수 없고 예약된 기호를 포함할 수 없습니다."
            }
        },
        "annotations": {
            "label": "$~갈등과 도움",
            "cursor": "$~이것은 *$1*$2[이고 $2|] 유형입니다.    $3[ *$3* 안에 있습니다.|]",
            "cursorParent": "$~$2|] 유형의 *$1*$2[ 안에 있습니다.",
            "learn": "$~/더 알아보기/",
            "evaluating": "$~아 재밌다 평가해보자!",
            "space": "$~이것은 공간이다! 아무것도 그렇게 많이 말할 수 있다는 것을 누가 알았습니까?",
            "button": {
                "resolution": "$~이 충돌을 해결하세요"
            }
        },
        "output": {
            "label": "$~프로그램 출력",
            "toggle": {
                "grid": {
                    "on": "$~그리드선 숨기기",
                    "off": "$~그리드 선 표시"
                },
                "fit": {
                    "on": "$~수동으로 확대/축소 제어",
                    "off": "$~콘텐츠에 맞게 확대/축소"
                },
                "paint": {
                    "on": "$~페인트 출력",
                    "off": "$~장소 출력"
                }
            },
            "field": {
                "key": {
                    "description": "$~키 누르는 소리 듣기",
                    "placeholder": "$~메시지"
                }
            },
            "button": {
                "submit": "$~이 채팅 메시지를 제출하세요"
            },
            "options": {
                "locale": "$~출력할 언어를 선택하세요"
            }
        },
        "timeline": {
            "label": "$~타임라인",
            "slider": "$~시간 슬라이더",
            "button": {
                "play": "$~실시간으로 입력에 응답하여 프로그램을 끝까지 평가합니다.",
                "pause": "$~프로그램을 일시 중지하여 앞으로 및 뒤로 이동할 수 있습니다.",
                "backStep": "$~한발 물러서다",
                "backNode": "$~커서의 이전 평가 단계",
                "backInput": "$~하나의 입력으로 돌아가기",
                "out": "$~이 기능에서 나가세요",
                "forwardStep": "$~한 걸음 앞으로 나아가다",
                "forwardNode": "$~커서의 다음 평가 단계",
                "forwardInput": "$~다음 스트림 입력으로 앞으로 이동",
                "present": "$~끝까지",
                "start": "$~처음으로",
                "reset": "$~성능 다시 시작"
            }
        },
        "docs": {
            "label": "$~문서 브라우저",
            "link": "$~문서에 개념 $1 표시",
            "learn": "$~더 알아보기 …",
            "nodoc": "$~나는 누구입니까? 난 무엇인가? 내 목적은 무엇입니까?",
            "button": {
                "home": "$~귀국",
                "back": "$~이전으로 돌아가기"
            },
            "field": {
                "search": "$~단어로 개념 검색"
            },
            "header": {
                "inputs": "$~입력",
                "interfaces": "$~인터페이스",
                "properties": "$~속성",
                "functions": "$~기능",
                "conversions": "$~전환"
            },
            "modes": {
                "label": "$~먹다",
                "modes": ["$~어떻게", "$~개념"]
            },
            "how": {
                "category": {
                    "characters": "$~캐릭터 생성 및 제어",
                    "styling": "$~스타일 문자 및 텍스트",
                    "animation": "$~캐릭터와 텍스트에 애니메이션을 적용하다",
                    "layout": "$~문자와 텍스트를 정렬하다",
                    "randomization": "$~무작위를 사용하다",
                    "remembering": "$~변경 사항 및 선택 사항 추적",
                    "stories": "$~이야기를 들려주다",
                    "motion": "$~물리학을 사용하다",
                    "video": "$~카메라를 사용하다"
                },
                "related": "$~원하시는 내용이 아닌가요?"
            }
        },
        "dialog": {
            "share": {
                "header": "$~나누는",
                "explanation": "$~이 프로젝트를 편집하고 볼 수 있는 사람을 제어합니다.",
                "subheader": {
                    "gallery": {
                        "header": "$~갤러리",
                        "explanation": "$~이 프로젝트를 다른 제작자와 함께 갤러리에 추가하거나 <projects@://projects> 페이지에 갤러리를 만드세요. 공개 갤러리에 프로젝트를 추가하면 프로젝트가 공개됩니다."
                    },
                    "public": {
                        "header": "$~공개/비공개",
                        "explanation": "$~공공 프로젝트와 갤러리는 전 세계 누구나 볼 수 있습니다. 우리의 목표는 이 콘텐츠가 긍정과 기쁨을 가져오는 것이며, 공개적으로 공유하는 것이 이를 위한 방법입니다. 하지만 이는 몇 가지 규칙을 따르는 것을 의미하기도 합니다. 귀하는 귀하의 프로젝트가 다음과 같은 일을 하지 않을 것을 약속합니다."
                    },
                    "pii": {
                        "header": "$~개인 정보",
                        "explanation": "$~개인 식별 정보(PII)를 공개적으로 공유하면 크리에이터가 위험에 처할 수 있으므로, 당사는 가능한 PII를 감지하고 크리에이터에게 민감한 데이터를 제거하거나 민감하지 않은 데이터로 표시하도록 경고합니다.\n\n다음은 귀하가 민감하지 않은 것으로 표시한 이 프로젝트에서 가능한 PII 목록입니다. 옆에 있는 버튼을 클릭하여 다시 민감한 항목으로 표시할 수 있지만 그렇게 하면 프로젝트가 더 이상 온라인에 저장되지 않습니다."
                    },
                    "copy": {
                        "header": "$~복사 및 붙여넣기",
                        "explanation": "$~이 프로젝트를 텍스트로 클립보드에 복사하여 다른 곳에 공유하세요."
                    }
                },
                "field": {
                    "emailOrUsername": {
                        "placeholder": "$~이메일 또는 사용자 이름",
                        "description": "$~편집 액세스 권한을 부여하려는 사람의 이메일 또는 사용자 이름"
                    }
                },
                "mode": {
                    "public": {
                        "label": "$~시계",
                        "modes": ["$~사적인", "$~공공의"]
                    }
                },
                "error": {
                    "unknown": "$~이 이메일을 받은 작성자를 알 수 없습니다.",
                    "anonymous": "$~공유하려면 로그인이 필요합니다.",
                    "self": "$~자신을 추가할 수 없습니다."
                },
                "button": {
                    "submit": "$~이 이메일 주소로 프로젝트를 공유하세요",
                    "sensitive": {
                        "tip": "$~이 텍스트를 다시 민감한 항목으로 표시",
                        "label": "$~예민한"
                    }
                },
                "options": {
                    "gallery": "$~갤러리 선택기"
                }
            },
            "settings": {
                "header": "$~설정",
                "explanation": "$~레이아웃, 장치, 테마 설정을 변경합니다.",
                "button": {
                    "show": "$~설정 대화상자 표시"
                },
                "mode": {
                    "layout": {
                        "label": "$~공들여 나열한 것",
                        "modes": [
                            "$~자동적 인",
                            "$~수평의",
                            "$~수직의",
                            "$~무료"
                        ]
                    },
                    "animate": {
                        "label": "$~애니메이션",
                        "modes": [
                            "$~애니메이션 꺼짐",
                            "$~정상 속도",
                            "$~절반 속도",
                            "$~세 번째 속도",
                            "$~1/4 속도"
                        ]
                    },
                    "dark": {
                        "label": "$~주제",
                        "modes": [
                            "$~밝은 색상",
                            "$~어두운 색",
                            "$~장치 설정 사용"
                        ]
                    },
                    "space": {
                        "label": "$~공간 표시기",
                        "modes": [
                            "$~공백 및 탭 표시기를 명시적으로 표시",
                            "$~공백 및 탭 표시기를 표시하지 않음"
                        ]
                    },
                    "writing": {
                        "label": "$~쓰기 레이아웃",
                        "modes": [
                            "$~수평, 왼쪽에서 오른쪽으로",
                            "$~수직, 오른쪽에서 왼쪽으로",
                            "$~수직, 왼쪽에서 오른쪽으로"
                        ]
                    },
                    "lines": {
                        "label": "$~줄 번호",
                        "modes": [
                            "$~텍스트 모드에서 줄 번호 표시",
                            "$~텍스트 모드에서 줄 번호를 표시하지 않음"
                        ]
                    }
                },
                "options": {
                    "mic": "$~선택한 마이크",
                    "camera": "$~선택한 카메라",
                    "face": "$~글꼴면"
                }
            },
            "locale": {
                "header": "$~언어",
                "explanation": "$~언어와 지역을 선택하세요.",
                "subheader": {
                    "selected": "$~선택된",
                    "supported": "$~사용 가능",
                    "help": "$~번역을 도와주세요…"
                },
                "button": {
                    "show": "$~로케일 변경",
                    "add": "$~이 로케일을 추가하세요",
                    "remove": "$~이 로케일을 제거하세요",
                    "replace": "$~이 로케일로 교체"
                }
            },
            "help": {
                "header": "$~단축키",
                "explanation": "$~보다 효율적인 편집을 위해 다음 키보드 명령을 사용하십시오.",
                "subheader": {
                    "moveCursor": "$~이동하다",
                    "editCode": "$~편집하다",
                    "insertCode": "$~끼워 넣다",
                    "debug": "$~디버그"
                }
            },
            "feedback": {
                "header": "$~피드백",
                "explanation": "$~*문제*를 보고하고 *아이디어*를 공유하여 Wordplay를 개선하는 데 도움을 주세요!",
                "button": {
                    "show": "$~피드백 양식을 보여주세요.",
                    "submit": {
                        "tip": "$~의견을 제출하세요.",
                        "label": "$~제출하다"
                    },
                    "delete": {
                        "description": "$~피드백을 삭제하세요.",
                        "prompt": "$~삭제"
                    },
                    "like": "$~이 피드백을 좋아하세요",
                    "close": {
                        "label": "$~닫다",
                        "tip": "$~이 피드백을 관리자 권한으로 닫습니다."
                    }
                },
                "mode": {
                    "label": "$~피드백",
                    "modes": ["$~결함", "$~이데사"]
                },
                "field": {
                    "title": {
                        "description": "$~귀하의 피드백 제목",
                        "placeholder": "$~제목"
                    },
                    "defect": {
                        "description": "$~귀하의 결함에 대한 설명",
                        "placeholder": "$~어떤 단계를 밟았나요? 그 후에 무슨 일이 일어났나요? 가능한 한 정확하게 말씀해 주세요."
                    },
                    "idea": {
                        "description": "$~귀하의 결함에 대한 설명",
                        "placeholder": "$~당신은 무엇을 하려고 하는데 할 수 없는 건가요?"
                    }
                },
                "subheader": {
                    "defect": "$~결함",
                    "idea": "$~아이디어"
                },
                "prompt": {
                    "defect": "$~겪고 있는 문제를 보지 못하셨나요? 여기에 보고하세요.",
                    "idea": "$~당신이 생각하는 아이디어를 보지 못하셨나요? 제안해 보세요."
                },
                "error": {
                    "login": "$~피드백을 제출하려면 로그인해야 합니다.",
                    "submit": "$~피드백을 제출할 수 없습니다.",
                    "load": "$~피드백을 로드할 수 없습니다",
                    "empty": "$~표시할 피드백이 없습니다."
                }
            }
        },
        "palette": {
            "label": "$~팔레트",
            "labels": {
                "mixed": "$~혼합된",
                "computed": "$~계산된",
                "default": "$~기본",
                "inherited": "$~물려받은",
                "notSequence": "$~시퀀스가 아님",
                "notContent": "$~콘텐츠 목록이 아닙니다",
                "format": "$~체재",
                "weight": "$~무게",
                "light": "$~빛",
                "normal": "$~정상",
                "bold": "$~용감한",
                "extra": "$~추가의",
                "italic": "$~이탤릭체",
                "underline": "$~밑줄"
            },
            "button": {
                "revert": "$~기본값으로 되돌리기",
                "set": "$~이 속성을 편집하세요",
                "addPhrase": "$~이 뒤에 문구를 추가하세요",
                "addGroup": "$~이 뒤에 그룹 추가",
                "addShape": "$~이 뒤에 모양을 추가하세요",
                "addMotion": "$~모션 스트림으로 장소 설정",
                "addPlacement": "$~장소를 배치 스트림으로 설정",
                "remove": "$~이 콘텐츠를 삭제하세요",
                "up": "$~이 콘텐츠를 위로 이동하세요",
                "down": "$~이 콘텐츠를 아래로 이동하세요",
                "edit": "$~이 내용을 편집하세요",
                "sequence": "$~시퀀스로 변환",
                "createPhrase": "$~기존 값을 텍스트로 표시하는 구문을 만듭니다.",
                "createGroup": "$~기존 문구를 래핑하여 그룹을 만듭니다.",
                "createStage": "$~기존 그룹이나 프레이즈를 래핑하여 스테이지를 생성합니다."
            },
            "prompt": {
                "offerPhrase": "$~당신은 정말 멋진 가치를 만들어냈습니다! @Stage 에서 보여드릴까요?",
                "offerGroup": "$~정말 멋진 @Phrase 를 만드셨습니다. @그룹으로 모아 정리하시겠습니까?",
                "offerStage": "$~아주 좋아요 @프로그램. 조명 제어에 나를 추가해 주세요. 그림 물감. 프레임.",
                "editing": "$~편집해 주세요!",
                "select": "$~편집하려면 코드에서 💬, 🔳, 🎭를 선택하거나 스테이지에서 ⏸️를 선택하고 출력을 선택하세요."
            },
            "field": {
                "coordinate": "$~좌표 편집",
                "text": "$~텍스트 편집"
            },
            "sequence": {
                "button": {
                    "add": "$~포즈 추가",
                    "remove": "$~포즈 제거",
                    "up": "$~포즈를 취하다",
                    "down": "$~자세를 아래로 이동"
                },
                "field": {
                    "percent": "$~퍼센트 편집"
                }
            },
            "error": {
                "nan": "$~이는 숫자가 아닙니다.",
                "percent": "$~0~100 사이의 백분율이어야 합니다.",
                "lessThanNext": "$~다음 항목보다 작아야 합니다.",
                "moreThanPrevious": "$~이는 이전 항목보다 많아야 합니다."
            }
        },
        "save": {
            "saving": "$~절약",
            "saved": "$~온라인에 저장됨",
            "local": "$~브라우저에 저장됨",
            "unsaved": "$~저장되지 않은"
        },
        "page": {
            "unknown": {
                "header": "$~으악!",
                "message": "$~여기서이 곳은? 집에 갈 수 있나요?"
            },
            "landing": {
                "value": "단어, 기호, 이모티콘, 코드를 사용하여 대화형 스토리를 만들어보세요!",
                "description": [
                    "Wordplay는 다음을 수행할 수 있는 프로그래밍 언어입니다",
                    "• 단어와 이모티콘에 장난스럽게 애니메이션을 적용해보세요 🤪︎",
                    "• 시간 🕦︎, 소리 🎤︎, 웹사이트 🔗︎, 물리학 🌎︎을 활용하세요.",
                    "• 친구, 그룹 또는 누구와도 🤝︎ 공유하세요",
                    "• 모든 세계 언어로 코드를 작성하세요 🌐︎",
                    "• 마우스 🖱︎️, 터치 👆︎, 키보드 ⌨︎️로 편집하세요",
                    "• 디버그 앞으로 ⏩︎ 및 뒤로 ⏪︎",
                    "• 화면🖥︎️ 및 화면 리더로 보기 🔊",
                    "워싱턴 대학교↗에서 영원히 무료입니다."
                ],
                "beta": [
                    "$~Wordplay는 *베타* 버전이므로 의도한 대로 작동하지 않거나 완전하지 않을 수 있습니다. <GitHub@https://github.com/wordplaydev/wordplay/issues>에서 버그를 보고하고 아이디어를 공유하세요. <1.0plans@https://github.com/wordplaydev/wordplay/milestones/1.0>을 참조하세요. @https://github.com/wordplaydev/wordplay/wiki/contribute>."
                ],
                "link": {
                    "about": "$~이 장소는 왜 존재하는가?",
                    "learn": "$~드라마틱한 등장인물과 함께 언어를 배워보세요",
                    "guide": "$~언어 참조 검색 및 찾아보기",
                    "projects": "$~공연 창작 및 공유",
                    "galleries": "$~다른 사람의 공연을 경험해 보세요",
                    "rights": "$~우리와 귀하의 책임",
                    "community": {
                        "label": "지역 사회",
                        "subtitle": "Discord에서 우리와 채팅하세요"
                    },
                    "contribute": {
                        "label": "기여하다",
                        "subtitle": "워드플레이를 만들 수 있도록 도와주세요."
                    },
                    "teach": "$~학생들의 수업과 프로젝트를 관리합니다",
                    "characters": "$~사용자 정의 이모티콘과 기호 만들기"
                }
            },
            "learn": {
                "header": "배우기",
                "error": "이 언어에 대한 튜토리얼을 찾을 수 없습니다.",
                "button": {
                    "next": "$~대화상자의 다음 일시중지",
                    "previous": "$~대화상자의 이전 일시중지"
                },
                "options": {
                    "lesson": "$~현재 수업"
                }
            },
            "guide": {
                "header": "$~가이드",
                "description": "$~이것은 Wordplay 프로그래밍 언어의 모든 부분에 대한 참조입니다. 자세한 내용을 보려면 개념을 검색하거나 목록을 찾아보세요."
            },
            "projects": {
                "header": "$~프로젝트",
                "projectprompt": "$~말할 준비가 되셨나요? 프로젝트를 만들거나 작업해 보세요. 막히면 계속 <learning@://learn>하세요.",
                "archiveprompt": "$~이는 귀하가 보관한 프로젝트입니다. 소유자만이 해당 항목을 영구적으로 삭제하거나 보관 취소할 수 있습니다. 보관된 프로젝트는 마지막 편집 후 30일이 지나면 영구적으로 삭제됩니다.",
                "galleriesheader": "$~갤러리",
                "galleryprompt": "$~갤러리를 만들고 관리하여 프로젝트 컬렉션을 다른 사람들과 공유하세요.",
                "add": {
                    "header": "$~새 프로젝트",
                    "explanation": "$~새 프로젝트를 만들려면 템플릿을 선택하세요."
                },
                "button": {
                    "newproject": "$~새 프로젝트",
                    "editproject": "$~이 프로젝트를 편집하세요",
                    "viewcode": "$~이 프로젝트의 코드 보기",
                    "newgallery": "$~새 갤러리",
                    "unarchive": "$~이 프로젝트 보관 취소"
                },
                "confirm": {
                    "archive": {
                        "description": "$~이 공연을 보관처리하세요",
                        "prompt": "$~보관소"
                    },
                    "delete": {
                        "description": "$~이 공연을 영구적으로 삭제",
                        "prompt": "$~영원히 삭제"
                    }
                },
                "error": {
                    "noaccess": "$~인터넷에 연결할 수 없습니다.",
                    "nogalleryedits": "$~갤러리를 생성하고 변경하려면 로그인이 필요합니다.",
                    "newgallery": "$~새 갤러리를 만들 수 없습니다.",
                    "nodeletes": "$~보관된 프로젝트를 삭제하려면 로그인이 필요합니다.",
                    "delete": "$~이런, 프로젝트를 삭제할 수 없습니다!"
                },
                "subheader": {
                    "shared": "$~공유",
                    "archived": "$~보관됨"
                }
            },
            "galleries": {
                "header": "$~갤러리",
                "prompt": "$~이것은 다른 사람들이 만든 공연입니다. 그것을 경험하고, 연구하고, 자신의 진술에 적용하십시오.",
                "examples": "ejemplos",
                "button": {
                    "more": {
                        "label": "$~더...",
                        "tip": "$~더 많은 갤러리를 로드하세요"
                    }
                }
            },
            "about": {
                "header": "$~에 대한",
                "content": [
                    "$~코딩이 컴퓨터와 함께 자란 영어에 능통하고 장애가 없는 서양인만을 위한 것이라고 느낀 적이 있습니까?",
                    "$~응, 우리도 마찬가지야.",
                    "$~이것은 사고가 아닙니다. 컴퓨팅이 시작된 이래로 프로그래밍 언어는 대부분 동일한 그룹의 사람들, 즉 미국과 유럽의 학계와 산업계에 종사하는 백인, 시스, 영어를 사용하는 남성, 그리고 몇몇 뛰어난 여성 수학자에 의해 설계되고 구축되었습니다. 그들은 탈식민주의, 승자독식의 권력 시대에 일을 했고, 프로그래밍 언어는 그 권력을 확보하기 위한 핵심 도구였습니다.",
                    "$~이러한 역사는 주로 속도, 논리, 이익 및 지배에 관한 계산의 비전으로 이어졌습니다.",
                    "$~이것은 불의입니다. 좋든 나쁘든 컴퓨팅은 이제 눈에 보이거나 보이지 않는 방식으로 일상 생활을 뒷받침하고 있으며, 컴퓨팅을 사용하여 창작할 수 있는 사람들은 컴퓨팅을 만든 사람과 가장 비슷하기 때문입니다. 나머지 인류는 여전히 이 힘에 묶여 있습니다. 왜냐하면 다른 것을 상상하려면 언어 장벽, 접근성 장벽, 경제적 장벽 및 공교육의 불평등으로 인해 문해력이 필요하기 때문입니다.",
                    "$~*워드플레이*는 이러한 변화를 돕고자 합니다. 이는 전 세계 언어를 /모든/ 지원하는 동시에 /대략/ 세계 언어를 지원하도록 설계된 프로그래밍 플랫폼입니다. 누구나 자신의 능력에 관계없이 누구나 경험할 수 있는 대화형 콘텐츠를 공유할 수 있는 플랫폼입니다. 대화형 단어, 이모티콘, 타이포그래피를 통해 재미있고 예술적으로 자신을 표현하고 싶은 청소년 및 청년을 위한 제품입니다. 스스로 힘을 얻는 것이 목표가 아니라, 우리의 아름다운 차이의 놀라운 힘과 필요성을 인식하는 컴퓨팅 세계를 만드는 것입니다.",
                    "$~우리는 이러한 비전을 실현하기 위해 노력하는 디자이너, 교육자, 개발자로 구성된 커뮤니티입니다. 우리는 유색인종, 트랜스젠더, 퀴어, 장애인, 이민자, 난민입니다. 우리는 모두를 환영하고 되돌리기를 지향하는 미국 워싱턴 주 시애틀의 <University of Washington@https://washington.edu> <Information School@https://ischool.uw.edu/>를 중심으로 하고 있습니다. 오늘날에도 계속되는 식민주의의 유능하고 인종차별적인 파괴. 이 프로그래밍 언어와 플랫폼을 만드는 것은 /모든 사람/이 속한 컴퓨팅의 미래를 엿볼 수 있는 임무의 작은 부분입니다.",
                    "$~우리는 당신의 도움을 환영합니다. <기여 방법@https://github.com/wordplaydev/wordplay/wiki/contribute>, <donate@://donate>에 대해 알아보거나 <progress@https://github.com/amyjko/wordplay/를 추적하세요. 이정표>. 질문이 있으시면 커뮤니티 주최자 <Amy@https://amyjko.phd>에게 메일을 보내주세요."
                ]
            },
            "login": {
                "header": "$~로그인",
                "anonymous": "$~로그인",
                "prompt": {
                    "forgot": "$~*비밀번호를 잊으셨나요?* 안타깝게도 당사에서는 연락처 정보를 수집하지 않으므로 귀하의 계정을 복구할 수 없습니다.",
                    "email": "$~이메일 전용 계정이 있나요? 이메일을 제출하여 로그인하세요. 연결된 계정이 있는 경우 로그인 링크가 포함된 이메일을 보내드립니다. 개인 정보 보호를 위해 새로운 이메일 전용 계정은 지원되지 않습니다.",
                    "enter": "$~로그인 링크가 다른 브라우저나 기기에서 온 것 같습니다. 본인임을 확인하기 위해 이메일을 다시 입력해 주시겠습니까?",
                    "tooyoung": "$~이메일로 로그인하려면 13세 이상이어야 합니다.",
                    "passwordrule": "$~비밀번호는 6자 이상이어야 합니다. 비밀번호 관리자를 사용하지 않는 경우 기억할 수 있는 긴 단어 3개를 선택하세요.",
                    "passwordreminder": "$~아직 계정이 없는 것 같습니다. 비밀번호는 복구할 수 없으므로 다시 한번 입력하시고, 안전하고 정확하게 보관했는지 확인하세요.",
                    "play": "$~로그인하셨습니다. 이제 프로젝트를 온라인에 저장할 수 있습니다! 뭔가를 만들고 싶나요?",
                    "changeEmail": "$~이메일을 변경하고 싶으신가요? 새 항목을 제출하면 기존 항목으로 확인 메일을 보내드립니다.",
                    "changePassword": "$~비밀번호를 변경하고 싶으신가요? 새로운 것을 제출하고 반복하세요.",
                    "logout": "$~공유 장치를 사용하고 있으며 프로젝트를 비공개로 유지하고 싶으십니까? 로그아웃하면 이 장치에서 *프로젝트*가 삭제되지만 온라인에 저장됩니다.",
                    "sent": "$~이 이메일이 계정과 연결되어 있으면 로그인 링크가 포함된 이메일을 받게 됩니다. 표시되는 데 몇 분 정도 걸릴 수 있습니다. 이 이메일과 연결된 계정이 없으면 아무 것도 받을 수 없습니다.",
                    "success": "$~계정이 생성되었습니다!",
                    "confirm": "$~이전 이메일 주소를 확인하여 새 주소를 확인하세요.",
                    "delete": "$~당신이 여기서 만든 모든 것을 잊어버리고 싶나요? 이 작업은 취소할 수 없습니다.",
                    "reallyDelete": "$~확실합니까? 귀하의 계정과 설정은 즉시 삭제되며 프로젝트도 삭제될 예정입니다. 프로젝트의 공동작업자는 즉시 해당 프로젝트에 액세스할 수 없게 됩니다. 이메일이나 사용자 이름을 입력하여 이것이 원하는 것인지 확인하세요.",
                    "name": "$~다른사람에게자신을표현할이모티콘을선택하세요.",
                    "login": "$~프로젝트를 저장하고, 협업하고, 공유하려면 로그인하세요.",
                    "join": "$~또는 <계정 만들기@://join>으로 시작하세요."
                },
                "error": {
                    "expired": "$~이 링크는 만료되었습니다.",
                    "invalid": "$~이 링크는 유효하지 않습니다.",
                    "email": "$~이 이메일은 유효하지 않습니다.",
                    "offline": "$~클라우드에 연결할 수 없습니다 ☁️.",
                    "failure": "$~로그인 할 수 없습니다 :(",
                    "unchanged": "$~귀하의 이메일 주소를 변경할 수 없지만 이유를 알 수 없습니다.",
                    "delete": "$~귀하의 계정을 삭제할 수 없지만 이유를 알 수 없습니다.",
                    "wrongPassword": "$~유효한 사용자 이름과 비밀번호가 아닙니다. 귀하의 비밀번호가 잘못되었거나 다른 사람이 이 사용자 이름을 사용하고 있습니다.",
                    "tooMany": "$~로그인을 너무 많이 시도했지만 실패했습니다. 다시 시도하려면 기다려야 합니다.",
                    "invalidUsername": "$~사용자 이름은 공백 없이 이메일 주소나 5자 이상이어야 합니다.",
                    "invalidPassword": "$~비밀번호는 최소 6자 이상이어야 합니다.",
                    "mismatched": "$~비밀번호가 일치하지 않습니다."
                },
                "feedback": {
                    "changing": "$~새 이메일을 제출하는 중...",
                    "deleting": "$~알겠습니다. 프로젝트와 설정을 삭제하겠습니다...",
                    "updatedPassword": "$~귀하의 비밀번호가 업데이트되었습니다.",
                    "match": "$~이는 귀하의 계정 사용자 이름과 일치해야 합니다."
                },
                "field": {
                    "email": {
                        "description": "$~로그인 이메일 수정",
                        "placeholder": "$~이메일"
                    },
                    "username": {
                        "description": "$~로그인 사용자 이름, 개인 식별 정보를 사용하지 마세요",
                        "placeholder": "$~사용자 이름"
                    },
                    "password": {
                        "description": "$~로그인 비밀번호는 6자 이상",
                        "placeholder": "$~비밀번호"
                    },
                    "currentPassword": {
                        "description": "$~현재 로그인 비밀번호",
                        "placeholder": "$~현재 비밀번호"
                    },
                    "newPassword": {
                        "description": "$~새로운 비밀번호",
                        "placeholder": "$~새 비밀번호"
                    }
                },
                "button": {
                    "logout": {
                        "tip": "$~귀하의 계정에서 로그 아웃",
                        "label": "$~로그 아웃"
                    },
                    "login": "$~이 이메일로 로그인하여 로그인 링크 보내기",
                    "updateEmail": "$~이메일을 바꿔라",
                    "updatePassword": "$~새 비밀번호 제출",
                    "delete": {
                        "tip": "$~계정을 삭제하세요",
                        "label": "$~내 데이터 삭제해…"
                    },
                    "reallyDelete": {
                        "tip": "$~계정을 영원히 삭제하세요",
                        "label": "$~삭제해!!!"
                    }
                },
                "toggle": {
                    "reveal": {
                        "on": "$~비밀번호 표시",
                        "off": "$~비밀번호 숨기기"
                    }
                },
                "subtitle": "$~저장, 협업 및 공유"
            },
            "join": {
                "header": "$~가입하다",
                "prompt": {
                    "create": "$~프로젝트를 저장하고, 다른 사람과 협업하고, 작업을 공유하려면 계정을 만드세요.",
                    "username": "$~사용자 이름은 최소 5자 이상이어야 하며, 이메일 주소를 사용할 수 없으며, 이름이나 기타 개인 식별 정보를 포함할 수 없습니다.",
                    "password": "$~비밀번호는 최소 /6자/ 이상이어야 합니다. 두 번 입력하고 비밀번호 관리자와 같이 안전한 곳에 적어 두세요. 연락처 정보를 수집하지 않으므로 계정을 분실하면 *계정을 복구할 방법이 없습니다*."
                }
            },
            "rights": {
                "header": "$~진상",
                "content": [
                    "$~안녕!",
                    "$~귀하와 우리의 권리에 대해 몇 가지 기대치를 설정해 봅시다(또한 <COPPA@https://www.ecfr.gov/current/title-16/chapter-I/subchapter-C/part-312>와 같은 정책에 비추어). 및 <GDPR@https://gdpr.eu/compliance-checklist-us-companies/>).",
                    "$~가장 먼저 알아야 할 것은 우리는 상업적인 실체가 아니라는 것입니다. 우리는 비영리 대학에서 진행되는 커뮤니티 기반 연구 프로젝트입니다. 우리의 목표는 여러분에게 즐거움을 선사하고 보다 공평하고 정의로운 컴퓨팅 세계를 발견할 수 있도록 돕는 플랫폼을 만드는 것입니다. 우리는 이 플랫폼에서 돈을 버는 데 관심이 없습니다. 우리가 모은 돈(대개 공공 자금을 통해)은 플랫폼을 유지하는 데 사용되며 플랫폼에서 작업하는(또는 기여하는) 사람을 풍요롭게 하는 데 사용되지 않습니다.",
                    "$~우리는 이익을 추구하지 않기 때문에 이는 이 플랫폼의 신뢰성, 가용성 또는 수명에 대해 어떠한 약속도 할 수 없음을 의미합니다. 그렇긴 하지만, <Amy@https://amyjko.phd>는 이를 장기적으로 유지하기 위해 노력하고 있으며 종신 교수로서 꽤 안정적인 활동을 하고 있습니다.",
                    "$~이는 *데이터*에 영향을 미칩니다. 우리가 클라우드에 수집하고 저장하는 내용은 다음과 같습니다.",
                    "$~• 귀하의 *프로젝트*. 해당 프로젝트에 전화번호, 이메일 주소, 사용자 이름, 세금 식별자 또는 주소와 같은 개인 식별 정보가 있는 것으로 나타나지 않는 한, 당사는 귀하가 기여한 모든 프로젝트와 변경 사항을 저장합니다.",
                    "$~• 귀하의 *설정*. 여기에는 선택한 언어, 애니메이션 기본 설정 및 튜토리얼 진행 상황이 포함됩니다. 다른 모든 내용은 귀하의 장치에만 저장됩니다.",
                    "$~• *활동*을 집계합니다. 당사는 로그인 정보와 귀하가 방문하는 페이지를 추적하지만 귀하를 식별하거나 사이트 전반에서 추적하거나 다른 사이트에서 귀하를 추적할 수 있는 방식은 아닙니다. 당사는 쿠키를 저장하거나 IP 주소 정보를 Google에 전송하지 않고 페이지 조회에 대해 식별할 수 없는 최소한의 정보만 수집하는 '동의 거부' 모드로 Google Analytics를 사용합니다. 우리는 이 집계 정보를 사용하여 플랫폼이 얼마나 사용되고 있는지 보고함으로써 자금 조달을 돕습니다.",
                    "$~우리는 다른 어떤 것도 저장하지 않습니다. <source@https://github.com/amyjko/wordplay/tree/main/src>는 공개되어 있어 누구나 이를 확인할 수 있고, 의도하지 않은 추적을 신고할 수 있습니다.",
                    "$~*귀하*는 당사가 아니라 귀하의 데이터를 소유합니다. 그 의미는:",
                    "$~• 프로젝트에 액세스할 수 있는 사람을 제어합니다. 기본적으로 비공개이지만 개인, 그룹과 공유하거나 완전히 공개할 수 있습니다.",
                    "$~• 언제든지 프로젝트나 자신의 계정을 완전히 삭제할 수 있습니다.",
                    "$~• 언제든지 프로젝트 또는 전체 계정을 내보낼 수 있습니다.",
                    "$~당사가 귀하의 데이터를 사용하는 방법과 사용하지 않는 방법은 다음과 같습니다.",
                    "$~• 법에서 명시적으로 요구하지 않는 한 귀하의 데이터를 누구와도 공유하지 않습니다. 귀하의 데이터가 허가 없이 유출될 가능성은 항상 있습니다('데이터 침해'). 이런 일이 발생했다는 사실을 발견하면 귀하가 당사와 공유한 이메일을 사용하여 이러한 일이 발생했음을 알려드립니다.",
                    "$~• 귀하가 1) 계정 변경을 요구하는 경우, 2) 귀하가 명시적으로 연락에 동의한 경우 또는 3) 위의 데이터 침해가 발생한 경우를 제외하고는 귀하의 이메일 주소로 연락하지 않습니다.",
                    "$~• 플랫폼의 프로젝트를 분석하여 모두가 무엇을 만들고 있는지, 어떻게 만들고 있는지 이해할 수 있습니다. 우리는 학술 출판물에서 이렇게 집계되고 익명화된 통찰력을 공유할 수 있습니다. 우리는 미국 연방법에 따라 기관 검토 위원회의 감독 하에서만 이 작업을 수행할 것입니다.",
                    "$~마지막으로 연설에 관한 메모입니다. 이 플랫폼에서 *비공개*로 원하는 내용을 말할 수 있습니다. 프로젝트는 기본적으로 비공개이며 특정 이메일 주소와 공유하는 경우에도 여전히 비공개로 간주됩니다. 우리는 비공개 프로젝트에 대해서는 어떤 것도 조정하지 않습니다.",
                    "$~하지만 프로젝트를 *공개*로 설정하거나 공개 갤러리에 포함시키는 것은 특권입니다. 이것은 사랑, 긍정, 존중, 존엄성을 위해 만들어진 플랫폼입니다. 따라서 귀하의 *공개* 콘텐츠는 다음과 같을 것으로 예상되지 않습니다."
                ],
                "consequences": [
                    "$~이러한 규칙을 위반하는 프로젝트나 갤러리를 발견하면 제작자가 보기 전에 경고하거나 볼 수 없도록 차단할 것입니다. 이러한 규칙을 반복적으로 위반하는 경우 공개적으로 게시할 수 있는 권한을 잃게 됩니다."
                ]
            },
            "donate": {
                "header": "$~기부",
                "prompt": "$~대역폭 비용을 지불하고 학생 및 교사 기여자에게 보상할 수 있도록 도와주세요.",
                "content": [
                    "$~Wordplay는 <University of Washington@https://washington.edu>에서 지원하는 무료 커뮤니티 기반 프로젝트입니다. 우리는 접근 가능하고 언어를 포함하며 교육적인 프로그래밍 언어라는 우리의 사명을 믿는 사람들의 선물에 의존합니다.",
                    "$~현재 비용은 다음과 같습니다.",
                    "$~• 우리는 워싱턴 대학교 학부생, 특히 장애가 있거나 모국어가 영어가 아닌 학부생에게 프로젝트를 발전시키고 유지하도록 보상합니다. 이는 우리 비용의 약 90%입니다.",
                    "$~• 우리는 접근 가능한 다국어 커리큘럼을 개발하기 위해 협력하는 교사에게 급여를 제공합니다.",
                    "$~• 우리는 <Firebase@https://firebase.google.com/> 대역폭과 저장 공간, <Workspace@https://workspace.google.com/> 서비스 비용을 Google에 지불합니다.",
                    "$~• 우리는 <Squarespace@https://www.squarespace.com/>에 매년 도메인 비용을 지불합니다.",
                    "$~학년도(36주) 동안 5명의 학부생이 시간당 $$20 USD, 주당 10시간, 여름(12주) 동안 2명의 학부생이 클라우드 서비스를 사용한다고 가정할 때 현재 비용은 클라우드 서비스당 약 $$60,000입니다. 년도.",
                    "$~2,400명의 사람들이 연간 $$25 USD를 기부한다면 이는 현재 비용을 충당할 수 있으며 초과분은 더 많은 학생과 교사에게 보상됩니다.",
                    "$~당신도 그 2,400명 중 한 명이 될 수 있나요? 그렇다면 워싱턴 대학의 링크를 참조하세요."
                ]
            },
            "teach": {
                "header": "$~가르치다",
                "prompt": {
                    "none": "$~선생님, 환영합니다! 학생 계정과 프로젝트 갤러리를 설정하고 관리할 수 있는 수업을 만드세요.",
                    "some": "$~선생님, 환영합니다! 수업을 관리하거나 새 수업을 만드세요."
                },
                "error": {
                    "offline": "$~교사 상태를 확인할 수 없습니다.",
                    "login": "$~수업을 관리하려면 로그인해야 합니다.",
                    "teacher": "$~수업을 만들고 관리하려면 교사 권한이 필요합니다. 이 양식을 작성하고 서로 알아가세요!"
                },
                "link": {
                    "request": "$~교사 권한 요청",
                    "new": "$~클래스 만들기"
                }
            },
            "newclass": {
                "header": "$~새로운 클래스",
                "subheader": {
                    "class": "$~당신의 수업",
                    "students": "$~귀하의 학생들",
                    "credentials": "$~사용자 이름과 비밀번호",
                    "submit": "$~제출하다"
                },
                "prompt": {
                    "start": "$~모든 학생을 위한 생성 계정이 있는 클래스를 만들고 모든 학생이 프로젝트를 추가할 수 있는 갤러리를 만들 수 있습니다. 학생에게 기존 계정이 있는 경우 나중에 추가할 수 있습니다.",
                    "review": "$~우리가 만든 사용자 이름과 비밀번호를 검토하세요. 진행하기 전에 *편집*하시겠습니까? 그럴 경우 위의 학생 정보를 편집할 수 없습니다.",
                    "ready": "$~위에서 자격 증명을 생성할 준비가 되면 알려주세요. 생성한 후에 편집할 수 있습니다.",
                    "pending": "$~사용자 이름과 비밀번호를 생성합니다...",
                    "submit": "$~제출할 준비가 되셨나요? 성공하자마자 이 정보의 다운로드를 받게 됩니다. 비밀번호는 *복구 불가능*하므로 안전한 곳에 보관하세요.",
                    "submitting": "$~위에 있는 사용자 이름과 비밀번호로 새로운 계정을 요청합니다...",
                    "download": "$~수업이 준비되었습니다! 다운로드 폴더에서 학생 데이터 다운로드를 볼 수 있습니다. *비밀번호는 복구할 수 없으므로* 이 파일을 안전한 곳에 보관하세요!"
                },
                "field": {
                    "name": {
                        "description": "$~클래스 이름",
                        "placeholder": "$~짧은 이름"
                    },
                    "description": {
                        "description": "$~설명",
                        "placeholder": "$~당신과 당신의 학생들을 위한 수업에 대한 설명입니다."
                    },
                    "existing": {
                        "label": "$~계정을 가진 학생들",
                        "prompt": "$~학생 중 이미 Wordplay 계정이 있는 사람이 있나요? 여기에 포함하세요."
                    },
                    "metadata": {
                        "description": "$~학생 정보",
                        "placeholder": "$~예를 들어, 학생 번호, 성, 이름",
                        "prompt": "$~학생을 위한 새 계정을 만들고 싶으신가요? 학생에 대한 *모든 정보*를 쉼표로 구분하여 한 줄에 하나씩 입력하세요. 이는 성, 이름, 학생 번호 또는 기타 구별되는 세부 정보일 수 있습니다. 이를 사용하여 아래에서 편집할 수 있는 사용자 이름을 생성하여 사용자 이름을 학습자와 연관시키는 데 도움이 됩니다."
                    },
                    "words": {
                        "description": "$~비밀번호에 사용할 단어",
                        "placeholder": "$~예를 들어, 고양이 점 쥐...",
                        "prompt": "$~최소 *25개 단어*를 제공하고 2-3개 단어의 기억하기 쉬운 비밀번호를 무작위로 생성합니다. 학생들이 아는 단어를 선택하거나 단어를 브레인스토밍하도록 요청합니다. 무작위가 많을수록 보안이 더 강화됩니다!"
                    },
                    "generate": {
                        "label": "$~생성하다",
                        "tip": "$~위 정보를 토대로 사용자 이름과 비밀번호를 생성하세요."
                    },
                    "edit": {
                        "label": "$~편집하다",
                        "tip": "$~생성된 학생 정보를 편집합니다"
                    },
                    "submit": {
                        "label": "$~클래스를 생성하다",
                        "tip": "$~이 정보로 새로운 클래스를 만듭니다."
                    }
                },
                "error": {
                    "duplicates": "$~학생 정보에 중복된 항목이 있습니다.",
                    "columns": "$~각 학생이 같은 개수의 열을 가지고 있는지 확인하세요.",
                    "generate": "$~고유한 사용자 이름을 만들 수 없습니다.",
                    "taken": "$~위에 있는 사용자 이름 중 하나 이상이 이미 사용 중입니다.",
                    "limit": "$~한 번에 35명이 넘는 학생이 있는 학급을 만들 수 없습니다.",
                    "words": "$~최소 25개 단어를 입력하세요.",
                    "account": "$~일부 계정을 만들 수 없습니다.",
                    "generic": "$~클래스를 만들 수 없습니다. 개발자가 무엇이 잘못되었는지 알아내는 데 도움이 되는 몇 가지 정보가 있습니다."
                }
            },
            "class": {
                "header": "$~수업",
                "subheader": {
                    "teachers": "$~교사들",
                    "students": "$~재학생",
                    "galleries": "$~갤러리"
                },
                "prompt": {
                    "gallery": "$~과제나 프로젝트를 정리하기 위해 학급을 위한 갤러리를 만드세요. 프로젝트에 참여하는 모든 교사는 갤러리 큐레이터가 되고 모든 학생은 갤러리 크리에이터가 됩니다.",
                    "delete": "$~이 수업을 삭제하면 수업 정보는 영구적으로 삭제되지만, 프로젝트, 갤러리, 학생 계정도 삭제됩니다."
                },
                "field": {
                    "name": {
                        "description": "$~클래스의 이름",
                        "placeholder": "$~이름"
                    },
                    "description": {
                        "description": "$~수업 설명",
                        "placeholder": "$~설명"
                    },
                    "newteacher": {
                        "placeholder": "$~이메일 또는 사용자 이름",
                        "description": "$~이 수업에 교사에게 접근 권한을 부여하려는 작성자의 이메일 또는 사용자 이름"
                    },
                    "addteacher": "$~이 수업에 교사 추가",
                    "delete": {
                        "tip": "$~이 수업을 영구히 삭제하세요.",
                        "label": "$~이 수업을 삭제합니다"
                    }
                },
                "error": {
                    "notfound": "$~이 수업을 찾을 수 없거나 이를 볼 수 있는 권한이 없습니다.",
                    "gallery": "$~이 수업에 대한 갤러리를 만들 수 없습니다."
                }
            },
            "characters": {
                "header": "$~캐릭터",
                "prompt": "$~프로젝트에 사용할 사용자 정의 이모티콘과 기호를 만들고 다른 사람들과 공유하세요.",
                "button": {
                    "new": "$~새로운 캐릭터를 생성하세요",
                    "copy": "$~이 문자를 복사하세요",
                    "remove": {
                        "tip": "$~이 문자를 삭제하세요",
                        "prompt": "$~삭제?"
                    }
                },
                "error": {
                    "offline": "$~온라인에 저장된 문자에 접근할 수 없습니다.",
                    "noauth": "$~캐릭터를 확인하고 새로운 캐릭터를 생성하려면 로그인해야 합니다.",
                    "create": "$~새로운 캐릭터를 만들 수 없습니다."
                },
                "subheader": {
                    "shared": "$~공유"
                }
            },
            "character": {
                "header": "$~성격",
                "prompt": "$~모양과 픽셀을 사용해 이모티콘이나 기호를 만들어보세요.",
                "instructions": {
                    "empty": "$~팔레트에서 그리기 모드를 선택하여 모양을 만듭니다.",
                    "unselected": "$~그리기 모드를 선택하거나 모양을 선택하여 편집합니다.",
                    "selected": "$~*화살표* 키를 사용하여 모양을 이동합니다. *shift* 키를 눌러 선택 항목에 모양을 더 추가합니다. *delete* 키를 사용하여 선택 항목을 제거합니다. 아래 컨트롤을 사용하여 선택한 모양을 변경합니다.",
                    "pixel": "$~픽셀을 그리려면 색상을 선택합니다. 그런 다음 캔버스를 클릭하거나 *화살표*를 사용하여 커서를 이동하고 *스페이스*를 사용하여 픽셀을 만듭니다. *더블 클릭*하여 채웁니다.",
                    "rect": "$~직사각형을 그리려면 색상과 획을 선택합니다. 그런 다음 클릭하고 드래그하거나 *화살표*와 *스페이스* 키를 사용하여 중심과 크기를 선택합니다.",
                    "ellipse": "$~타원과 원을 그리려면 색상과 획을 선택합니다. 그런 다음 클릭하고 드래그하거나 *화살표*와 *스페이스* 키를 사용하여 중심과 크기를 선택합니다.",
                    "path": "$~경로는 선분, 다각형 및 곡선일 수 있습니다. 클릭하여 점 추가를 시작하거나 *화살표* 키와 *스페이스*를 사용합니다. *esc*를 눌러 경로를 완료합니다. *delete*는 마지막 점을 제거합니다.",
                    "eraser": "$~모양을 지우려면 모양을 클릭하거나 탭합니다. 픽셀을 지우려면 드래그합니다. 지우개를 이동하려면 *화살표* 키를 사용하고 삭제하려면 *스페이스*를 사용합니다.",
                    "emoji": "$~픽셀로 가져올 이모지를 선택한 다음 원하는 대로 수정하세요."
                },
                "shape": {
                    "shape": "$~모양",
                    "pixel": "$~픽셀",
                    "rect": "$~구형",
                    "ellipse": "$~타원",
                    "path": "$~길",
                    "eraser": "$~지우개",
                    "emoji": "$~이모티콘"
                },
                "field": {
                    "name": {
                        "description": "$~캐릭터의 이름",
                        "placeholder": "$~이름"
                    },
                    "description": {
                        "description": "$~캐릭터 설명",
                        "placeholder": "$~설명"
                    },
                    "mode": {
                        "label": "$~방법",
                        "modes": [
                            "$~선택하다",
                            "$~지우개",
                            "$~픽셀",
                            "$~구형",
                            "$~타원",
                            "$~길",
                            "$~이모티콘"
                        ]
                    },
                    "fill": {
                        "label": "$~채우다",
                        "modes": ["$~없음", "$~불활성", "$~선택하다"]
                    },
                    "stroke": {
                        "label": "$~뇌졸중",
                        "modes": ["$~없음", "$~불활성", "$~선택하다"]
                    },
                    "none": "$~없음",
                    "inherit": "$~텍스트 색상",
                    "strokeWidth": {
                        "label": "$~스트로크 폭",
                        "tip": "$~스트로크가 얼마나 넓게 렌더링되는지"
                    },
                    "radius": {
                        "label": "$~모서리 반경",
                        "tip": "$~직사각형 모서리가 얼마나 둥글까"
                    },
                    "angle": {
                        "label": "$~각도",
                        "tip": "$~모양을 중심 주위로 얼마나 회전시킬 것인가"
                    },
                    "width": {
                        "label": "$~너비",
                        "tip": "$~모양이 얼마나 넓은지"
                    },
                    "height": {
                        "label": "$~키",
                        "tip": "$~모양이 얼마나 높은지"
                    },
                    "closed": "$~연결됨"
                },
                "button": {
                    "back": {
                        "label": "$~뒤쪽에",
                        "tip": "$~선택한 모양을 뒤로 이동합니다."
                    },
                    "toBack": {
                        "label": "$~뒤로",
                        "tip": "$~선택한 모양을 뒤로 이동합니다."
                    },
                    "forward": {
                        "label": "$~앞으로",
                        "tip": "$~선택한 모양을 앞으로 이동합니다."
                    },
                    "toFront": {
                        "label": "$~앞으로",
                        "tip": "$~선택한 모양을 앞으로 이동합니다."
                    },
                    "copy": {
                        "label": "$~복사",
                        "tip": "$~선택한 모양을 클립보드에 복사합니다."
                    },
                    "paste": {
                        "label": "$~반죽",
                        "tip": "$~클립보드에서 복사한 모양을 붙여넣습니다."
                    },
                    "clear": {
                        "label": "$~모두",
                        "tip": "$~모든 모양을 제거합니다."
                    },
                    "clearPixels": {
                        "label": "$~픽셀",
                        "tip": "$~모든 픽셀을 제거합니다."
                    },
                    "undo": {
                        "label": "$~끄르다",
                        "tip": "$~이전 디자인을 취소합니다"
                    },
                    "redo": {
                        "label": "$~다시 하다",
                        "tip": "$~다음 디자인으로 다시 실행"
                    },
                    "all": {
                        "label": "$~모두 선택",
                        "tip": "$~모든 모양과 픽셀을 선택하세요"
                    },
                    "end": {
                        "label": "$~마무리 모양",
                        "tip": "$~현재 경로를 종료합니다"
                    },
                    "horizontal": {
                        "label": "$~수평으로 뒤집다",
                        "tip": "$~중앙을 중심으로 수평으로 점을 뒤집습니다."
                    },
                    "vertical": {
                        "label": "$~수직으로 뒤집다",
                        "tip": "$~중앙을 중심으로 수직으로 점을 뒤집습니다."
                    },
                    "fit": {
                        "label": "$~맞다",
                        "tip": "$~캔버스에 모양을 맞추다"
                    }
                },
                "feedback": {
                    "name": "$~캐릭터는최소1자길이의유효한Wordplay이름이필요합니다.'UI',10진수또는16진수,내장언어기능의이름은될수없습니다.",
                    "description": "$~볼 수 없는 사람들이 무엇을 나타내는지 알 수 있도록 등장인물에 대한 설명이 필요합니다.",
                    "end": "$~또는 ESC를 누르세요.",
                    "loadfail": "$~이 문자를 로딩하는 중에 문제가 발생했습니다.",
                    "notfound": "$~이런 문자는 존재하지 않습니다.",
                    "unauthenticated": "$~문자를 편집하려면 로그인해야 합니다.",
                    "taken": "$~이미 이 이름을 가진 캐릭터가 있습니다. 저장하지 않습니다.",
                    "unsaved": "$~이 캐릭터에 대한 설명과 유효하고 고유한 이름을 입력하여 저장하세요."
                },
                "announce": {
                    "position": "$~1달러에 2달러",
                    "selection": "$~$1[선택됨 $1|선택된 것이 없습니다]"
                },
                "share": {
                    "dialog": {
                        "header": "$~공유하다",
                        "explanation": "$~이 캐릭터를 볼 수 있는 사람을 제한하려면 협력자를 추가하세요."
                    },
                    "button": {
                        "label": "$~공유하다",
                        "tip": "$~이 캐릭터를 공유하세요"
                    },
                    "delete": {
                        "label": "$~삭제",
                        "tip": "$~이 문자를 삭제하세요"
                    },
                    "public": {
                        "label": "$~시계",
                        "modes": ["$~공공의", "$~사적인"]
                    },
                    "collaborators": "$~협력자"
                }
            }
        },
        "edit": {
            "node": "$~$1$2[, $2|] 입력",
            "before": "$~$1[$1|끝] 이전",
            "inside": "$~$1에서 $2[$2|start]와 $3[$3|end] 사이",
            "between": "$~$1에서 $2 사이",
            "line": "$~$1[$1|start]와 $2[$2|end] 사이의 빈 줄",
            "conflicts": "$~$1 충돌",
            "assign": "$~/$2[가입 의향|탈퇴 고려]…/",
            "append": "$~/삽입하고 싶어…/",
            "remove": "$~/퇴사를 고려 중…/",
            "replace": "$~/참여하고 싶다…/",
            "wrap": "$~괄호 안에 넣다",
            "unwrap": "$~풀다",
            "bind": "$~이 표현의 이름을 지정하세요",
            "range": "$~$1에서 $2까지 선택 가능",
            "show": "$~… 더 보기"
        },
        "template": {
            "unwritten": "$~미정",
            "unparsable": "$~구문 분석할 수 없는 템플릿: $1"
        },
        "collaborate": {
            "label": "$~협력하다",
            "role": {
                "owner": "$~소유자",
                "collaborators": "$~협력자",
                "curators": "$~큐레이터"
            },
            "field": {
                "message": {
                    "description": "$~제출할 채팅 메시지",
                    "placeholder": "$~메시지를 입력하세요"
                }
            },
            "button": {
                "submit": {
                    "label": "$~보내다",
                    "tip": "$~협력자에게 메시지를 보내세요"
                },
                "start": {
                    "label": "$~채팅을 시작하세요",
                    "tip": "$~자신이나 다른 사람과 토론을 시작하세요."
                },
                "delete": "$~이 메시지를 삭제하세요"
            },
            "error": {
                "unowned": "$~이 프로젝트에는 소유자가 없으므로 채팅을 할 수 없습니다.",
                "offline": "$~이 채팅을 불러올 수 없습니다.",
                "empty": "$~메시지가 없습니다.",
                "deleted": "$~이 메시지는 삭제되었습니다."
            },
            "prompt": {
                "solo": "$~본인과 채팅을 하거나, 편집하고 채팅할 수 있는 공동 작업자를 추가하세요.",
                "owner": "$~공동 작업자는 이 프로젝트를 편집하고 이에 대해 채팅할 수 있습니다.",
                "collaborator": "$~당신은 협력자입니다. 이 프로젝트를 편집하고 이에 대해 이야기할 수 있습니다.",
                "curator": "$~당신은 이 프로젝트 갤러리의 큐레이터입니다. 이 프로젝트를 편집하고 이에 대해 이야기할 수 있습니다."
            }
        },
        "checkpoints": {
            "label": {
                "now": "$~지금",
                "history": "$~복원하다",
                "restore": "$~이것은 이 프로젝트의 이전 버전입니다.",
                "ago": "$~$1 $2 전"
            },
            "button": {
                "clear": "$~기록 삭제",
                "select": "$~이 버전 보기",
                "checkpoint": "$~이 버전의 프로젝트를 저장하세요",
                "back": "$~이전 버전으로 돌아가다",
                "forward": "$~다음 버전으로 돌아가기",
                "restore": "$~이 버전을 복원하다",
                "now": "$~현재 버전으로 돌아가기"
            }
        }
    },
    "moderation": {
        "warning": {
            "header": "경고",
            "explanation": "중재자는 이 콘텐츠가 다음과 같을 수 있다고 판단했습니다."
        },
        "blocked": {
            "header": "막힌",
            "explanation": "중재자는 이 콘텐츠가 다음과 같을 수 있다고 판단했습니다."
        },
        "unmoderated": {
            "header": "무중재",
            "explanation": "이 콘텐츠는 아직 중재재되지 않았습니다. 중재할수도도 있습니다."
        },
        "moderate": {
            "header": "중재하기",
            "explanation": "이 프로젝트를 검토하고 콘텐츠가 다음 중 하나를 수행하는지 결정하세요. 만약 그렇다면 콘텐츠에 경고가 표시되거나 차단됩니다. 확실하지 않으면 건너뛰어도 됩니다."
        },
        "flags": {
            "violence": "누구에게나 폭력, 해로움, 자해를 선동하거나 격려하거나 칭찬한다.",
            "dehumanization": "인종, 민족, 출신 국가, 계급, 성적 취향, 성별, 종교, 나이, 능력 또는 외모를 기준으로 개인이나 집단을 비인간화한다.",
            "disclosure": "이름, 연락처 정보, 실제 주소 등 다른 사람의 개인 정보를 공개한다.",
            "misinformation": "허위, 오해의 소지가 있거나 기만적이거나 조작된 정보가 포함되어 있습니다."
        },
        "progress": "*$1* 중재됨, *$2* 남음",
        "button": {
            "submit": {
                "tip": "이 중재 설정을 저장하세요",
                "label": "저장"
            },
            "skip": {
                "tip": "이 프로젝트 건너뛰기",
                "label": "건너뛰기"
            }
        }
    },
    "gallery": {
        "games": {
            "name": "게임",
            "description": "단어와 기호가 포함된 대화형 게임입니다."
        },
        "visualizations": {
            "name": "시각화",
            "description": "텍스트를 통한 시각화."
        },
        "motion": {
            "name": "움직임",
            "description": "움직임과 충돌의 예."
        },
        "av": {
            "name": "오디오/비디오",
            "description": "볼륨, 피치, 비디오를 입력으로 사용합니다."
        },
        "tools": {
            "name": "도구",
            "description": "간단한 유틸리티 와와 애플리케이션."
        },
        "stories": {
            "name": "$~스토리",
            "description": "$~대화형 스토리와 내러티브."
        }
    }
}
