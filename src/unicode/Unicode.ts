// Generated by unicode/compress.js. Run with Node.
import UnicodeDataTxt from './codes.txt?raw';
import WordplayCategoryJson from './wordplay-categories.json';
import fuzzysort from 'fuzzysort';

export type WordplayCategories = 'emojis' | 'arrows' | 'shapes' | 'other';

type Codepoint = {
    hex: number;
    name: string;
    unicodeCategory: string;
    wordplayCategory: WordplayCategories;
    emoji: { group: string; subgroup: string } | undefined;
};

const codepoints: Codepoint[] = [];
const wordplayCategoryMap = WordplayCategoryJson as Record<
    string,
    WordplayCategories
>;

for (const entry of UnicodeDataTxt.split('\n')) {
    const [code, name, category, group, subgroup] = entry.split(';');

    const isEmoji = group && subgroup;

    codepoints.push({
        hex: parseInt(code, 16),
        name: name.toLowerCase(),
        unicodeCategory: category,
        wordplayCategory: isEmoji
            ? 'emojis'
            : wordplayCategoryMap[code] || 'other',
        emoji: group && subgroup ? { group, subgroup } : undefined,
    });
}

export function getUnicodeNamed(
    name: string,
    wordplayCategory?: WordplayCategories,
    limit = 300,
    all = true,
) {
    name = name.toLowerCase();

    const filteredCodepoints = codepoints.filter(
        (point) => point.wordplayCategory === wordplayCategory,
    );

    const result =
        name.length > 0
            ? fuzzysort
                  .go(name, filteredCodepoints, {
                      key: 'name',
                      limit,
                  })
                  .map((result) => result.obj.hex)
            : filteredCodepoints
                  .map((point) => point.hex)
                  .slice(0, all ? filteredCodepoints.length : limit);

    return result;
}

export function getEmoji() {
    return codepoints.filter((point) => point.wordplayCategory === 'emojis');
}
