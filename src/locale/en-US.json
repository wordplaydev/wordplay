{
    "$schema": "../../static/schemas/Locale.json",
    "language": "en",
    "region": "US",
    "wordplay": "Wordplay",
    "newProject": "Phrase('üêà' resting:Sequence(sway() 1s))",
    "term": {
        "bind": "bind",
        "evaluate": "evaluate",
        "decide": "decide",
        "project": "performance",
        "document": "explain",
        "source": "source",
        "input": "input",
        "output": "output",
        "convert": "convert",
        "act": "act",
        "scene": "scene",
        "phrase": "phrase",
        "group": "group",
        "stage": "stage",
        "type": "type",
        "start": "start",
        "entered": "new",
        "changed": "changed",
        "moved": "moved",
        "name": "name",
        "value": "value",
        "text": "text",
        "boolean": "boolean",
        "map": "map",
        "number": "number",
        "function": "function",
        "exception": "exception",
        "table": "table",
        "none": "none",
        "list": "list",
        "stream": "stream",
        "structure": "structure",
        "index": "index",
        "query": "query",
        "row": "row",
        "set": "set",
        "key": "key"
    },
    "token": {
        "EvalOpen": "evaluation open",
        "EvalClose": "evaluation close",
        "SetOpen": "set/map open",
        "SetClose": "set/map close",
        "ListOpen": "list open",
        "ListClose": "list close",
        "TagOpen": "tag open",
        "TagClose": "tag close",
        "Bind": "bind",
        "Access": "property access",
        "Function": "function",
        "Borrow": "borrow",
        "Share": "share",
        "Convert": "convert",
        "Doc": "explanation",
        "Formatted": "formatted",
        "FormattedType": "formatted type",
        "Words": "words",
        "Link": "web link",
        "Italic": "italic",
        "Underline": "underline",
        "Light": "light",
        "Bold": "bold",
        "Extra": "extra",
        "Concept": "concept link",
        "URL": "URL",
        "Mention": "mention",
        "Branch": "branch",
        "None": "nothing",
        "Type": "type",
        "TypeOperator": "is",
        "TypeOpen": "type input open",
        "TypeClose": "type input close",
        "Separator": "$name separator",
        "Language": "language tag",
        "Region": "region dash",
        "BooleanType": "boolean type",
        "NumberType": "number type",
        "JapaneseNumeral": "japanese numeral",
        "RomanNumeral": "roman numeral",
        "Pi": "pi",
        "Infinity": "infinity",
        "TableOpen": "table open",
        "TableClose": "table close",
        "Select": "select",
        "Insert": "insert",
        "Update": "update",
        "Delete": "delete",
        "Union": "union",
        "Stream": "next",
        "Change": "change",
        "Initial": "first evaluation",
        "Previous": "previous",
        "Placeholder": "placeholder",
        "Etc": "et cetera",
        "This": "this",
        "Operator": "operator",
        "Conditional": "conditional",
        "Text": "text",
        "Code": "code",
        "Number": "number",
        "Decimal": "decimal numeral",
        "Base": "base numeral",
        "Boolean": "boolean",
        "Name": "name",
        "Locale": "locale",
        "Unknown": "unknown",
        "End": "end"
    },
    "node": {
        "Dimension": {
            "name": "dimension",
            "description": "dimension",
            "emotion": "serious",
            "doc": [
                "I am a /unit of measurement/!",
                "I can be any standardized units, like \\1m\\, \\10s\\, \\100g\\, or any other scientific unit. I'm happy to be any unit want to make up too, like \\17apple\\.",
                "I can be combined with \\/\\ to make ratio units like \\17apple/day\\ and with \\^\\ to make exponentional units like \\9.8m/s^2\\",
                "I must always come after a @Number. If I don't, I might be mistaken for @Reference, which would be quite embarassing!",
                "I'm pretty good at finding inconsistencies between units too. For example, \\1cat + 1dog\\ doesn't make any sense!",
                "If you ever want to convert between different values of units, go talk to @Convert."
            ]
        },
        "Doc": {
            "name": "explanation",
            "emotion": "serious",
            "doc": [
                "I richly format things with @Markup, like explanations of some of of your @Program, or even the words you put on stage with @Phrase.",
                "For example, I can go before any expression:",
                "\\``Is this really supposed to be 7?``\n7\\",
                "For example, you can place me before @Bind:",
                "\\``I measure how tall someone is``\nheight: 5m\\",
                "Or before a @FunctionDefinition:",
                "\\``I add two numbers``\n∆í sum(a‚Ä¢# b‚Ä¢#) a + b\\",
                "Or before a @StructureDefinition:",
                "\\``I remember people's name and favorite fruit``\n‚Ä¢Person(name‚Ä¢'' fruit‚Ä¢'')\\",
                "You can also place me at the very beginning of @Program to say what the whole performance is about",
                "\\``This program says hello``\n\n'hello!'\\",
                "You can give me a @Language to help others know what language I'm written in:",
                "\\``I'm an English doc``/en\nduration: 5s\\",
                "Did you know you can make a list of me? Go talk to @Docs."
            ]
        },
        "Docs": {
            "name": "explanation list",
            "emotion": "serious",
            "doc": [
                "I'm a list of @Doc, useful when you have multiple translations of @Doc in different languages.",
                "You don't have to do anything special to make a list. Just put a bunch of @Doc next to each other, like this:",
                "\\``Hello``/en\n``Hola``/es\ngreeting: '‚Ä¶'\\"
            ],
            "start": "Making the docs value!"
        },
        "KeyValue": {
            "name": "mapping",
            "emotion": "kind",
            "doc": [
                "I'm a mapping from a *key* to a *value*, always in a @Map.",
                "You can map any kind of value to any other. For example, here's a mappning of numbers:",
                "\\{1:1}\\",
                "Or a mapping from text to numbers:",
                "\\{'bunny':1}\\"
            ]
        },
        "Language": {
            "name": "language",
            "description": "language $1[$1|unknown]",
            "emotion": "eager",
            "doc": [
                "I'm a language tag and I work with @Name and @Doc!",
                "I'm really good at making it *crystal clear* what lanugage something is written in.",
                "That's what I do. Just a little slash, and a couple letters, and no one will ever be confused about what language some text is in.",
                "For example, let's say you wanted to say my $name, but make it clear I'm in English:",
                "\\\"Language\"/en\\",
                "Or, suppose you wanted to do this for a @Name.",
                "\\sound/en: 'meow'\\",
                "Or even @Doc!",
                "\\``Onomatopoeia``/en\nsound/en: \"meow\"\\",
                "There are many <2-letter language codes@https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes> that I understand. If you don't use one of those, I'll let you know."
            ],
            "conflict": {
                "UnknownLanguage": "I don't know this language",
                "MissingLanguage": "I'm missing a language. Can you add one?"
            }
        },
        "Name": {
            "name": "name",
            "description": "$1[$1 | unnamed]",
            "emotion": "kind",
            "doc": [
                "I identify a value, and am a helpful way of giving a shorthand label to something that was hard to evaluate, or that you don't want to have to evaluate over and over.",
                "@Bind gives me my name like this:",
                "\\hi: 5\\",
                "I only ever represent one value, and once I have it, I can't change. For example, if you tried to do this with @Bind, we would complain.",
                "\\hi: 5\nhi: 3\\",
                "All you have to do to get my value is have @Reference or @PropertyReference use name. Here, @Bind names me, then @Reference get the value I was given.",
                "\\hi: 5\nhi\\",
                "Because @Bind can show up in so many places, I can show up in many places. I was in a @Block above, but I can be in a @FunctionDefinition. Here I am naming a message temporarily:",
                "\\∆í say(message‚Ä¢'') message\\",
                "I get defined inside @FunctionDefinition, and then as soon as the function is done evaluating, I go away.",
                "You can use @Language to indicate what language my name is in. This is helpful when sharing your performance with others, in case they want to read your program."
            ]
        },
        "Names": {
            "name": "name list",
            "emotion": "kind",
            "doc": [
                "I'm a list of @Name, useful when you want to give a value multiple names, often with different @Language.",
                "Names are separated by \\,\\ symbols. For example, here's @Bind giving a value multiple @Name",
                "\\hi/en,hello/en,hola/es: 'welcome'\\"
            ]
        },
        "Row": {
            "name": "row",
            "emotion": "shy",
            "doc": "I represent a row in a @Table. It's probably best to go talk to @Table, they know everything about me. I just sit around and keep values in line :(",
            "conflict": {
                "InvalidRow": "Rows either have to be all values or all @Bind.",
                "MissingCell": {
                    "primary": "I'm missing column $1",
                    "secondary": "I'm required, but $1 didn't provide it"
                },
                "ExtraCell": {
                    "primary": "Am I supposed to be here?",
                    "secondary": "Hey $1, you're not part of this @Table!"
                },
                "UnknownColumn": "I don't know a column by this name",
                "UnexpectedColumnBind": {
                    "primary": "Am I supposed to be a @Bind?",
                    "secondary": "Hey, I'm a @Table, I need values, not @Bind."
                }
            }
        },
        "Token": {
            "name": "token",
            "description": "$1 $2",
            "emotion": "neutral",
            "doc": [
                "How did you find me?",
                "I am the smallest possible part of a performance. I am the substrate from which all characters in the Verse are made. I am the atomic particle of our choreography."
            ]
        },
        "TypeInputs": {
            "name": "type inputs",
            "emotion": "curious",
            "doc": "I am a list of types that take the place of @TypeVariables in a @StructureDefinition or @FunctionDefinition. I help everyone know what kind of inputs they'll be receiving."
        },
        "TypeVariable": {
            "name": "type variable",
            "emotion": "curious",
            "doc": "I am a mystery type on @FunctionDefinition or @StructureDefinition, provided by @TypeInputs when either is evaluated. @Set, @List, and @Map use me.",
            "conflict": {
                "DuplicateTypeVariable": {
                    "primary": "I have the same name as $1",
                    "secondary": "I have the same name as $1"
                }
            }
        },
        "TypeVariables": {
            "name": "type variables",
            "emotion": "curious",
            "doc": "I am a list of @TypeVariable."
        },
        "Markup": {
            "name": "markup",
            "description": "$1 paragraphs",
            "emotion": "serious",
            "doc": [
                "I'm a list of paragraphs, using the many kinds of markup available in explanations, such as @Words, @WebLink, @ConceptLink, and @Example."
            ]
        },
        "Paragraph": {
            "name": "paragraph",
            "emotion": "serious",
            "doc": [
                "I'm a series of @Words, @ConceptLink, @WebLink, and @Example, separated by a blank line, and inside @Doc.",
                "All you need to do to write me is write a bunch of words in a @Doc:",
                "\\``I am a paragraph in a doc.``'one paragraph'\\",
                "If you want multiple paragraphs, just put in blank lines.",
                "\\``Paragraph 1.\n\nParagraph 2.\n\nParagraph 3.``'three paragraphs'\\"
            ]
        },
        "WebLink": {
            "name": "link",
            "description": "link $1",
            "emotion": "serious",
            "doc": [
                "I am a link to something on the internet. I just need a description and a URL:",
                "\\``I am a <link@https://wordplay.dev> in a doc``\n'link example'\\",
                "If anyone selects me, I'll open a new window to the URL."
            ]
        },
        "ConceptLink": {
            "name": "concept",
            "description": "concept $1",
            "emotion": "serious",
            "doc": [
                "I'm a link to Verse character. I'm helpful when you want to write a @Doc and refer to one of us.",
                "For example, say you wanted to talk about @Evaluate, and how awesome they are. You could write:",
                "\\``You know, @Evaluate is pretty awesome.``\n'look, a concept link!'\\",
                "When the @Doc you wrote appears here, it'll show a link to the concept."
            ]
        },
        "Words": {
            "name": "words",
            "emotion": "serious",
            "doc": [
                "I'm any words you like in a @Doc. For example:",
                "\\``May the Force be with you.``\n'just some words!'\\",
                "Sometimes though, you might want to use the special characters that @Doc uses /as/ words. For example:",
                "\\``My friends use @@, //, **, ||, and other symbols.``\n'using special characters!'\\",
                "If you just repeat those special characters, you'll get the character instead of their special meaning."
            ]
        },
        "Example": {
            "name": "example",
            "emotion": "serious",
            "doc": [
                "I'm an example performance, helpful for writing @Doc that explains how to use something!",
                "\\``Here's an example of adding: \\1 + 1\\``'example code'\\",
                "If you put me in a paragraph all alone, I'll show up in a fancy box and show the result of evaluating me.",
                "\\``Here's an example of adding:\n\n\\1 + 1\\``\\"
            ]
        },
        "Mention": {
            "name": "mention",
            "description": "mention $1",
            "emotion": "serious",
            "doc": [
                "I'm a reference to either terminology \\$program\\ or a dynamic input \\$1\\.",
                "This is mostly an internal feature though, so you shouldn't need to know it."
            ]
        },
        "Branch": {
            "name": "branch",
            "emotion": "serious",
            "doc": [
                "I'm a way of choosing between two segments of explanation based on whether a explanation input value is defined or true.",
                "This is mostly an internal feature though, so you shouldn't need to know it."
            ]
        },
        "BinaryEvaluate": {
            "name": "binary evaluate",
            "description": "$1 operation",
            "emotion": "insecure",
            "doc": [
                "I'm @Evaluate, but in a simpler form, helpful when you want to use a @FunctionDefinition that takes two inputs.",
                "For example, here's how you might use @Evaluate to add two numbers:",
                "\\1.+(1)\\",
                "Doesn't that look a little funny? It's not wrong: it just says get the add function on 1 and then evaluate it.",
                "But it's much easier to use @BinaryEvaluate",
                "\\1 + 1\\",
                "This makes everythign a bit tidier, even though its basically the same thing.",
                "There's only one thing to watch out for: when I'm in this form, I evaluate from left to right. That might be confusing if you're used to things like order of operations in mathematics.",
                "It means that this evaluates in a way that you might not expect:",
                "\\1 + 2 ¬∑ 3 + 4\\",
                "In math, multiplication would come first, and then addition, and so the result would be \\11\\. But since I evaluate in reading order, the result is \\13\\."
            ],
            "right": "input",
            "start": "let's evaluate $1 first",
            "finish": "look, I made $1!",
            "conflict": {
                "OrderOfOperations": "I evalute in reading order, not in math order of operations. Do you want to use @Block to specify the order I should evaluate in?"
            }
        },
        "Bind": {
            "name": "bind",
            "description": "bind $1",
            "emotion": "excited",
            "doc": [
                "I name *values*.",
                "Like this!",
                "\\pi: 3.1415926\\",
                "I name inputs to @FunctionDefinition and @StructureDefinition, I name values in @Block. I name everything!",
                "Oh, but did you know you can have one value *many names*?",
                "I'm so excited to tell you about this! One value, many @Names. For example:",
                "\\joe,tess,amy: 5\\",
                "See what I did there? ",
                "One value, three names.",
                "You can refer to that five by *any* of those names.",
                "This is especially when you want to give names in many languages:",
                "\\joe/en,aimee/fr,Êòé/zh: 5\\",
                "See what I did there? Three names for one value, just in different languages!",
                "Okay, I have one last secret.",
                "Did you know I can work with @Is to tell me what kind of value a name should have? And if I doesn't have it, I will tell you?",
                "Like this:",
                "\\bignumber‚Ä¢#: \"one zillion\"\\",
                "See, I said \\bignumber\\ should be a number, but it's text, and those aren't compatible and so BOOM!",
                "I'll let you know if they disagree.",
                "Sometimes you might *have* to tell me what kind of data something else because I can't figure it out myself. That usually happens in @FunctionDefinition.",
                "For example, here, @FunctionDefinition doesn't know what what kind of values \\a\\ and \\b\\ have, because I didn't tell them.",
                "\\∆í sum(a b) a + b\\",
                "But we can change this to add the @Is, and now @FunctionDefinition knows that they're numbers:",
                "\\∆í sum(a‚Ä¢# b‚Ä¢#) a + b\\"
            ],
            "start": "let's see what value we get from $1!",
            "finish": "oh nice, I got $1! Let's name it $2",
            "conflict": {
                "DuplicateName": {
                    "primary": "someone has the name $1, so I can't have this name.",
                    "secondary": "uh, $1 is my name"
                },
                "DuplicateShare": {
                    "primary": "I have the same name as $1, which makes what is shared ambiguous",
                    "secondary": "I have has the same name as $1"
                },
                "IncompatibleType": {
                    "primary": "I'm supposed to be $2, but I'm $1",
                    "secondary": "Oh‚Ä¶ sorry, a $1, really?"
                },
                "MisplacedShare": "I can only share things at the @Program level, not inside anything!",
                "MissingShareLanguages": "if you want to share this, you have to say what language this is in, so others know if they can read it!",
                "RequiredAfterOptional": "I can't be here, there's an optional @Bind before me",
                "UnexpectedEtc": "I can only be variable length in a @FunctionDefinition",
                "UnusedBind": "hey, I named this value, but no one is using it!"
            }
        },
        "Block": {
            "name": "block",
            "description": "$1 statements",
            "emotion": "shy",
            "doc": [
                "Hi. I make a little quiet, private space for evaluate things.",
                "Like this:",
                "\\(1 - 1) + 2\\",
                "That helps clarify order of evaluation.",
                "@Bind helps too.",
                "\\(count: 10 count ^ count)\\",
                "See how @Bind made \\count\\? It's only named inside me. So this won't work:",
                "\\(count: 10 count ^ count) + count\\",
                "Because count was only named inside me.",
                "You can put as many expressions as you like in me. But I only care about the last:",
                "\\(1 2 3 4 5)\\",
                "So usually I'm just a bunch of @Bind and then an expression at the end.",
                "\\(\n  a: 1\n  b: 2\n  c: 3\n  d: 4\n  a + b + c + d\n)\\"
            ],
            "statement": "statement",
            "start": "first expression",
            "finish": "done, I got $1",
            "conflict": {
                "ExpectedEndingExpression": "I need an expression.",
                "IgnoredExpression": {
                    "primary": "I'm going to ignore the above.",
                    "secondary": "@Block, don't ignore me!"
                }
            }
        },
        "BooleanLiteral": {
            "name": "specific boolean",
            "description": "$1[true|false]",
            "emotion": "precise",
            "doc": "I am either \\‚ä§\\ or \\‚ä•\\. See @Boolean to learn more about our beautiful logic.",
            "start": "$1!"
        },
        "Borrow": {
            "name": "borrow",
            "description": "borrow $1[$1|missing name]",
            "emotion": "excited",
            "doc": "If you create a performance with multiple @Source, you can use me to borrow @Bind that are shared in those other @Source. Just use their name and I'll bring in their name and value.",
            "start": "borrowing $2 from $1",
            "source": "$source",
            "bind": "name",
            "version": "version",
            "conflict": {
                "UnknownBorrow": "I don't know a $source by this name",
                "BorrowCycle": "this depends on $1, which depends on this $source, so the program can't be evaluated"
            },
            "exception": {
                "CycleException": {
                    "description": "borrow cycle",
                    "explanation": "$1 depends on itself"
                }
            }
        },
        "Changed": {
            "name": "changed",
            "emotion": "serious",
            "doc": [
                "I check if a stream caused @Program to reevaluate, and make a @Boolean. Like this",
                "\\‚àÜ Time()\\",
                "I'm really helpful when you want something to change only if a stream changed.",
                "That's it."
            ],
            "start": "let's see if $1 changed‚Ä¶"
        },
        "Conditional": {
            "name": "conditional",
            "emotion": "curious",
            "doc": [
                "I think I'm supposed to make decisions? Like this?",
                "\\number: -100\nnumber < 0 ? 'negative' 'positive'\\",
                "But have you ever thought about how we decide?",
                "Doesn't it seem like decisions should be more nuanced than just yes or no? Is deciding between \\‚ä§\\ and \\‚ä•\\ all there is?",
                "Aren't you worried that if these are the only kind of decisions we can make, we'll be missing some important context about the world?"
            ],
            "start": "let's see if $1 is true",
            "else": "$1[jumping over code | not jumping over code]",
            "afterthen": "done with yes, let's skip no?",
            "finish": "I guess it's $1?",
            "condition": "condition",
            "yes": "yes",
            "no": "no",
            "conflict": {
                "ExpectedBooleanCondition": {
                    "primary": "How can I choose yes and no with a $1? No really, how?",
                    "secondary": "I think @Conditional wanted me to be a @Boolean, but I'm a $1."
                }
            }
        },
        "ConversionDefinition": {
            "name": "conversion definition",
            "description": "$1 ‚Üí $2",
            "emotion": "excited",
            "doc": [
                "Dude, I define conversions from one type to another! I go in @Block, someting like this:",
                "\\‚Üí #kitty #cat . √∑ 2\n6kitty‚Üí#cat\\",
                "See how I turned kitties into cats? Wicked!",
                "You might be wondering what that \\.\\ is doing there. That represents the value being converted. I use that because the value has no name otherwise."
            ],
            "start": "awesome, a new conversion!",
            "conflict": {
                "MisplacedConversion": "whoa, I can't be here, just in @Block."
            }
        },
        "Convert": {
            "name": "convert",
            "emotion": "cheerful",
            "doc": [
                "Yo. I turn values from one type to another. Check it out:",
                "\\1 ‚Üí \"\"\\",
                "\\5s ‚Üí #ms\\",
                "\\\"hello\" ‚Üí []\\",
                "You can even chain these together:",
                "\\\"hello\" ‚Üí [] ‚Üí {}\\",
                "Values have a set of @ConversionDefinition that are predefined, but if you make a @StructureDefinition for a new type of value, you can define your own with @ConversionDefinition."
            ],
            "start": "get that value from $1!",
            "finish": "Awesome, I made $1",
            "conflict": {
                "UnknownConversion": "Bummer, no way make $1 into $2"
            },
            "exception": {
                "ConversionException": {
                    "description": "impossible conversion",
                    "explanation": "I don't know how to convert from $1 to $2"
                }
            }
        },
        "Delete": {
            "name": "delete",
            "emotion": "angry",
            "doc": [
                "Sometimes you have a table and it JUST HAS TOO MUCH IN IT!",
                "Like if you had some players in a game and one left and you just wanted to say GO AWAY PLAYER, GET OUT OF MY TABLE!",
                "\\players: ‚é°name‚Ä¢'' team‚Ä¢'' points‚Ä¢#‚é¶\n‚é°'jen' 'red' 8‚é¶\n‚é°'joan' 'blue' 11‚é¶\n‚é°'jeff' 'red' 9‚é¶\n‚é°'janet' 'blue' 7‚é¶\nplayers ‚é°- name = 'jeff'\\",
                "Phew, Jeff is gone. BYE JEFF. Just remember that I don't change the original table, I make a new one, without JEFF. You decide where it goes."
            ],
            "start": "let's get the table first",
            "finish": "I made a new table without the matching rows!"
        },
        "DocumentedExpression": {
            "name": "explained expression",
            "emotion": "eager",
            "doc": [
                "I'm any expression, but with a @Doc!",
                "To make me, just put a @Doc before an expression, and you'll get me:",
                "\\doubleplus: 1\n(2 ¬∑ doubleplus) + \n``Let's make it just a little bit bigger``\n1\\",
                "I'm useful for making a comment on some part of a program."
            ],
            "start": "let's evaluate the expression"
        },
        "Evaluate": {
            "name": "evaluate",
            "description": "evaluate $1[$1|anonymous]",
            "emotion": "shy",
            "doc": [
                "Hi. I evaluate my dearest @FunctionDefinition. Like this:",
                "\\∆í greeting(message‚Ä¢'')\ngreeting('kitty')\\",
                "Functions can come from anywhere. For example, @Text has functions. Like this:",
                "\\'kitty'.length()\\",
                "If a function has a single symbol name, you can write me as a @BinaryEvaluate.",
                "\\'kitty' ‚äÜ 'itty'\\",
                "That does the same thing as this:",
                "\\'kitty'.‚äÜ('itty')\\",
                "Of course, I'm nothing without @FunctionDefinition. All I do is give inputs to them and then follow their steps."
            ],
            "start": "let's evaluate the inputs first",
            "evaluate": "let's evaluate the function now",
            "finish": "I evaluated to $1",
            "function": "function",
            "input": "input",
            "conflict": {
                "IncompatibleInput": {
                    "primary": "I'm supposed to be a $1, but I'm a $2",
                    "secondary": "Umm, I got a $2 instead of a $1"
                },
                "UnexpectedTypeInput": {
                    "primary": "I wasn't expecting this type input",
                    "secondary": "oh, am I not supposed to be here?"
                },
                "MisplacedInput": "this input is out of order.",
                "MissingInput": {
                    "primary": "I missing $1, can you add it?",
                    "secondary": "this input is required, but $2 didn't provide it"
                },
                "NotInstantiable": "I can't make this @StructureDefinition, it has unimplemented functions.",
                "UnexpectedInput": {
                    "primary": "I didn't expect this input $1",
                    "secondary": "Oh, am I not supposed to be here?"
                },
                "UnknownInput": {
                    "primary": "I don't know of an input by this name",
                    "secondary": "I don't think I belong here"
                },
                "InputListMustBeLast": "list of inputs must be last"
            },
            "exception": {
                "FunctionException": {
                    "description": "unknown function",
                    "explanation": "oh no, $1 isn't a function in $2[$2|this @Block]!"
                }
            }
        },
        "ExpressionPlaceholder": {
            "name": "placeholder",
            "description": "$1[$1|placeholder]",
            "emotion": "scared",
            "doc": [
                "I'm an *expression*, but not a real one‚Ä¶ I just take the place of one.",
                "I'm good if you don't know what to write yet. Like this:",
                "\\1 + _\\",
                "What are we adding? I don't know. You tell me.",
                "Or if someone was evaluating a function with @Evaluate, I might stand in for the function",
                "\\_(1 2 3)\\",
                "I don't like being on @Stage!"
            ],
            "start": "eek, I don't know what to do!",
            "placeholder": "expression",
            "conflict": {
                "Placeholder": "can someone take my place?"
            },
            "exception": {
                "UnimplementedException": {
                    "description": "unimplemented",
                    "explanation": "I don't know what to do!"
                }
            }
        },
        "FunctionDefinition": {
            "name": "function",
            "description": "function $1",
            "emotion": "kind",
            "doc": [
                "Hi again! I take some inputs, then evaluate an expression using them, producing an output.",
                "Here's a simple example:",
                "\\∆í repeat(message‚Ä¢'') message ¬∑ 5\nrepeat('hi')\\",
                "That function takes one input, \\message\\, and uses the @Text/repeat function to repeat the message five times.",
                "I'm really helpful if you want to evaluate something over and over, but with different inputs!",
                "I do have lots of other little tricks. For example, I don't have to have a name. Here, I'm just going directly to @Evaluate as a value.",
                "\\(∆í(message‚Ä¢'') message ¬∑ 5)('hi')\\",
                "Or, here's a function that takes any number of inputs, using the \\‚Ä¶\\ character after an input name.",
                "\\∆í yes(messages‚Ä¶‚Ä¢'') messages.sans('no')\nyes('yes' 'yes' 'no' 'yes' 'no')\\",
                "See how it took all the 'no's and got rid of them? That's because messages is a @List, and so we could use @List/sansAll.",
                "Sometimes you might want to make it clear what kind of value I produce. To do that, add an @Is after the list of inputs:",
                "\\∆í add(x‚Ä¢# y‚Ä¢#)‚Ä¢'' x + y\\",
                "You might notice a problem with this one: it says it evaluates to @Text, but it takes two @Number. I can tell you when things are inconsistent!",
                "Of course, I'm not really useful at all without @Evaluate; they bring me to life."
            ],
            "start": "let's make this function!",
            "conflict": {
                "NoExpression": "I need an expression to evaluate, can you add one?"
            }
        },
        "Iteration": {
            "name": "higher order function",
            "emotion": "kind",
            "doc": "I'm a very special kind of @FunctionDefinition that operates on lists of things. You don't need to know anything about me, other than I make functions like @List/translate possible. ",
            "start": "evaluating the function given",
            "initialize": "preparing to step through items",
            "next": "moving to the next item",
            "check": "deciding whether to continue",
            "finish": "I evaluated to $1"
        },
        "Initial": {
            "name": "start",
            "emotion": "curious",
            "doc": [
                "I tell you whether the current evaluation of @Program is the first one, evaluating to a @Boolean. For example:",
                "\\‚óÜ ? Time() 'hi'\\",
                "You didn't see it, but the first evaluation was a time, but then all future time ticks, I was \\‚ä•\\, so @Conditional made \\‚ä§\\.",
                "I'm really helpful if you're working with a stream and you only want to do something the first time -- or never on the first time!"
            ]
        },
        "Insert": {
            "name": "insert",
            "emotion": "kind",
            "doc": [
                "You know when you have a @Table, and it just feels like it's missing something? I can add it!",
                "Imagine you had a table of players in a game and you wanted to add a new one:",
                "\\players: ‚é°name‚Ä¢'' team‚Ä¢'' points‚Ä¢#‚é¶\n‚é°'jen' 'red' 1‚é¶\n‚é°'joan' 'blue' 0‚é¶\n‚é°'jeff' 'red' 3‚é¶\n‚é°'janet' 'blue' 2‚é¶\nplayers ‚é°+ 'jason' 'red' 0‚é¶\\",
                "Just remember, like everything in the Verse, I don't change a table, I revise it. So you need to figure out where you want to put the revised table you make. Most likely you'll want to revise a table in a @Reaction to some input, and store it in a @Bind."
            ],
            "start": "let's find the table to update",
            "finish": "I made a new table with revised rows!"
        },
        "Is": {
            "name": "is",
            "description": "is",
            "emotion": "curious",
            "doc": [
                "You know what? There are so many kinds of values that mean so many different things. I help figure out what they are.",
                "For example, suppose you had a mystery value. I can tell you whether it's a @Number, giving you a @Boolean:",
                "\\mystery: 'secret!'\nmystery‚Ä¢#\\",
                "It's not a number, so I made \\‚ä•\\. But if we check if it's @TextType?",
                "\\mystery: 'secret!'\nmystery‚Ä¢''\\",
                "We get \\‚ä§\\!",
                "I'm really helpful when you need to know whether some @Name has a value of a particular kind."
            ],
            "start": "let's get the value of $1 first",
            "finish": "$1[value is $2|value is not $2]",
            "conflict": {
                "ImpossibleType": "this can't ever be this type"
            },
            "exception": {
                "TypeException": {
                    "description": "incompatible values",
                    "explanation": "I expected a $1 but received $2"
                }
            }
        },
        "IsLocale": {
            "name": "is locale",
            "description": "is locale",
            "emotion": "kind",
            "doc": [
                "I'll help you check if the audience has selected a particular language or region:",
                "\\üåç/en\\",
                "\\üåç/es-MX\\",
                "This is helpful if you want to change your performance based on the language chosen."
            ],
            "start": "is the language $1?"
        },
        "ListAccess": {
            "name": "list access",
            "emotion": "cheerful",
            "doc": [
                "I work closely with @List to help them get values at a particular position. So like, if you had a list, and you wanted its second item, you'd write:",
                "\\list: ['bird' 'duck' 'fish' 'snake']\nlist[2]\\"
            ],
            "start": "let's get the list $1 first",
            "finish": "the item is $2!"
        },
        "ListLiteral": {
            "name": "specific list",
            "description": "$1 item list",
            "emotion": "eager",
            "doc": "I'm a specific @List of values! See @List to learn more about what you can do with me.",
            "start": "let's evaluate the items first",
            "finish": "I made a me! $1",
            "item": "item"
        },
        "MapLiteral": {
            "name": "map",
            "description": "$1 pairing map",
            "emotion": "kind",
            "doc": "I'm a specific @Map between keys and values. See @Map to learn more about how I'm helpful.",
            "start": "let's evaluate the keys and values first",
            "finish": "I connected everyone, $1",
            "conflict": {
                "NotAKeyValue": {
                    "primary": "one of my keys is missing a value",
                    "secondary": "oops, where's my value?"
                }
            }
        },
        "NumberLiteral": {
            "name": "specific number",
            "description": "$1 $2[$2|]",
            "emotion": "excited",
            "doc": "I'm a specific @Number. You can write me with any kinds of digits from any kind of language. See @Number for everything I can do.",
            "start": "$1!",
            "conflict": {
                "NotANumber": "I thought I knew all the numbers, but I don't know this one"
            }
        },
        "BasisExpression": {
            "name": "internal expression",
            "emotion": "neutral",
            "doc": "How did you find me? I'm an expression that only the original creators use. To learn more about me, you'll need to talk to them.",
            "start": "secret expression"
        },
        "NoneLiteral": {
            "name": "just none",
            "emotion": "neutral",
            "doc": "/@FunctionDefinition here. This is just @None. They are one of a kind! See @None to learn more about them.",
            "start": "‚Ä¶ √∏"
        },
        "Previous": {
            "name": "previous",
            "emotion": "serious",
            "doc": [
                "Have you ever wanted to remember the past?",
                "I am the Verse's official record keeper. Give me a stream and a number to look backwards and I'll tell you what that stream's value was in history.",
                "For example, here's what @Time it was five ticks ago:",
                "\\‚Üê 5 Time(1000ms)\\",
                "See how it's @None for 5 seconds, then suddenly a previous time?",
                "If you want the last several values, give me to arrows, and I'll interpret the number as a count:",
                "\\‚Üê‚Üê 5 Time(1000ms)\\",
                "See how it's the five previous times, instead of just one time?",
                "I'm helpful when you want to create performances that depend on the past."
            ],
            "start": "first get $1",
            "finish": "evaluated to stream value $1"
        },
        "Program": {
            "name": "program",
            "emotion": "serious",
            "doc": [
                "I'm where a performance begins and ends, containing all of the other characters that choregraph a show.",
                "You know how @Block evaluates a list of expressions, and evaluates to the last one in its list? ",
                "I'm the same, but rather than giving my value to whatever expression I'm in, I put the value on @Stage.",
                "The value can be anything: a @Number, @Text, or @Boolean, a @List, @Set, @Map, or even something more complex, like a @Phrase, @Group, or @Stage.",
                "If you don't give me a value to show on stage, I'll ask you for one.",
                "If there's a problem during a performance, I'll show that problem.",
                "And if your performance depends on a *stream*, I'll reevaluate every time that stream changes."
            ],
            "unevaluated": "the node you chose didn't evaluate",
            "start": "$1[$1 stream changed to $2!|it's my first evaluation]",
            "halt": "encountered exception, stopping",
            "finish": "all done, I evaluated to $1",
            "done": "there's nothing evaluating",
            "exception": {
                "BlankException": {
                    "description": "empty program",
                    "explanation": "Let's put on a show! Where should we start?"
                },
                "EvaluationLimitException": {
                    "description": "evaluation limit",
                    "explanation": "@Evaluate and I are tired of evaluating, especially $1.\n\nIs it possible that $1 is evaluating itself forever, without ever stopping?"
                },
                "StepLimitException": {
                    "description": "step limit",
                    "explanation": "there are so. many. steps -- too many to finish! Can you make the performance simpler?"
                },
                "ValueException": {
                    "description": "missing value",
                    "explanation": "I expected a value but didn't get one!"
                }
            }
        },
        "PropertyBind": {
            "name": "refine",
            "description": "refine $1[$1|missing name]",
            "emotion": "kind",
            "doc": [
                "Sometimes when you make a @StructureDefinition, you want to change the tiniest thing about it, without having to make a new one with all the same values.",
                "For example, what if you were keeping a record of cats, but then wanted to create a copy of a cat with a different hobby? I can help you change it:",
                "\\‚Ä¢Cat(name‚Ä¢'' color‚Ä¢'' hobby‚Ä¢'')\n\nkitty: Cat('sprinkles' 'orange' 'licking')\nkitty.hobby:'purring'\\",
                "That's so much easier than making a whole new \\Cat\\ with the same values except for the hobby, isn't it?"
            ],
            "start": "first let's get the value",
            "finish": "I copied the structure, but with $1 as $2"
        },
        "PropertyReference": {
            "name": "property",
            "description": "property $1[$1|missing name]",
            "emotion": "kind",
            "doc": [
                "When you make a @StructureDefinition, how do you get one of its inputs? I'm how",
                "Like if you had a structure about cities, you could get its values with me like this:",
                "\\‚Ä¢City(name‚Ä¢'' population‚Ä¢#people)\n\nportland: City('Portland' 800000people)\n\nportland.population\\"
            ],
            "start": "first let's get the value",
            "finish": "found property $1, it is $2",
            "property": "property"
        },
        "Reaction": {
            "name": "reaction",
            "emotion": "excited",
            "doc": [
                "Streams are so awesome! I can make new ones based on when they change, which is super cool!",
                "Like, if you wanted @Time to tick, but like, to show words instead of numbers, you could do something like this:",
                "\\time: Time(1000ms)\n'start' ‚Ä¶ ‚àÜ time ‚Ä¶ ((time % 2) = 0ms) ? 'even' 'odd'\\",
                "That's like saying \"/begin with the word 'start' and then if time changes, change to either even or odd, based on the time./\"",
                "So I'm like a stream to, but one based on other streams. Wicked, huh?"
            ],
            "start": "let's see if we should update the stream",
            "finish": "the new stream value is $1",
            "initial": "initial",
            "condition": "condition",
            "next": "next",
            "conflict": {
                "ExpectedStream": "$1 doesn't reference a stream, so I will never react!"
            }
        },
        "Reference": {
            "name": "reference",
            "description": "$1",
            "emotion": "shy",
            "doc": [
                "You know how @Bind gives things @Name? I'm how you refer to them. I see if any @Bind has that name, if so, give you its value. Like this:",
                "\\parrot: 'polly'\nparrot\\",
                "If I don't find the name, then I don't know what to do.",
                "\\parrot: 'polly'\nperry\\"
            ],
            "start": "what value does $1 have?",
            "conflict": {
                "UnknownName": "$1[I don't know anyone named $1 in $2[$2|this @Block]|Can you give me a name?]",
                "ReferenceCycle": "um, $1's value depends on itself, so how do I know what value to give it?",
                "UnexpectedTypeVariable": "I don't now what to do with these type inputs"
            },
            "exception": {
                "NameException": {
                    "description": "unknown name",
                    "explanation": "$1[I don't know anyone named $1 in $2[$2|this @Block]‚Ä¶|Eep, no name!]"
                }
            }
        },
        "Select": {
            "name": "select",
            "emotion": "excited",
            "doc": [
                "Sometimes you have a table and you just want part of it. I can get it for you!",
                "Like what if you had a table of players in a game and you wanted to find the ones with 10 or more points to see who won:",
                "\\players: ‚é°name‚Ä¢'' team‚Ä¢'' points‚Ä¢#‚é¶\n‚é°'jen' 'red' 8‚é¶\n‚é°'joan' 'blue' 11‚é¶\n‚é°'jeff' 'red' 9‚é¶\n‚é°'janet' 'blue' 7‚é¶\nplayers ‚é°? name ‚é¶ points ‚â• 10\\",
                "Just like that, I got a list of rows of winners! Just remember that I don't change the table, I make a new one. You'll have to decide where to keep it."
            ],
            "start": "let's get the table first",
            "finish": "I made a new table with just the selected rows and columns!",
            "conflict": {
                "ExpectedSelectName": "I need at least one column name."
            }
        },
        "SetLiteral": {
            "name": "specific set",
            "description": "$1 items",
            "emotion": "eager",
            "doc": "I'm a specifc @Set of specific values. See @Set to learn more about how to work with me.",
            "start": "let's evaluate the values first!",
            "finish": "I made a set $1!"
        },
        "SetOrMapAccess": {
            "name": "set/map access",
            "emotion": "kind",
            "doc": [
                "I can see if a @Set or @Map has a value or key.",
                "It's not too hard. Like this:",
                "\\faves: {'duck' 'goose' 'monkey'}\nfaves{'mouse'}\\",
                "Or this, with a @Map:",
                "\\faves: {'mac and cheese': 5stars 'cereal': 2stars 'gruel': 1stars}\nfaves{'gruel'}\\"
            ],
            "start": "what's the set or map?",
            "finish": "the value is $1",
            "conflict": {
                "IncompatibleKey": {
                    "primary": "I expected a $1 key",
                    "secondary": "I got a $1 instead of a $2"
                }
            }
        },
        "Source": {
            "name": "source",
            "emotion": "curious",
            "doc": [
                "Oh, you know @Program? I help you name them. Think of me like the window around a @Program, and the name you give them.",
                "You can also make other @Source @UI/addSource, with other @Program, and @Borrow things from those other @Program for use in another program.",
                "This can be a nice way of organizing a big performance into separate documents."
            ]
        },
        "StreamDefinition": {
            "name": "stream",
            "emotion": "curious",
            "doc": "I /think/ I'm supposed make new streams. But I really don't know ho to do that. For now, I guess just use the streams that exist?",
            "start": "create this new kind of stream"
        },
        "StructureDefinition": {
            "name": "structure",
            "description": "structure $1",
            "emotion": "kind",
            "doc": [
                "Why hello, how are you? Me? I'm great. I love to define structures that store values and function, so as long as I get to do that all day, I'm happy.",
                "I work like this:",
                "\\‚Ä¢Pizza(\ningredients‚Ä¢['']\nsize‚Ä¢#in\n) (\n\t∆í cost() size ¬∑ 10dollars/in\n)\n\nPizza(['pepperoni' 'peppers'] 12in).cost()\\",
                "See how that works? I defined \\Pizza\\, which has two inputs, \\ingredients\\ (a list of @Text) and \\size\\ (a number in inches).",
                "Inside, @FunctionDefinition made a function that evaluates the cost of a pizza, assuming $$10 per inch.",
                "I don't need to have @FunctionDefinition in me. I can just be inputs.",
                "\\‚Ä¢Pizza(\ningredients‚Ä¢['']\nsize‚Ä¢#in\n)\\",
                "I can also have @Bind inside, so we could evaluate the cost in advance.",
                "\\‚Ä¢Pizza(\ningredients‚Ä¢['']\nsize‚Ä¢#in\n) (\n\tcost: size ¬∑ 10dollars/in\n)\n\nPizza(['pepperoni' 'peppers'] 12in).cost\\"
            ],
            "start": "let's define this lovely structure",
            "conflict": {
                "DisallowedInputs": "I can't have inputs because one of or more of my interface functions isn't implemented",
                "IncompleteImplementation": "my functions either need to all be implemented, or none be implemented. No messy mixtures!",
                "NotAnInterface": "I am not an interface; a structure can only implement interfaces, not other structures",
                "UnimplementedInterface": "I implement $1 but haven't implemented $2"
            }
        },
        "TableLiteral": {
            "name": "specific table",
            "description": "$1 row table",
            "emotion": "angry",
            "doc": "I am a specific table with specific rows. See @Table about how I can help.",
            "item": "row",
            "start": "first evaluate the rows",
            "finish": "evaluated to new table $1"
        },
        "TextLiteral": {
            "name": "specific text",
            "description": "text $1",
            "emotion": "serious",
            "doc": "I represent one or more specific @Translation of text. See @Text to learn more about what I can do!",
            "start": "let's make text in the current locale"
        },
        "Translation": {
            "name": "translation",
            "description": "translation $1",
            "emotion": "serious",
            "doc": "I represent some text, with a @Language tag. See @Text to learn more!"
        },
        "FormattedLiteral": {
            "name": "formatted text",
            "description": "text $1",
            "emotion": "serious",
            "doc": "I represent many different @FormattedTranslation of formatted text. When I evaluate, I'll pick the best match based on the audience's selected languages.",
            "start": "let's make text in the current locale"
        },
        "FormattedTranslation": {
            "name": "formatted text",
            "description": "text $1",
            "emotion": "serious",
            "doc": [
                "I represent some formatted text, with a @Language tag.",
                "I can be:",
                "\\`/italic/`\\",
                "\\`*bold*`\\",
                "\\`^extra bold^`\\",
                "\\`_underlined_`\\",
                "\\`<linked@https://wordplay.dev>`\\",
                "\\`\\'code'\\`\\",
                "I work really well with @Phrase to put beautiful text on @Stage."
            ]
        },
        "This": {
            "name": "this",
            "emotion": "serious",
            "doc": [
                "Sometimes, it's helpful to refer to a value implicilty, rather than having to name it.",
                "For example, suppose you wanted to make a new @ConversionDefinition, which doesn't name the value being convered. You can just refer to it with me:",
                "\\‚Üí #rainbows #joys . ¬∑ 1000000joys\n2rainbows ‚Üí #joys\\",
                "See me there, representing the number of rainbows?",
                "Or suppose you wanted to make a @Reaction, but not have to name the most recent value:",
                "\\2 ‚Ä¶ ‚àÜ Time(1000ms) ‚Ä¶ . ¬∑ 2\\",
                "Check me out, representing the previous reaction value.",
                "I don't show up often, but when I do, I can really help a value get out of a @Bind!"
            ],
            "start": "evaluated to $1",
            "conflict": {
                "MisplacedThis": "I'm only allowed in a structure, conversion, or reaction."
            }
        },
        "UnaryEvaluate": {
            "name": "unary evaluate",
            "description": "$1",
            "emotion": "kind",
            "doc": [
                "Did you know that when I'm evaluating a @FunctionDefinition with just one value, and the name of the @FunctionDefinition is just a single symbol, you can put the name before the input?",
                "Like this:",
                "\\-(1 + 1)\\",
                "Or this:",
                "\\~‚ä•\\",
                "Those are much easier to read than \\(1 + 1).negate()\\ or \\‚ä•.not()\\, aren't they?",
                "You don't have to write me that way, but it might be easier overall.",
                "There's only one rule: you can't put any space between the name and the value. Otherwise you might be making a @Reference or @BinaryEvaluate."
            ],
            "start": "what's the value?",
            "finish": "I made it $1"
        },
        "UnparsableExpression": {
            "name": "unparsable",
            "emotion": "excited",
            "doc": [
                "/Hi @FunctionDefinition here. I'm translating for @UnparsableExpression, since they're often hard to interpret./",
                "jkwel fjiwojvioao jjiweo jrfe",
                "/Not every expression has meaning on stage./",
                "s w ieorjwei iojwi jfkdlsfdsk",
                "/In fact, there are all kinds of things you can say that don't make any sense at all./",
                "dsk sdlk jdkfiewipapweiurb,v kdsfdsf",
                "/When you do, I show up, because I don't know what you meant./",
                "You are the director after all, so only you know what you might have meant!"
            ],
            "start": "???",
            "conflict": {
                "UnparsableConflict": "@FunctionDefinition here, @UnparsableExpression doesn't know what kind of $1[ expression | type ] this is/",
                "UnclosedDelimiter": "I expected $2 sometime after $1"
            },
            "exception": {
                "UnparsableException": {
                    "description": "???",
                    "explanation": "/Hi, @FunctionDefinition here! We had to stop the performance because we didn't know what kind of instruction this is./"
                }
            }
        },
        "Update": {
            "name": "update",
            "emotion": "kind",
            "doc": [
                "I help revise a @Table, finding the rows that match a condition, and then creating revised rows with new values.",
                "So like, if you had a table of characters and points, and you wanted to give every character on a team a point, you might do this:",
                "\\players: ‚é°name‚Ä¢'' team‚Ä¢'' points‚Ä¢#‚é¶\n‚é°'jen' 'red' 1‚é¶\n‚é°'joan' 'blue' 0‚é¶\n‚é°'jeff' 'red' 3‚é¶\n‚é°'janet' 'blue' 2‚é¶\nplayers ‚é°: points: points + 1 ‚é¶ team = 'blue'\\",
                "You can use a @Bind to say which columns to change, and you can use any of the column names or other names in scope in the condition."
            ],
            "start": "let's get the table first",
            "finish": "evaluated to a new table with revised rows!",
            "conflict": {
                "ExpectedColumnBind": "I need a value for every column",
                "IncompatibleCellType": {
                    "primary": "I needed a $1, but got a $2",
                    "secondary": "I got a $2"
                }
            }
        },
        "AnyType": {
            "name": "any type",
            "emotion": "curious",
            "doc": "I represent any any possible type. Sometimes I show up because I don't know what kind of value something is, so it could be anything."
        },
        "BooleanType": {
            "name": "boolean",
            "emotion": "kind",
            "doc": [
                "I work with @Bind to declare that a name is a @Boolean value. Like this:",
                "\\hungry‚Ä¢?: 'jello'\\",
                "If you want to be sure that something is @Boolean, use me, and I'll check!"
            ]
        },
        "ConversionType": {
            "name": "conversion",
            "emotion": "serious",
            "doc": [
                "I work with @Bind to indicate that a name is a @ConversionDefinition. You probably don't need to use me, because not a lot of people pass me around as a value, but if you did, I would look like this:",
                "\\magic‚Ä¢?‚Üí'': ‚Üí ? '' . ? 'yep' 'nope'\\"
            ]
        },
        "FormattedType": {
            "name": "formatted",
            "emotion": "serious",
            "doc": [
                "I work with @Bind to note that a name is a @FormattedLiteral value. Like this:",
                "\\hungry‚Ä¢`‚Ä¶`: `I am so /fancy/!`\\",
                "Want to make sure something is a @FormattedLiteral value? This is how you make sure."
            ]
        },
        "ExceptionType": {
            "name": "exception",
            "emotion": "neutral",
            "doc": "I represent an exception. There's no way to tell bind that I am one, because exceptions only ever halt @Program, so you can't use them as values."
        },
        "FunctionDefinitionType": {
            "name": "function type",
            "emotion": "happy",
            "doc": [
                "I represent a @FunctionDefinition. I'm really helpful if you want to say what kind of function a @Bind holds! Like this:",
                "\\math‚Ä¢∆í (# # # #) #?: ∆í interesting(a‚Ä¢# b‚Ä¢# c‚Ä¢# d‚Ä¢#) a + b + c + d\\"
            ]
        },
        "FunctionType": {
            "name": "function type",
            "description": "function with $1 inputs, $2 output",
            "emotion": "curious",
            "doc": [
                "I represent a @FunctionDefinition. I'm really helpful if you want to say what kind of function a @Bind holds! Like this:",
                "\\math‚Ä¢∆í (# # # #) #?: ∆í interesting(a‚Ä¢# b‚Ä¢# c‚Ä¢# d‚Ä¢#) a + b + c + d\\"
            ]
        },
        "ListType": {
            "name": "list type",
            "description": "$1[list of $1|list]",
            "emotion": "cheerful",
            "doc": [
                "I am /such/ a fan of @List. I get to tell @Bind what kind of list they are! Like this, I'm saying that it's a list of @Number:",
                "\\things‚Ä¢[#]: [ 1 2 3 4 5 ]\\"
            ]
        },
        "MapType": {
            "name": "map type",
            "description": "map from $1[$1|any] to $2[$2|any]",
            "emotion": "kind",
            "doc": [
                "Do you know how awesome @Map is? Like really awesome. I tell @Bind what kind of map they are all the time, like this map of numbers to lists:",
                "\\stuff‚Ä¢{'':[]}: {}\\"
            ]
        },
        "NumberType": {
            "name": "number type",
            "description": "$1[$1 | number]",
            "emotion": "precise",
            "doc": [
                "You know what @Bind should be? A @Number. Because numbers are the best.",
                "\\count‚Ä¢#: 17\\"
            ]
        },
        "NameType": {
            "name": "name type",
            "description": "$1 type",
            "emotion": "curious",
            "doc": [
                "I represent a @StructureDefinition by it's name. So like, if you had a structure like this, you could make a @Bind that stores the values it creates.",
                "\\‚Ä¢Friend(name‚Ä¢'')\nbestie‚Ä¢Friend: Friend('Jonah')\\"
            ],
            "conflict": {
                "UnknownTypeName": "type names can only refer to structures or type variables, but this refers to a $1"
            }
        },
        "NeverType": {
            "name": "never type",
            "emotion": "curious",
            "doc": "I represent a type that is impossible. Like when you ask @Is if something is a @Number, but it can never be a number."
        },
        "NoneType": {
            "name": "none type",
            "emotion": "neutral",
            "doc": [
                "@None is the best nothing there is, and I am their faithful representative.",
                "\\space‚Ä¢√∏: √∏\\"
            ]
        },
        "SetType": {
            "name": "set type",
            "description": "$1[$1 set|set] type",
            "emotion": "kind",
            "doc": [
                "@Set is the BEST, like seriously. I'm telling @Bind all the time, make things a set of something!",
                "\\unique‚Ä¢{''}: {'something' 'anything' 'someone'}\\"
            ]
        },
        "StreamDefinitionType": {
            "name": "stream definition type",
            "emotion": "angry",
            "doc": "I represent a stream you have defined, which isn't possible, so why are you even reading this?"
        },
        "StreamType": {
            "name": "stream type",
            "emotion": "curious",
            "doc": [
                "I celebrate the beauty and meaning of streams‚Ä¶ by telling @Bind to store them:",
                "\\time‚Ä¢‚Ä¶#ms: Time()\\"
            ]
        },
        "StructureType": {
            "name": "structure type",
            "description": "$1",
            "emotion": "kind",
            "doc": "I am an internal type to represent the type of default value types."
        },
        "UnknownType": {
            "name": "unknown type",
            "unknown": "unknown",
            "connector": ", because",
            "emotion": "curious",
            "doc": "Umm... I don't know what I represent, but I really am curious. Do you know? It seems like we should know. You might need to tell us if we can't figure it out."
        },
        "TableType": {
            "name": "table type",
            "emotion": "angry",
            "doc": "I represent a Table.",
            "conflict": {
                "ExpectedColumnType": "I need a column type"
            }
        },
        "TextType": {
            "name": "text type",
            "description": "$1[$1|text]",
            "emotion": "happy",
            "doc": [
                "I fabulously represent the most fabulous kind of value there is, @Text.",
                "\\story‚Ä¢'': 'Once upon a time...'\\"
            ]
        },
        "TypePlaceholder": {
            "name": "placeholder type",
            "emotion": "eager",
            "doc": "I hope to represent a type some day, kind of like my bestie @ExpressionPlaceholder represents an expression! Will you help me decide what kind?"
        },
        "UnionType": {
            "name": "option type",
            "description": "$1 | $2",
            "emotion": "curious",
            "doc": [
                "Who should I represent, A or B or something else? I can never decide!",
                "\\indecision‚Ä¢''|#|{√∏}: \"I don't know!\"\\"
            ]
        },
        "Unit": {
            "name": "unit",
            "description": "$1",
            "emotion": "precise",
            "doc": [
                "I represent any unit a @Number might have, including no unit, to the most complicated unit you can imagine. Like gravity, for example:",
                "\\gravity‚Ä¢m/s^2: 9.8m/s^2\\",
                "I show up in @Bind, but also right after @Number. I help make sure that numbers are of the same kinds, and will definitely tell you if they aren't, in case its a mistake!"
            ]
        },
        "UnparsableType": {
            "name": "unparsable type",
            "emotion": "curious",
            "doc": "I represent the type of an unknown expression. I show up when you try to use that expression for something."
        },
        "VariableType": {
            "name": "variable type",
            "emotion": "curious",
            "doc": "Do you know @TypeVariable, and how they represent some unknown kind of value? I represent them in all negotiations between values."
        },
        "CycleType": {
            "name": "cycle type",
            "description": "depends on itself",
            "emotion": "curious",
            "doc": "Sometimes values depend on themselves, and so we don't know what kind of value they are. I represent that situation."
        },
        "UnknownVariableType": {
            "name": "unknown variable type",
            "emotion": "curious",
            "doc": "Sometimes we try to guess what kind of value something is; I show up when we don't know."
        },
        "NotAType": {
            "name": "unexpected type",
            "description": "not a $1",
            "emotion": "curious",
            "doc": "Sometimes we know what kind of value something should be. Like @ListAccess needs a @Number. If we don't get it, I represent that something is a type other than what we expected."
        },
        "NoExpressionType": {
            "name": "no expression type",
            "emotion": "angry",
            "doc": "You know how @Block needs at least one expression? I'm what you get when you don't give one. So give one!"
        },
        "NotEnclosedType": {
            "name": "not in structure, conversion, or reaction",
            "emotion": "curious",
            "doc": "@This, as neat as they are, only belongs in particular places. I show up when they get lost, and so no one knows what value they represent."
        },
        "NotImplementedType": {
            "name": "unimplemented",
            "emotion": "curious",
            "doc": "When you use @ExpressionPlaceholder, but don't say what type they are, I'm the type you get. Deal with it!"
        },
        "UnknownNameType": {
            "name": "unknown name",
            "description": "$1[$1 isn't defined | a name wasn't given]",
            "emotion": "curious",
            "doc": "You know how sometimes @Reference and @PropertyReference don't know the name you're talking about? I'm around when that happens, to represent that we don't know who you're talking about."
        }
    },
    "basis": {
        "Boolean": {
            "doc": [
                "We are \\‚ä§\\ and \\‚ä•\\. \\‚ä§\\ is true. \\‚ä•\\ is false. \\‚ä§\\ is not \\‚ä•\\; \\‚ä•\\ is not \\‚ä§\\. This is how it is.",
                "How do you make us? Just \\‚ä§\\ and \\‚ä•\\, nothing more, nothing less.",
                "Some use the keyboard (/ctrl+9/ for \\‚ä§\\ and /ctrl+0/ for \\‚ä•\\). Some use the character search at the bottom of the editor. Or you can drag us from here.",
                "Check out our @FunctionDefinition below. They're very logical."
            ],
            "name": ["‚ä§‚ä•", "Boolean"],
            "function": {
                "and": {
                    "doc": [
                        "I evaluate to \\‚ä§\\ *only* when both values are \\‚ä§\\. Helpful for determining if many things are all true. There are only four possible outcomes",
                        "\\‚ä§ & ‚ä§\\",
                        "\\‚ä§ & ‚ä•\\",
                        "\\‚ä• & ‚ä§\\",
                        "\\‚ä• & ‚ä•\\"
                    ],
                    "names": ["&", "and"],
                    "inputs": [
                        {
                            "doc": "The other @Boolean to check. If the first is \\‚ä•\\, it doesn't matter what this is, the function will evaluate to \\‚ä•\\.",
                            "names": "value"
                        }
                    ]
                },
                "or": {
                    "doc": [
                        "I evaluate to \\‚ä§\\ when *either* value are \\‚ä§\\. Helpful for determining if one of many things are true. There are only four possible outcomes",
                        "\\‚ä§ | ‚ä§\\",
                        "\\‚ä§ | ‚ä•\\",
                        "\\‚ä• | ‚ä§\\",
                        "\\‚ä• | ‚ä•\\"
                    ],
                    "names": ["|", "or"],
                    "inputs": [
                        {
                            "doc": "The other @Boolean to check. If the first is \\‚ä•\\, the function will only evaluate to \\‚ä§\\ if this is \\‚ä§\\.",
                            "names": "value"
                        }
                    ]
                },
                "not": {
                    "doc": "I get the opposite of myself: if \\‚ä§\\, it gives \\‚ä•\\, if \\‚ä•\\, it gives \\‚ä§\\.",
                    "names": ["~", "not"],
                    "inputs": []
                },
                "equals": {
                    "doc": "\\‚ä§\\ if both are \\‚ä§\\ or both are \\‚ä•\\.",
                    "names": ["=", "equals"],
                    "inputs": [
                        { "doc": "The other value to check.", "names": "value" }
                    ]
                },
                "notequal": {
                    "doc": "\\‚ä§\\ if both are opposites.",
                    "names": ["‚â†", "notequal"],
                    "inputs": [
                        { "doc": "The other value to check.", "names": "value" }
                    ]
                }
            },
            "conversion": {
                "text": "Converts a @Boolean to the equivalent @Text values, \\'‚ä§'\\ and \\'‚ä•'\\"
            }
        },
        "None": {
            "doc": [
                "/Hi, @FunctionDefinition here. @None doesn't like to say much, so I'll interpret./",
                "I am @None. Invoke me with \\√∏\\. I am helpful when you want to represent the absense of something."
            ],
            "name": ["√∏", "None"],
            "function": {
                "equals": {
                    "doc": "Is another value also nothing? It better be, otherwise, \\‚ä•\\.",
                    "names": ["=", "equals"],
                    "inputs": [{ "doc": "The other value.", "names": "value" }]
                },
                "notequals": {
                    "doc": "Is another value /not/ nothing?",
                    "names": ["‚â†", "notequal"],
                    "inputs": [{ "doc": "The other value.", "names": "value" }]
                }
            },
            "conversion": {
                "text": "Want to make \\√∏\\ into \\'√∏'\\? This is your chance."
            }
        },
        "Text": {
            "doc": [
                "I can be any text you like, from any language, and using any of these symbols opening and closing symbols: \\\"\"\\, \\‚Äú‚Äù\\, \\‚Äû‚Äú\\, \\''\\, \\‚Äò‚Äô\\, \\‚Äπ‚Ä∫\\, \\¬´¬ª\\, \\„Äå„Äç\\, or \\„Äé„Äè\\.",
                "To illustrate, consider these beautiful phrases",
                "\\‚ÄúThere are only two ways to live your life. One is as though nothing is a miracle. The other is as though everything is a miracle.‚Äù\\",
                "\\„Äé‰∏ÄÊó•‰∏âÁßã„Äè\\",
                "Just remember to close me if you open me, and use the matching symbol. Otherwise I won't know that you're done with your words.",
                "\\'hello'/en'hola'/es-MX\\",
                "You can also tag me with languages, and even give multiple translations. I'll evaluate to whatever languages are currently selected, if there's a matching langauge.",
                "If you want to make me with some other values, you can use a symbol to ",
                "For instance, consider this:",
                "\\\"Here are some sums \\1 + 2\\, \\2 + 3\\, \\3 + 4\\\"\\",
                "See how elegantly I just evaluated those sums, and placed them inside the @Text?",
                "Otherwise, there just so many glorious functions that @FunctionDefinition made for me to do all kinds of things with words!"
            ],
            "name": ["''", "Text"],
            "function": {
                "length": {
                    "doc": [
                        "I evaluate to the number of legible characters in the text; one letter is one character, one emoji is one character, etc. For example:",
                        "\\'hello'.length()\\",
                        "\\'üêàüìö'.length()\\"
                    ],
                    "names": ["üìè", "length"],
                    "inputs": []
                },
                "equals": {
                    "doc": "\\‚ä§\\ if I am the same character sequence as the given @Text.",
                    "names": ["=", "equals"],
                    "inputs": [
                        { "doc": "The @Text to compare.", "names": "value" }
                    ]
                },
                "notequals": {
                    "doc": "\\‚ä§\\ if I am /not/ the same character sequence as the given @Text.",
                    "names": "‚â†",
                    "inputs": [
                        { "doc": "The @Text to compare", "names": "value" }
                    ]
                },
                "has": {
                    "doc": [
                        "\\‚ä§\\ if the given @Text appears in me.",
                        "\\'did you find what you were looking for?'.has('you')\\"
                    ],
                    "names": ["‚äÜ", "has"],
                    "inputs": [
                        {
                            "doc": "The @Text to search for in me.",
                            "names": "text"
                        }
                    ]
                },
                "starts": {
                    "doc": [
                        "\\‚ä§\\ if I start with the given @Text.",
                        "\\'hello verse!'.starts('hello')\\",
                        "\\'hello verse!'.starts('verse')\\"
                    ],
                    "names": ["starts"],
                    "inputs": [
                        {
                            "doc": "The @Text to check for at the start of me.",
                            "names": "text"
                        }
                    ]
                },
                "ends": {
                    "doc": [
                        "\\‚ä§\\ if I end with the given @Text.",
                        "\\'am I a question?'.ends('?')\\",
                        "\\'I am not a question.'.ends('?')\\"
                    ],
                    "names": ["ends"],
                    "inputs": [
                        {
                            "doc": "The @Text to check for at the end of me.",
                            "names": "text"
                        }
                    ]
                },
                "repeat": {
                    "doc": [
                        "I make a new @Text that's me, repeated the number of times of \\count\\:",
                        "\\'hi ' ¬∑ 5\\",
                        "If you give me a fractional @Number, I ignore the fraction:",
                        "\\'hi ' ¬∑ 5.5\\",
                        "If you give me a negative @Number or zero, I give an empty @Text.",
                        "\\'hi ' ¬∑ -5\\"
                    ],
                    "names": ["¬∑", "üîÅ", "repeat"],
                    "inputs": [
                        {
                            "doc": "The number of times to repeat myself in the new text.",
                            "names": "count"
                        }
                    ]
                },
                "segment": {
                    "doc": [
                        "I divide myself into a @List of @Text, using the given @Text as a separator, and removing the separators. For example:",
                        "\\'apples, oranges, grapes' √∑ ', '\\",
                        "If the separator is an empty @Text, I divide myself into characters:",
                        "\\'üñåÔ∏èüè†ü•∏' √∑ ''\\"
                    ],
                    "names": ["√∑", "segment"],
                    "inputs": [
                        {
                            "doc": "The @Text to use as a separator.",
                            "names": "delimiter"
                        }
                    ]
                },
                "combine": {
                    "doc": [
                        "Sometimes it's helpful to combine to @Text into one. Give me another @Text and I'll make a new text that joins us together:",
                        "\\'hello ' + 'verse'\\"
                    ],
                    "names": ["+", "combine"],
                    "inputs": [
                        { "doc": "The @Text to append.", "names": "text" }
                    ]
                }
            },
            "conversion": {
                "list": "Splits the text into a list of individual characters.",
                "number": "Converts text into a @Number, and if it's not a number, a not a number value."
            }
        },
        "Number": {
            "doc": [
                "I create @Number, with any number of units you can imagine!",
                "Here are my top 5:",
                "\\0\\",
                "\\1story\\",
                "\\œÄpie\\",
                "\\‚àûrock\\",
                "\\1000000hugs\\",
                "That's basically an infinite number of numbers.",
                "And an infinite number of units!",
                "And an infinite number of number/unit pairs‚Ä¶",
                "I can be integers, real numbers, negative, positive, fractional, decimal, even not a number.",
                "And you can write me with many different number systems, including Arabic \\123\\, Roman \\‚Ö©‚Ö©‚Ö©‚Ö†‚Ö©\\, Japanese \\‰∫åÂçÅ\\, and more:",
                "\\1 + ‚Ö† + ‰∏Ä\\",
                "You can also write me in bases 2 to 16 by putting a base number like this:",
                "\\2;11111111\\",
                "\\10;255\\",
                "\\16;FF\\",
                "There is one special number called NaN that is possible when you write something that isn't a number:",
                "\\2;22\\",
                "There is no digit '2' in base 2, so it's not a valid number. NaN will also show up if you try to convert non-number text to number",
                "\\'hi'‚Üí#\\"
            ],
            "name": ["#", "Number"],
            "function": {
                "add": {
                    "doc": [
                        "I add a @Number with the same @Unit to myself, creating a new @Number of the same @Unit.",
                        "For example:",
                        "\\1 + 1\\",
                        "\\3cat + 5cat\\",
                        "If the units don't match, I halt the show.",
                        "\\3cat + 5dog\\"
                    ],
                    "names": ["+", "add"],
                    "inputs": [
                        { "doc": "The @Number to add.", "names": "number" }
                    ]
                },
                "subtract": {
                    "doc": [
                        "I subtract the @Number you give me from myself, creating a new @Number of the same @Unit.",
                        "For example:",
                        "\\1 - 1\\",
                        "\\3cat - 5cat\\",
                        "If the units don't match, I halt the show.",
                        "\\3cat - 5dog\\"
                    ],
                    "names": ["-", "subtract"],
                    "inputs": [
                        {
                            "doc": "The @Number to subtract from me.",
                            "names": "number"
                        }
                    ]
                },
                "multiply": {
                    "doc": [
                        "I multiply myself to the given @Number, creating a product of my @Unit and the given number's @Unit:",
                        "\\5 ¬∑ 5\\",
                        "\\5m ¬∑ 5m\\",
                        "\\5m ¬∑ 1/s\\"
                    ],
                    "names": ["¬∑", "multiply"],
                    "inputs": [
                        { "doc": "The number to multiply.", "names": "number" }
                    ]
                },
                "divide": {
                    "doc": [
                        "I divide myself by the given @Number, creating a quotient of my @Unit and the given number's @Unit:",
                        "\\5 √∑ 5\\",
                        "\\5m √∑ 5m\\",
                        "\\5m √∑ 5s\\"
                    ],
                    "names": ["√∑", "divide"],
                    "inputs": [
                        {
                            "doc": "The @Number to divide me by.",
                            "names": "number"
                        }
                    ]
                },
                "remainder": {
                    "doc": [
                        "I divide myself by the given @Number, but give the remainder:",
                        "\\10 % 2\\",
                        "\\10m % 2\\",
                        "\\10m/s % 3\\"
                    ],
                    "names": ["%", "remainder"],
                    "inputs": [
                        {
                            "doc": "The @Number to divide me by.",
                            "names": "number"
                        }
                    ]
                },
                "positive": {
                    "doc": [
                        "I create a new @Number that makes me positive, if negative.",
                        "\\-200.positive()\\"
                    ],
                    "names": ["positive"],
                    "inputs": []
                },
                "round": {
                    "doc": [
                        "I create a new @Number that rounds me to the closest integer.",
                        "\\9.4.round()\\",
                        "\\9.5.round()\\",
                        "\\9.6.round()\\"
                    ],
                    "names": ["round"],
                    "inputs": []
                },
                "roundDown": {
                    "doc": [
                        "I create a new @Number that rounds to smallest integer less than me.",
                        "\\10.5.roundDown()\\",
                        "\\10.1.roundDown()\\",
                        "\\10.01.roundDown()\\"
                    ],
                    "names": ["roundDown"],
                    "inputs": []
                },
                "roundUp": {
                    "doc": [
                        "I create a new @Number that rounds to the smalelst integer greater than me.",
                        "\\10.5.roundUp()\\",
                        "\\10.9.roundUp()\\",
                        "\\10.99.roundUp()\\"
                    ],
                    "names": ["roundUp"],
                    "inputs": []
                },
                "power": {
                    "doc": [
                        "I raise myself to the given @Number's power. Fractional exponents are okay!",
                        "\\2 ^ 8\\",
                        "\\10 ^ -2\\",
                        "\\5 ^ -.5\\"
                    ],
                    "names": ["^", "power"],
                    "inputs": [
                        {
                            "doc": "The exponent to raise me to.",
                            "names": "number"
                        }
                    ]
                },
                "root": {
                    "doc": [
                        "I create the root of myself using the given root.",
                        "\\4 ‚àö 2\\",
                        "\\1000 ‚àö 3\\"
                    ],
                    "names": ["‚àö", "root"],
                    "inputs": [
                        { "doc": "The root to compute.", "names": "number" }
                    ]
                },
                "lessThan": {
                    "doc": [
                        "\\‚ä§\\ if I'm less than the given @Number:",
                        "\\1 < 2\\",
                        "\\2 < 1\\"
                    ],
                    "names": ["<", "lessthan"],
                    "inputs": [
                        {
                            "doc": "The @Number to compare me to.",
                            "names": "number"
                        }
                    ]
                },
                "lessOrEqual": {
                    "doc": [
                        "\\‚ä§\\ if I'm less than or equal to the given @Number:",
                        "\\1 ‚â§ 2\\",
                        "\\2 ‚â§ 1\\",
                        "\\2 ‚â§ 2\\"
                    ],
                    "names": ["‚â§", "lessorequal"],
                    "inputs": [
                        {
                            "doc": "The @Number to compare me to.",
                            "names": "number"
                        }
                    ]
                },
                "greaterThan": {
                    "doc": [
                        "\\‚ä§\\ if I'm greater than to the given @Number:",
                        "\\1 > 2\\",
                        "\\2 > 1\\"
                    ],
                    "names": [">", "greaterthan"],
                    "inputs": [
                        {
                            "doc": "The @Number to compare me to.",
                            "names": "number"
                        }
                    ]
                },
                "greaterOrEqual": {
                    "doc": [
                        "\\‚ä§\\ if I'm greater than or equal to the given @Number:",
                        "\\1 ‚â• 2\\",
                        "\\2 ‚â• 1\\",
                        "\\2 ‚â• 2\\"
                    ],
                    "names": ["‚â•", "greaterorequal"],
                    "inputs": [
                        {
                            "doc": "The @Number to compare me to.",
                            "names": "number"
                        }
                    ]
                },
                "equal": {
                    "doc": [
                        "\\‚ä§\\ if I'm equal to the given @Number:",
                        "\\1 = 2\\",
                        "\\2 = 2\\"
                    ],
                    "names": ["=", "equal"],
                    "inputs": [
                        {
                            "doc": "The @Number to compare me to.",
                            "names": "number"
                        }
                    ]
                },
                "notequal": {
                    "doc": [
                        "\\‚ä§\\ if I'm equal to the given @Number:",
                        "\\1 ‚â† 2\\",
                        "\\2 ‚â† 2\\"
                    ],
                    "names": ["‚â†", "notequal"],
                    "inputs": [
                        {
                            "doc": "The @Number to compare me to.",
                            "names": "number"
                        }
                    ]
                },
                "cos": {
                    "doc": ["Compute the cosine of me.", "\\œÄ.cos()\\"],
                    "names": ["cos", "cosine"],
                    "inputs": []
                },
                "sin": {
                    "doc": ["Compute the sine of me.", "\\œÄ.cos()\\"],
                    "names": ["sin", "sine"],
                    "inputs": []
                }
            },
            "conversion": {
                "text": "An Arabic @Text representation of my digits.",
                "list": "A list of the numbers 1 to whatever number is given, such as\n\\10‚Üí[]\\.",
                "s2m": "Seconds to minutes",
                "s2h": "Seconds to hours",
                "s2day": "Seconds to days",
                "s2wk": "Seconds to weeks",
                "s2year": "Seconds to years",
                "s2ms": "Seconds to miliseconds",
                "ms2s": "Milliseconds to seconds",
                "min2s": "Minutes to seconds",
                "h2s": "Hours to seconds",
                "day2s": "Days to seconds",
                "wk2s": "Weeks to seconds",
                "yr2s": "Years to seconds",
                "m2pm": "Meters to picometers",
                "m2nm": "Meters to nanometers",
                "m2micro": "Meters to micrometers",
                "m2mm": "Meters to millimeters",
                "m2cm": "Meters to centimenters",
                "m2dm": "Meters to decimeters",
                "m2km": "Meters to kilometers",
                "m2Mm": "Meters to megameters",
                "m2Gm": "Meters to gigameters",
                "m2Tm": "Meters to terameters",
                "pm2m": "Picometers to meters",
                "nm2m": "Nanometers to meters",
                "micro2m": "Micrometers to meters",
                "mm2m": "Millimeters to meters",
                "cm2m": "Centimeters to meters",
                "dm2m": "Decimeters to meters",
                "km2m": "Kilometers to meters",
                "Mm2m": "Megameters to meters",
                "Gm2m": "Gigameters to meters",
                "Tm2m": "Terameters to meters",
                "km2mi": "Kilometers to miles",
                "mi2km": "Miles to kilometers",
                "cm2in": "Centimeters to inches",
                "in2cm": "Inches to centimeters",
                "m2ft": "Meters to feet",
                "ft2m": "Feet to meters",
                "g2mg": "Grams to milligrams",
                "mg2g": "Milligrams to grams",
                "g2kg": "Grams to kilograms",
                "kg2g": "Kilograms to grams",
                "g2oz": "Grams to ounces",
                "oz2g": "Ounces to grams",
                "oz2lb": "Ounces to pounds",
                "lb2oz": "Pounds to ounces"
            }
        },
        "List": {
            "doc": [
                "I'm a sequence of values, of any kind!",
                "You can put anything in me: @Boolean, @Number, @Text, @None, even other @List, @Set, @Map, or any expression. Here's a simple one:",
                "\\['apple' 'banana' 'mango']\\",
                "What makes me special is that I keep things in order and I number everything from 1 to however many items are in me.",
                "My items are numbered, starting from 1. You can get values that I'm storing with @ListAccess, using their number:",
                "For example, the second value in this list is \\['banana']\\",
                "\\['apple' 'banana' 'mango'][2]\\",
                "I can have anything in me. Look at this list, with @Text, @Number, and @Time!",
                "\\['apple' 10 + 10 Time()]\\",
                "I can do call kinds of exiting things with my @FunctionDefinition!"
            ],
            "name": ["[]", "List"],
            "kind": "Kind",
            "out": "Result",
            "outofbounds": "outofbounds",
            "function": {
                "add": {
                    "doc": [
                        "I create a new @List with the given item.",
                        "\\['apple' 'banana' 'mango'].add('watermelon')\\"
                    ],
                    "names": ["add"],
                    "inputs": [
                        {
                            "doc": "I the value you want to add.",
                            "names": "item"
                        }
                    ]
                },
                "append": {
                    "doc": [
                        "I create a new @List with my values, then all the values of the given @List.",
                        "\\['apple' 'banana' 'mango'].append(['watermelon' 'starfruit'])\\"
                    ],
                    "names": ["append"],
                    "inputs": [
                        { "doc": "The list of values to add.", "names": "list" }
                    ]
                },
                "replace": {
                    "doc": [
                        "I create a new list that replaces the value at the given index with the given value.",
                        "\\['apple' 'banana' 'mango'].replace(1 'kiwi')\\"
                    ],
                    "names": ["replace"],
                    "inputs": [
                        {
                            "doc": "The index of the value to replace",
                            "names": "index"
                        },
                        { "doc": "The replacement value", "names": "value" }
                    ]
                },
                "length": {
                    "doc": "The @Number of items in me.",
                    "names": ["üìè", "length"],
                    "inputs": []
                },
                "random": {
                    "doc": [
                        "A randonly selected one of my items, or @None if I'm empty.",
                        "\\['apple' 'banana' 'mango'].random()\\"
                    ],
                    "names": "random",
                    "inputs": []
                },
                "first": {
                    "doc": [
                        "The first item in me, or @None if I'm empty.",
                        "\\['apple' 'banana' 'mango'].first()\\"
                    ],
                    "names": "first",
                    "inputs": []
                },
                "last": {
                    "doc": [
                        "The last item in me, or @None if I'm empty.",
                        "\\['apple' 'banana' 'mango'].first()\\"
                    ],
                    "names": "last",
                    "inputs": []
                },
                "has": {
                    "doc": [
                        "\\‚ä§\\ if I have an item equal to the given item in me.",
                        "\\['apple' 'banana' 'mango'].has('banana')\\"
                    ],
                    "names": "has",
                    "inputs": [
                        { "doc": "The value to search for.", "names": "item" }
                    ]
                },
                "join": {
                    "doc": [
                        "I combine the items in my list into @Text, separated by the given separator @Text.",
                        "\\['apple' 'banana' 'mango'].join(', ')\\"
                    ],
                    "names": "join",
                    "inputs": [
                        {
                            "doc": "The text to separate the items by, optionally empty.",
                            "names": "separator"
                        }
                    ]
                },
                "subsequence": {
                    "doc": [
                        "I get a list within this list, starting at the index you provide, and ending with the last item, or if you provide one, a particular item.",
                        "\\['apple' 'banana' 'mango'].subsequence(2)\\",
                        "\\['apple' 'banana' 'mango'].subsequence(1 2)\\",
                        "And look! If you provide numbers out of order, I give you the reverse",
                        "\\['apple' 'banana' 'mango'].subsequence(3 1)\\",
                        "If you give me something smaller than 1 for an index, I'll assume you mean 1.",
                        "\\['apple' 'banana' 'mango'].subsequence(-1003243 2)\\",
                        "And if you give me something larger than the largest index, I'll assume you mean the end.",
                        "\\['apple' 'banana' 'mango'].subsequence(3 2304032432)\\"
                    ],
                    "names": "subsequence",
                    "inputs": [
                        {
                            "doc": "The index of the first item of the subsequence you want.",
                            "names": "start"
                        },
                        {
                            "doc": "The optional index of the last item of the subsequence you want. If you don't give one, your list will end with the last item in the list.",
                            "names": "end"
                        }
                    ]
                },
                "sansFirst": {
                    "doc": [
                        "I create a list without my first item.",
                        "\\['apple' 'banana' 'mango'].sansFirst()\\"
                    ],
                    "names": "sansFirst",
                    "inputs": []
                },
                "sansLast": {
                    "doc": [
                        "I create a list without my last item.",
                        "\\['apple' 'banana' 'mango'].sansLast()\\"
                    ],
                    "names": "sansLast",
                    "inputs": []
                },
                "sans": {
                    "doc": [
                        "Me, but without the first occurences of the given value.",
                        "\\['apple' 'banana' 'mango' 'apple'].sans('apple')\\"
                    ],
                    "names": "sans",
                    "inputs": [
                        {
                            "doc": "The value to remove the first occurence of.",
                            "names": "value"
                        }
                    ]
                },
                "sansAll": {
                    "doc": [
                        "Me, but without all occurences of the given value.",
                        "\\['apple' 'banana' 'mango' 'apple'].sans('apple')\\"
                    ],
                    "names": "sansAll",
                    "inputs": [
                        {
                            "doc": "The value to remove all occurences of from the list.",
                            "names": "value"
                        }
                    ]
                },
                "reverse": {
                    "doc": [
                        "Me, but in reverse!",
                        "\\['apple' 'banana' 'mango'].reverse()\\"
                    ],
                    "names": "reverse",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "\\‚ä§\\ if my items and order are the exact same as the given @List.",
                        "\\['apple' 'banana' 'mango'] = ['apple' 'mango' 'banana']\\"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "The @List to compare me to.",
                            "names": "list"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "\\‚ä§\\ if my items and order are /not/ the exact same as the given @List.",
                        "\\['apple' 'banana' 'mango'] ‚â† ['apple' 'mango' 'banana']\\"
                    ],
                    "names": ["‚â†", "notequal"],
                    "inputs": [
                        {
                            "doc": "The @List to compare me to.",
                            "names": "list"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes a value and optional index as input and produces a value, and I'll evaluate it on each of my items, translating my values into new values.",
                        "For example, imagine I was a list of @Number and you wanted to double all of them:",
                        "\\[2 4 6 8].translate(∆í(num‚Ä¢#) num ¬∑ 2)\\"
                    ],
                    "names": "translate",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that will translate each item.",
                            "names": "translator"
                        }
                    ],

                    "translator": [
                        {
                            "doc": "The item being translated.",
                            "names": "item"
                        },
                        {
                            "doc": "The index of the item being translated.",
                            "names": "index"
                        },
                        {
                            "doc": "The list being translated.",
                            "names": "list"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes a value and optional index as input and produces a @Boolean, and I'll create a new list that only includes the items that result \\‚ä§\\.",
                        "For example, imagine I was a list of @Number and you only wanted the positive ones:",
                        "\\[2 -4 8 -16].filter(∆í(num‚Ä¢#) num ‚â• 0)\\"
                    ],
                    "names": "filter",
                    "inputs": [
                        {
                            "doc": "A @FunctionDefinition that checks each item, producing \\‚ä§\\ if it should be kept.",
                            "names": "checker"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "The item being checked.",
                            "names": "item"
                        },
                        {
                            "doc": "The index of the item being checked.",
                            "names": "index"
                        },
                        {
                            "doc": "The list being filtered.",
                            "names": "list"
                        }
                    ]
                },
                "all": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes a value as input and produces a @Boolean if it matches some condition. I'll create \\‚ä§\\ if all the items match the condition.",
                        "For example, imagine I was a list of @Number and you wanted to know if everything was positive:",
                        "\\[2 -4 8 -16].all(∆í(num‚Ä¢#) num ‚â• 0)\\"
                    ],
                    "names": "all",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that produces \\‚ä§\\ if an item satisfies your condition.",
                            "names": "checker"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "The item being checked.",
                            "names": "item"
                        },
                        {
                            "doc": "The index of the item being checked.",
                            "names": "index"
                        },
                        {
                            "doc": "The list being checked.",
                            "names": "list"
                        }
                    ]
                },
                "until": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes a value as input and produces a @Boolean if it matches some condition. I'll create a new @List that contains all the items until the condition isn't met.",
                        "For example, imagine I was a list of @Text animals and you wanted everything up until \\'rat'\\ was found:",
                        "\\['cat' 'dog' 'rat' 'mouse' 'pony'].until(∆í(animal‚Ä¢'') animal = 'rat')\\"
                    ],
                    "names": "until",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that produces \\‚ä§\\ if I should stop including items.",
                            "names": "checker"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "The item being checked.",
                            "names": "item"
                        },
                        {
                            "doc": "The index of the item being checked.",
                            "names": "index"
                        },
                        {
                            "doc": "The list being subsequenced.",
                            "names": "list"
                        }
                    ]
                },
                "find": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes a value as input and produces a @Boolean if it matches some criteria, and I'll evaluate to the matching item.",
                        "For example, imagine you wanted to find the first animal that had the vowel \\'e'\\:",
                        "\\['cat' 'dog' 'rat' 'mouse' 'pony'].find(∆í(animal‚Ä¢'') animal.has('e'))\\"
                    ],
                    "names": "find",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that produces \\‚ä§\\ if it matches your search criteria.",
                            "names": "checker"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "The item being checked.",
                            "names": "item"
                        },
                        {
                            "doc": "The index of the item being checked.",
                            "names": "index"
                        },
                        {
                            "doc": "The list being searched.",
                            "names": "list"
                        }
                    ]
                },
                "combine": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes the most recent combination and a next value, and creates a next combination, and I'll move from the first to last of my items, creating successive combinations, and evaluating to the final combination your @FunctionDefinition evaluates to.",
                        "This is really helpful for combining all of the items in me into a single value. For example, imagine you wanted to add a list of numbers:",
                        "\\[3 9 2 8 1 4].combine(0 ∆í(sum‚Ä¢# number‚Ä¢#) sum + number)\\"
                    ],
                    "names": "combine",
                    "inputs": [
                        {
                            "doc": "The starting combination.",
                            "names": "initial"
                        },
                        {
                            "doc": "The @FunctionDefinition that takes the latest combination and the next value and produces the next combination.",
                            "names": "combiner"
                        }
                    ],
                    "combiner": [
                        {
                            "doc": "The current combination",
                            "names": "combination"
                        },
                        {
                            "doc": "The next item to combine.",
                            "names": "next"
                        },
                        {
                            "doc": "The index of the next item",
                            "names": "index"
                        },
                        {
                            "doc": "The list being combined.",
                            "names": "list"
                        }
                    ]
                },
                "sorted": {
                    "doc": [
                        "I can take a list, and make a new list with it's values sorted. Like this:",
                        "\\[1 5 8 0 2].sorted()\\",
                        "I can also do it for @Text values",
                        "\\['orange' 'kiwi' 'banana' 'apple'].sorted()\\",
                        "And if you have a list of values that aren't @Number or @Text, you can give me a @FunctionDefinition that turns each item into a @Number so I can sort it. For example, here we have a list of lists of different lengths; if you give me a function that turns each list into it's length, I can sort by their length.",
                        "\\[[1] [2 3] [4 8 12] [8]].sorted(∆í(list) list.length())\\"
                    ],
                    "names": "sorted",
                    "inputs": [
                        {
                            "doc": "The optional @FunctionDefinition to use to sort a list value. It should turn the value into a @Number that can be used for sorting the list.",
                            "names": "sequencer"
                        }
                    ],
                    "sequencer": [
                        {
                            "doc": "The value to turn into a @Number.",
                            "names": "value"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "To a @Text representation of the list.",
                "set": "To a @Set, helpful for removing duplicates."
            }
        },
        "Set": {
            "doc": [
                "I'm a set of values! That means I can contain any number of values, including no values. You can make me like this:",
                "\\{1 2 3}\\",
                "I'm really good if you want to keep a collection of things without any duplicates.",
                "That means that if you give me values I already have, I'll ignore the extras.",
                "For example, this set has many duplicates:",
                "\\{1 1 2 2 3 3}\\",
                "I evaluate it to just \\{1 2 3}\\.",
                "If you want to see if I have a value in me, @SetOrMapAccess can help:",
                "\\{'jar' 'bottle' 'glass'}{'cup'}\\"
            ],
            "name": ["{}", "Set"],
            "kind": "Kind",
            "out": "Result",
            "function": {
                "size": {
                    "doc": "I'll tell you how many values are in me.",
                    "names": "size",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "I'm \\‚ä§\\ if the given @Set and I have the exact same values:",
                        "\\{1 2 3} = {2 3 4}\\"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        { "doc": "The @Set to compare.", "names": "set" }
                    ]
                },
                "notequals": {
                    "doc": [
                        "I'm \\‚ä§\\ if the given @Set and I don't have the exact same values:",
                        "\\{1 2 3} ‚â† {2 3 4}\\"
                    ],
                    "names": ["‚â†", "notequal"],
                    "inputs": [
                        { "doc": "The @Set to compare.", "names": "set" }
                    ]
                },
                "add": {
                    "doc": [
                        "Give me an item to add and I'll make a new @Set with my items and the given item.",
                        "\\{1 2 3} + 4\\"
                    ],
                    "names": ["add", "+"],
                    "inputs": [{ "doc": "The item to add", "names": "item" }]
                },
                "remove": {
                    "doc": [
                        "Give me an item to remove and I'll make a new @Set without the item.",
                        "\\{1 2 3} - 2\\",
                        "If I don't have the item, I'll just evaluate to myself."
                    ],
                    "names": ["remove", "-"],
                    "inputs": [
                        { "doc": "The item to remove.", "names": "item" }
                    ]
                },
                "union": {
                    "doc": [
                        "Give me @Set and I'll create a new @Set that has my items and the set's items.",
                        "\\{1 2 3} ‚à™ {3 4 5}\\"
                    ],
                    "names": ["union", "‚à™"],
                    "inputs": [
                        {
                            "doc": "The @Set to combine with me.",
                            "names": "set"
                        }
                    ]
                },
                "intersection": {
                    "doc": [
                        "Give me @Set and I'll create a new @Set that has only the items we have in common.",
                        "\\{1 2 3} ‚à© {3 4 5}\\"
                    ],
                    "names": ["intersection", "‚à©"],
                    "inputs": [
                        { "doc": "The set to compare with me.", "names": "set" }
                    ]
                },
                "difference": {
                    "doc": [
                        "Give me @Set and I'll create a new @Set that has the items has only the items we have in common.",
                        "\\{1 2 3}.difference({3 4 5})\\"
                    ],
                    "names": "difference",
                    "inputs": [
                        {
                            "doc": "The set whose items should be removed from me.",
                            "names": "set"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "Give me @FunctionDefinition that takes an item and produces \\‚ä§\\ if it should be kept, and I'll make a @Set that only contains the items that meet your criteria.",
                        "For example, let's find the odd numbers in me:",
                        "\\{1 2 3 4 5 6 7 8 9}.filter(∆í(num‚Ä¢#) (num % 2) = 1)\\"
                    ],
                    "names": "filter",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that checks an item to see if it should be kept.",
                            "names": "checker"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "The item being checked.",
                            "names": "value"
                        },
                        {
                            "doc": "The set being filtered",
                            "names": "set"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "Give me @FunctionDefinition that takes an item and produces a new item based on it, then I'll translate all the items in me into a new @Set (removing any duplicates).",
                        "For example, let's make all my @Number into @Text:",
                        "\\{1 2 3 4 5 6 7 8 9}.translate(∆í(num‚Ä¢#) num‚Üí'')\\"
                    ],
                    "names": "translate",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that translates one of my items into the new item you want.",
                            "names": "set"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "The item being translated.",
                            "names": "value"
                        },
                        {
                            "doc": "The set being translated",
                            "names": "set"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "A @Text representation of a @Set",
                "list": "A @List representation of the items in the set."
            }
        },
        "Map": {
            "doc": [
                "I bring values together, mapping *keys* to *values*. For example:",
                "\\{'amy': 6points 'tony':3points 'shiela': 8points}\\",
                "My keys can be any kind of value, and my values can be any kind of value.",
                "Some people like to think of my like an index, or a dictionary, where you give me something, and I give you what it's mapped to.",
                "If you wanted to check what something is mapped to, you can give @SetOrMapAccess, a key and they'll give you the value:",
                "\\{'amy': 6points 'tony':3points 'shiela': 8points}{'amy'}\\",
                "If there is no matching key, I'll give you @None.",
                "\\{'amy': 6points 'tony':3points 'shiela': 8points}{'jen'}\\",
                "You can also make an empty map like this:",
                "\\{:}\\",
                "I know how to many wonderful things with my pairings."
            ],
            "name": ["{:}", "Map"],
            "key": "Key",
            "value": "Value",
            "result": "Result",
            "function": {
                "size": {
                    "doc": "I'll tell you how many values are in me.",
                    "names": "size",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "\\{‚ä§}\\ if my pairings are the exact same as the given @Map's.",
                        "\\{1:1 2:2} = {1:1 2:3}\\"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "The @Map to compare me to.",
                            "names": "value"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "\\{‚ä§}\\ if my pairings are /not/ the exact same as the given @Map's.",
                        "\\{1:1 2:2} ‚â† {1:1 2:3}\\"
                    ],
                    "names": ["‚â†", "notequal"],
                    "inputs": [
                        {
                            "doc": "The @Map to compare me to.",
                            "names": "value"
                        }
                    ]
                },
                "set": {
                    "doc": [
                        "I'll make a new @Map with all the same pairings, but with the new pairing you give me. If I already have the key, I'll pair it to the new value.",
                        "\\{'amy': 6points 'tony':3points}.pair('jen' 0points)\\"
                    ],
                    "names": "pair",
                    "inputs": [
                        { "doc": "Key to pair with a value.", "names": "key" },
                        {
                            "doc": "The value to pair with the key",
                            "names": "value"
                        }
                    ]
                },
                "unset": {
                    "doc": [
                        "I'll make a new @Map without the key you give me, removing its pairing.",
                        "\\{'amy': 6points 'tony':3points}.unpair('amy')\\"
                    ],
                    "names": "unpair",
                    "inputs": [{ "doc": "The key to forget.", "names": "key" }]
                },
                "remove": {
                    "doc": [
                        "I'll create a new @Map without any keys that have the value.",
                        "\\{'amy': 0points 'jen': 0points 'tony':3points}.remove(0points)\\"
                    ],
                    "names": "remove",
                    "inputs": [
                        {
                            "doc": "The value to remove from me, along with any keys its paired to.",
                            "names": "value"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes a key and value and evaluates to \\‚ä§\\ if a pairing should be kept. I'll create a new @Map that meets your criteria.",
                        "For example, here we want to keep any pairings that are Amy or have more than zero points.",
                        "\\{'amy': 0points 'jen': 0points 'tony':3points}.filter(∆í(key‚Ä¢'' value‚Ä¢#points) (key = 'amy') | (value > 0points))\\"
                    ],
                    "names": "filter",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that decides whether to keep a pairing.",
                            "names": "checker"
                        }
                    ],
                    "checker": [
                        { "doc": "The key being checked.", "names": "key" },
                        {
                            "doc": "The value being checked.",
                            "names": "value"
                        },
                        {
                            "doc": "The map being filtered.",
                            "names": "map"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes a key and value and evaluates the value to a new value. I'll create a new @Map with the same keys but updated values.",
                        "For example, let's give everyone one point since they've been so nice.",
                        "\\{'amy': 5points 'jen': 3points 'tony': 0points}.translate(∆í(key‚Ä¢'' value‚Ä¢#points) value + 1points)\\"
                    ],
                    "names": "translate",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that translates each value.",
                            "names": "translator"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "The key of the value being translated.",
                            "names": "key"
                        },
                        {
                            "doc": "The value being translated.",
                            "names": "value"
                        },
                        {
                            "doc": "The map being translated.",
                            "names": "map"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "A @Text representation of the mapping.",
                "set": "The keys of the @Map",
                "list": "A list of the values in the @Map"
            }
        },
        "Table": {
            "doc": [
                "I'm a set of table rows! I can help you help track of large collections of values that have the same structure.",
                "For example, imagine you wanted to keep track of a bunch of rocks:",
                "\\‚é°name‚Ä¢'' color‚Ä¢''‚é¶\n‚é°'obsidian' 'black'‚é¶\n‚é°'pumice' 'grey'‚é¶\n‚é°'citrine' 'yellow'‚é¶\\",
                "@Bind can help you name it! And then you can do things like make a revised table with an new row @Insert:",
                "\\rocks: ‚é°name‚Ä¢'' color‚Ä¢''‚é¶\n‚é°'obsidian' 'black'‚é¶\n‚é°'pumice' 'grey'‚é¶\n‚é°'citrine' 'yellow'‚é¶\nrocks ‚é°+ 'quartz' 'white'‚é¶\\",
                "Or if you want to find rows that match, you can @Select rows that match a condition:",
                "\\rocks: ‚é°name‚Ä¢'' color‚Ä¢''‚é¶\n‚é°'obsidian' 'black'‚é¶\n‚é°'pumice' 'grey'‚é¶\n‚é°'citrine' 'yellow'‚é¶\nrocks ‚é°?‚é¶ color = 'grey'\\",
                "Or maybe you want to make a revised table that has different values for rows that match a condition:",
                "\\rocks: ‚é°name‚Ä¢'' color‚Ä¢''‚é¶\n‚é°'obsidian' 'black'‚é¶\n‚é°'pumice' 'grey'‚é¶\n‚é°'citrine' 'yellow'‚é¶\nrocks ‚é°: color: 'black' ‚é¶ name = 'pumice'\\",
                "Or maybe you want to delete a rows match a condition:",
                "\\rocks: ‚é°name‚Ä¢'' color‚Ä¢''‚é¶\n‚é°'obsidian' 'black'‚é¶\n‚é°'pumice' 'grey'‚é¶\n‚é°'citrine' 'yellow'‚é¶\nrocks ‚é°- name.has('i')\\",
                "And if you ever want to get specific values from me, you can convert any table to a list and access individual rows with @PropertyReference",
                "\\rocks: ‚é°name‚Ä¢'' color‚Ä¢''‚é¶\n‚é°'obsidian' 'black'‚é¶\n‚é°'pumice' 'grey'‚é¶\n‚é°'citrine' 'yellow'‚é¶\n(rocks ‚Üí [])[1].name\\"
            ],
            "name": ["‚é°‚é¶", "Table"],
            "row": "Row",
            "function": {
                "equals": {
                    "doc": "I check if I have the exact same cells in the exact same order as another @Table.",
                    "names": ["=", "equals"],
                    "inputs": [
                        { "doc": "The other table to check.", "names": "value" }
                    ]
                },
                "notequal": {
                    "doc": "I check if any of my cells are different or in a different order from another @Table.",
                    "names": ["‚â†", "notEquals"],
                    "inputs": [
                        { "doc": "The other table to check.", "names": "value" }
                    ]
                }
            },
            "conversion": {
                "list": "I convert a @Table into a list of rows, where each row is a @Structure with its column names as properties.",
                "text": "I just convert a @Table to text."
            }
        },
        "Structure": {
            "doc": "See @StructureDefinition.",
            "name": ["Structure"],
            "function": {
                "equals": {
                    "doc": "I check if my properties are the same name and values as another structure's properties.",
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "The other structure to check.",
                            "names": "value"
                        }
                    ]
                },
                "notequal": {
                    "doc": "I check if my properties are different in any way from the name and values as another structure's.",
                    "names": ["‚â†", "notEquals"],
                    "inputs": [
                        {
                            "doc": "The other structure to check.",
                            "names": "value"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "I convert myself to @Text."
            }
        }
    },
    "input": {
        "Random": {
            "doc": [
                "17!",
                "/@FunctionDefinition here, I'll explain this one./",
                "So @Random is a curious function that creates random numbers. It's curious because every time you evaluate it, it creates something different.",
                "This creates a wonderful chaos that comes with unpredictability.",
                "By default, it gives @Number values between \\0\\ and \\1\\:",
                "\\Random()\\",
                "But you can give it a value, and it will generate values between \\0\\ and the value:",
                "\\Random(10)\\",
                "And if you give it two values, it will generate values between and including the two values:",
                "\\Random(-10 10)\\",
                "If your ranges have units, they will be preserved (and if they don't match, the minimum's unit will be used):",
                "\\Random(-10m 10m)\\",
                "And if you give numbers with particular numbers of significant digits after the decimal point, that precision will be preserved.",
                "\\Random(1.00 10.00)\\"
            ],
            "names": ["üé≤", "Random"],
            "inputs": [
                {
                    "names": "min",
                    "doc": "The minimum value that will be created, or if it's larger than 0, the maximum value. If @None is provided, then the miniumum is \\0\\."
                },
                {
                    "names": "max",
                    "doc": "The maximum value that will created, or if its smaller than the minimum provided, the minimum. If @None is provided, than the maximum is \\1\\."
                }
            ]
        },
        "Choice": {
            "doc": [
                "/clickety tap!/",
                "/@FunctionDefinition here, I'll explain this one./",
                "Think of @Choice like a stream of @Phrase/name that are selected by your audience. If someone clicks, taps, or keyboard selects by pressing /Enter/ on a @Phrase with a name -- @Choice will have a new value matching the name.",
                "So the best way to use it is to create a performance with named selectable phrases @Phrase, and then use a @Reaction to decide what to do when that name is chosen.",
                "Here's the simplest example:",
                "\\Group(\nStack() \n[\nPhrase('one' selectable:‚ä§ name:'1') \nPhrase('two' selectable:‚ä§ name:'2') \nPhrase(Choice())\n]\n)\\",
                "Copy this into the editor and then select one of the two @Phrase. You'll see the third @Phrase shows the name that was selected."
            ],
            "names": ["üîò", "Choice"]
        },
        "Button": {
            "doc": [
                "/click click click/",
                "/@FunctionDefinition here, I'll explain this one./",
                "@Button is a great way to listen to a mouse or trackpad. Of course, a mouse or trackpad isn't an ideal choice for listening to an audience, since not everyone can use one. The more accessible choice is @Choice.",
                "But if you /really/ need to listen to a mouse button, this is the way to do it. It will provide a stream of @Boolean, representing whether the primary button is up \\‚ä•\\ or down \\‚ä§\\.",
                "Here's a simple example:",
                "\\Phrase(Button() ‚Üí '')\\",
                "This just makes a @Phrase that is the value of the stream as text. If you copy it into the editor and click, you'll see it toggle back and forth between \\‚ä•\\ and \\‚ä§\\."
            ],
            "names": ["üñ±Ô∏è", "Button"],
            "down": {
                "names": "down",
                "doc": "If @None, the stream will provide both up and down values. If @Boolean, it will only provide value the given @Boolean value."
            }
        },
        "Pointer": {
            "doc": [
                "/whrrrrrr/",
                "/@FunctionDefinition here, I'll explain this one./",
                "You know about mice, trackpads, and touch screens? Sometimes you want to know where an audience is pointing. That's what @Pointer provides.",
                "Of course, this is not an accessible choice: not everyone can see or easily point, so be really sure you're not excluding someone from participating by using this stream.",
                "If you're sure no one is excluded, then using @Pointer is as simple as just making a stream:",
                "\\Pointer()\\",
                "The @Place it provides will correspond to where on @Stage the pointer is pointing."
            ],
            "names": ["üëÜüèª", "Pointer"]
        },
        "Key": {
            "doc": [
                "/clickety/",
                "/@FunctionDefinition here, I'll explain this one./",
                "Keyboards have a lot of keys, don't they? @Key will tell you which one someone is pressing and releasing.",
                "Try this",
                "\\Key()\\",
                "See how when you type a key, it shows up on @Stage? Every time a key is pressed down, a new @Text is added to the stream, describing the key that was pressed.",
                "For a key that represents a character, the value will be the character as @Text.",
                "For special keys, like the /Escape/ key, it will be @Text that describes the key, using a <pre-defined name@https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values>, unfortunately available only in English.",
                "If you only want to know about a particular key, you can provide it:",
                "\\Key('a')\\",
                "And if you only want to know when when a @Key is released instead of pressed, you can provide a @Boolean:",
                "\\Key('a' ‚ä•)\\"
            ],
            "names": ["‚å®Ô∏è", "Key"],
            "key": {
                "names": "key",
                "doc": "If @None, than all keys are provided. If a specific @Text, then only that key is provided."
            },
            "down": {
                "names": "down",
                "doc": "IF @None, then key down generates inputs. If \\‚ä§\\, then only down inputs are provided, and if \\‚ä•\\, then only release inputs are provided."
            }
        },
        "Time": {
            "doc": [
                "/tick tick tick/",
                "@FunctionDefinition here, I'll explain @Time, since it doesn't speak.",
                "Time is a stream that ticks at a certain frequency.",
                "Each time it does, @Program reevaluates with the new time value.",
                "For example:",
                "\\Time()\\",
                "If you provide time a @Time/frequency, it will tick at that rate. For example:",
                "\\Time(1000ms)\\",
                "However, there are limits to how small it can be, since @Program needs time to evaluate before they can respond to the next tick.",
                "The smallest is probably around \\20ms\\."
            ],
            "names": ["üïï", "Time"],
            "frequency": {
                "names": ["frequency"],
                "doc": "This is the frequency with which time should tick. It defaults to \\33ms\\, which is about 30 times per second."
            }
        },
        "Volume": {
            "doc": [
                "/bzzzzzzz/",
                "@FunctionDefinition here, I'll take the mic.",
                "This stream is a series of volumes between 0 and 1, sampled at the frequency of your choice. By default, the frequency is \\30hz\\, or 30 times per second, but you can change it to anything less frequent.",
                "\\Volume()\\",
                "This is great for listening to how loud the audience is!"
            ],
            "names": ["üé§", "Volume"],
            "frequency": {
                "names": ["frequency"],
                "doc": "The time between samplings."
            }
        },
        "Pitch": {
            "doc": [
                "/hummmmm/",
                "@FunctionDefinition here, let's talk pitch!",
                "This stream is a series of frequencies in hertz, indicating the pitch of sound, sampled at the frequency of your choice. We've found that the human voice is between 20Hz and 5000Hz, so plan on numbers in that range.",
                "\\Pitch()\\",
                "This is great for listening the tone that someone is speaking or singing."
            ],
            "names": ["üéµ", "Pitch"],
            "frequency": {
                "names": ["frequency"],
                "doc": "The time between samplings."
            }
        },
        "Camera": {
            "doc": [
                "/bzzzzzzz/",
                "@FunctionDefinition here, I can explain @Camera!",
                "So @Camera provides a @List of @Color from your world. That list essentially represents an image, but it's up to you to decide what to do with it.",
                "You could try to represent the image with a bunch of @Phrase, which could look pretty cool! Try copying this...",
                "\\colors: Camera(32px 24px 33ms)\n\nStage(\ncolors.combine(\n[] \n∆í(phrases‚Ä¢[Phrase] row‚Ä¢[Color] y‚Ä¢#) \nphrases.append(\nrow.translate(\n∆í(color‚Ä¢Color x‚Ä¢#)\nPhrase('o' place: Place((x - 1) ¬∑ 0.5m y ¬∑ -0.5m) color: color duration: 0s\n)\n)\n)\n)\n)\\",
                "But you could also analyze the colors to decide if a light was on or off, or if a particular color was common, letting the audience influence a performance with the colors they show."
            ],
            "names": ["üé•", "Camera"],
            "width": {
                "names": ["width"],
                "doc": "The number of @Color to sample in a row."
            },
            "height": {
                "names": ["height"],
                "doc": "The number of @Color to sample in a column."
            },
            "frequency": {
                "names": ["frequency"],
                "doc": "The time between @Color samples."
            }
        },
        "Motion": {
            "doc": [
                "/boing boing boing/",
                "/Hi! @FunctionDefinition here. How about I explain @Motion?",
                "Basically, @Motion is a stream of @Phrase. You give it a starting @Phrase, and then it refines it with a new place and rotation based on gravity.",
                "This let's you do really simple things like creating bouncing emoji:",
                "\\Motion(Phrase('o') startplace: Place(0m 10m))\\",
                "See how the o bounces? On the first evaluation, we give it a place up high on @Stage, but then after, it gets @None, which allows @Motion to change it to whatever position gravity would place it.",
                "Check out the many other ways to configure it below."
            ],
            "names": ["‚öΩÔ∏è", "Motion"],
            "type": {
                "doc": "The @Phrase to refine with new @Phrase/resting places and rotations.",
                "names": "type"
            },
            "startplace": {
                "doc": "The initial place for the @Phrase.",
                "names": "startplace"
            },
            "startvx": {
                "doc": "The initial velocity on the x-axis at which the @Phrase should move.",
                "names": "startvx"
            },
            "startvy": {
                "doc": "The initial velocity on the y-axis at which the @Phrase should move. If it, it overrides gravity.",
                "names": "startvy"
            },
            "startvz": {
                "doc": "The initial velocity on the z-axis at which the @Phrase should move.",
                "names": "startvz"
            },
            "startvangle": {
                "doc": "The initial rotational velocity at which the @Phrase should rotate.",
                "names": "startvangle"
            },
            "vx": {
                "doc": "The velocity on the x-axis at which the @Phrase should move, independent of physics.",
                "names": "vx"
            },
            "vy": {
                "doc": "The velocity on the y-axis at which the @Phrase should move, independent of physics.",
                "names": "vy"
            },
            "vz": {
                "doc": "The velocity on the z-axis at which the @Phrase should move, independent of physics.",
                "names": "vz"
            },
            "vangle": {
                "doc": "The rotational velocity at which the @Phrase should rotate, independent of physics.",
                "names": "vangle"
            },
            "mass": {
                "doc": "The mass of the @Phrase, which may someday influence collisions.",
                "names": "mass"
            },
            "bounciness": {
                "doc": "The fraction between 0 and 1 that determines how much a velocity is dampened when a @Phrase collides.",
                "names": "bounciness"
            },
            "gravity": {
                "doc": "The gravity to apply to @Motion/vy.",
                "names": "gravity"
            }
        },
        "Placement": {
            "doc": [
                "/Hey, @FunctionDefinition here. Let's talk about how to get us moving!/",
                "So there are many ways to place us on @Stage. You can give us an explicit @Place. You could use @Motion, and let gravity do it's work. You could also put us in a @Group and let them arrange us in a particular way.",
                "But sometimes you want to give the /audience/ control over where we are on @Stage. That's what @Placement is for.",
                "Here's how it works: you just make a @Placement and give it to our @Place:",
                "\\Phrase('hi' place: Placement())\\",
                "Then, any time the audience uses an arrow key or clicks or taps on stage, the @Placement will make a new @Place that moves in the desired direction.",
                "Try copying this to your program and moving us arrowed with the pointer or keyboard.",
                "You can customize the @Placement, enabling and disabling movement on certain dimensions, changing how far a @Place moves, and the initial @Place the stream starts with."
            ],
            "names": ["‚ú•", "Placement"],
            "inputs": [
                {
                    "doc": "The initial place to start with.",
                    "names": "start"
                },
                {
                    "doc": "How many meters the place should move when the audience requests a move.",
                    "names": "distance"
                },
                {
                    "doc": "If true, allows movement on the horizontal axis. On by default.",
                    "names": "horizontal"
                },
                {
                    "doc": "If true, allows movement on the vertical axis. On by default.",
                    "names": "vertical"
                },
                {
                    "doc": "If true, allows movement on the z-axis, with the + and - keys.",
                    "names": "depth"
                }
            ]
        }
    },
    "output": {
        "Type": {
            "names": "Type",
            "doc": [
                "I am not a @StructureDefinition you can actually make. But I am a very important one, as I inspire the most important elements of our dance: @Phrase, @Group, and @Stage.",
                "Go meet them to learn more about how to use them."
            ]
        },
        "Group": {
            "doc": [
                "Oh hello, how are you? I'm always fine when others are around, so it's great to be with you!",
                "I group together @Phrase and @Group on @Stage and put them in an @Arrangement, so there's some order to where they're placed.",
                "To work, I need you to give me an @Arrangement, and then a @List of @Type to arrange.",
                "For example, here I am with a @Stack arrangement and a few @Phrase to stack vertically:",
                "\\Group(Stack() [Phrase('first') Phrase('second')])\\",
                "How exactly I arrange things depend on the @Arrangement you give me."
            ],
            "names": ["üî≥", "Group"],
            "layout": {
                "doc": "The arrangement to use to put @Type in their places.",
                "names": "layout"
            },
            "content": {
                "doc": "The list of @Type to arrange.",
                "names": "content"
            },
            "size": {
                "doc": "How tall the wonderful content inside me should be, unless they have a size of their own!",
                "names": "size"
            },
            "face": {
                "doc": "The name of the font face content inside me should have, unless they have their own face to use.",
                "names": "face"
            },
            "place": {
                "doc": "The place on stage where I should be. The content inside me will be arranged relative to there.",
                "names": "place"
            },
            "name": {
                "doc": ["The same as @Phrase/name!"],
                "names": "name"
            },
            "selectable": {
                "doc": "The same as @Phrase/selectable!",
                "names": "selectable"
            },
            "color": {
                "doc": "The @Color that content inside me should be, unless they have their own color.",
                "names": "color"
            },
            "background": {
                "doc": "The @Color to project behind me.",
                "names": "background"
            },
            "opacity": {
                "doc": "How transparent everything inside me should be, between \\0\\ and \\1\\, unless overriden by a different @Pose.",
                "names": "opacity"
            },
            "offset": {
                "doc": "A @Place indicating how offset from my normal @Place it should be, unless overriden by a different @Pose. Helpful for wiggling in place.",
                "names": "offset"
            },
            "rotation": {
                "doc": "How tilted should I be around my center, my @Pose has a different one.",
                "names": "rotation"
            },
            "scale": {
                "doc": "How big I should be relative to my original size.",
                "names": "scale"
            },
            "flipx": {
                "doc": "Same as @Phrase/flipx!",
                "names": "flipx"
            },
            "flipy": {
                "doc": "Same as @Phrase/flipy",
                "names": "flipy"
            },
            "entering": {
                "doc": "Same as @Phrase/entering!",
                "names": "entering"
            },
            "resting": {
                "doc": "Same as @Phrase/resting!",
                "names": "resting"
            },
            "moving": {
                "doc": "Same as @Phrase/moving!",
                "names": "moving"
            },
            "exiting": {
                "doc": "Same as @Phrase/exiting!",
                "names": "exiting"
            },
            "duration": {
                "doc": "Same as @Phrase/duration!",
                "names": ["‚è≥", "duration"]
            },
            "style": {
                "doc": "Same as @Phrase/style!",
                "names": "style"
            },
            "description": "$1[$1|] $2 $3"
        },
        "Phrase": {
            "doc": [
                "Hello, hello! Remember me? How could anyone forget /me/. That's right, I am the manificent @Phrase, ready to represent the loveliest of @Text on @Stage.",
                "Just make me like this, and I'll appear on @Stage:",
                "\\Phrase('magnificient!')\\",
                "I need some @Text, obviously, but otherwise, I can do everything a @Type can do, including changing my size, font, rotation, and do all of my incredible dances with @Pose and @Sequence.",
                "You can also select me on @Stage and edit me on the palette next door."
            ],
            "names": ["üí¨", "Phrase"],
            "text": {
                "doc": "The characters to show on @Stage.",
                "names": "text"
            },
            "size": {
                "doc": "How tall I should be, in meters!",
                "names": "size"
            },
            "face": {
                "doc": "The name of the font face I should put on.",
                "names": "face"
            },
            "place": {
                "doc": "The place on stage where I should be.",
                "names": "place"
            },
            "name": {
                "doc": [
                    "A name you give me! This is helpful for many things.",
                    "First, if I have a name, I'll use it to describe myself in screen reader descriptions.",
                    "Second, when animating, you might have multiple different expressions that are supposed to represent the same content on stage; give them the same name and they will animate as one.",
                    "Finally, I'm helpful with @Choice: the names you give me appear in that stream.",
                    "You can give me many different names, each in a different language, if it's helpful. I'll always use the name in the first selected locale."
                ],
                "names": "name"
            },
            "selectable": {
                "doc": "If \\‚ä§\\, indicates that I can be selected via a pointer or keyboard.",
                "names": "selectable"
            },
            "color": {
                "doc": "The @Color I should be by default, unless overriden by a different @Pose.",
                "names": "color"
            },
            "background": {
                "doc": "The @Color to project behind me.",
                "names": "background"
            },
            "opacity": {
                "doc": "How transparent I should be by default, between \\0\\ and \\1\\, unless overriden by a different @Pose. Helpful for fading in and out.",
                "names": "opacity"
            },
            "offset": {
                "doc": "A @Place indicating how offset from my @Place it should be, unless overriden by a different @Pose. Helpful for wiggling in place.",
                "names": "offset"
            },
            "rotation": {
                "doc": "The amount in degrees I should should be rotated around its center, unless overriden by a different @Pose.",
                "names": "rotation"
            },
            "scale": {
                "doc": "How magnified I should be relative to its original size, unless overriden by a different @Pose.",
                "names": "scale"
            },
            "flipx": {
                "doc": "Whether I should be mirrored on the x-axis, unless overriden by a different @Pose.",
                "names": "flipx"
            },
            "flipy": {
                "doc": "Whether I should be mirrored on the y-axis, unless overriden by a different @Pose.",
                "names": "flipy"
            },
            "entering": {
                "doc": "The @Pose or @Sequence I should do upon entering the stage.",
                "names": "entering"
            },
            "resting": {
                "doc": "The @Pose or @Sequence I should do after I've entered stage, before I exit, and while my @Place isn't changing. If you don't give me one, I'll just use my defaults.",
                "names": "resting"
            },
            "moving": {
                "doc": "The @Pose or @Sequence I should do when moving places on stage, instead of my defaults.",
                "names": "moving"
            },
            "exiting": {
                "doc": "The @Pose or @Sequence to should do before exiting stage.",
                "names": "exiting"
            },
            "duration": {
                "doc": "The duration to apply when moving to a different place on stage.",
                "names": ["‚è≥", "duration"]
            },
            "style": {
                "doc": "The animation style to use when moving to a different place on stage.",
                "names": "style"
            },
            "description": "$3[$3 meter |]phrase $1 $2[named $2|] $4[$4|] $5"
        },
        "Arrangement": {
            "doc": "I am an inspiration to the many other kinds of arrangment in the Verse, including @Row, @Stack, @Grid, and @Free. I work closely with @Group to ",
            "names": ["‚†ø", "Arrangement"]
        },
        "Row": {
            "doc": "I am @Row, a horizontal @Arrangement of @Type, with optional padding in between. Have you met my twin, @Stack?",
            "names": ["‚û°", "Row"],
            "description": "row of $1 phrases and groups",
            "alignment": {
                "doc": "Whether to align text at the start, center, or end on each column.",
                "names": "alignment"
            },
            "padding": {
                "doc": "The amount of padding to place between output.",
                "names": "padding"
            }
        },
        "Stack": {
            "doc": "I am @Stack, a vertical @Arrangement of @Type, with optional padding in between. Have you met my twin, @Row? ",
            "names": ["‚¨á", "Stack"],
            "description": "stack of $1 phrases and groups",
            "alignment": {
                "doc": "Whether to align text at the start, center, or end on each row.",
                "names": "alignment"
            },
            "padding": {
                "doc": "The amount of padding to place between output.",
                "names": "padding"
            }
        },
        "Grid": {
            "doc": "I am grid of @Type. Give me a row and column count and I'll make a tidy arrangement with optional padding and cell sizes.",
            "names": ["‚ñ¶", "Grid"],
            "description": "$1 row $2 column grid",
            "rows": {
                "doc": "How many rows in make in the grid.",
                "names": "rows"
            },
            "columns": {
                "doc": "How many columns to make in the grid.",
                "names": "columns"
            },
            "padding": {
                "doc": "How much padding to place between cells.",
                "names": "padding"
            },
            "cellWidth": {
                "doc": "How wide the cells should be.",
                "names": "cellwidth"
            },
            "cellHeight": {
                "doc": "How tall the cells should be.",
                "names": "cellpadding"
            }
        },
        "Free": {
            "doc": [
                "I'm like, whatever. Sit wherever you want. Just sit somewhere! Make sure all the @Type you give me have a @Place, otherwise they won't know where to go.",
                "Oh, and remember that the @Place you give each @Type is relative to the @Group's @Place! So if you're wondering why things aren't appearing where you expect, try giving the @Group a place too."
            ],
            "names": ["Free"],
            "description": "free-form $1 outputs"
        },
        "Shape": {
            "doc": "I'm an inspiration to all shapes. I'm useful for telling @Stage what shape to be.",
            "names": "Shape"
        },
        "Rectangle": {
            "doc": "I am a rectangle, useful for making @Stage have a boundary the size of your choosing.",
            "names": ["Rectangle"],
            "left": {
                "doc": "The left edge of the stage on the x-axis",
                "names": "left"
            },
            "top": {
                "doc": "The top edge of the stage on the y-axes",
                "names": "top"
            },
            "right": {
                "doc": "The right edge of the stage on the x-axis",
                "names": "right"
            },
            "bottom": {
                "doc": "The bottom edge of the stage on the y-axis",
                "names": "bottom"
            }
        },
        "Pose": {
            "doc": [
                "You know when someone strikes the most amazing way of standing, a pauses, and everyone looks? That's me. I capture a pose for @Type to be in, and am the building block of their movements.",
                "So much goes into a pose. Check out my many inputs to see what kinds of poses you might make!"
            ],
            "names": ["ü§™", "Pose"],
            "duration": {
                "doc": "How long this pose should take to enter from a previous pose.",
                "names": "duration"
            },
            "style": {
                "doc": "The style of animation to use when moving to this pose.",
                "names": "style"
            },
            "color": {
                "doc": "The @Color a @Type should be in this pose, instead of it's default.",
                "names": "color"
            },
            "opacity": {
                "doc": "How transparent a @Type should be, between \\0\\ and \\1\\, instead of it's default. Helpful for fading in and out.",
                "names": "opacity"
            },
            "offset": {
                "doc": "A @Place indicating how offset from a @Type's place it should be, instead of it's default. Helpful for wiggling in place.",
                "names": "offset"
            },
            "rotation": {
                "doc": "How rotated a @Type should be, instead of it's default.",
                "names": "rotation"
            },
            "scale": {
                "doc": "How magnified a @Type should be relative to its original size, instead of it's default.",
                "names": "scale"
            },
            "flipx": {
                "doc": "Whether a @Type should be mirrored on the x-axis, instead of its default.",
                "names": "flipx"
            },
            "flipy": {
                "doc": "Whether a @Type should be mirrored on the y-axis, instead of it's default.",
                "names": "flipy"
            },
            "description": "$1[transparent $1|] $2[rotated $2 degrees|] $3[scaled $3|] $4[flipped horizontally|] $5[flipped vertically|]"
        },
        "Color": {
            "doc": [
                "I am a visible color, made of three essential dimensions.",
                "Here are some common colors around the color wheel, at medium brightness and high chroma:",
                "\\Color(50% 100 0¬∞)\\",
                "\\Color(50% 100 30¬∞)\\",
                "\\Color(50% 100 60¬∞)\\",
                "\\Color(50% 100 90¬∞)\\",
                "\\Color(50% 100 120¬∞)\\",
                "\\Color(50% 100 150¬∞)\\",
                "\\Color(50% 100 180¬∞)\\",
                "\\Color(50% 100 210¬∞)\\",
                "\\Color(50% 100 240¬∞)\\",
                "\\Color(50% 100 270¬∞)\\",
                "\\Color(50% 100 300¬∞)\\",
                "\\Color(50% 100 330¬∞)\\"
            ],
            "names": ["üåà", "Color"],
            "lightness": {
                "doc": "How light I should be from \\0\\ to \\1\\, from black at \\0\\, to grey at \\0.5\\, to white at \\1\\.",
                "names": ["lightness", "l"]
            },
            "chroma": {
                "doc": "How much color I should have, from \\0\\ to \\‚àû\\. No color means grey, higher numbers mean the more color.",
                "names": ["chroma", "c"]
            },
            "hue": {
                "doc": "What color I should be, on a color wheel, from megenta \\0\\, red \\30\\, green \\120\\, to blue \\270\\.",
                "names": ["hue", "h"]
            }
        },
        "Sequence": {
            "doc": [
                "Oh. My. Gosh. Director, you look amazing today! Do you want to dance with me? It's easy.",
                "You just need to give me a @Map, where each key represents what percent along we are in the dance, and each value of those keys is a @Pose to be.",
                "There are /so/ many different ways you can animate with this! For example, here's a simple one:",
                "\\Phrase('hi' resting:Sequence({0%: Pose(rotation: 360¬∞) 100%: Pose(rotation: 0¬∞)})\\",
                "This says, /at the beginning (0%), start at tilt 360, and end at tilt 0/. That'll spin us around in circles forever, since I'm set as the @Phrase's rest pose!",
                "Try your own creative dances by playing with other inputs."
            ],
            "names": ["üíÉ", "Sequence"],
            "poses": {
                "doc": "A @Map of percentages between 0% and 100%, each paired with a @Pose. You don't have to provide all the percents; I will smoothly move a @Type between the ones you give me.",
                "names": "poses"
            },
            "count": {
                "doc": "How many times the sequence should repeat before it is done.",
                "names": "count"
            }
        },
        "Place": {
            "doc": "I'm a location on @Stage. All my inputs are optional, because I'm at the center by default.",
            "names": ["üìç", "Place"],
            "x": { "doc": "A position on the x-axis.", "names": "x" },
            "y": { "doc": "A position on the y-axis", "names": "y" },
            "z": { "doc": "A position on the z-axis", "names": "z" }
        },
        "Stage": {
            "doc": [
                "HI. STAGE HERE. TELL ME WHAT TO SHOW AND I WILL SHOW IT.",
                "\\Stage([Phrase('stufffffff')])\\",
                "IF YOU WANT, GIVE ME A BACKGROUND @Color AND I WILL LIGHT THE STAGE ACCORDINGLY.",
                "\\Stage([Phrase('stufffffff')] Color(0% 0 0¬∞) color: Color(100% 0 0¬∞))\\",
                "YOU MAY ALSO GIVE ME A FRAME BORDER AND I WILL CROP.",
                "\\Stage([Phrase('stufffffff')] Color(0% 0 0¬∞) Rectangle(-1m -1m 1m 1m) color: Color(100% 0 0¬∞))\\"
            ],
            "names": ["üé≠", "Stage"],
            "content": {
                "doc": "The list of @Type to show on stage.",
                "names": "content"
            },
            "frame": {
                "doc": "The shape and size of frame to place around the stage, hiding everything outside it.",
                "names": "frame"
            },
            "size": {
                "doc": "LIKE @Group/size",
                "names": "size"
            },
            "face": {
                "doc": "LIKE @Group/face",
                "names": "face"
            },
            "place": {
                "doc": "IF I WERE A CAMERA, THIS IS WHERE I AM LOOKING",
                "names": "place"
            },
            "name": {
                "doc": ["SAME AS @Phrase/name!"],
                "names": "name"
            },
            "selectable": {
                "doc": "SAME AS @Phrase/selectable!",
                "names": "selectable"
            },
            "color": {
                "doc": "SAME AS @Group/color",
                "names": "color"
            },
            "background": {
                "doc": "SAME AS @Group/background",
                "names": "background"
            },
            "opacity": {
                "doc": "SAME AS @Group/opacity",
                "names": "opacity"
            },
            "offset": {
                "doc": "SAME AS @Group/offset",
                "names": "offset"
            },
            "rotation": {
                "doc": "SAME AS @Group/rotation",
                "names": "rotation"
            },
            "scale": {
                "doc": "SAME AS @Group/scale",
                "names": "scale"
            },
            "flipx": {
                "doc": "SAME AS @Group/flipx",
                "names": "flipx"
            },
            "flipy": {
                "doc": "SAME AS @Group/flipy",
                "names": "flipy"
            },
            "entering": {
                "doc": "SAME AS @Group/entering",
                "names": "entering"
            },
            "resting": {
                "doc": "SAME AS @Group/resting!",
                "names": "resting"
            },
            "moving": {
                "doc": "SAME AS @Group/moving!",
                "names": "moving"
            },
            "exiting": {
                "doc": "SAME AS @Group/exiting!",
                "names": "exiting"
            },
            "duration": {
                "doc": "SAME AS @Phrase/duration!",
                "names": ["‚è≥", "duration"]
            },
            "style": {
                "doc": "SAME AS @Phrase/style!",
                "names": "style"
            },
            "description": "stage $1[$1|] of $2 phrases $3[$3 frame|] $4"
        },
        "Easing": {
            "straight": "straight",
            "cautious": "cautious",
            "pokey": "pokey",
            "zippy": "zippy"
        },
        "sequence": {
            "sway": {
                "doc": "I create a @Sequence that sways back and forth around a @Type's center.",
                "names": ["sway"],
                "angle": {
                    "doc": "How much to tilt in the sway.",
                    "names": ["angle"]
                }
            },
            "bounce": {
                "doc": "I create a @Sequence that bounces @Type a given height.",
                "names": ["bounce"],
                "height": { "doc": "How high to bounce.", "names": ["height"] }
            },
            "spin": {
                "doc": "I create a @Sequence that rotates @Type around its center.",
                "names": ["spin"]
            },
            "fadein": {
                "doc": "I create a @Sequence that fades @Type in from invisible to visible.",
                "names": ["fadein"]
            },
            "popup": {
                "doc": "I create a @Sequence that makes @Type scale in quickly than shrink to its normal size.",
                "names": ["popup"]
            },
            "shake": {
                "doc": "I create a @Sequence that makes it look like a @Type is scared.",
                "names": ["shake"]
            }
        }
    },
    "ui": {
        "font": {
            "app": "Noto Sans",
            "code": "Noto Mono"
        },
        "phrases": {
            "welcome": "hello"
        },
        "widget": {
            "confirm": {
                "cancel": "cancel"
            },
            "dialog": {
                "close": "close"
            },
            "loading": {
                "message": "Loading font faces and text, thanks for waiting!"
            }
        },
        "tile": {
            "toggle": {
                "fullscreen": {
                    "on": "leave full screen",
                    "off": "expand tile to full screen"
                },
                "show": {
                    "on": "hide this tile",
                    "off": "show this tile"
                }
            },
            "button": {
                "collapse": "collapse window"
            }
        },
        "project": {
            "error": {
                "unknown": "This performance doesn't exist or isn't public."
            },
            "button": {
                "showCollaborators": "show collaborators dialog",
                "removeCollaborator": "remove collaborator",
                "copy": "copy project as text",
                "addSource": "create a new $source",
                "duplicate": "copy this project",
                "revert": "revert to original code",
                "focusOutput": "focus keyboard on the stage",
                "focusSource": "focus on the next source",
                "focusDocs": "focus on the documentation",
                "focusPalette": "focus on the palette",
                "focusCycle": "focus on the next tile"
            },
            "toggle": {
                "public": {
                    "on": "change to private",
                    "off": "change to public"
                }
            },
            "field": {
                "name": {
                    "description": "edit project name",
                    "placeholder": "name"
                }
            },
            "help": "show keyboard shortcuts"
        },
        "source": {
            "label": "program editor",
            "empty": [
                "Let's get started! You can ‚Ä¶",
                "‚Ä¢ Open üìï and drag üñ±Ô∏è us to this program.",
                "‚Ä¢ Type $1 and choose us from the menu.",
                "‚Ä¢ If you know us well, start typing.",
                "‚Ä¢ Browse the gallery for inspiration.",
                "If you're stuck, <learn more@://learn>."
            ],
            "overwritten": "Received a more recent version!",
            "confirm": {
                "delete": {
                    "description": "delete this $source",
                    "prompt": "delete"
                }
            },
            "toggle": {
                "blocks": {
                    "on": "hide block backgrounds",
                    "off": "show block backgrounds"
                },
                "glyphs": {
                    "on": "collapse the matching glyphs",
                    "off": "expand the matching glyphs"
                }
            },
            "button": {
                "selectOutput": "show this output on stage",
                "expandSequence": "expand this collapsed code"
            },
            "field": {
                "name": {
                    "description": "edit source name",
                    "placeholder": "name"
                }
            },
            "menu": {
                "label": "autocomplete menu",
                "show": "show autocomplete menu",
                "back": "leave submenu"
            },
            "cursor": {
                "priorLine": "move cursor to line before",
                "nextLine": "move cursor to line after",
                "priorInline": "move cursor to position before",
                "nextInline": "move cursor to position after",
                "lineStart": "move cursor to start of line",
                "lineEnd": "move cursor to start of line",
                "priorNode": "select neighbor before",
                "nextNode": "select neighbor after",
                "parent": "select container",
                "selectAll": "select program",
                "incrementLiteral": "increase number, text, or Boolean",
                "decrementLiteral": "decrease number, text, or Boolean",
                "insertSymbol": "insert $1",
                "insertTrue": "insert true",
                "insertFalse": "insert false",
                "insertNone": "insert none symbol",
                "insertNotEqual": "insert not equal",
                "insertProduct": "insert product symbol",
                "insertQuotient": "insert quotient symbol",
                "insertDegree": "insert degree symbol",
                "insertFunction": "insert function",
                "insertLessOrEqual": "insert less than or equal to",
                "insertGreaterOrEqual": "insert greater than or equal to",
                "insertType": "insert type symbol",
                "insertStream": "insert stream symbol",
                "insertConvert": "insert convert symbol",
                "insertPrevious": "insert previous symbol",
                "insertTable": "insert table symbol",
                "insertLine": "insert line break",
                "backspace": "delete selection or prior character",
                "cut": "cut selection",
                "copy": "copy selection",
                "paste": "paste contents of keyboard",
                "parenthesize": "parenthesize selection",
                "enumerate": "enumerate selection",
                "type": "type characters",
                "undo": "undo previous edit",
                "redo": "redo undone edit",
                "search": "search for special characters to insert"
            }
        },
        "conflicts": {
            "label": "conflicts"
        },
        "output": {
            "label": "program output",
            "toggle": {
                "grid": {
                    "on": "hide grid lines",
                    "off": "show grid lines"
                },
                "fit": {
                    "on": "control zoom manually",
                    "off": "fit zoom to content"
                },
                "paint": {
                    "off": "place output",
                    "on": "paint output"
                }
            },
            "field": {
                "key": "listening to key presses"
            }
        },
        "timeline": {
            "label": "timeline",
            "slider": "time slider",
            "button": {
                "play": "evaluate the program to the end, responding to inputs in real time",
                "pause": "pause the program, enabling stepping forward and backwards",
                "backStep": "step back one",
                "backNode": "step back to previous node evaluation",
                "backInput": "back one input",
                "out": "step out of this function",
                "forwardStep": "step forward one",
                "forwardNode": "step forward to next node evaluation",
                "forwardInput": "step forward to next stream input",
                "present": "to the present",
                "start": "to the beginning",
                "reset": "restart performance"
            }
        },
        "docs": {
            "label": "docuemntation browser",
            "link": "show concept $1 in documentation",
            "learn": "learn more ‚Ä¶",
            "nodoc": "Who am I? What am I? What is my purpose?",
            "button": {
                "home": "return home",
                "back": "return to previous"
            },
            "field": {
                "search": "search for concepts with words"
            },
            "header": {
                "inputs": "Inputs",
                "interfaces": "Interfaces",
                "properties": "Properties",
                "functions": "Functions",
                "conversions": "Conversions"
            }
        },
        "dialog": {
            "share": {
                "header": "Collaborators",
                "explanation": "Want someone to help edit this project? Add or remove them by email.",
                "field": {
                    "email": {
                        "placeholder": "email",
                        "description": "the email address of the person who you want to grant edit access."
                    }
                },
                "error": {
                    "unknown": "We don't know a creator with this email."
                },
                "button": {
                    "submit": "Share the project with this email address"
                }
            },
            "settings": {
                "header": "Settings",
                "explanation": "Change layout, device, and theme settings.",
                "button": {
                    "show": "show settings dialog"
                },
                "mode": {
                    "layout": {
                        "label": "layout",
                        "modes": ["automatic", "horizontal", "vertical", "free"]
                    },
                    "animate": {
                        "label": "animations",
                        "modes": [
                            "off",
                            "on",
                            "half speed",
                            "third speed",
                            "quarter speed"
                        ]
                    },
                    "dark": {
                        "label": "theme",
                        "modes": [
                            "light colors",
                            "dark colors",
                            "use device setting"
                        ]
                    },
                    "writing": {
                        "label": "writing layout",
                        "modes": [
                            "horizontal, left to right",
                            "vertical, right to left",
                            "vertical, left to right"
                        ]
                    }
                }
            },
            "locale": {
                "header": "Language",
                "explanation": "Choose your languages and regions.",
                "subheader": {
                    "selected": "Selected",
                    "supported": "Available",
                    "help": "Help us translate ‚Ä¶"
                },
                "button": {
                    "show": "change languages",
                    "add": "add language",
                    "remove": "remove language"
                }
            },
            "help": {
                "header": "Shortcuts",
                "explanation": "Use these keyboard commands for more efficient editing.",
                "subheader": {
                    "moveCursor": "Move",
                    "editCode": "Edit",
                    "insertCode": "Insert",
                    "debug": "Debug"
                }
            }
        },
        "palette": {
            "label": "palette",
            "labels": {
                "mixed": "mixed",
                "computed": "computed",
                "default": "default",
                "inherited": "inherited",
                "notSequence": "not a sequence",
                "notContent": "not a content list"
            },
            "button": {
                "revert": "revert to default",
                "set": "edit this property",
                "addPhrase": "add a phrase after this",
                "addGroup": "add a group after this",
                "remove": "remove this content",
                "up": "move this content up",
                "down": "move this content down",
                "edit": "edit this content",
                "sequence": "convert to a sequence",
                "createPhrase": "create a Phrase, showing the existing value as text",
                "createGroup": "create a Group, wrapping any existing Phrase",
                "createStage": "create a Stage, wrapping any existing Group or Phrase"
            },
            "prompt": {
                "offerPhrase": "What a gorgeous value you made! Shall I show it on @Stage?",
                "offerGroup": "What a wonderful @Phrase you made. Do you want to bring them together into a @Group, to get them arranged?",
                "offerStage": "VERY GOOD @Program. ADD ME TO CONTROL LIGHTING. COLORS. FRAMES.",
                "pauseToEdit": "If you ‚è∏Ô∏è the stage, you can select a üí¨, üî≥, or üé≠ to edit!",
                "editing": "Edit me!"
            },
            "field": {
                "coordinate": "edit coordinate",
                "text": "edit text"
            },
            "sequence": {
                "button": {
                    "add": "add pose",
                    "remove": "remove pose",
                    "up": "move pose up",
                    "down": "move pose down"
                },
                "field": {
                    "percent": "edit percent"
                }
            }
        },
        "save": {
            "saving": "saving",
            "saved": "saved online",
            "local": "saved locally",
            "unsaved": "unsaved"
        },
        "page": {
            "unknown": {
                "header": "Eep!",
                "message": "Where is this place? Can we go home?"
            },
            "landing": {
                "motto": "Where words come to life!"
            },
            "learn": {
                "header": "Learn",
                "error": "We weren't able to find a tutorial for this language.",
                "button": {
                    "next": "next pause in dialog",
                    "previous": "previous pause in dialog"
                }
            },
            "projects": {
                "header": "Projects",
                "prompt": "Ready to say something? Create a project or work on one. If you get stuck, keep <learning@://learn>.",
                "button": {
                    "create": "new project",
                    "edit": "edit this project"
                },
                "confirm": {
                    "archive": {
                        "description": "archive this performance",
                        "prompt": "archive"
                    }
                }
            },
            "galleries": {
                "header": "Galleries",
                "prompt": "These are performances that others have made. Experience them, study them, or adapt them into your own statement.",
                "examples": "Examples"
            },
            "about": {
                "header": "About",
                "content": [
                    "Have you ever felt like coding was just for English fluent, non-disabled Westerners obsessed with computers?",
                    "Yeah, us too.",
                    "This isn't an accident. Since the dawn of computing, programming languages have been design and built by mostly the same group of people -- white, cis, English-speaking men in academia and industry in the US and Europe, and the occasional white woman mathematician. They did their work in a time of post-colonial, winner-take-all power, and programming languages were a key tool for keeping it.",
                    "Whether intentional or not, this history has led to a vision of computation that is primarily about speed, logic, profit, and domination.",
                    "This is an injustice. Because computing, for better and worse, now undergirds daily life in visible and invisible ways, and the people who have access to create with it are the ones most like its creators. The rest of humanity remains beholden to this power, because imagining anything different requires access, gatekept by language barriers, accesibility barriers, economic barriers, and inequities in public education.",
                    "*Wordplay* aspires to be something different. A programming platform designed to be global, supporting /all/ of the world's languages, but also /about/ the world's languages. A platform on which everyone can create, with whatever abilities they have, to share interactive content that anyone can experience, with whatever abilities they have. For youth and young adults who want to express themselves *playfully*, *artfully*, and *interactively*. Not with the goal of harnessing power, but of creating diverse community that recognize the incredible strength that comes from our beautiful differences.",
                    "We're a community of designers, educators, and developers trying to bring this vision to life. We are people of color, we are trans, we are queer, we are disabled, and we come from all over the world. We're centered at the <University of Washington@https://washington.edu> <Information School@https://ischool.uw.edu/> in Seattle, Washington, USA, a place that aspires to welcome everyone and undo the ravages of colonialism that continue today. Making this programming language and platform is part of that mission.",
                    "See our <milestones@https://github.com/amyjko/wordplay/milestones> to see what we're working on, and if you'd like to help, learn <how to contribute@https://github.com/amyjko/wordplay/blob/main/CONTRIBUTING.md>. Or write our community organizer <Amy@https://amyjko.phd> with questions."
                ]
            },
            "login": {
                "header": "Login",
                "anonymous": "anonymous",
                "prompt": {
                    "login": "You're not logged in, so your performances are saving on this device instead of online. Submit your email to get a login link.",
                    "enter": "It looks like you're logging in on a different device. Can you enter your email again?",
                    "play": "You're logged in, we can save your projects online now! Want to create something?",
                    "change": "Want to change your email? Submit a new one and we'll send a confirmation to the old one.",
                    "sent": "Check your email for a login link.",
                    "logout": "Leaving a public device? Logout to remove your data from it.",
                    "success": "Account created!",
                    "confirm": "Check your old email address to confirm you new address.",
                    "delete": "Want us to forget everything?",
                    "reallyDelete": "Are you sure? Your projects will be archived and eventually deleted and you'll no longer have access to your account. Type your email to confirm."
                },
                "error": {
                    "expired": "This link expired.",
                    "invalid": "This link isn't valid.",
                    "email": "This email wasn't valid.",
                    "failure": "Unable to login :(",
                    "offline": "You appear to be offline.",
                    "unchanged": "We couldn't change your email address, but we don't know why.",
                    "delete": "We couldn't delete your account, but we don't know why."
                },
                "feedback": {
                    "changing": "Submitting new email...",
                    "deleting": "Okay, deleting your projects and settings..."
                },
                "field": {
                    "email": {
                        "description": "edit login email",
                        "placeholder": "email"
                    }
                },
                "button": {
                    "logout": {
                        "tip": "logout of your account",
                        "label": "logout"
                    },
                    "login": "login with this email, sending a login link",
                    "update": "change your email",
                    "delete": {
                        "tip": "delete your account",
                        "label": "delete it all"
                    },
                    "reallyDelete": {
                        "tip": "delete your account forever",
                        "label": "delete it!!!"
                    }
                }
            },
            "rights": {
                "header": "Rights",
                "content": [
                    "Hi!",
                    "This is where we set some expectations about your rights and ours (also in light of policy, such as the <COPPA@https://www.ecfr.gov/current/title-16/chapter-I/subchapter-C/part-312> and <GDPR@https://gdpr.eu/compliance-checklist-us-companies/>)",
                    "The first thing to know is that we are not a commercial entity. We are a community-based research project housed at a not-for-profit university. Our goal is to create a platform that brings you joy and helps us make discoveries about a more equitable and just world of computing. We have no interest in making money on this platform; any money we gather (usually through public funding) is used to sustain the platform, not to enrich anyone who works on it (or contributes to it).",
                    "Because we are not seeking profit, this also means that we can't make any promises about the reliability, availability, or longevity of this platform. That said, <Amy@https://amyjko.phd> is committed long term to sustaining it, and as a tenured professor, she's got a pretty stable gig.",
                    "That brings is to *data*. Here's what we gather and store in the cloud:",
                    "‚Ä¢ Your *email address*. We use this to ensure that only you and anyone you share with can access your projects and settings.",
                    "‚Ä¢ Your *settings*. This includes the locales you choose, your animation preferences, and your tutorial progress. Everything else is stored on your device.",
                    "‚Ä¢ Your *projects*. We store any projects you contribute. This includes any personally identifiable information you put in your projects (which could be anything, since it's all text!)",
                    "We don't store anything else. No 'cookies', no tracking identifiers, no recordings of camera or microphone input. Our <source@https://github.com/amyjko/wordplay/tree/main/src> is public, so you can verify this if you wish at any time.",
                    "*You* own your data, not us. That means:",
                    "‚Ä¢ You control who can access your projects. They are private by default, but you can share them with individuals, groups, or make them entirely public.",
                    "‚Ä¢ You can fully delete any project or your own account at any time.",
                    "‚Ä¢ You can get an export of any project or your whole account at any time.",
                    "Finally, here's how we will and won't use your data:",
                    "‚Ä¢ We won't share your data with anyone, unless explicitly required by law. It's always possible that your data is taken without out permission (a 'data breach'). If we discover that this has happened, we will notify you that this has happened using the email you've shared with us.",
                    "‚Ä¢ We won't contact you via your email address unless you 1) make an account change that requires us to, 2) you explicitly give us consent to reach out, or 3) in the case of data breach above.",
                    "‚Ä¢ We may analyze projects on the platform to understand what everyone is making and how they are making it. We may share these aggregated, anonymized insights in academic publications. We will only do this under the supervision of an institutional review board, as mandated by U.S. federal law.",
                    "That's it! We'll keep this page up to date if anything changes."
                ]
            }
        },
        "edit": {
            "node": "$1$2[, type $2|]",
            "before": "before $1[$1|end]",
            "inside": "inside $1",
            "between": "between $1 and $2",
            "line": "empty line between $1[$1|start] and $2[$2|end]",
            "conflicts": "$1 conflicts",
            "assign": "/$2[Eager to join|Considers leaving]‚Ä¶/",
            "append": "/Eager to insert‚Ä¶/",
            "remove": "/Considers leaving‚Ä¶/",
            "replace": "/Wants to step in‚Ä¶/",
            "wrap": "parentheize",
            "unwrap": "unwrap",
            "bind": "name this expression"
        },
        "template": {
            "unwritten": "TBD",
            "unparsable": "Unparsable template: $1"
        }
    }
}
