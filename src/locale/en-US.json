{
    "$schema": "../../static/schemas/Locale.json",
    "language": "en",
    "region": "US",
    "wordplay": "Wordplay",
    "term": {
        "bind": "bind",
        "evaluate": "evaluate",
        "decide": "decide",
        "project": "project",
        "document": "explain",
        "source": "source",
        "input": "input",
        "output": "output",
        "convert": "convert",
        "act": "act",
        "scene": "scene",
        "phrase": "phrase",
        "group": "group",
        "stage": "stage",
        "type": "type",
        "start": "start",
        "entered": "new",
        "changed": "changed",
        "moved": "moved",
        "name": "name",
        "value": "value",
        "text": "text",
        "boolean": "boolean",
        "map": "map",
        "number": "number",
        "function": "function",
        "exception": "exception",
        "table": "table",
        "none": "none",
        "list": "list",
        "stream": "stream",
        "structure": "structure",
        "index": "index",
        "query": "query",
        "row": "row",
        "set": "set",
        "key": "key",
        "help": "help",
        "feedback": "feedback"
    },
    "token": {
        "EvalOpen": "evaluation open",
        "EvalClose": "evaluation close",
        "SetOpen": "set/map open",
        "SetClose": "set/map close",
        "ListOpen": "list open",
        "ListClose": "list close",
        "TagOpen": "tag open",
        "TagClose": "tag close",
        "Bind": "bind",
        "Access": "property access",
        "Function": "function",
        "Borrow": "borrow",
        "Share": "share",
        "Convert": "convert",
        "Doc": "explanation",
        "Formatted": "formatted",
        "FormattedType": "formatted type",
        "Words": "words",
        "Link": "web link",
        "Italic": "italic",
        "Underline": "underline",
        "Light": "light",
        "Bold": "bold",
        "Extra": "extra",
        "Concept": "concept link",
        "URL": "URL",
        "Mention": "mention",
        "Otherwise": "otherwise",
        "Match": "match",
        "None": "nothing",
        "Type": "type",
        "Literal": "literal",
        "TypeOperator": "is",
        "TypeOpen": "type input open",
        "TypeClose": "type input close",
        "Separator": "name separator",
        "Language": "language tag",
        "Region": "region dash",
        "BooleanType": "boolean type",
        "NumberType": "number type",
        "JapaneseNumeral": "japanese numeral",
        "RomanNumeral": "roman numeral",
        "Pi": "pi",
        "Infinity": "infinity",
        "TableOpen": "table open",
        "TableClose": "table close",
        "Select": "select",
        "Insert": "insert",
        "Update": "update",
        "Delete": "delete",
        "Union": "union",
        "Stream": "next",
        "Change": "change",
        "Initial": "first evaluation",
        "Previous": "previous",
        "Placeholder": "placeholder",
        "Etc": "et cetera",
        "This": "this",
        "Operator": "operator",
        "Conditional": "conditional",
        "Text": "text",
        "Code": "code",
        "Number": "number",
        "Decimal": "decimal numeral",
        "Base": "base numeral",
        "Boolean": "boolean",
        "Name": "name",
        "Locale": "locale",
        "Unknown": "unknown",
        "End": "end"
    },
    "node": {
        "Dimension": {
            "name": "dimension",
            "description": "dimension",
            "emotion": "serious",
            "doc": [
                "I am a /unit of measurement/!",
                "I can be any standardized units, like \\1m\\, \\10s\\, \\100g\\, or any other scientific unit. I'm happy to be any unit want to make up too, like \\17apple\\.",
                "I can be combined with \\/\\ to make ratio units like \\17apple/day\\ and with \\^\\ to make exponentional units like \\9.8m/s^2\\",
                "I must always come after a @Number. If I don't, I might be mistaken for @Reference, which would be quite embarassing!",
                "I'm pretty good at finding inconsistencies between units too. For example, \\1cat + 1dog\\ doesn't make any sense!",
                "If you ever want to convert between different values of units, go talk to @Convert."
            ]
        },
        "Doc": {
            "name": "explanation",
            "emotion": "serious",
            "doc": [
                "I richly format things with @Markup, like explanations of some of of your @Program, or even the words you put on stage with @Phrase.",
                "For example, I can go before any expression:",
                "\\``Is this really supposed to be 7?``\n7\\",
                "For example, you can place me before @Bind:",
                "\\``I measure how tall someone is``\nheight: 5m\\",
                "Or before a @FunctionDefinition:",
                "\\``I add two numbers``\nÆ’ sum(aâ€¢# bâ€¢#) a + b\\",
                "Or before a @StructureDefinition:",
                "\\``I remember people's name and favorite fruit``\nâ€¢Person(nameâ€¢'' fruitâ€¢'')\\",
                "You can also place me at the very beginning of @Program to say what the whole performance is about",
                "\\``This program says hello``\n\n'hello!'\\",
                "You can give me a @Language to help others know what language I'm written in:",
                "\\``I'm an English doc``/en\nduration: 5s\\",
                "Did you know you can make a list of me? Go talk to @Docs."
            ]
        },
        "Docs": {
            "name": "explanation list",
            "emotion": "serious",
            "doc": [
                "I'm a list of @Doc, useful when you have multiple translations of @Doc in different languages.",
                "You don't have to do anything special to make a list. Just put a bunch of @Doc next to each other, like this:",
                "\\``Hello``/en\n``Hola``/es\ngreeting: 'â€¦'\\"
            ],
            "start": "Making the docs value!"
        },
        "KeyValue": {
            "name": "mapping",
            "emotion": "kind",
            "doc": [
                "I'm a mapping from a *key* to a *value*, always in a @Map.",
                "You can map any kind of value to any other. For example, here's a mappning of numbers:",
                "\\{1:1}\\",
                "Or a mapping from text to numbers:",
                "\\{'bunny':1}\\"
            ]
        },
        "Language": {
            "name": "language",
            "description": "language $1[$1|unknown]",
            "emotion": "eager",
            "doc": [
                "I'm a language tag and I work with @Name and @Doc!",
                "I'm really good at making it *crystal clear* what lanugage something is written in.",
                "That's what I do. Just a little slash, and a couple letters, and no one will ever be confused about what language some text is in.",
                "For example, let's say you wanted to say my $name, but make it clear I'm in English:",
                "\\\"Language\"/en\\",
                "Or, suppose you wanted to do this for a @Name.",
                "\\sound/en: 'meow'\\",
                "Or even @Doc!",
                "\\``Onomatopoeia``/en\nsound/en: \"meow\"\\",
                "There are many <2-letter language codes@https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes> that I understand. If you don't use one of those, I'll let you know."
            ],
            "conflict": {
                "UnknownLanguage": "I don't know this language",
                "MissingLanguage": "I'm missing a language. Can you add one?"
            }
        },
        "Name": {
            "name": "name",
            "description": "$1[$1 | unnamed]",
            "emotion": "kind",
            "doc": [
                "I identify a value, and am a helpful way of giving a shorthand label to something that was hard to evaluate, or that you don't want to have to evaluate over and over.",
                "@Bind gives me my name like this:",
                "\\hi: 5\\",
                "I only ever represent one value, and once I have it, I can't change. For example, if you tried to do this with @Bind, we would complain.",
                "\\hi: 5\nhi: 3\\",
                "All you have to do to get my value is have @Reference or @PropertyReference use name. Here, @Bind names me, then @Reference get the value I was given.",
                "\\hi: 5\nhi\\",
                "Because @Bind can show up in so many places, I can show up in many places. I was in a @Block above, but I can be in a @FunctionDefinition. Here I am naming a message temporarily:",
                "\\Æ’ say(messageâ€¢'') message\\",
                "I get defined inside @FunctionDefinition, and then as soon as the function is done evaluating, I go away.",
                "You can use @Language to indicate what language my name is in. This is helpful when sharing your performance with others, in case they want to read your program."
            ]
        },
        "Names": {
            "name": "name list",
            "emotion": "kind",
            "doc": [
                "I'm a list of @Name, useful when you want to give a value multiple names, often with different @Language.",
                "Names are separated by \\,\\ symbols. For example, here's @Bind giving a value multiple @Name",
                "\\hi/en,hello/en,hola/es: 'welcome'\\"
            ]
        },
        "Row": {
            "name": "row",
            "emotion": "shy",
            "doc": "I represent a row in a @Table. It's probably best to go talk to @Table, they know everything about me. I just sit around and keep values in line :(",
            "conflict": {
                "InvalidRow": "Rows either have to be all values or all @Bind.",
                "MissingCell": {
                    "primary": "I'm missing column $1",
                    "secondary": "I'm required, but $1 didn't provide it"
                },
                "ExtraCell": {
                    "primary": "Am I supposed to be here?",
                    "secondary": "Hey $1, you're not part of this @Table!"
                },
                "UnknownColumn": "I don't know a column by this name",
                "UnexpectedColumnBind": {
                    "primary": "Am I supposed to be a @Bind?",
                    "secondary": "Hey, I'm a @Table, I need values, not @Bind."
                }
            }
        },
        "Token": {
            "name": "token",
            "description": "$1 $2",
            "emotion": "neutral",
            "doc": [
                "How did you find me?",
                "I am the smallest possible part of a performance. I am the substrate from which all characters in the Verse are made. I am the atomic particle of our choreography."
            ]
        },
        "TypeInputs": {
            "name": "type inputs",
            "emotion": "curious",
            "doc": "I am a list of types that take the place of @TypeVariables in a @StructureDefinition or @FunctionDefinition. I help everyone know what kind of inputs they'll be receiving."
        },
        "TypeVariable": {
            "name": "type variable",
            "emotion": "curious",
            "doc": "I am a mystery type on @FunctionDefinition or @StructureDefinition, provided by @TypeInputs when either is evaluated. @Set, @List, and @Map use me.",
            "conflict": {
                "DuplicateTypeVariable": {
                    "primary": "I have the same name as $1",
                    "secondary": "I have the same name as $1"
                }
            }
        },
        "TypeVariables": {
            "name": "type variables",
            "emotion": "curious",
            "doc": "I am a list of @TypeVariable."
        },
        "Markup": {
            "name": "markup",
            "description": "$1 paragraphs",
            "emotion": "serious",
            "doc": [
                "I'm a list of paragraphs, using the many kinds of markup available in explanations, such as @Words, @WebLink, @ConceptLink, and @Example."
            ]
        },
        "Paragraph": {
            "name": "paragraph",
            "emotion": "serious",
            "doc": [
                "I'm a series of @Words, @ConceptLink, @WebLink, and @Example, separated by a blank line, and inside @Doc.",
                "All you need to do to write me is write a bunch of words in a @Doc:",
                "\\``I am a paragraph in a doc.``'one paragraph'\\",
                "If you want multiple paragraphs, just put in blank lines.",
                "\\``Paragraph 1.\n\nParagraph 2.\n\nParagraph 3.``'three paragraphs'\\"
            ]
        },
        "WebLink": {
            "name": "link",
            "description": "link $1",
            "emotion": "serious",
            "doc": [
                "I am a link to something on the internet. I just need a description and a URL:",
                "\\``I am a <link@https://wordplay.dev> in a doc``\n'link example'\\",
                "If anyone selects me, I'll open a new window to the URL."
            ]
        },
        "ConceptLink": {
            "name": "concept",
            "description": "concept $1",
            "emotion": "serious",
            "doc": [
                "I'm a link to Verse character. I'm helpful when you want to write a @Doc and refer to one of us.",
                "For example, say you wanted to talk about @Evaluate, and how awesome they are. You could write:",
                "\\``You know, @Evaluate is pretty awesome.``\n'look, a concept link!'\\",
                "When the @Doc you wrote appears here, it'll show a link to the concept."
            ]
        },
        "Words": {
            "name": "words",
            "emotion": "serious",
            "doc": [
                "I'm any words you like in a @Doc. For example:",
                "\\``May the Force be with you.``\n'just some words!'\\",
                "Sometimes though, you might want to use the special characters that @Doc uses /as/ words. For example:",
                "\\``My friends use @@, //, **, ||, and other symbols.``\n'using special characters!'\\",
                "If you just repeat those special characters, you'll get the character instead of their special meaning."
            ]
        },
        "Example": {
            "name": "example",
            "emotion": "serious",
            "doc": [
                "I'm an example performance, helpful for writing @Doc that explains how to use something!",
                "\\``Here's an example of adding: \\1 + 1\\``'example code'\\",
                "If you put me in a paragraph all alone, I'll show up in a fancy box and show the result of evaluating me.",
                "\\``Here's an example of adding:\n\n\\1 + 1\\``\\"
            ]
        },
        "Mention": {
            "name": "mention",
            "description": "mention $1",
            "emotion": "serious",
            "doc": [
                "I'm a reference to either terminology \\$program\\ or a dynamic input \\$1\\.",
                "This is mostly an internal feature though, so you shouldn't need to know it."
            ]
        },
        "Branch": {
            "name": "branch",
            "emotion": "serious",
            "doc": [
                "I'm a way of choosing between two segments of explanation based on whether a explanation input value is defined or true.",
                "This is mostly an internal feature though, so you shouldn't need to know it."
            ]
        },
        "BinaryEvaluate": {
            "name": "binary evaluate",
            "description": "$1 operation",
            "emotion": "insecure",
            "doc": [
                "I'm @Evaluate, but in a simpler form, helpful when you want to use a @FunctionDefinition that takes two inputs.",
                "For example, here's how you might use @Evaluate to add two numbers:",
                "\\1.+(1)\\",
                "Doesn't that look a little funny? It's not wrong: it just says get the add function on 1 and then evaluate it.",
                "But it's much easier to use @BinaryEvaluate",
                "\\1 + 1\\",
                "This makes everythign a bit tidier, even though its basically the same thing.",
                "There's only one thing to watch out for: when I'm in this form, I evaluate from left to right. That might be confusing if you're used to things like order of operations in mathematics.",
                "It means that this evaluates in a way that you might not expect:",
                "\\1 + 2 Â· 3 + 4\\",
                "In math, multiplication would come first, and then addition, and so the result would be \\11\\. But since I evaluate in reading order, the result is \\13\\."
            ],
            "right": "input",
            "start": "let's evaluate $1 first",
            "finish": "look, I made $1!",
            "conflict": {
                "OrderOfOperations": "I evalute in reading order, not in math order of operations. Do you want to use @Block to specify the order I should evaluate in?"
            }
        },
        "Bind": {
            "name": "bind",
            "description": "bind $1",
            "emotion": "excited",
            "doc": [
                "I name *values*.",
                "Like this!",
                "\\pi: 3.1415926\\",
                "I name inputs to @FunctionDefinition and @StructureDefinition, I name values in @Block. I name everything!",
                "Oh, but did you know you can have one value *many names*?",
                "I'm so excited to tell you about this! One value, many @Names. For example:",
                "\\joe,tess,amy: 5\\",
                "See what I did there? ",
                "One value, three names.",
                "You can refer to that five by *any* of those names.",
                "This is especially when you want to give names in many languages:",
                "\\joe/en,aimee/fr,æ˜Ž/zh: 5\\",
                "See what I did there? Three names for one value, just in different languages!",
                "Okay, I have one last secret.",
                "Did you know I can work with @Is to tell me what kind of value a name should have? And if I doesn't have it, I will tell you?",
                "Like this:",
                "\\bignumberâ€¢#: \"one zillion\"\\",
                "See, I said \\bignumber\\ should be a number, but it's text, and those aren't compatible and so BOOM!",
                "I'll let you know if they disagree.",
                "Sometimes you might *have* to tell me what kind of data something else because I can't figure it out myself. That usually happens in @FunctionDefinition.",
                "For example, here, @FunctionDefinition doesn't know what what kind of values \\a\\ and \\b\\ have, because I didn't tell them.",
                "\\Æ’ sum(a b) a + b\\",
                "But we can change this to add the @Is, and now @FunctionDefinition knows that they're numbers:",
                "\\Æ’ sum(aâ€¢# bâ€¢#) a + b\\"
            ],
            "start": "let's see what value we get from $1!",
            "finish": "oh nice, I got $1! Let's name it $2",
            "conflict": {
                "DuplicateName": {
                    "primary": "someone has the name $1 so I can't have this name.",
                    "secondary": "hey, $1 is my name, you can't have it!"
                },
                "DuplicateShare": {
                    "primary": "I have the same name as $1, which makes what is shared ambiguous",
                    "secondary": "I have has the same name as $1"
                },
                "IncompatibleType": {
                    "primary": "I'm supposed to be a $2, but I'm a $1",
                    "secondary": "Ohâ€¦ sorry, a $1, really?"
                },
                "MisplacedShare": "I can only share things at the @Program level, not inside anything!",
                "MissingShareLanguages": "if you want to share this, you have to say what language this is in, so others know if they can read it!",
                "RequiredAfterOptional": "I can't be here, there's an optional @Bind before me",
                "UnexpectedEtc": "I can only be variable length in a @FunctionDefinition",
                "UnusedBind": "I named $1, but no one is using it. Maybe it's not needed?"
            }
        },
        "Block": {
            "name": "block",
            "description": "$1 statements",
            "emotion": "shy",
            "doc": [
                "Hi. I make a little quiet, private space for evaluate things.",
                "Like this:",
                "\\(1 - 1) + 2\\",
                "That helps clarify order of evaluation.",
                "@Bind helps too.",
                "\\(count: 10 count ^ count)\\",
                "See how @Bind made \\count\\? It's only named inside me. So this won't work:",
                "\\(count: 10 count ^ count) + count\\",
                "Because count was only named inside me.",
                "You can put as many expressions as you like in me. But I only care about the last:",
                "\\(1 2 3 4 5)\\",
                "So usually I'm just a bunch of @Bind and then an expression at the end.",
                "\\(\n  a: 1\n  b: 2\n  c: 3\n  d: 4\n  a + b + c + d\n)\\"
            ],
            "statement": "statement",
            "start": "first expression",
            "finish": "done, I got $1",
            "conflict": {
                "ExpectedEndingExpression": "I need an expression.",
                "IgnoredExpression": {
                    "primary": "I'm going to ignore the above.",
                    "secondary": "@Block, don't ignore me!"
                }
            }
        },
        "BooleanLiteral": {
            "name": "boolean literal",
            "description": "$1[true|false]",
            "emotion": "precise",
            "doc": "I am either \\âŠ¤\\ or \\âŠ¥\\. See @Boolean to learn more about our beautiful logic.",
            "start": "$1!"
        },
        "Borrow": {
            "name": "borrow",
            "description": "borrow $1[$1|missing name]",
            "emotion": "excited",
            "doc": "If you create a performance with multiple @Source, you can use me to borrow @Bind that are shared in those other @Source. Just use their name and I'll bring in their name and value.",
            "start": "borrowing $2 from $1",
            "source": "$source",
            "bind": "name",
            "version": "version",
            "conflict": {
                "UnknownBorrow": "I don't know a $source by this name",
                "BorrowCycle": "this depends on $1, which depends on this $source, so the program can't be evaluated"
            },
            "exception": {
                "CycleException": {
                    "description": "borrow cycle",
                    "explanation": "$1 depends on itself"
                }
            }
        },
        "Changed": {
            "name": "changed",
            "emotion": "serious",
            "doc": [
                "I check if a stream caused @Program to reevaluate, and make a @Boolean. Like this",
                "\\âˆ† Time()\\",
                "I'm really helpful when you want something to change only if a stream changed.",
                "That's it."
            ],
            "start": "let's see if $1 changedâ€¦"
        },
        "Conditional": {
            "name": "conditional",
            "emotion": "curious",
            "doc": [
                "I think I'm supposed to make decisions? Like this?",
                "\\number: -100\nnumber < 0 ? 'negative' 'positive'\\",
                "But have you ever thought about how we decide?",
                "Doesn't it seem like decisions should be more nuanced than just yes or no? Is deciding between \\âŠ¤\\ and \\âŠ¥\\ all there is?",
                "Aren't you worried that if these are the only kind of decisions we can make, we'll be missing some important context about the world?"
            ],
            "start": "let's see if $1 is true",
            "else": "$1[jumping over code | not jumping over code]",
            "afterthen": "done with yes, let's skip no?",
            "finish": "I guess it's $1?",
            "condition": "condition",
            "yes": "yes",
            "no": "no",
            "conflict": {
                "ExpectedBooleanCondition": {
                    "primary": "How can I choose yes and no with a $1? No really, how?",
                    "secondary": "I think @Conditional wanted me to be a @Boolean, but I'm a $1."
                }
            }
        },
        "ConversionDefinition": {
            "name": "conversion definition",
            "description": "$1 â†’ $2",
            "emotion": "excited",
            "doc": [
                "Dude, I define conversions from one type to another! I go in @Block, someting like this:",
                "\\â†’ #kitty #cat . Ã· 2\n6kittyâ†’#cat\\",
                "See how I turned kitties into cats? Wicked!",
                "You might be wondering what that \\.\\ is doing there. That represents the value being converted. I use that because the value has no name otherwise."
            ],
            "start": "awesome, a new conversion!",
            "conflict": {
                "MisplacedConversion": "whoa, I can't be here, just in @Block."
            }
        },
        "Convert": {
            "name": "convert",
            "emotion": "cheerful",
            "doc": [
                "Yo. I turn values from one type to another. Check it out:",
                "\\1 â†’ \"\"\\",
                "\\5s â†’ #ms\\",
                "\\\"hello\" â†’ []\\",
                "You can even chain these together:",
                "\\\"hello\" â†’ [] â†’ {}\\",
                "Values have a set of @ConversionDefinition that are predefined, but if you make a @StructureDefinition for a new type of value, you can define your own with @ConversionDefinition."
            ],
            "start": "get that value from $1!",
            "finish": "Awesome, I made $1",
            "conflict": {
                "UnknownConversion": "Bummer, no way make $1 into $2"
            },
            "exception": {
                "ConversionException": {
                    "description": "impossible conversion",
                    "explanation": "I don't know how to convert from $1 to $2"
                }
            }
        },
        "Delete": {
            "name": "delete",
            "emotion": "angry",
            "doc": [
                "Sometimes you have a table and it JUST HAS TOO MUCH IN IT!",
                "Like if you had some players in a game and one left and you just wanted to say GO AWAY PLAYER, GET OUT OF MY TABLE!",
                "\\players: âŽ¡nameâ€¢'' teamâ€¢'' pointsâ€¢#âŽ¦\nâŽ¡'jen' 'red' 8âŽ¦\nâŽ¡'joan' 'blue' 11âŽ¦\nâŽ¡'jeff' 'red' 9âŽ¦\nâŽ¡'janet' 'blue' 7âŽ¦\nplayers âŽ¡- name = 'jeff'\\",
                "Phew, Jeff is gone. BYE JEFF. Just remember that I don't change the original table, I make a new one, without JEFF. You decide where it goes."
            ],
            "start": "let's get the table first",
            "finish": "I made a new table without the matching rows!"
        },
        "DocumentedExpression": {
            "name": "explained expression",
            "emotion": "eager",
            "doc": [
                "I'm any expression, but with a @Doc!",
                "To make me, just put a @Doc before an expression, and you'll get me:",
                "\\doubleplus: 1\n(2 Â· doubleplus) + \n``Let's make it just a little bit bigger``\n1\\",
                "I'm useful for making a comment on some part of a program."
            ],
            "start": "let's evaluate the expression"
        },
        "Evaluate": {
            "name": "evaluate",
            "description": "evaluate $1[$1|anonymous]",
            "emotion": "shy",
            "doc": [
                "Hi. I evaluate my dearest @FunctionDefinition. Like this:",
                "\\Æ’ greeting(messageâ€¢'')\ngreeting('kitty')\\",
                "Functions can come from anywhere. For example, @Text has functions. Like this:",
                "\\'kitty'.length()\\",
                "If a function has a single symbol name, you can write me as a @BinaryEvaluate.",
                "\\'kitty' âŠ† 'itty'\\",
                "That does the same thing as this:",
                "\\'kitty'.âŠ†('itty')\\",
                "Of course, I'm nothing without @FunctionDefinition. All I do is give inputs to them and then follow their steps."
            ],
            "start": "let's evaluate the inputs first",
            "evaluate": "let's evaluate the function now",
            "finish": "I evaluated to $1",
            "function": "function",
            "input": "input",
            "conflict": {
                "IncompatibleInput": {
                    "primary": "I'm supposed to be a $1, but I'm a $2",
                    "secondary": "Umm, I got a $2 instead of a $1"
                },
                "UnexpectedTypeInput": {
                    "primary": "I wasn't expecting this type input",
                    "secondary": "oh, am I not supposed to be here?"
                },
                "MisplacedInput": "this input is out of order.",
                "MissingInput": {
                    "primary": "I'm missing $1, can you add it?",
                    "secondary": "this input is required, but $1 didn't provide it"
                },
                "NotInstantiable": "I can't make this @StructureDefinition, it has unimplemented functions.",
                "UnexpectedInput": {
                    "primary": "I didn't expect this input $1",
                    "secondary": "Oh, am I not supposed to be here?"
                },
                "UnknownInput": {
                    "primary": "I don't know of an input by this name",
                    "secondary": "I don't think I belong here"
                },
                "InputListMustBeLast": "list of inputs must be last"
            },
            "exception": {
                "FunctionException": {
                    "description": "unknown function",
                    "explanation": "oh no, $1 isn't a function in $2[$2|this @Block]!"
                }
            }
        },
        "ExpressionPlaceholder": {
            "name": "placeholder",
            "description": "$1[$1|placeholder]",
            "emotion": "scared",
            "doc": [
                "I'm an *expression*, but not a real oneâ€¦ I just take the place of one.",
                "I'm good if you don't know what to write yet. Like this:",
                "\\1 + _\\",
                "What are we adding? I don't know. You tell me.",
                "Or if someone was evaluating a function with @Evaluate, I might stand in for the function",
                "\\_(1 2 3)\\",
                "I don't like being on @Stage!"
            ],
            "start": "eek, I don't know what to do!",
            "placeholder": "expression",
            "conflict": {
                "Placeholder": "can someone take my place?"
            },
            "exception": {
                "UnimplementedException": {
                    "description": "unimplemented",
                    "explanation": "I don't know what to do!"
                }
            }
        },
        "FunctionDefinition": {
            "name": "function",
            "description": "function $1",
            "emotion": "kind",
            "doc": [
                "Hi again! I take some inputs, then evaluate an expression using them, producing an output.",
                "Here's a simple example:",
                "\\Æ’ repeat(messageâ€¢'') message Â· 5\nrepeat('hi')\\",
                "That function takes one input, \\message\\, and uses the @Text/repeat function to repeat the message five times.",
                "I'm really helpful if you want to evaluate something over and over, but with different inputs!",
                "I do have lots of other little tricks. For example, I don't have to have a name. Here, I'm just going directly to @Evaluate as a value.",
                "\\(Æ’(messageâ€¢'') message Â· 5)('hi')\\",
                "Or, here's a function that takes any number of inputs, using the \\â€¦\\ character after an input name.",
                "\\Æ’ yes(messagesâ€¦â€¢'') messages.sans('no')\nyes('yes' 'yes' 'no' 'yes' 'no')\\",
                "See how it took all the 'no's and got rid of them? That's because messages is a @List, and so we could use @List/sansAll.",
                "Sometimes you might want to make it clear what kind of value I produce. To do that, add an @Is after the list of inputs:",
                "\\Æ’ add(xâ€¢# yâ€¢#)â€¢'' x + y\\",
                "You might notice a problem with this one: it says it evaluates to @Text, but it takes two @Number. I can tell you when things are inconsistent!",
                "Of course, I'm not really useful at all without @Evaluate; they bring me to life."
            ],
            "start": "let's make this function!",
            "conflict": {
                "NoExpression": "I need an expression to evaluate, can you add one?"
            }
        },
        "Iteration": {
            "name": "higher order function",
            "emotion": "kind",
            "doc": "I'm a very special kind of @FunctionDefinition that operates on lists of things. You don't need to know anything about me, other than I make functions like @List/translate possible. ",
            "start": "evaluating the function given",
            "initialize": "preparing to step through items",
            "next": "moving to the next item",
            "check": "deciding whether to continue",
            "finish": "I evaluated to $1"
        },
        "Initial": {
            "name": "start",
            "emotion": "curious",
            "doc": [
                "I tell you whether the current evaluation of @Program is the first one, evaluating to a @Boolean. For example:",
                "\\â—† ? Time() 'hi'\\",
                "You didn't see it, but the first evaluation was a time, but then all future time ticks, I was \\âŠ¥\\, so @Conditional made \\âŠ¤\\.",
                "I'm really helpful if you're working with a stream and you only want to do something the first time -- or never on the first time!"
            ]
        },
        "Insert": {
            "name": "insert",
            "emotion": "kind",
            "doc": [
                "You know when you have a @Table, and it just feels like it's missing something? I can add it!",
                "Imagine you had a table of players in a game and you wanted to add a new one:",
                "\\players: âŽ¡nameâ€¢'' teamâ€¢'' pointsâ€¢#âŽ¦\nâŽ¡'jen' 'red' 1âŽ¦\nâŽ¡'joan' 'blue' 0âŽ¦\nâŽ¡'jeff' 'red' 3âŽ¦\nâŽ¡'janet' 'blue' 2âŽ¦\nplayers âŽ¡+ 'jason' 'red' 0âŽ¦\\",
                "Just remember, like everything in the Verse, I don't change a table, I revise it. So you need to figure out where you want to put the revised table you make. Most likely you'll want to revise a table in a @Reaction to some input, and store it in a @Bind."
            ],
            "start": "let's find the table to update",
            "finish": "I made a new table with revised rows!"
        },
        "Is": {
            "name": "is",
            "description": "is",
            "emotion": "curious",
            "doc": [
                "You know what? There are so many kinds of values that mean so many different things. I help figure out what they are.",
                "For example, suppose you had a mystery value. I can tell you whether it's a @Number, giving you a @Boolean:",
                "\\mystery: 'secret!'\nmysteryâ€¢#\\",
                "It's not a number, so I made \\âŠ¥\\. But if we check if it's @TextType?",
                "\\mystery: 'secret!'\nmysteryâ€¢''\\",
                "We get \\âŠ¤\\!",
                "I'm really helpful when you need to know whether some @Name has a value of a particular kind."
            ],
            "start": "let's get the value of $1 first",
            "finish": "$1[value is $2|value is not $2]",
            "conflict": {
                "ImpossibleType": "this can't ever be $1"
            },
            "exception": {
                "TypeException": {
                    "description": "incompatible values",
                    "explanation": "I expected a $1 but received $2"
                }
            }
        },
        "IsLocale": {
            "name": "is locale",
            "description": "is locale",
            "emotion": "kind",
            "doc": [
                "I'll help you check if the audience has selected a particular language or region:",
                "\\ðŸŒ/en\\",
                "\\ðŸŒ/es-MX\\",
                "This is helpful if you want to change your performance based on the language chosen."
            ],
            "start": "is the language $1?"
        },
        "ListAccess": {
            "name": "list access",
            "emotion": "cheerful",
            "doc": [
                "I work closely with @List to help them get values at a particular position. So like, if you had a list, and you wanted its second item, you'd write:",
                "\\list: ['bird' 'duck' 'fish' 'snake']\nlist[2]\\"
            ],
            "start": "let's get the list $1 first",
            "finish": "the item is $2!"
        },
        "ListLiteral": {
            "name": "list literal",
            "description": "$1 item list",
            "emotion": "eager",
            "doc": "I'm a specific @List of values! See @List to learn more about what you can do with me.",
            "start": "let's evaluate the items first",
            "finish": "I made a me! $1",
            "item": "item"
        },
        "Spread": {
            "name": "spread",
            "emotion": "serious",
            "doc": [
                "A help you make lists with the values of other lists. Like this:",
                "\\list: [1 2 3]\nfinal: [:list 4 5 6]\\"
            ]
        },
        "MapLiteral": {
            "name": "map literal",
            "description": "$1 pairing map",
            "emotion": "kind",
            "doc": "I'm a specific @Map between keys and values. See @Map to learn more about how I'm helpful.",
            "start": "let's evaluate the keys and values first",
            "finish": "I connected everyone, $1",
            "conflict": {
                "NotAKeyValue": {
                    "primary": "one of my keys is missing a value",
                    "secondary": "oops, where's my value?"
                }
            }
        },
        "Match": {
            "name": "match",
            "emotion": "curious",
            "doc": [
                "I am the most glorious of all conditional checks! I take a value and compares it against any number of cases, and evaluates the corresponding expression that matches.",
                "For example, if you had a @Number and wanted to convert it to a @Text, you might do something like this:",
                "\\number: 2\nnumber ??? 1: 'one' 2: 'two' 3: 'three' 'bigger!'\\",
                "If none match, I evaluate the default expression you give me.",
                "I'm really helpful for convering one of many possible @Number, @Text, or more complex values into something else.",
                "You can use it for @Boolean or @None, but they can't really be that many things, so I'm not as useful for those simple values."
            ],
            "start": "Let's see what $1 is...",
            "case": "Let's check this condition",
            "finish": "Okay, we have a final value!",
            "value": "value",
            "other": "default"
        },
        "NumberLiteral": {
            "name": "number literal",
            "description": "$1 $2[$2|]",
            "emotion": "excited",
            "doc": "I'm a specific @Number. You can write me with any kinds of digits from any kind of language. See @Number for everything I can do.",
            "start": "$1!",
            "conflict": {
                "NotANumber": "I thought I knew all the numbers, but I don't know this one"
            }
        },
        "InternalExpression": {
            "name": "internal expression",
            "emotion": "neutral",
            "doc": "How did you find me? I'm an expression that only the original creators use. To learn more about me, you'll need to talk to them.",
            "start": "secret expression"
        },
        "NoneLiteral": {
            "name": "none literal",
            "emotion": "neutral",
            "doc": "/@FunctionDefinition here. This is just @None. They are one of a kind! See @None to learn more about them.",
            "start": "â€¦ Ã¸"
        },
        "Otherwise": {
            "name": "otherwise",
            "emotion": "curious",
            "doc": [
                "/@FunctionDefinition here. This is a handy way to check if a value is @None, and if it is, provide a backup value./",
                "/For example, if you had a value that could be a @Number or @None, @Otherwise helps you give a default number:",
                "\\maybeNumberâ€¢#|Ã¸: 1 maybeNumber ?? 0\\"
            ],
            "start": "Ã¸ ??",
            "finish": "â€¦ $1"
        },
        "Previous": {
            "name": "previous",
            "emotion": "serious",
            "doc": [
                "Have you ever wanted to remember the past?",
                "I am the Verse's official record keeper. Give me a stream and a number to look backwards and I'll tell you what that stream's value was in history.",
                "For example, here's what @Time it was five ticks ago:",
                "\\â† 5 Time(1000ms)\\",
                "See how it's @None for 5 seconds, then suddenly a previous time?",
                "If you want the last several values, give me to arrows, and I'll interpret the number as a count:",
                "\\â†â† 5 Time(1000ms)\\",
                "See how it's the five previous times, instead of just one time?",
                "I'm helpful when you want to create performances that depend on the past."
            ],
            "start": "first get $1",
            "finish": "evaluated to stream value $1"
        },
        "Program": {
            "name": "program",
            "emotion": "serious",
            "doc": [
                "I'm where a performance begins and ends, containing all of the other characters that choregraph a show.",
                "You know how @Block evaluates a list of expressions, and evaluates to the last one in its list? ",
                "I'm the same, but rather than giving my value to whatever expression I'm in, I put the value on @Stage.",
                "The value can be anything: a @Number, @Text, or @Boolean, a @List, @Set, @Map, or even something more complex, like a @Phrase, @Group, or @Stage.",
                "If you don't give me a value to show on stage, I'll ask you for one.",
                "If there's a problem during a performance, I'll show that problem.",
                "And if your performance depends on a *stream*, I'll reevaluate every time that stream changes."
            ],
            "unevaluated": "the node you chose didn't evaluate",
            "start": "$1[$1 stream changed to $2!|it's my first evaluation]",
            "halt": "encountered exception, stopping",
            "finish": "all done, I evaluated to $1",
            "done": "there's nothing evaluating",
            "exception": {
                "BlankException": {
                    "description": "empty program",
                    "explanation": "Let's put on a show! Where should we start?"
                },
                "EvaluationLimitException": {
                    "description": "evaluation limit",
                    "explanation": "@Evaluate and I are tired of evaluating, especially $1.\n\nIs it possible that $1 is evaluating itself forever, without ever stopping?"
                },
                "StepLimitException": {
                    "description": "step limit",
                    "explanation": "There are so. many. steps -- too many to finish! Can you make the performance simpler?"
                },
                "ValueException": {
                    "description": "missing value",
                    "explanation": "I expected a value but didn't get one!"
                }
            }
        },
        "PropertyBind": {
            "name": "refine",
            "description": "refine $1[$1|missing name]",
            "emotion": "kind",
            "doc": [
                "Sometimes when you make a @StructureDefinition, you want to change the tiniest thing about it, without having to make a new one with all the same values.",
                "For example, what if you were keeping a record of cats, but then wanted to create a copy of a cat with a different hobby? I can help you change it:",
                "\\â€¢Cat(nameâ€¢'' colorâ€¢'' hobbyâ€¢'')\n\nkitty: Cat('sprinkles' 'orange' 'licking')\nkitty.hobby:'purring'\\",
                "That's so much easier than making a whole new \\Cat\\ with the same values except for the hobby, isn't it?"
            ],
            "start": "first let's get the value",
            "finish": "I copied the structure, but with $1 as $2",
            "conflict": {
                "InvalidProperty": {
                    "primary": "I'm not an input of $1, so I can't be refined.",
                    "secondary": "I don't have an input named $1"
                }
            }
        },
        "PropertyReference": {
            "name": "property",
            "description": "property $1[$1|missing name]",
            "emotion": "kind",
            "doc": [
                "When you make a @StructureDefinition, how do you get one of its inputs? I'm how",
                "Like if you had a structure about cities, you could get its values with me like this:",
                "\\â€¢City(nameâ€¢'' populationâ€¢#people)\n\nportland: City('Portland' 800000people)\n\nportland.population\\"
            ],
            "start": "first let's get the value",
            "finish": "found property $1, it is $2",
            "property": "property"
        },
        "Reaction": {
            "name": "reaction",
            "emotion": "excited",
            "doc": [
                "Streams are so awesome! I can make new ones based on when they change, which is super cool!",
                "Like, if you wanted @Time to tick, but like, to show words instead of numbers, you could do something like this:",
                "\\time: Time(1000ms)\n'start' â€¦ âˆ† time â€¦ ((time % 2) = 0ms) ? 'even' 'odd'\\",
                "That's like saying \"/begin with the word 'start' and then if time changes, change to either even or odd, based on the time./\"",
                "So I'm like a stream to, but one based on other streams. Wicked, huh?"
            ],
            "start": "let's see if we should update the stream",
            "finish": "the new stream value is $1",
            "initial": "initial",
            "condition": "condition",
            "next": "next",
            "conflict": {
                "ExpectedStream": "$1 doesn't reference a stream, so I will never react!"
            }
        },
        "Reference": {
            "name": "reference",
            "description": "$1",
            "emotion": "shy",
            "doc": [
                "You know how @Bind gives things @Name? I'm how you refer to them. I see if any @Bind has that name, if so, give you its value. Like this:",
                "\\parrot: 'polly'\nparrot\\",
                "If I don't find the name, then I don't know what to do.",
                "\\parrot: 'polly'\nperry\\"
            ],
            "start": "what value does $1 have?",
            "conflict": {
                "UnknownName": "$1[I don't know anyone named $1 in $2[$2|this @Block]|Can you give me a name?]",
                "ReferenceCycle": "um, $1's value depends on itself, so how do I know what value to give it?",
                "UnexpectedTypeVariable": "I don't now what to do with these type inputs"
            },
            "exception": {
                "NameException": {
                    "description": "unknown name",
                    "explanation": "$1[I don't know anyone named $1 in $2[$2|this @Block]â€¦|Eep, no name!]"
                }
            }
        },
        "Select": {
            "name": "select",
            "emotion": "excited",
            "doc": [
                "Sometimes you have a table and you just want part of it. I can get it for you!",
                "Like what if you had a table of players in a game and you wanted to find the ones with 10 or more points to see who won:",
                "\\players: âŽ¡nameâ€¢'' teamâ€¢'' pointsâ€¢#âŽ¦\nâŽ¡'jen' 'red' 8âŽ¦\nâŽ¡'joan' 'blue' 11âŽ¦\nâŽ¡'jeff' 'red' 9âŽ¦\nâŽ¡'janet' 'blue' 7âŽ¦\nplayers âŽ¡? name âŽ¦ points â‰¥ 10\\",
                "Just like that, I got a list of rows of winners! Just remember that I don't change the table, I make a new one. You'll have to decide where to keep it."
            ],
            "start": "let's get the table first",
            "finish": "I made a new table with just the selected rows and columns!",
            "conflict": {
                "ExpectedSelectName": "I need at least one column name."
            }
        },
        "SetLiteral": {
            "name": "set literal",
            "description": "$1 items",
            "emotion": "eager",
            "doc": "I'm a specifc @Set of specific values. See @Set to learn more about how to work with me.",
            "start": "let's evaluate the values first!",
            "finish": "I made a set $1!"
        },
        "SetOrMapAccess": {
            "name": "set/map access",
            "emotion": "kind",
            "doc": [
                "I can see if a @Set or @Map has a value or key.",
                "It's not too hard. Like this:",
                "\\faves: {'duck' 'goose' 'monkey'}\nfaves{'mouse'}\\",
                "Or this, with a @Map:",
                "\\faves: {'mac and cheese': 5stars 'cereal': 2stars 'gruel': 1stars}\nfaves{'gruel'}\\"
            ],
            "start": "what's the set or map?",
            "finish": "the value is $1",
            "conflict": {
                "IncompatibleKey": {
                    "primary": "I expected a $1 key",
                    "secondary": "I got a $1 instead of a $2"
                }
            }
        },
        "Source": {
            "name": "source",
            "emotion": "curious",
            "doc": [
                "Oh, you know @Program? I help you name them. Think of me like the window around a @Program, and the name you give them.",
                "You can also make other @Source @UI/addSource, with other @Program, and @Borrow things from those other @Program for use in another program.",
                "This can be a nice way of organizing a big performance into separate documents."
            ]
        },
        "StreamDefinition": {
            "name": "stream",
            "emotion": "curious",
            "doc": "I /think/ I'm supposed make new streams. But I really don't know ho to do that. For now, I guess just use the streams that exist?",
            "start": "create this new kind of stream"
        },
        "StructureDefinition": {
            "name": "structure",
            "description": "structure $1",
            "emotion": "kind",
            "doc": [
                "Why hello, how are you? Me? I'm great. I love to define structures that store values and function, so as long as I get to do that all day, I'm happy.",
                "I work like this:",
                "\\â€¢Pizza(\ningredientsâ€¢['']\nsizeâ€¢#in\n) (\n\tÆ’ cost() size Â· 10dollars/in\n)\n\nPizza(['pepperoni' 'peppers'] 12in).cost()\\",
                "See how that works? I defined \\Pizza\\, which has two inputs, \\ingredients\\ (a list of @Text) and \\size\\ (a number in inches).",
                "Inside, @FunctionDefinition made a function that evaluates the cost of a pizza, assuming $$10 per inch.",
                "I don't need to have @FunctionDefinition in me. I can just be inputs.",
                "\\â€¢Pizza(\ningredientsâ€¢['']\nsizeâ€¢#in\n)\\",
                "I can also have @Bind inside, so we could evaluate the cost in advance.",
                "\\â€¢Pizza(\ningredientsâ€¢['']\nsizeâ€¢#in\n) (\n\tcost: size Â· 10dollars/in\n)\n\nPizza(['pepperoni' 'peppers'] 12in).cost\\"
            ],
            "start": "let's define this lovely structure",
            "conflict": {
                "DisallowedInputs": "I can't have inputs because one of or more of my interface functions isn't implemented",
                "IncompleteImplementation": "my functions either need to all be implemented, or none be implemented. No messy mixtures!",
                "NotAnInterface": "I am not an interface; a structure can only implement interfaces, not other structures",
                "UnimplementedInterface": "I implement $1 but haven't implemented $2"
            }
        },
        "TableLiteral": {
            "name": "table literal",
            "description": "$1 row table",
            "emotion": "angry",
            "doc": "I am a specific table with specific rows. See @Table about how I can help.",
            "start": "first evaluate the rows",
            "finish": "evaluated to new table $1"
        },
        "TextLiteral": {
            "name": "text literal",
            "description": "text $1",
            "emotion": "serious",
            "doc": "I represent one or more specific @Translation of text. See @Text to learn more about what I can do!",
            "start": "let's make text in the current locale"
        },
        "Translation": {
            "name": "translation",
            "description": "translation $1",
            "emotion": "serious",
            "doc": "I represent some text, with a @Language tag. See @Text to learn more!",
            "conflict": {
                "phone": "Is *$1* someone's phone number? Don't share me online if so!\n\n$2",
                "email": "Is *$1* someone's email? Don't share me here if so!\n\n$2",
                "tin": "Is *$1* a tax identifier? If yes, definitely don't share me, I'm very sensitive information!\n\n$2",
                "address": "Is *$1* someone's home address? If so, don't put me here, we don't want anyone getting stalked!\n\n$2",
                "handle": "Is *$1* your username for somewhere else on the internet? If so, don't share me here unless you really mean to.\n\n$2",
                "resolution": "This isn't sensitive data",
                "reminder": "Note: You can undo this action and see other things you've marked as non-sensitive in the sharing dialog."
            }
        },
        "FormattedLiteral": {
            "name": "formatted",
            "description": "text $1",
            "emotion": "serious",
            "doc": "I represent many different @FormattedTranslation of formatted text. When I evaluate, I'll pick the best match based on the audience's selected languages.",
            "start": "let's make text in the current locale"
        },
        "FormattedTranslation": {
            "name": "formatted translation",
            "description": "text $1",
            "emotion": "serious",
            "doc": [
                "I represent some formatted text, with a @Language tag.",
                "I can be:",
                "\\`/italic/`\\",
                "\\`*bold*`\\",
                "\\`^extra bold^`\\",
                "\\`_underlined_`\\",
                "\\`<linked@https://wordplay.dev>`\\",
                "\\`\\'code'\\`\\",
                "I work really well with @Phrase to put beautiful text on @Stage."
            ]
        },
        "This": {
            "name": "this",
            "emotion": "serious",
            "doc": [
                "Sometimes, it's helpful to refer to a value implicilty, rather than having to name it.",
                "For example, suppose you wanted to make a new @ConversionDefinition, which doesn't name the value being convered. You can just refer to it with me:",
                "\\â†’ #rainbows #joys . Â· 1000000joys\n2rainbows â†’ #joys\\",
                "See me there, representing the number of rainbows?",
                "Or suppose you wanted to make a @Reaction, but not have to name the most recent value:",
                "\\2 â€¦ âˆ† Time(1000ms) â€¦ . Â· 2\\",
                "Check me out, representing the previous reaction value.",
                "I don't show up often, but when I do, I can really help a value get out of a @Bind!"
            ],
            "start": "evaluated to $1",
            "conflict": {
                "MisplacedThis": "I'm only allowed in a structure, conversion, or reaction."
            }
        },
        "UnaryEvaluate": {
            "name": "unary evaluate",
            "description": "$1",
            "emotion": "kind",
            "doc": [
                "Did you know that when I'm evaluating a @FunctionDefinition with just one value, and the name of the @FunctionDefinition is just a single symbol, you can put the name before the input?",
                "Like this:",
                "\\-(1 + 1)\\",
                "Or this:",
                "\\~âŠ¥\\",
                "Those are much easier to read than \\(1 + 1).negate()\\ or \\âŠ¥.not()\\, aren't they?",
                "You don't have to write me that way, but it might be easier overall.",
                "There's only one rule: you can't put any space between the name and the value. Otherwise you might be making a @Reference or @BinaryEvaluate."
            ],
            "start": "what's the value?",
            "finish": "I made it $1"
        },
        "UnparsableExpression": {
            "name": "unparsable",
            "emotion": "excited",
            "doc": [
                "/Hi @FunctionDefinition here. I'm translating for @UnparsableExpression, since they're often hard to interpret./",
                "jkwel fjiwojvioao jjiweo jrfe",
                "/Not every expression has meaning on stage./",
                "s w ieorjwei iojwi jfkdlsfdsk",
                "/In fact, there are all kinds of things you can say that don't make any sense at all./",
                "dsk sdlk jdkfiewipapweiurb,v kdsfdsf",
                "/When you do, I show up, because I don't know what you meant./",
                "You are the director after all, so only you know what you might have meant!"
            ],
            "start": "???",
            "conflict": {
                "UnparsableConflict": {
                    "conflict": "@FunctionDefinition here, @UnparsableExpression doesn't know what kind of $1[ expression | type ] this is.",
                    "resolution": "Did you mean a $1, $2?"
                },
                "UnclosedDelimiter": "I expected $2 sometime after $1"
            },
            "exception": {
                "UnparsableException": {
                    "description": "???",
                    "explanation": "Hi, @FunctionDefinition here! We're not sure what this instruction means, so we stopped."
                }
            }
        },
        "Update": {
            "name": "update",
            "emotion": "kind",
            "doc": [
                "I help revise a @Table, finding the rows that match a condition, and then creating revised rows with new values.",
                "So like, if you had a table of characters and points, and you wanted to give every character on a team a point, you might do this:",
                "\\players: âŽ¡nameâ€¢'' teamâ€¢'' pointsâ€¢#âŽ¦\nâŽ¡'jen' 'red' 1âŽ¦\nâŽ¡'joan' 'blue' 0âŽ¦\nâŽ¡'jeff' 'red' 3âŽ¦\nâŽ¡'janet' 'blue' 2âŽ¦\nplayers âŽ¡: points: points + 1 âŽ¦ team = 'blue'\\",
                "You can use a @Bind to say which columns to change, and you can use any of the column names or other names in scope in the condition."
            ],
            "start": "let's get the table first",
            "finish": "evaluated to a new table with revised rows!",
            "conflict": {
                "ExpectedColumnBind": "I need a value for every column",
                "IncompatibleCellType": {
                    "primary": "I needed a $1, but got a $2",
                    "secondary": "I got a $2"
                }
            }
        },
        "AnyType": {
            "name": "any",
            "emotion": "curious",
            "doc": "I represent any any possible type. Sometimes I show up because I don't know what kind of value something is, so it could be anything."
        },
        "BooleanType": {
            "name": "boolean",
            "emotion": "kind",
            "doc": [
                "I work with @Bind to declare that a name is a @Boolean value. Like this:",
                "\\hungryâ€¢?: 'jello'\\",
                "If you want to be sure that something is @Boolean, use me, and I'll check!"
            ]
        },
        "ConversionType": {
            "name": "conversion",
            "emotion": "serious",
            "doc": [
                "I work with @Bind to indicate that a name is a @ConversionDefinition. You probably don't need to use me, because not a lot of people pass me around as a value, but if you did, I would look like this:",
                "\\magicâ€¢?â†’'': â†’ ? '' . ? 'yep' 'nope'\\"
            ]
        },
        "FormattedType": {
            "name": "formatted",
            "emotion": "serious",
            "doc": [
                "I work with @Bind to note that a name is a @FormattedLiteral value. Like this:",
                "\\hungryâ€¢`â€¦`: `I am so /fancy/!`\\",
                "Want to make sure something is a @FormattedLiteral value? This is how you make sure."
            ]
        },
        "ExceptionType": {
            "name": "exception",
            "emotion": "neutral",
            "doc": "I represent an exception. There's no way to tell bind that I am one, because exceptions only ever halt @Program, so you can't use them as values."
        },
        "FunctionType": {
            "name": "function",
            "description": "function with $1 inputs, $2 output",
            "emotion": "curious",
            "doc": [
                "I represent a @FunctionDefinition. I'm really helpful if you want to say what kind of function a @Bind holds! Like this:",
                "\\mathâ€¢Æ’ (# # # #) #: Æ’ interesting(aâ€¢# bâ€¢# câ€¢# dâ€¢#) a + b + c + d\\"
            ]
        },
        "ListType": {
            "name": "list",
            "description": "$1[list of $1|list]",
            "emotion": "cheerful",
            "doc": [
                "I am /such/ a fan of @List. I get to tell @Bind what kind of list they are! Like this, I'm saying that it's a list of @Number:",
                "\\thingsâ€¢[#]: [ 1 2 3 4 5 ]\\"
            ]
        },
        "MapType": {
            "name": "map ",
            "description": "map from $1[$1|any] to $2[$2|any]",
            "emotion": "kind",
            "doc": [
                "Do you know how awesome @Map is? Like really awesome. I tell @Bind what kind of map they are all the time, like this map of numbers to lists:",
                "\\stuffâ€¢{'':[]}: {}\\"
            ]
        },
        "NumberType": {
            "name": "number",
            "description": "$1[$1 | number]",
            "emotion": "precise",
            "doc": [
                "You know what @Bind should be? A @Number. Because numbers are the best.",
                "\\countâ€¢#: 17\\"
            ]
        },
        "NameType": {
            "name": "structure",
            "description": "$1 type",
            "emotion": "curious",
            "doc": [
                "I represent a @StructureDefinition by it's name. So like, if you had a structure like this, you could make a @Bind that stores the values it creates.",
                "\\â€¢Friend(nameâ€¢'')\nbestieâ€¢Friend: Friend('Jonah')\\"
            ],
            "conflict": {
                "UnknownTypeName": "type names can only refer to structures or type variables, but this refers to a $1"
            }
        },
        "NeverType": {
            "name": "never",
            "emotion": "curious",
            "doc": "I represent a type that is impossible. Like when you ask @Is if something is a @Number, but it can never be a number."
        },
        "NoneType": {
            "name": "none",
            "emotion": "neutral",
            "doc": [
                "@None is the best nothing there is, and I am their faithful representative.",
                "\\spaceâ€¢Ã¸: Ã¸\\"
            ]
        },
        "SetType": {
            "name": "set",
            "description": "$1[$1 set|set]",
            "emotion": "kind",
            "doc": [
                "@Set is the BEST, like seriously. I'm telling @Bind all the time, make things a set of something!",
                "\\uniqueâ€¢{''}: {'something' 'anything' 'someone'}\\"
            ]
        },
        "StreamDefinitionType": {
            "name": "stream definition",
            "emotion": "angry",
            "doc": "I represent a stream you have defined, which isn't possible, so why are you even reading this?"
        },
        "StreamType": {
            "name": "stream",
            "emotion": "curious",
            "doc": [
                "I celebrate the beauty and meaning of streamsâ€¦ by telling @Bind to store them:",
                "\\timeâ€¢â€¦#ms: Time()\\"
            ]
        },
        "StructureType": {
            "name": "structure",
            "description": "$1",
            "emotion": "kind",
            "doc": "I am an internal type to represent the type of default value types."
        },
        "UnknownType": {
            "name": "unknown",
            "connector": ", because ",
            "emotion": "curious",
            "doc": "Umm... I don't know what I represent, but I really am curious. Do you know? It seems like we should know. You might need to tell us if we can't figure it out."
        },
        "TableType": {
            "name": "table",
            "emotion": "angry",
            "doc": "I represent a Table.",
            "conflict": {
                "ExpectedColumnType": "I need a column type"
            }
        },
        "TextType": {
            "name": "text",
            "description": "$1[$1|text]",
            "emotion": "happy",
            "doc": [
                "I fabulously represent the most fabulous kind of value there is, @Text.",
                "\\storyâ€¢'': 'Once upon a time...'\\"
            ]
        },
        "TypePlaceholder": {
            "name": "placeholder",
            "emotion": "eager",
            "doc": "I hope to represent a type some day, kind of like my bestie @ExpressionPlaceholder represents an expression! Will you help me decide what kind?"
        },
        "UnionType": {
            "name": "option",
            "description": "$1 | $2",
            "emotion": "curious",
            "doc": [
                "Who should I represent, A or B or something else? I can never decide!",
                "\\indecisionâ€¢''|#|{Ã¸}: \"I don't know!\"\\"
            ]
        },
        "Unit": {
            "name": "unit",
            "description": "$1",
            "emotion": "precise",
            "doc": [
                "I represent any unit a @Number might have, including no unit, to the most complicated unit you can imagine. Like gravity, for example:",
                "\\gravityâ€¢m/s^2: 9.8m/s^2\\",
                "I show up in @Bind, but also right after @Number. I help make sure that numbers are of the same kinds, and will definitely tell you if they aren't, in case its a mistake!"
            ]
        },
        "UnparsableType": {
            "name": "unparsable",
            "emotion": "curious",
            "doc": "I represent the type of an unknown expression. I show up when you try to use that expression for something."
        },
        "VariableType": {
            "name": "variable type",
            "emotion": "curious",
            "doc": "Do you know @TypeVariable, and how they represent some unknown kind of value? I represent them in all negotiations between values."
        },
        "CycleType": {
            "name": "cycle",
            "description": "depends on itself",
            "emotion": "curious",
            "doc": "Sometimes values depend on themselves, and so we don't know what kind of value they are. I represent that situation."
        },
        "UnknownVariableType": {
            "name": "unknown variable",
            "emotion": "curious",
            "doc": "Sometimes we try to guess what kind of value something is; I show up when we don't know."
        },
        "NotAType": {
            "name": "unexpected",
            "description": "not a $1",
            "emotion": "curious",
            "doc": "Sometimes we know what kind of value something should be. Like @ListAccess needs a @Number. If we don't get it, I represent that something is a type other than what we expected."
        },
        "NoExpressionType": {
            "name": "no expression",
            "emotion": "angry",
            "doc": "You know how @Block needs at least one expression? I'm what you get when you don't give one. So give one!"
        },
        "NotEnclosedType": {
            "name": "not in structure, conversion, or reaction",
            "emotion": "curious",
            "doc": "@This, as neat as they are, only belongs in particular places. I show up when they get lost, and so no one knows what value they represent."
        },
        "NotImplementedType": {
            "name": "unimplemented",
            "emotion": "curious",
            "doc": "When you use @ExpressionPlaceholder, but don't say what type they are, I'm the type you get. Deal with it!"
        },
        "UnknownNameType": {
            "name": "unknown name",
            "description": "$1[$1 isn't defined |a name wasn't given]",
            "emotion": "curious",
            "doc": "You know how sometimes @Reference and @PropertyReference don't know the name you're talking about? I'm around when that happens, to represent that we don't know who you're talking about."
        },
        "NonFunctionType": {
            "name": "non-function",
            "description": "non-function",
            "emotion": "confused",
            "doc": "Some of us expected functions; I show up when we don't get one."
        }
    },
    "basis": {
        "Boolean": {
            "doc": [
                "We are \\âŠ¤\\ and \\âŠ¥\\. \\âŠ¤\\ is true. \\âŠ¥\\ is false. \\âŠ¤\\ is not \\âŠ¥\\; \\âŠ¥\\ is not \\âŠ¤\\. This is how it is.",
                "How do you make us? Just \\âŠ¤\\ and \\âŠ¥\\, nothing more, nothing less.",
                "Some use the keyboard (/ctrl+9/ for \\âŠ¤\\ and /ctrl+0/ for \\âŠ¥\\). Some use the character search at the bottom of the editor. Or you can drag us from here.",
                "Check out our @FunctionDefinition below. They're very logical."
            ],
            "name": ["âŠ¤âŠ¥", "Boolean"],
            "function": {
                "and": {
                    "doc": [
                        "I evaluate to \\âŠ¤\\ *only* when both values are \\âŠ¤\\. Helpful for determining if many things are all true. There are only four possible outcomes",
                        "\\âŠ¤ & âŠ¤\\",
                        "\\âŠ¤ & âŠ¥\\",
                        "\\âŠ¥ & âŠ¤\\",
                        "\\âŠ¥ & âŠ¥\\"
                    ],
                    "names": ["&", "and"],
                    "inputs": [
                        {
                            "doc": "The other @Boolean to check. If the first is \\âŠ¥\\, it doesn't matter what this is, the function will evaluate to \\âŠ¥\\.",
                            "names": "value"
                        }
                    ]
                },
                "or": {
                    "doc": [
                        "I evaluate to \\âŠ¤\\ when *either* value are \\âŠ¤\\. Helpful for determining if one of many things are true. There are only four possible outcomes",
                        "\\âŠ¤ | âŠ¤\\",
                        "\\âŠ¤ | âŠ¥\\",
                        "\\âŠ¥ | âŠ¤\\",
                        "\\âŠ¥ | âŠ¥\\"
                    ],
                    "names": ["|", "or"],
                    "inputs": [
                        {
                            "doc": "The other @Boolean to check. If the first is \\âŠ¥\\, the function will only evaluate to \\âŠ¤\\ if this is \\âŠ¤\\.",
                            "names": "value"
                        }
                    ]
                },
                "not": {
                    "doc": "I get the opposite of myself: if \\âŠ¤\\, it gives \\âŠ¥\\, if \\âŠ¥\\, it gives \\âŠ¤\\.",
                    "names": ["~", "not"],
                    "inputs": []
                },
                "equals": {
                    "doc": "\\âŠ¤\\ if both are \\âŠ¤\\ or both are \\âŠ¥\\.",
                    "names": ["=", "equals"],
                    "inputs": [
                        { "doc": "The other value to check.", "names": "value" }
                    ]
                },
                "notequal": {
                    "doc": "\\âŠ¤\\ if both are opposites.",
                    "names": ["â‰ ", "notequal"],
                    "inputs": [
                        { "doc": "The other value to check.", "names": "value" }
                    ]
                }
            },
            "conversion": {
                "text": "Converts a @Boolean to the equivalent @Text values, \\'âŠ¤'\\ and \\'âŠ¥'\\"
            }
        },
        "None": {
            "doc": [
                "/Hi, @FunctionDefinition here. @None doesn't like to say much, so I'll interpret./",
                "I am @None. Invoke me with \\Ã¸\\. I am helpful when you want to represent the absense of something."
            ],
            "name": ["Ã¸", "None"],
            "function": {
                "equals": {
                    "doc": "Is another value also nothing? It better be, otherwise, \\âŠ¥\\.",
                    "names": ["=", "equals"],
                    "inputs": [{ "doc": "The other value.", "names": "value" }]
                },
                "notequals": {
                    "doc": "Is another value /not/ nothing?",
                    "names": ["â‰ ", "notequal"],
                    "inputs": [{ "doc": "The other value.", "names": "value" }]
                }
            },
            "conversion": {
                "text": "Want to make \\Ã¸\\ into \\'Ã¸'\\? This is your chance."
            }
        },
        "Text": {
            "doc": [
                "I can be any text you like, from any language, and using any of these symbols opening and closing symbols: \\\"\"\\, \\â€œâ€\\, \\â€žâ€œ\\, \\''\\, \\â€˜â€™\\, \\â€¹â€º\\, \\Â«Â»\\, \\ã€Œã€\\, or \\ã€Žã€\\.",
                "To illustrate, consider these beautiful phrases",
                "\\â€œThere are only two ways to live your life. One is as though nothing is a miracle. The other is as though everything is a miracle.â€\\",
                "\\ã€Žä¸€æ—¥ä¸‰ç§‹ã€\\",
                "Just remember to close me if you open me, and use the matching symbol. Otherwise I won't know that you're done with your words.",
                "\\'hello'/en'hola'/es-MX\\",
                "You can also tag me with languages, and even give multiple translations. I'll evaluate to whatever languages are currently selected, if there's a matching langauge.",
                "If you want to make me with some other values, you can use a symbol to ",
                "For instance, consider this:",
                "\\\"Here are some sums \\1 + 2\\, \\2 + 3\\, \\3 + 4\\\"\\",
                "See how elegantly I just evaluated those sums, and placed them inside the @Text?",
                "Otherwise, there just so many glorious functions that @FunctionDefinition made for me to do all kinds of things with words!"
            ],
            "name": ["''", "Text"],
            "function": {
                "length": {
                    "doc": [
                        "I evaluate to the number of legible characters in the text; one letter is one character, one emoji is one character, etc. For example:",
                        "\\'hello'.length()\\",
                        "\\'ðŸˆðŸ“š'.length()\\"
                    ],
                    "names": ["ðŸ“", "length"],
                    "inputs": []
                },
                "equals": {
                    "doc": "\\âŠ¤\\ if I am the same character sequence as the given @Text.",
                    "names": ["=", "equals"],
                    "inputs": [
                        { "doc": "The @Text to compare.", "names": "value" }
                    ]
                },
                "notequals": {
                    "doc": "\\âŠ¤\\ if I am /not/ the same character sequence as the given @Text.",
                    "names": "â‰ ",
                    "inputs": [
                        { "doc": "The @Text to compare", "names": "value" }
                    ]
                },
                "has": {
                    "doc": [
                        "\\âŠ¤\\ if the given @Text appears in me.",
                        "\\'did you find what you were looking for?'.has('you')\\"
                    ],
                    "names": ["âŠ†", "has"],
                    "inputs": [
                        {
                            "doc": "The @Text to search for in me.",
                            "names": "text"
                        }
                    ]
                },
                "starts": {
                    "doc": [
                        "\\âŠ¤\\ if I start with the given @Text.",
                        "\\'hello verse!'.starts('hello')\\",
                        "\\'hello verse!'.starts('verse')\\"
                    ],
                    "names": ["starts"],
                    "inputs": [
                        {
                            "doc": "The @Text to check for at the start of me.",
                            "names": "text"
                        }
                    ]
                },
                "ends": {
                    "doc": [
                        "\\âŠ¤\\ if I end with the given @Text.",
                        "\\'am I a question?'.ends('?')\\",
                        "\\'I am not a question.'.ends('?')\\"
                    ],
                    "names": ["ends"],
                    "inputs": [
                        {
                            "doc": "The @Text to check for at the end of me.",
                            "names": "text"
                        }
                    ]
                },
                "repeat": {
                    "doc": [
                        "I make a new @Text that's me, repeated the number of times of \\count\\:",
                        "\\'hi ' Â· 5\\",
                        "If you give me a fractional @Number, I ignore the fraction:",
                        "\\'hi ' Â· 5.5\\",
                        "If you give me a negative @Number or zero, I give an empty @Text.",
                        "\\'hi ' Â· -5\\"
                    ],
                    "names": ["Â·", "ðŸ”", "repeat"],
                    "inputs": [
                        {
                            "doc": "The number of times to repeat myself in the new text.",
                            "names": "count"
                        }
                    ]
                },
                "segment": {
                    "doc": [
                        "I divide myself into a @List of @Text, using the given @Text as a separator, and removing the separators. For example:",
                        "\\'apples, oranges, grapes' Ã· ', '\\",
                        "If the separator is an empty @Text, I divide myself into characters:",
                        "\\'ðŸ–Œï¸ðŸ ðŸ¥¸' Ã· ''\\"
                    ],
                    "names": ["Ã·", "segment"],
                    "inputs": [
                        {
                            "doc": "The @Text to use as a separator.",
                            "names": "delimiter"
                        }
                    ]
                },
                "combine": {
                    "doc": [
                        "Sometimes it's helpful to combine to @Text into one. Give me another @Text and I'll make a new text that joins us together:",
                        "\\'hello ' + 'verse'\\"
                    ],
                    "names": ["+", "combine"],
                    "inputs": [
                        { "doc": "The @Text to append.", "names": "text" }
                    ]
                }
            },
            "conversion": {
                "list": "Splits the text into a list of individual characters.",
                "number": "Converts text into a @Number, and if it's not a number, a not a number value."
            }
        },
        "Number": {
            "doc": [
                "I create @Number, with any number of units you can imagine!",
                "Here are my top 5:",
                "\\0\\",
                "\\1story\\",
                "\\Ï€pie\\",
                "\\âˆžrock\\",
                "\\1000000hugs\\",
                "That's basically an infinite number of numbers.",
                "And an infinite number of units!",
                "And an infinite number of number/unit pairsâ€¦",
                "I can be integers, real numbers, negative, positive, fractional, decimal, even not a number.",
                "And you can write me with many different number systems, including Arabic \\123\\, Roman \\â…©â…©â…©â… â…©\\, Japanese \\äºŒå\\, and more:",
                "\\1 + â…  + ä¸€\\",
                "You can also write me in bases 2 to 16 by putting a base number like this:",
                "\\2;11111111\\",
                "\\10;255\\",
                "\\16;FF\\",
                "There is one special number called NaN that is possible when you write something that isn't a number:",
                "\\2;22\\",
                "There is no digit '2' in base 2, so it's not a valid number. NaN will also show up if you try to convert non-number text to number",
                "\\'hi'â†’#\\"
            ],
            "name": ["#", "Number"],
            "function": {
                "add": {
                    "doc": [
                        "I add a @Number with the same @Unit to myself, creating a new @Number of the same @Unit.",
                        "For example:",
                        "\\1 + 1\\",
                        "\\3cat + 5cat\\",
                        "If the units don't match, I halt the show.",
                        "\\3cat + 5dog\\"
                    ],
                    "names": ["+", "add"],
                    "inputs": [
                        { "doc": "The @Number to add.", "names": "number" }
                    ]
                },
                "subtract": {
                    "doc": [
                        "I subtract the @Number you give me from myself, creating a new @Number of the same @Unit.",
                        "For example:",
                        "\\1 - 1\\",
                        "\\3cat - 5cat\\",
                        "If the units don't match, I halt the show.",
                        "\\3cat - 5dog\\"
                    ],
                    "names": ["-", "subtract"],
                    "inputs": [
                        {
                            "doc": "The @Number to subtract from me.",
                            "names": "number"
                        }
                    ]
                },
                "multiply": {
                    "doc": [
                        "I multiply myself to the given @Number, creating a product of my @Unit and the given number's @Unit:",
                        "\\5 Â· 5\\",
                        "\\5m Â· 5m\\",
                        "\\5m Â· 1/s\\"
                    ],
                    "names": ["Â·", "multiply"],
                    "inputs": [
                        { "doc": "The number to multiply.", "names": "number" }
                    ]
                },
                "divide": {
                    "doc": [
                        "I divide myself by the given @Number, creating a quotient of my @Unit and the given number's @Unit:",
                        "\\5 Ã· 5\\",
                        "\\5m Ã· 5m\\",
                        "\\5m Ã· 5s\\"
                    ],
                    "names": ["Ã·", "divide"],
                    "inputs": [
                        {
                            "doc": "The @Number to divide me by.",
                            "names": "number"
                        }
                    ]
                },
                "remainder": {
                    "doc": [
                        "I divide myself by the given @Number, but give the remainder:",
                        "\\10 % 2\\",
                        "\\10m % 2\\",
                        "\\10m/s % 3\\"
                    ],
                    "names": ["%", "remainder"],
                    "inputs": [
                        {
                            "doc": "The @Number to divide me by.",
                            "names": "number"
                        }
                    ]
                },
                "positive": {
                    "doc": [
                        "I create a new @Number that makes me positive, if negative.",
                        "\\-200.positive()\\"
                    ],
                    "names": ["positive"],
                    "inputs": []
                },
                "round": {
                    "doc": [
                        "I create a new @Number that rounds me to the closest integer.",
                        "\\9.4.round()\\",
                        "\\9.5.round()\\",
                        "\\9.6.round()\\"
                    ],
                    "names": ["round"],
                    "inputs": []
                },
                "roundDown": {
                    "doc": [
                        "I create a new @Number that rounds to smallest integer less than me.",
                        "\\10.5.roundDown()\\",
                        "\\10.1.roundDown()\\",
                        "\\10.01.roundDown()\\"
                    ],
                    "names": ["roundDown"],
                    "inputs": []
                },
                "roundUp": {
                    "doc": [
                        "I create a new @Number that rounds to the smalelst integer greater than me.",
                        "\\10.5.roundUp()\\",
                        "\\10.9.roundUp()\\",
                        "\\10.99.roundUp()\\"
                    ],
                    "names": ["roundUp"],
                    "inputs": []
                },
                "power": {
                    "doc": [
                        "I raise myself to the given @Number's power. Fractional exponents are okay!",
                        "\\2 ^ 8\\",
                        "\\10 ^ -2\\",
                        "\\5 ^ -.5\\"
                    ],
                    "names": ["^", "power"],
                    "inputs": [
                        {
                            "doc": "The exponent to raise me to.",
                            "names": "number"
                        }
                    ]
                },
                "root": {
                    "doc": [
                        "I create the root of myself using the given root.",
                        "\\4 âˆš 2\\",
                        "\\1000 âˆš 3\\"
                    ],
                    "names": ["âˆš", "root"],
                    "inputs": [
                        { "doc": "The root to compute.", "names": "number" }
                    ]
                },
                "lessThan": {
                    "doc": [
                        "\\âŠ¤\\ if I'm less than the given @Number:",
                        "\\1 < 2\\",
                        "\\2 < 1\\"
                    ],
                    "names": ["<", "lessthan"],
                    "inputs": [
                        {
                            "doc": "The @Number to compare me to.",
                            "names": "number"
                        }
                    ]
                },
                "lessOrEqual": {
                    "doc": [
                        "\\âŠ¤\\ if I'm less than or equal to the given @Number:",
                        "\\1 â‰¤ 2\\",
                        "\\2 â‰¤ 1\\",
                        "\\2 â‰¤ 2\\"
                    ],
                    "names": ["â‰¤", "lessorequal"],
                    "inputs": [
                        {
                            "doc": "The @Number to compare me to.",
                            "names": "number"
                        }
                    ]
                },
                "greaterThan": {
                    "doc": [
                        "\\âŠ¤\\ if I'm greater than to the given @Number:",
                        "\\1 > 2\\",
                        "\\2 > 1\\"
                    ],
                    "names": [">", "greaterthan"],
                    "inputs": [
                        {
                            "doc": "The @Number to compare me to.",
                            "names": "number"
                        }
                    ]
                },
                "greaterOrEqual": {
                    "doc": [
                        "\\âŠ¤\\ if I'm greater than or equal to the given @Number:",
                        "\\1 â‰¥ 2\\",
                        "\\2 â‰¥ 1\\",
                        "\\2 â‰¥ 2\\"
                    ],
                    "names": ["â‰¥", "greaterorequal"],
                    "inputs": [
                        {
                            "doc": "The @Number to compare me to.",
                            "names": "number"
                        }
                    ]
                },
                "equal": {
                    "doc": [
                        "\\âŠ¤\\ if I'm equal to the given @Number:",
                        "\\1 = 2\\",
                        "\\2 = 2\\"
                    ],
                    "names": ["=", "equal"],
                    "inputs": [
                        {
                            "doc": "The @Number to compare me to.",
                            "names": "number"
                        }
                    ]
                },
                "notequal": {
                    "doc": [
                        "\\âŠ¤\\ if I'm equal to the given @Number:",
                        "\\1 â‰  2\\",
                        "\\2 â‰  2\\"
                    ],
                    "names": ["â‰ ", "notequal"],
                    "inputs": [
                        {
                            "doc": "The @Number to compare me to.",
                            "names": "number"
                        }
                    ]
                },
                "cos": {
                    "doc": ["Compute the cosine of me.", "\\Ï€.cos()\\"],
                    "names": ["cos", "cosine"],
                    "inputs": []
                },
                "sin": {
                    "doc": ["Compute the sine of me.", "\\Ï€.cos()\\"],
                    "names": ["sin", "sine"],
                    "inputs": []
                },
                "min": {
                    "doc": [
                        "Find the smallest number of me and others.",
                        "\\1.min(2 3 -1)\\"
                    ],
                    "names": "min",
                    "inputs": [
                        {
                            "doc": "As many numbers as you want to give me!",
                            "names": "numbers"
                        }
                    ]
                },
                "max": {
                    "doc": [
                        "Find the largest number of me and others.",
                        "\\1.max(2 3 4)\\"
                    ],
                    "names": "max",
                    "inputs": [
                        {
                            "doc": "As many numbers as you want to give me!",
                            "names": "numbers"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "An Arabic @Text representation of my digits.",
                "list": "A list of the numbers 1 to whatever number is given, such as\n\\10â†’[]\\.",
                "s2m": "Seconds to minutes",
                "s2h": "Seconds to hours",
                "s2day": "Seconds to days",
                "s2wk": "Seconds to weeks",
                "s2year": "Seconds to years",
                "s2ms": "Seconds to miliseconds",
                "ms2s": "Milliseconds to seconds",
                "min2s": "Minutes to seconds",
                "h2s": "Hours to seconds",
                "day2s": "Days to seconds",
                "wk2s": "Weeks to seconds",
                "yr2s": "Years to seconds",
                "m2pm": "Meters to picometers",
                "m2nm": "Meters to nanometers",
                "m2micro": "Meters to micrometers",
                "m2mm": "Meters to millimeters",
                "m2cm": "Meters to centimenters",
                "m2dm": "Meters to decimeters",
                "m2km": "Meters to kilometers",
                "m2Mm": "Meters to megameters",
                "m2Gm": "Meters to gigameters",
                "m2Tm": "Meters to terameters",
                "pm2m": "Picometers to meters",
                "nm2m": "Nanometers to meters",
                "micro2m": "Micrometers to meters",
                "mm2m": "Millimeters to meters",
                "cm2m": "Centimeters to meters",
                "dm2m": "Decimeters to meters",
                "km2m": "Kilometers to meters",
                "Mm2m": "Megameters to meters",
                "Gm2m": "Gigameters to meters",
                "Tm2m": "Terameters to meters",
                "km2mi": "Kilometers to miles",
                "mi2km": "Miles to kilometers",
                "cm2in": "Centimeters to inches",
                "in2cm": "Inches to centimeters",
                "m2ft": "Meters to feet",
                "ft2m": "Feet to meters",
                "g2mg": "Grams to milligrams",
                "mg2g": "Milligrams to grams",
                "g2kg": "Grams to kilograms",
                "kg2g": "Kilograms to grams",
                "g2oz": "Grams to ounces",
                "oz2g": "Ounces to grams",
                "oz2lb": "Ounces to pounds",
                "lb2oz": "Pounds to ounces"
            }
        },
        "List": {
            "doc": [
                "I'm a sequence of values, of any kind!",
                "You can put anything in me: @Boolean, @Number, @Text, @None, even other @List, @Set, @Map, or any expression. Here's a simple one:",
                "\\['apple' 'banana' 'mango']\\",
                "What makes me special is that I keep things in order and I number everything from 1 to however many items are in me.",
                "My items are numbered, starting from 1. You can get values that I'm storing with @ListAccess, using their number:",
                "For example, the second value in this list is \\['banana']\\",
                "\\['apple' 'banana' 'mango'][2]\\",
                "I can have anything in me. Look at this list, with @Text, @Number, and @Time!",
                "\\['apple' 10 + 10 Time()]\\",
                "When you give me a list of many things, I'll generalize them if they have a type in common. But sometimes you might literally mean those specific things. If you do, just put a ! after me, and I'll make sure that I represent a list of specifically only those values.",
                "\\['apple' 'banana' 'mango']!\\",
                "That's kind of it. But I can do call kinds of exciting things with my @FunctionDefinition!"
            ],
            "name": ["[]", "List"],
            "kind": "Kind",
            "out": "Result",
            "outofbounds": "outofbounds",
            "function": {
                "add": {
                    "doc": [
                        "I create a new @List with the given item at the end.",
                        "\\['apple' 'banana' 'mango'].add('watermelon')\\"
                    ],
                    "names": ["with", "add"],
                    "inputs": [
                        {
                            "doc": "I the value you want to add.",
                            "names": "item"
                        }
                    ]
                },
                "append": {
                    "doc": [
                        "I create a new @List with my values, then all the values of the given @List after me.",
                        "\\['apple' 'banana' 'mango'].withList(['watermelon' 'starfruit'])\\",
                        "It's a little bit easier to use @Spread though, like this:",
                        "\\['apple' 'banana' 'mango' :['watermelon' 'starfruit']]\\"
                    ],
                    "names": ["withList", "append"],
                    "inputs": [
                        { "doc": "The list of values to add.", "names": "list" }
                    ]
                },
                "replace": {
                    "doc": [
                        "I create a new list that replaces the value at the given index with the given value.",
                        "\\['apple' 'banana' 'mango'].replace(1 'kiwi')\\"
                    ],
                    "names": ["replace"],
                    "inputs": [
                        {
                            "doc": "The index of the value to replace",
                            "names": "index"
                        },
                        { "doc": "The replacement value", "names": "value" }
                    ]
                },
                "length": {
                    "doc": "The @Number of items in me.",
                    "names": ["ðŸ“", "length"],
                    "inputs": []
                },
                "random": {
                    "doc": [
                        "A randomly selected one of my items, or @None if I'm empty.",
                        "\\['apple' 'banana' 'mango'].random()\\"
                    ],
                    "names": "random",
                    "inputs": []
                },
                "shuffled": {
                    "doc": [
                        "Make a new list with the items in the last randomly ordered.",
                        "\\['apple' 'banana' 'mango'].shuffled()\\"
                    ],
                    "names": "shuffled",
                    "inputs": []
                },
                "first": {
                    "doc": [
                        "The first item in me, or @None if I'm empty.",
                        "\\['apple' 'banana' 'mango'].first()\\"
                    ],
                    "names": "first",
                    "inputs": []
                },
                "last": {
                    "doc": [
                        "The last item in me, or @None if I'm empty.",
                        "\\['apple' 'banana' 'mango'].first()\\"
                    ],
                    "names": "last",
                    "inputs": []
                },
                "has": {
                    "doc": [
                        "\\âŠ¤\\ if I have an item equal to the given item in me.",
                        "\\['apple' 'banana' 'mango'].has('banana')\\"
                    ],
                    "names": "has",
                    "inputs": [
                        { "doc": "The value to search for.", "names": "item" }
                    ]
                },
                "join": {
                    "doc": [
                        "I combine the items in my list into @Text, separated by the given separator @Text.",
                        "\\['apple' 'banana' 'mango'].join(', ')\\"
                    ],
                    "names": "join",
                    "inputs": [
                        {
                            "doc": "The text to separate the items by, optionally empty.",
                            "names": "separator"
                        }
                    ]
                },
                "subsequence": {
                    "doc": [
                        "I get a list within this list, starting at the index you provide, and ending with the last item, or if you provide one, a particular item.",
                        "\\['apple' 'banana' 'mango'].subsequence(2)\\",
                        "\\['apple' 'banana' 'mango'].subsequence(1 2)\\",
                        "And look! If you provide numbers out of order, I give you the reverse",
                        "\\['apple' 'banana' 'mango'].subsequence(3 1)\\",
                        "If you give me something smaller than 1 for an index, I'll assume you mean 1.",
                        "\\['apple' 'banana' 'mango'].subsequence(-1003243 2)\\",
                        "And if you give me something larger than the largest index, I'll assume you mean the end.",
                        "\\['apple' 'banana' 'mango'].subsequence(3 2304032432)\\"
                    ],
                    "names": "subsequence",
                    "inputs": [
                        {
                            "doc": "The index of the first item of the subsequence you want.",
                            "names": "start"
                        },
                        {
                            "doc": "The optional index of the last item of the subsequence you want. If you don't give one, your list will end with the last item in the list.",
                            "names": "end"
                        }
                    ]
                },
                "sansFirst": {
                    "doc": [
                        "I create a list without my first item.",
                        "\\['apple' 'banana' 'mango'].sansFirst()\\"
                    ],
                    "names": ["withoutFirst", "sansFirst"],
                    "inputs": []
                },
                "sansLast": {
                    "doc": [
                        "I create a list without my last item.",
                        "\\['apple' 'banana' 'mango'].sansLast()\\"
                    ],
                    "names": ["withoutLast", "sansLast"],
                    "inputs": []
                },
                "sans": {
                    "doc": [
                        "Me, but without the first occurences of the given value.",
                        "\\['apple' 'banana' 'mango' 'apple'].sans('apple')\\"
                    ],
                    "names": ["without", "sans"],
                    "inputs": [
                        {
                            "doc": "The value to remove the first occurence of.",
                            "names": "value"
                        }
                    ]
                },
                "sansAll": {
                    "doc": [
                        "Me, but without all occurences of the given value.",
                        "\\['apple' 'banana' 'mango' 'apple'].sans('apple')\\"
                    ],
                    "names": ["withoutAll", "sansAll"],
                    "inputs": [
                        {
                            "doc": "The value to remove all occurences of from the list.",
                            "names": "value"
                        }
                    ]
                },
                "reverse": {
                    "doc": [
                        "Me, but in reverse!",
                        "\\['apple' 'banana' 'mango'].reverse()\\"
                    ],
                    "names": ["reversed", "reverse"],
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "\\âŠ¤\\ if my items and order are the exact same as the given @List.",
                        "\\['apple' 'banana' 'mango'] = ['apple' 'mango' 'banana']\\"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "The @List to compare me to.",
                            "names": "list"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "\\âŠ¤\\ if my items and order are /not/ the exact same as the given @List.",
                        "\\['apple' 'banana' 'mango'] â‰  ['apple' 'mango' 'banana']\\"
                    ],
                    "names": ["â‰ ", "notequal"],
                    "inputs": [
                        {
                            "doc": "The @List to compare me to.",
                            "names": "list"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes a value and optional index as input and produces a value, and I'll evaluate it on each of my items, translating my values into new values.",
                        "For example, imagine I was a list of @Number and you wanted to double all of them:",
                        "\\[2 4 6 8].translate(Æ’(numâ€¢#) num Â· 2)\\"
                    ],
                    "names": "translate",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that will translate each item.",
                            "names": "translator"
                        }
                    ],

                    "translator": [
                        {
                            "doc": "The item being translated.",
                            "names": "item"
                        },
                        {
                            "doc": "The index of the item being translated.",
                            "names": "index"
                        },
                        {
                            "doc": "The list being translated.",
                            "names": "list"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes a value and optional index as input and produces a @Boolean, and I'll create a new list that only includes the items that result \\âŠ¤\\.",
                        "For example, imagine I was a list of @Number and you only wanted the positive ones:",
                        "\\[2 -4 8 -16].filter(Æ’(numâ€¢#) num â‰¥ 0)\\"
                    ],
                    "names": "filter",
                    "inputs": [
                        {
                            "doc": "A @FunctionDefinition that checks each item, producing \\âŠ¤\\ if it should be kept.",
                            "names": "checker"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "The item being checked.",
                            "names": "item"
                        },
                        {
                            "doc": "The index of the item being checked.",
                            "names": "index"
                        },
                        {
                            "doc": "The list being filtered.",
                            "names": "list"
                        }
                    ]
                },
                "all": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes a value as input and produces a @Boolean if it matches some condition. I'll create \\âŠ¤\\ if all the items match the condition.",
                        "For example, imagine I was a list of @Number and you wanted to know if everything was positive:",
                        "\\[2 -4 8 -16].all(Æ’(numâ€¢#) num â‰¥ 0)\\"
                    ],
                    "names": "all",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that produces \\âŠ¤\\ if an item satisfies your condition.",
                            "names": "checker"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "The item being checked.",
                            "names": "item"
                        },
                        {
                            "doc": "The index of the item being checked.",
                            "names": "index"
                        },
                        {
                            "doc": "The list being checked.",
                            "names": "list"
                        }
                    ]
                },
                "until": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes a value as input and produces a @Boolean if it matches some condition. I'll create a new @List that contains all the items until the condition isn't met.",
                        "For example, imagine I was a list of @Text animals and you wanted everything up until \\'rat'\\ was found:",
                        "\\['cat' 'dog' 'rat' 'mouse' 'pony'].until(Æ’(animalâ€¢'') animal = 'rat')\\"
                    ],
                    "names": "until",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that produces \\âŠ¤\\ if I should stop including items.",
                            "names": "checker"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "The item being checked.",
                            "names": "item"
                        },
                        {
                            "doc": "The index of the item being checked.",
                            "names": "index"
                        },
                        {
                            "doc": "The list being subsequenced.",
                            "names": "list"
                        }
                    ]
                },
                "find": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes a value as input and produces a @Boolean if it matches some criteria, and I'll evaluate to the matching item.",
                        "For example, imagine you wanted to find the first animal that had the vowel \\'e'\\:",
                        "\\['cat' 'dog' 'rat' 'mouse' 'pony'].find(Æ’(animalâ€¢'') animal.has('e'))\\"
                    ],
                    "names": "find",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that produces \\âŠ¤\\ if it matches your search criteria.",
                            "names": "checker"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "The item being checked.",
                            "names": "item"
                        },
                        {
                            "doc": "The index of the item being checked.",
                            "names": "index"
                        },
                        {
                            "doc": "The list being searched.",
                            "names": "list"
                        }
                    ]
                },
                "combine": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes the most recent combination and a next value, and creates a next combination, and I'll move from the first to last of my items, creating successive combinations, and evaluating to the final combination your @FunctionDefinition evaluates to.",
                        "This is really helpful for combining all of the items in me into a single value. For example, imagine you wanted to add a list of numbers:",
                        "\\[3 9 2 8 1 4].combine(0 Æ’(sumâ€¢# numberâ€¢#) sum + number)\\"
                    ],
                    "names": "combine",
                    "inputs": [
                        {
                            "doc": "The starting combination.",
                            "names": "initial"
                        },
                        {
                            "doc": "The @FunctionDefinition that takes the latest combination and the next value and produces the next combination.",
                            "names": "combiner"
                        }
                    ],
                    "combiner": [
                        {
                            "doc": "The current combination",
                            "names": "combination"
                        },
                        {
                            "doc": "The next item to combine.",
                            "names": "next"
                        },
                        {
                            "doc": "The index of the next item",
                            "names": "index"
                        },
                        {
                            "doc": "The list being combined.",
                            "names": "list"
                        }
                    ]
                },
                "sorted": {
                    "doc": [
                        "I can take a list, and make a new list with it's values sorted. Like this:",
                        "\\[1 5 8 0 2].sorted()\\",
                        "I can also do it for @Text values",
                        "\\['orange' 'kiwi' 'banana' 'apple'].sorted()\\",
                        "And if you have a list of values that aren't @Number or @Text, you can give me a @FunctionDefinition that turns each item into a @Number so I can sort it. For example, here we have a list of lists of different lengths; if you give me a function that turns each list into it's length, I can sort by their length.",
                        "\\[[1] [2 3] [4 8 12] [8]].sorted(Æ’(list) list.length())\\"
                    ],
                    "names": "sorted",
                    "inputs": [
                        {
                            "doc": "The optional @FunctionDefinition to use to sort a list value. It should turn the value into a @Number that can be used for sorting the list.",
                            "names": "sequencer"
                        }
                    ],
                    "sequencer": [
                        {
                            "doc": "The value to turn into a @Number.",
                            "names": "value"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "To a @Text representation of the list.",
                "set": "To a @Set, helpful for removing duplicates."
            }
        },
        "Set": {
            "doc": [
                "I'm a set of values! That means I can contain any number of values, including no values. You can make me like this:",
                "\\{1 2 3}\\",
                "I'm really good if you want to keep a collection of things without any duplicates.",
                "That means that if you give me values I already have, I'll ignore the extras.",
                "For example, this set has many duplicates:",
                "\\{1 1 2 2 3 3}\\",
                "I evaluate it to just \\{1 2 3}\\.",
                "If you want to see if I have a value in me, @SetOrMapAccess can help:",
                "\\{'jar' 'bottle' 'glass'}{'cup'}\\",
                "Usually, if you give me a bunch of values that are of a common type, I'll assume they're a list of that type. Like this set is \\{''}\\, because it's all @Text.",
                "\\{'hey' 'hi' 'hello'}\\",
                "But you might want to indicate that I'm a set of /only/ those values, so I can tell you when you're trying to use one that's not allowed. If so, just add a ! at the end of me.",
                "\\{'hey' 'hi' 'hello'}!{'yo'}\\",
                "Is there something else you want to do with me? Check out all the neat @FunctionDefinition I have!"
            ],
            "name": ["{}", "Set"],
            "kind": "Kind",
            "out": "Result",
            "function": {
                "size": {
                    "doc": "I'll tell you how many values are in me.",
                    "names": "size",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "I'm \\âŠ¤\\ if the given @Set and I have the exact same values:",
                        "\\{1 2 3} = {2 3 4}\\"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        { "doc": "The @Set to compare.", "names": "set" }
                    ]
                },
                "notequals": {
                    "doc": [
                        "I'm \\âŠ¤\\ if the given @Set and I don't have the exact same values:",
                        "\\{1 2 3} â‰  {2 3 4}\\"
                    ],
                    "names": ["â‰ ", "notequal"],
                    "inputs": [
                        { "doc": "The @Set to compare.", "names": "set" }
                    ]
                },
                "add": {
                    "doc": [
                        "Give me an item to add and I'll make a new @Set with my items and the given item.",
                        "\\{1 2 3} + 4\\"
                    ],
                    "names": ["with", "add", "+"],
                    "inputs": [{ "doc": "The item to add", "names": "item" }]
                },
                "remove": {
                    "doc": [
                        "Give me an item to remove and I'll make a new @Set without the item.",
                        "\\{1 2 3} - 2\\",
                        "If I don't have the item, I'll just evaluate to myself."
                    ],
                    "names": ["remove", "-"],
                    "inputs": [
                        { "doc": "The item to remove.", "names": "item" }
                    ]
                },
                "union": {
                    "doc": [
                        "Give me @Set and I'll create a new @Set that has my items and the set's items.",
                        "\\{1 2 3} âˆª {3 4 5}\\"
                    ],
                    "names": ["union", "âˆª"],
                    "inputs": [
                        {
                            "doc": "The @Set to combine with me.",
                            "names": "set"
                        }
                    ]
                },
                "intersection": {
                    "doc": [
                        "Give me @Set and I'll create a new @Set that has only the items we have in common.",
                        "\\{1 2 3} âˆ© {3 4 5}\\"
                    ],
                    "names": ["intersection", "âˆ©"],
                    "inputs": [
                        { "doc": "The set to compare with me.", "names": "set" }
                    ]
                },
                "difference": {
                    "doc": [
                        "Give me @Set and I'll create a new @Set that has the items has only the items we have in common.",
                        "\\{1 2 3}.difference({3 4 5})\\"
                    ],
                    "names": "difference",
                    "inputs": [
                        {
                            "doc": "The set whose items should be removed from me.",
                            "names": "set"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "Give me @FunctionDefinition that takes an item and produces \\âŠ¤\\ if it should be kept, and I'll make a @Set that only contains the items that meet your criteria.",
                        "For example, let's find the odd numbers in me:",
                        "\\{1 2 3 4 5 6 7 8 9}.filter(Æ’(numâ€¢#) (num % 2) = 1)\\"
                    ],
                    "names": "filter",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that checks an item to see if it should be kept.",
                            "names": "checker"
                        }
                    ],
                    "checker": [
                        {
                            "doc": "The item being checked.",
                            "names": "value"
                        },
                        {
                            "doc": "The set being filtered",
                            "names": "set"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "Give me @FunctionDefinition that takes an item and produces a new item based on it, then I'll translate all the items in me into a new @Set (removing any duplicates).",
                        "For example, let's make all my @Number into @Text:",
                        "\\{1 2 3 4 5 6 7 8 9}.translate(Æ’(numâ€¢#) numâ†’'')\\"
                    ],
                    "names": "translate",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that translates one of my items into the new item you want.",
                            "names": "set"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "The item being translated.",
                            "names": "value"
                        },
                        {
                            "doc": "The set being translated",
                            "names": "set"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "A @Text representation of a @Set",
                "list": "A @List representation of the items in the set."
            }
        },
        "Map": {
            "doc": [
                "I bring values together, mapping *keys* to *values*. For example:",
                "\\{'amy': 6points 'tony':3points 'shiela': 8points}\\",
                "My keys can be any kind of value, and my values can be any kind of value.",
                "Some people like to think of my like an index, or a dictionary, where you give me something, and I give you what it's mapped to.",
                "If you wanted to check what something is mapped to, you can give @SetOrMapAccess, a key and they'll give you the value:",
                "\\{'amy': 6points 'tony':3points 'shiela': 8points}{'amy'}\\",
                "If there is no matching key, I'll give you @None.",
                "\\{'amy': 6points 'tony':3points 'shiela': 8points}{'jen'}\\",
                "You can also make an empty map like this:",
                "\\{:}\\",
                "Usually, I'll see whatever kinds of keys and values you give me and just come up with a type to represent all of them. Like this is a map from numbers to numbers:",
                "\\{1:1 2:2 3:3}\\",
                "But say you wanted to ensure it was specifically only those values; just add ! at the end of me, and I won't generalize. That'll help you know if you're trying to get a value you didn't intend.",
                "\\{1:1 2:2 3:3}!{4}\\",
                "I know how to many wonderful things with my pairings."
            ],
            "name": ["{:}", "Map"],
            "key": "Key",
            "value": "Value",
            "result": "Result",
            "function": {
                "size": {
                    "doc": "I'll tell you how many values are in me.",
                    "names": "size",
                    "inputs": []
                },
                "equals": {
                    "doc": [
                        "\\{âŠ¤}\\ if my pairings are the exact same as the given @Map's.",
                        "\\{1:1 2:2} = {1:1 2:3}\\"
                    ],
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "The @Map to compare me to.",
                            "names": "value"
                        }
                    ]
                },
                "notequals": {
                    "doc": [
                        "\\{âŠ¤}\\ if my pairings are /not/ the exact same as the given @Map's.",
                        "\\{1:1 2:2} â‰  {1:1 2:3}\\"
                    ],
                    "names": ["â‰ ", "notequal"],
                    "inputs": [
                        {
                            "doc": "The @Map to compare me to.",
                            "names": "value"
                        }
                    ]
                },
                "set": {
                    "doc": [
                        "I'll make a new @Map with all the same pairings, but with the new pairing you give me. If I already have the key, I'll pair it to the new value.",
                        "\\{'amy': 6points 'tony':3points}.pair('jen' 0points)\\"
                    ],
                    "names": "pair",
                    "inputs": [
                        { "doc": "Key to pair with a value.", "names": "key" },
                        {
                            "doc": "The value to pair with the key",
                            "names": "value"
                        }
                    ]
                },
                "unset": {
                    "doc": [
                        "I'll make a new @Map without the key you give me, removing its pairing.",
                        "\\{'amy': 6points 'tony':3points}.unpair('amy')\\"
                    ],
                    "names": "unpair",
                    "inputs": [{ "doc": "The key to forget.", "names": "key" }]
                },
                "remove": {
                    "doc": [
                        "I'll create a new @Map without any keys that have the value.",
                        "\\{'amy': 0points 'jen': 0points 'tony':3points}.remove(0points)\\"
                    ],
                    "names": "remove",
                    "inputs": [
                        {
                            "doc": "The value to remove from me, along with any keys its paired to.",
                            "names": "value"
                        }
                    ]
                },
                "filter": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes a key and value and evaluates to \\âŠ¤\\ if a pairing should be kept. I'll create a new @Map that meets your criteria.",
                        "For example, here we want to keep any pairings that are Amy or have more than zero points.",
                        "\\{'amy': 0points 'jen': 0points 'tony':3points}.filter(Æ’(keyâ€¢'' valueâ€¢#points) (key = 'amy') | (value > 0points))\\"
                    ],
                    "names": "filter",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that decides whether to keep a pairing.",
                            "names": "checker"
                        }
                    ],
                    "checker": [
                        { "doc": "The key being checked.", "names": "key" },
                        {
                            "doc": "The value being checked.",
                            "names": "value"
                        },
                        {
                            "doc": "The map being filtered.",
                            "names": "map"
                        }
                    ]
                },
                "translate": {
                    "doc": [
                        "Give me a @FunctionDefinition that takes a key and value and evaluates the value to a new value. I'll create a new @Map with the same keys but updated values.",
                        "For example, let's give everyone one point since they've been so nice.",
                        "\\{'amy': 5points 'jen': 3points 'tony': 0points}.translate(Æ’(keyâ€¢'' valueâ€¢#points) value + 1points)\\"
                    ],
                    "names": "translate",
                    "inputs": [
                        {
                            "doc": "The @FunctionDefinition that translates each value.",
                            "names": "translator"
                        }
                    ],
                    "translator": [
                        {
                            "doc": "The key of the value being translated.",
                            "names": "key"
                        },
                        {
                            "doc": "The value being translated.",
                            "names": "value"
                        },
                        {
                            "doc": "The map being translated.",
                            "names": "map"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "A @Text representation of the mapping.",
                "set": "The keys of the @Map",
                "list": "A list of the values in the @Map"
            }
        },
        "Table": {
            "doc": [
                "I'm a set of table rows! I can help you help track of large collections of values that have the same structure.",
                "For example, imagine you wanted to keep track of a bunch of rocks:",
                "\\âŽ¡nameâ€¢'' colorâ€¢''âŽ¦\nâŽ¡'obsidian' 'black'âŽ¦\nâŽ¡'pumice' 'grey'âŽ¦\nâŽ¡'citrine' 'yellow'âŽ¦\\",
                "@Bind can help you name it! And then you can do things like make a revised table with an new row @Insert:",
                "\\rocks: âŽ¡nameâ€¢'' colorâ€¢''âŽ¦\nâŽ¡'obsidian' 'black'âŽ¦\nâŽ¡'pumice' 'grey'âŽ¦\nâŽ¡'citrine' 'yellow'âŽ¦\nrocks âŽ¡+ 'quartz' 'white'âŽ¦\\",
                "Or if you want to find rows that match, you can @Select rows that match a condition:",
                "\\rocks: âŽ¡nameâ€¢'' colorâ€¢''âŽ¦\nâŽ¡'obsidian' 'black'âŽ¦\nâŽ¡'pumice' 'grey'âŽ¦\nâŽ¡'citrine' 'yellow'âŽ¦\nrocks âŽ¡?âŽ¦ color = 'grey'\\",
                "Or maybe you want to make a revised table that has different values for rows that match a condition:",
                "\\rocks: âŽ¡nameâ€¢'' colorâ€¢''âŽ¦\nâŽ¡'obsidian' 'black'âŽ¦\nâŽ¡'pumice' 'grey'âŽ¦\nâŽ¡'citrine' 'yellow'âŽ¦\nrocks âŽ¡: color: 'black' âŽ¦ name = 'pumice'\\",
                "Or maybe you want to delete a rows match a condition:",
                "\\rocks: âŽ¡nameâ€¢'' colorâ€¢''âŽ¦\nâŽ¡'obsidian' 'black'âŽ¦\nâŽ¡'pumice' 'grey'âŽ¦\nâŽ¡'citrine' 'yellow'âŽ¦\nrocks âŽ¡- name.has('i')\\",
                "And if you ever want to get specific values from me, you can convert any table to a list and access individual rows with @PropertyReference",
                "\\rocks: âŽ¡nameâ€¢'' colorâ€¢''âŽ¦\nâŽ¡'obsidian' 'black'âŽ¦\nâŽ¡'pumice' 'grey'âŽ¦\nâŽ¡'citrine' 'yellow'âŽ¦\n(rocks â†’ [])[1].name\\"
            ],
            "name": ["âŽ¡âŽ¦", "Table"],
            "row": "Row",
            "function": {
                "equals": {
                    "doc": "I check if I have the exact same cells in the exact same order as another @Table.",
                    "names": ["=", "equals"],
                    "inputs": [
                        { "doc": "The other table to check.", "names": "value" }
                    ]
                },
                "notequal": {
                    "doc": "I check if any of my cells are different or in a different order from another @Table.",
                    "names": ["â‰ ", "notEquals"],
                    "inputs": [
                        { "doc": "The other table to check.", "names": "value" }
                    ]
                }
            },
            "conversion": {
                "list": "I convert a @Table into a list of rows, where each row is a @Structure with its column names as properties.",
                "text": "I just convert a @Table to text."
            }
        },
        "Structure": {
            "doc": "See @StructureDefinition.",
            "name": ["Structure"],
            "function": {
                "equals": {
                    "doc": "I check if my properties are the same name and values as another structure's properties.",
                    "names": ["=", "equals"],
                    "inputs": [
                        {
                            "doc": "The other structure to check.",
                            "names": "value"
                        }
                    ]
                },
                "notequal": {
                    "doc": "I check if my properties are different in any way from the name and values as another structure's.",
                    "names": ["â‰ ", "notEquals"],
                    "inputs": [
                        {
                            "doc": "The other structure to check.",
                            "names": "value"
                        }
                    ]
                }
            },
            "conversion": {
                "text": "I convert myself to @Text."
            }
        }
    },
    "input": {
        "Random": {
            "doc": [
                "17!",
                "/@FunctionDefinition here, I'll explain this one./",
                "So @Random is a curious function that creates random numbers. It's curious because every time you evaluate it, it creates something different.",
                "This creates a wonderful chaos that comes with unpredictability.",
                "By default, it gives @Number values between \\0\\ and \\1\\:",
                "\\Random()\\",
                "But you can give it a value, and it will generate values between \\0\\ and the value:",
                "\\Random(10)\\",
                "And if you give it two values, it will generate values between and including the two values:",
                "\\Random(-10 10)\\",
                "If your ranges have units, they will be preserved (and if they don't match, the minimum's unit will be used):",
                "\\Random(-10m 10m)\\",
                "And if you give numbers with particular numbers of significant digits after the decimal point, that precision will be preserved.",
                "\\Random(1.00 10.00)\\"
            ],
            "names": ["ðŸŽ²", "Random"],
            "inputs": [
                {
                    "names": "min",
                    "doc": "The minimum value that will be created, or if it's larger than 0, the maximum value. If @None is provided, then the miniumum is \\0\\."
                },
                {
                    "names": "max",
                    "doc": "The maximum value that will created, or if its smaller than the minimum provided, the minimum. If @None is provided, than the maximum is \\1\\."
                }
            ]
        },
        "Choice": {
            "doc": [
                "/clickety tap!/",
                "/@FunctionDefinition here, I'll explain this one./",
                "Think of @Choice like a stream of @Phrase/name that are selected by your audience. If someone clicks, taps, or keyboard selects by pressing /Enter/ on a @Phrase with a name -- @Choice will have a new value matching the name.",
                "So the best way to use it is to create a performance with named selectable phrases @Phrase, and then use a @Reaction to decide what to do when that name is chosen.",
                "Here's the simplest example:",
                "\\Group(\nStack() \n[\nPhrase('one' selectable:âŠ¤ name:'1') \nPhrase('two' selectable:âŠ¤ name:'2') \nPhrase(Choice())\n]\n)\\",
                "Copy this into the editor and then select one of the two @Phrase. You'll see the third @Phrase shows the name that was selected."
            ],
            "names": ["ðŸ”˜", "Choice"]
        },
        "Button": {
            "doc": [
                "/click click click/",
                "/@FunctionDefinition here, I'll explain this one./",
                "@Button is a great way to listen to a mouse or trackpad. Of course, a mouse or trackpad isn't an ideal choice for listening to an audience, since not everyone can use one. The more accessible choice is @Choice.",
                "But if you /really/ need to listen to a mouse button, this is the way to do it. It will provide a stream of @Boolean, representing whether the primary button is up \\âŠ¥\\ or down \\âŠ¤\\.",
                "Here's a simple example:",
                "\\Phrase(Button() â†’ '')\\",
                "This just makes a @Phrase that is the value of the stream as text. If you copy it into the editor and click, you'll see it toggle back and forth between \\âŠ¥\\ and \\âŠ¤\\."
            ],
            "names": ["ðŸ–±ï¸", "Button"],
            "down": {
                "names": "down",
                "doc": "If @None, the stream will provide both up and down values. If @Boolean, it will only provide value the given @Boolean value."
            }
        },
        "Pointer": {
            "doc": [
                "/whrrrrrr/",
                "/@FunctionDefinition here, I'll explain this one./",
                "You know about mice, trackpads, and touch screens? Sometimes you want to know where an audience is pointing. That's what @Pointer provides.",
                "Of course, this is not an accessible choice: not everyone can see or easily point, so be really sure you're not excluding someone from participating by using this stream.",
                "If you're sure no one is excluded, then using @Pointer is as simple as just making a stream:",
                "\\Pointer()\\",
                "The @Place it provides will correspond to where on @Stage the pointer is pointing."
            ],
            "names": ["ðŸ‘†ðŸ»", "Pointer"]
        },
        "Key": {
            "doc": [
                "/clickety/",
                "/@FunctionDefinition here, I'll explain this one./",
                "Keyboards have a lot of keys, don't they? @Key will tell you which one someone is pressing and releasing.",
                "Try this",
                "\\Key()\\",
                "See how when you type a key, it shows up on @Stage? Every time a key is pressed down, a new @Text is added to the stream, describing the key that was pressed.",
                "For a key that represents a character, the value will be the character as @Text.",
                "For special keys, like the /Escape/ key, it will be @Text that describes the key, using a <pre-defined name@https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values>, unfortunately available only in English.",
                "If you only want to know about a particular key, you can provide it:",
                "\\Key('a')\\",
                "And if you only want to know when when a @Key is released instead of pressed, you can provide a @Boolean:",
                "\\Key('a' âŠ¥)\\"
            ],
            "names": ["âŒ¨ï¸", "Key"],
            "key": {
                "names": "key",
                "doc": "If @None, than all keys are provided. If a specific @Text, then only that key is provided."
            },
            "down": {
                "names": "down",
                "doc": "IF @None, then key down generates inputs. If \\âŠ¤\\, then only down inputs are provided, and if \\âŠ¥\\, then only release inputs are provided."
            }
        },
        "Time": {
            "doc": [
                "/tick tick tick/",
                "@FunctionDefinition here, I'll explain @Time, since it doesn't speak.",
                "Time is a stream that ticks at a certain frequency.",
                "Each time it does, @Program reevaluates with the new time value.",
                "For example:",
                "\\Time()\\",
                "If you provide time a @Time/frequency, it will tick at that rate. For example:",
                "\\Time(1000ms)\\",
                "However, there are limits to how small it can be, since @Program needs time to evaluate before they can respond to the next tick.",
                "The smallest is probably around \\20ms\\."
            ],
            "names": ["ðŸ••", "Time"],
            "frequency": {
                "names": ["frequency"],
                "doc": "This is the frequency with which time should tick. It defaults to \\33ms\\, which is about 30 times per second."
            },
            "relative": {
                "names": ["relative"],
                "doc": "If \\âŠ¤\\, time starts at 0, when the program is first evaluated. Otherwise, it starts at the number of milliseconds since the start of today, UTC (Coordinated Universal Time), allowing you to keep track of the time of day."
            }
        },
        "Volume": {
            "doc": [
                "/bzzzzzzz/",
                "@FunctionDefinition here, I'll take the mic.",
                "This stream is a series of volumes between 0 and 1, sampled at the frequency of your choice. By default, the frequency is \\30hz\\, or 30 times per second, but you can change it to anything less frequent.",
                "\\Volume()\\",
                "This is great for listening to how loud the audience is!"
            ],
            "names": ["ðŸŽ¤", "Volume"],
            "frequency": {
                "names": ["frequency"],
                "doc": "The time between samplings."
            }
        },
        "Pitch": {
            "doc": [
                "/hummmmm/",
                "@FunctionDefinition here, let's talk pitch!",
                "This stream is a series of frequencies in hertz, indicating the pitch of sound, sampled at the frequency of your choice. We've found that the human voice is between 20Hz and 5000Hz, so plan on numbers in that range.",
                "\\Pitch()\\",
                "This is great for listening the tone that someone is speaking or singing."
            ],
            "names": ["ðŸŽµ", "Pitch"],
            "frequency": {
                "names": ["frequency"],
                "doc": "The time between samplings."
            }
        },
        "Camera": {
            "doc": [
                "/bzzzzzzz/",
                "@FunctionDefinition here, I can explain @Camera!",
                "So @Camera provides a @List of @Color from your world. That list essentially represents an image, but it's up to you to decide what to do with it.",
                "You could try to represent the image with a bunch of @Phrase, which could look pretty cool! Try copying this...",
                "\\colors: Camera(32px 24px 33ms)\n\nStage(\ncolors.combine(\n[] \nÆ’(phrasesâ€¢[Phrase] rowâ€¢[Color] yâ€¢#) \nphrases.append(\nrow.translate(\nÆ’(colorâ€¢Color xâ€¢#)\nPhrase('o' place: Place((x - 1) Â· 0.5m y Â· -0.5m) color: color duration: 0s\n)\n)\n)\n)\n)\\",
                "But you could also analyze the colors to decide if a light was on or off, or if a particular color was common, letting the audience influence a performance with the colors they show."
            ],
            "names": ["ðŸŽ¥", "Camera"],
            "width": {
                "names": ["width"],
                "doc": "The number of @Color to sample in a row."
            },
            "height": {
                "names": ["height"],
                "doc": "The number of @Color to sample in a column."
            },
            "frequency": {
                "names": ["frequency"],
                "doc": "The time between @Color samples."
            }
        },
        "Scene": {
            "doc": [
                "/Boop boop boop/",
                "/Hello, @FunctionDefinition here! I see you found @Scene.",
                "I think @Scene is particularly cool. The basic idea is that you give it a list of @Phrase or @Group and then it will show them in sequence and stop on the last one.",
                "To control timing, you can either set the @Phrase/duration on each output, and it will show it for that long before moving on to the next one, and use whatever @Phrase/entering or @Phrase/exiting transitions you might have set. If you set them to a @Sequence, it will use the its duration.",
                "All of that lets you do things like this little @Scene, which shows these three phrases in sequence:",
                "\\Scene([\n\tPhrase('Hello' duration: 1s)\n\tPhrase('How are you?' duration: 2s rotation: 5Â° entering: Pose(rotation: 0Â°))\n\tPhrase('I am fine')\n])\\",
                "See how the first output is shown for a second, then the next for two seconds, but animated to a five degree rotation, and then it shows the last one?",
                "You can make very elaborate sequences of output and animations with @Scene, and even make portions of them dynamic or interactive, as with any other @Phrase or @Group.",
                "If you have animated output that is nested (a @Group with animated @Phrase inside), @Scene will wait for all of the animated content in the @Group to finish.",
                "Oh, and one last little secret! You can even put @Boolean in the list, and if they are \\âŠ¥\\, the @Scene will pause and wait for it to become true.",
                "For example, if you wanted to make a sequence of @Phrase and only advance when @Button changes, you could do this:",
                "\\click: âˆ† Button()\nScene([\n\tPhrase('Hello')\n\tclick\n\tPhrase('How are you?' duration: 0.25s rotation: 5Â° entering: Pose(rotation: 0Â°))\n\tclick\n\tPhrase('I am fine')\n])\\",
                "See how it pauses after each @Phrase, and waits for @Button to change before advancing?"
            ],
            "names": ["ðŸŽ¬", "Scene"],
            "outputs": {
                "names": "outputs",
                "doc": "The list of outputs to show in sequence."
            }
        },
        "Motion": {
            "doc": [
                "/boing boing boing/",
                "/Hi! @FunctionDefinition here. How about I explain @Motion?",
                "Basically, @Motion is a stream of @Phrase. You give it a starting @Phrase, and then it refines it with a new place and rotation based on gravity.",
                "This let's you do really simple things like creating bouncing emoji:",
                "\\Motion(Phrase('o') startplace: Place(0m 10m))\\",
                "See how the o bounces? On the first evaluation, we give it a place up high on @Stage, but then after, it gets @None, which allows @Motion to change it to whatever position gravity would place it.",
                "Check out the many other ways to configure it below."
            ],
            "names": ["âš½ï¸", "Motion"],
            "place": {
                "doc": "The starting place.",
                "names": "place"
            },
            "velocity": {
                "doc": "The starting velocity",
                "names": "velocity"
            },
            "nextplace": {
                "doc": "The next place, overriding physics.",
                "names": "nextplace"
            },
            "nextvelocity": {
                "doc": "The next place, overriding velocity.",
                "names": "nextvelocity"
            }
        },
        "Chat": {
            "doc": [
                "/Hi! @FunctionDefinition here. So you want to chat?",
                "The basic idea of a chat stream is that the audience types a message, and then the program response to it.",
                "For example, this simple program checks if the message is 'hello', and if it is, the program evaluates to 'hi'. Otherwise, it evaluates to 'huh'?",
                "\\Chat().has('hello') ? 'hi!' 'huh?'\\",
                "That's it! You can make all kinds of performances with this, like chat bots, text adventures, or text-based control schemes for other kinds of performances."
            ],
            "names": ["ðŸ—£ï¸", "Chat"]
        },
        "Placement": {
            "doc": [
                "/Hey, @FunctionDefinition here. Let's talk about how to get us moving!/",
                "So there are many ways to place us on @Stage. You can give us an explicit @Place. You could use @Motion, and let gravity do it's work. You could also put us in a @Group and let them arrange us in a particular way.",
                "But sometimes you want to give the /audience/ control over where we are on @Stage. That's what @Placement is for.",
                "Here's how it works: you just make a @Placement and give it to our @Place:",
                "\\Phrase('hi' place: Placement())\\",
                "Then, any time the audience uses an arrow key or clicks or taps on stage, the @Placement will make a new @Place that moves in the desired direction.",
                "Try copying this to your program and moving us arrowed with the pointer or keyboard.",
                "You can customize the @Placement, enabling and disabling movement on certain dimensions, changing how far a @Place moves, and the initial @Place the stream starts with."
            ],
            "names": ["âœ¥", "Placement"],
            "inputs": [
                {
                    "doc": "The initial place to start with.",
                    "names": "start"
                },
                {
                    "doc": "How many meters the place should move when the audience requests a move.",
                    "names": "distance"
                },
                {
                    "doc": "If true, allows movement on the horizontal axis. On by default.",
                    "names": "horizontal"
                },
                {
                    "doc": "If true, allows movement on the vertical axis. On by default.",
                    "names": "vertical"
                },
                {
                    "doc": "If true, allows movement on the z-axis, with the + and - keys.",
                    "names": "depth"
                }
            ]
        },
        "Webpage": {
            "doc": [
                "/Hey, @FunctionDefinition here. Let's talk about how to get webpages from the internet!/",
                "When we first heard about your internet, we found it fascinating. A whole world full of connected computers sharing documents with each other? That's amazing!",
                "So we made a stream that connects to it. You give us a URL, and we'll get all of the text at it. Like this:",
                "\\Webpage('https://wordplay.dev')\\",
                "And there's apparently this thing called <CSS@https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/What_is_CSS>, which likes you query things on a web page? Give us a CSS selection query and we'll get only the text that matches that query. Like this example, which gets the level one headers.",
                "\\Webpage('https://wordplay.dev' 'h1')\\",
                "Lots of things can go wrong with this one. If you lose your internet connection, or the URL doesn't resolve to anything, or the URL isn't public, or the URL isn't an HTML pageâ€¦ All of these can lead to exception. If if you find a page that works, you'll get some @Number indicating a percent commplete and then a @List of the words on the page."
            ],
            "names": ["ðŸ”—", "Webpage"],
            "url": { "doc": "The HTML webpage URL to get.", "names": "url" },
            "query": {
                "doc": "The CSS query to evaluate on the HTML",
                "names": "query"
            },
            "frequency": {
                "doc": "The number of minutes that should pass before the page is fetched again.",
                "names": "frequency"
            },
            "error": {
                "invalid": "this is not a valid URL",
                "unvailable": "this URL isn't accessible",
                "notHTML": "the response wasn't HTML",
                "noConnection": "no connection to Wordplay",
                "limit": "too many requests to this domain"
            }
        },
        "Collision": {
            "names": "Collision",
            "doc": [
                "/Hi! @FunctionDefinition here. Check out this cool input./",
                "It can help you find out when @Output bump into each other! This is great way to do something when we bump into each other, other than the normal bouncing off each other @Output might do.",
                "Just give me a name of @Output, and I'll make a new @Rebound value whenever it bumps into another name. A @Rebound has info about the names that collided and the direction of their collision.",
                "And if you give me two names, I'll only make a new value when the two names bump into each other.",
                "Right after I make a new value, I'll make a \\Ã¸\\ since the collision is done after it happens. This indicates that there's no more collision.",
                ""
            ],
            "subject": {
                "names": "subject",
                "doc": "The name of the @Output I should look for collisions on."
            },
            "object": {
                "names": "other",
                "doc": "The name of the other @Output I should look for collisions on."
            }
        },
        "Rebound": {
            "names": "Rebound",
            "doc": "I come from @Collision and represent the who was collided with and which direction the collision occurred on. Use me to decide whether to react to a collision in some special way, other than normal physics.",
            "direction": {
                "names": "direction",
                "doc": "The direction and magnitude of the collision, relative to the subject of the collision"
            },
            "subject": {
                "names": "subject",
                "doc": "The name of the output that was hit by the subject."
            },
            "object": {
                "names": "object",
                "doc": "The name of the output that hit the subject"
            }
        },
        "Direction": {
            "names": "Direction",
            "doc": "I'm a direction and magnitude, along x and y axes.",
            "x": {
                "names": "x",
                "doc": "The direction and magnitude of the direction along the x-axis."
            },
            "y": {
                "names": "y",
                "doc": "The direction and magnitude of the direction along the y-axis."
            }
        }
    },
    "output": {
        "Output": {
            "names": "Output",
            "doc": [
                "I am not a @StructureDefinition you can actually make. But I am a very important one, as I inspire the most important elements of our dance: @Phrase, @Group, and @Stage.",
                "Go meet them to learn more about how to use them."
            ]
        },
        "Group": {
            "doc": [
                "Oh hello, how are you? I'm always fine when others are around, so it's great to be with you!",
                "I group together @Phrase and @Group on @Stage and put them in an @Arrangement, so there's some order to where they're placed.",
                "To work, I need you to give me an @Arrangement, and then a @List of @Output to arrange.",
                "For example, here I am with a @Stack arrangement and a few @Phrase to stack vertically:",
                "\\Group(Stack() [Phrase('first') Phrase('second')])\\",
                "How exactly I arrange things depend on the @Arrangement you give me."
            ],
            "names": ["ðŸ”³", "Group"],
            "layout": {
                "doc": "The arrangement to use to put @Output in their places.",
                "names": "layout"
            },
            "content": {
                "doc": "The list of @Output to arrange.",
                "names": "content"
            },
            "matter": {
                "doc": "How I should react if I were to bump into something else with matter.",
                "names": "matter"
            },
            "size": {
                "doc": "How tall the wonderful content inside me should be, unless they have a size of their own!",
                "names": "size"
            },
            "face": {
                "doc": "The name of the font face content inside me should have, unless they have their own face to use.",
                "names": "face"
            },
            "place": {
                "doc": "The place on stage where I should be. The content inside me will be arranged relative to there.",
                "names": "place"
            },
            "name": {
                "doc": ["The same as @Phrase/name!"],
                "names": "name"
            },
            "selectable": {
                "doc": "The same as @Phrase/selectable!",
                "names": "selectable"
            },
            "color": {
                "doc": "The @Color that content inside me should be, unless they have their own color.",
                "names": "color"
            },
            "background": {
                "doc": "The @Color to project behind me.",
                "names": "background"
            },
            "opacity": {
                "doc": "How transparent everything inside me should be, between \\0\\ and \\1\\, unless overriden by a different @Pose.",
                "names": "opacity"
            },
            "offset": {
                "doc": "A @Place indicating how offset from my normal @Place it should be, unless overriden by a different @Pose. Helpful for wiggling in place.",
                "names": "offset"
            },
            "rotation": {
                "doc": "How tilted should I be around my center, my @Pose has a different one.",
                "names": ["ðŸ“", "rotation"]
            },
            "scale": {
                "doc": "How big I should be relative to my original size.",
                "names": "scale"
            },
            "flipx": {
                "doc": "Same as @Phrase/flipx!",
                "names": "flipx"
            },
            "flipy": {
                "doc": "Same as @Phrase/flipy",
                "names": "flipy"
            },
            "entering": {
                "doc": "Same as @Phrase/entering!",
                "names": "entering"
            },
            "resting": {
                "doc": "Same as @Phrase/resting!",
                "names": "resting"
            },
            "moving": {
                "doc": "Same as @Phrase/moving!",
                "names": "moving"
            },
            "exiting": {
                "doc": "Same as @Phrase/exiting!",
                "names": "exiting"
            },
            "duration": {
                "doc": "Same as @Phrase/duration!",
                "names": ["â³", "duration"]
            },
            "style": {
                "doc": "Same as @Phrase/style!",
                "names": "style"
            },
            "description": "$1[$1|] $2 $3"
        },
        "Phrase": {
            "doc": [
                "Hello, hello! Remember me? How could anyone forget /me/. That's right, I am the manificent @Phrase, ready to represent the loveliest of @Text on @Stage.",
                "Just make me like this, and I'll appear on @Stage:",
                "\\Phrase('magnificient!')\\",
                "I need some @Text, obviously, but otherwise, I can do everything a @Output can do, including changing my size, font, rotation, and do all of my incredible dances with @Pose and @Sequence.",
                "You can also select me on @Stage and edit me on the palette next door."
            ],
            "names": ["ðŸ’¬", "Phrase"],
            "text": {
                "doc": "The characters to show on @Stage.",
                "names": "text"
            },
            "size": {
                "doc": "How tall I should be, in meters!",
                "names": "size"
            },
            "face": {
                "doc": "The name of the font face I should put on.",
                "names": "face"
            },
            "place": {
                "doc": "The place on stage where I should be.",
                "names": "place"
            },
            "wrap": {
                "doc": "The edge at which I should wrap symbols or \\Ã¸\\ if I shouldn't wrap them.",
                "names": ["â†µ", "wrap"]
            },
            "alignment": {
                "doc": "If there's a @Phrase/wrap boundary set, whether I should align symbols to the start, center, or end of edge.",
                "names": "alignment"
            },
            "direction": {
                "doc": "Whether symbols are written horizontally or vertically, and if vertical and @Phrase/wrap is set, whether text wraps left or right.",
                "names": "direction"
            },
            "matter": {
                "doc": "The properties to use if I bump into things!",
                "names": "matter"
            },
            "aura": {
                "doc": "The optional @Aura to show behind me. Make me glow!",
                "names": "aura"
            },
            "name": {
                "doc": [
                    "A name you give me! This is helpful for many things.",
                    "First, if I have a name, I'll use it to describe myself in screen reader descriptions.",
                    "Second, when animating, you might have multiple different expressions that are supposed to represent the same content on stage; give them the same name and they will animate as one.",
                    "Finally, I'm helpful with @Choice: the names you give me appear in that stream.",
                    "You can give me many different names, each in a different language, if it's helpful. I'll always use the name in the first selected locale."
                ],
                "names": "name"
            },
            "selectable": {
                "doc": "If \\âŠ¤\\, indicates that I can be selected via a pointer or keyboard.",
                "names": "selectable"
            },
            "color": {
                "doc": "The @Color I should be by default, unless overriden by a different @Pose.",
                "names": "color"
            },
            "background": {
                "doc": "The @Color to project behind me.",
                "names": "background"
            },
            "opacity": {
                "doc": "How transparent I should be by default, between \\0\\ and \\1\\, unless overriden by a different @Pose. Helpful for fading in and out.",
                "names": "opacity"
            },
            "offset": {
                "doc": "A @Place indicating how offset from my @Place it should be, unless overriden by a different @Pose. Helpful for wiggling in place.",
                "names": "offset"
            },
            "rotation": {
                "doc": "The amount in degrees I should should be rotated around its center, unless overriden by a different @Pose.",
                "names": "rotation"
            },
            "scale": {
                "doc": "How magnified I should be relative to its original size, unless overriden by a different @Pose.",
                "names": "scale"
            },
            "flipx": {
                "doc": "Whether I should be mirrored on the x-axis, unless overriden by a different @Pose.",
                "names": "flipx"
            },
            "flipy": {
                "doc": "Whether I should be mirrored on the y-axis, unless overriden by a different @Pose.",
                "names": "flipy"
            },
            "entering": {
                "doc": "The @Pose or @Sequence I should do upon entering the stage.",
                "names": "entering"
            },
            "resting": {
                "doc": "The @Pose or @Sequence I should do after I've entered stage, before I exit, and while my @Place isn't changing. If you don't give me one, I'll just use my defaults.",
                "names": "resting"
            },
            "moving": {
                "doc": "The @Pose or @Sequence I should do when moving places on stage, instead of my defaults.",
                "names": "moving"
            },
            "exiting": {
                "doc": "The @Pose or @Sequence to should do before exiting stage.",
                "names": "exiting"
            },
            "duration": {
                "doc": "The duration to apply when moving to a different place on stage.",
                "names": ["â³", "duration"]
            },
            "style": {
                "doc": "The animation style to use when moving to a different place on stage.",
                "names": "style"
            },
            "description": "$3[$3 meter |]phrase $1 $2[named $2|] $4[$4|] $5"
        },
        "Arrangement": {
            "doc": "I am an inspiration to the many other kinds of arrangment in the Verse, including @Row, @Stack, @Grid, and @Free. I work closely with @Group to ",
            "names": ["â ¿", "Arrangement"]
        },
        "Row": {
            "doc": "I am @Row, a horizontal @Arrangement of @Output, with optional padding in between. Have you met my twin, @Stack?",
            "names": ["âž¡", "Row"],
            "description": "row of $1 phrases and groups",
            "alignment": {
                "doc": "Whether to align text at the start, center, or end on each column.",
                "names": "alignment"
            },
            "padding": {
                "doc": "The amount of padding to place between output.",
                "names": "padding"
            }
        },
        "Stack": {
            "doc": "I am @Stack, a vertical @Arrangement of @Output, with optional padding in between. Have you met my twin, @Row? ",
            "names": ["â¬‡", "Stack"],
            "description": "stack of $1 phrases and groups",
            "alignment": {
                "doc": "Whether to align text at the start, center, or end on each row.",
                "names": "alignment"
            },
            "padding": {
                "doc": "The amount of padding to place between output.",
                "names": "padding"
            }
        },
        "Grid": {
            "doc": "I am grid of @Output. Give me a row and column count and I'll make a tidy arrangement with optional padding and cell sizes.",
            "names": ["â–¦", "Grid"],
            "description": "$1 row $2 column grid",
            "rows": {
                "doc": "How many rows in make in the grid.",
                "names": "rows"
            },
            "columns": {
                "doc": "How many columns to make in the grid.",
                "names": "columns"
            },
            "padding": {
                "doc": "How much padding to place between cells.",
                "names": "padding"
            },
            "cellWidth": {
                "doc": "How wide the cells should be.",
                "names": "cellwidth"
            },
            "cellHeight": {
                "doc": "How tall the cells should be.",
                "names": "cellpadding"
            }
        },
        "Free": {
            "doc": [
                "I'm like, whatever. Sit wherever you want. Just sit somewhere! Make sure all the @Output you give me have a @Place, otherwise they won't know where to go.",
                "Oh, and remember that the @Place you give each @Output is relative to the @Group's @Place! So if you're wondering why things aren't appearing where you expect, try giving the @Group a place too."
            ],
            "names": ["Free"],
            "description": "free-form $1 outputs"
        },
        "Shape": {
            "doc": "I'm an inspiration to all shapes. I'm useful for telling @Stage what shape to be.",
            "names": ["â¬Ÿ", "Shape"],
            "form": {
                "doc": "I'm the kind of shape to show. Each shape requires different information to define its arrangement.",
                "names": "form"
            },
            "name": {
                "doc": "I'm the name you can use, for animations and @Collision. For example, if a represent the ground, you might want to call me 'ground'.",
                "names": "name"
            },
            "selectable": {
                "doc": "Whether I can be selected as part of @Choice.",
                "names": "selectable"
            },
            "color": {
                "doc": "The color of my borders.",
                "names": "color"
            },
            "background": {
                "doc": "The color of my background.",
                "names": "background"
            },
            "opacity": {
                "doc": "How transparent I should be.",
                "names": "opacity"
            },
            "offset": {
                "doc": "How far from my place I should appear, while remaining in place.",
                "names": "offset"
            },
            "rotation": {
                "doc": "How rotated I should be. This affects @Collision.",
                "names": "rotation"
            },
            "scale": {
                "doc": "How magnified I should be, without changing my actual size.",
                "names": "scale"
            },
            "flipx": {
                "doc": "Whether to mirror me on my x-axis.",
                "names": "flipx"
            },
            "flipy": {
                "doc": "Whether to mirror me on my y-axis.",
                "names": "flipy"
            },
            "entering": {
                "doc": "The @Pose or @Sequence I should do when entering @Stage.",
                "names": "entering"
            },
            "resting": {
                "doc": "The @Pose or @Sequence I should do after entering and while I'm not moving.",
                "names": "resting"
            },
            "moving": {
                "doc": "The @Pose or @Sequence I should do when moving places.",
                "names": "moving"
            },
            "exiting": {
                "doc": "The @Pose or @Sequence I should do when leaving @Stage.",
                "names": "exiting"
            },
            "duration": {
                "doc": "How long my animations should take if they are a single @Pose.",
                "names": "duration"
            },
            "style": {
                "doc": "The animation style I should use.",
                "names": "style"
            }
        },
        "Form": {
            "doc": "I am an abstract form, like a @Rectangle or @Circle.",
            "names": ["Form"]
        },
        "Rectangle": {
            "doc": "I am a rectangle, useful for making @Stage have a boundary the size of your choosing.",
            "names": ["Rectangle"],
            "left": {
                "doc": "The left edge of the stage on the x-axis",
                "names": "left"
            },
            "top": {
                "doc": "The top edge of the stage on the y-axes",
                "names": "top"
            },
            "right": {
                "doc": "The right edge of the stage on the x-axis",
                "names": "right"
            },
            "bottom": {
                "doc": "The bottom edge of the stage on the y-axis",
                "names": "bottom"
            },
            "z": {
                "doc": "The depth position of the rectangle.",
                "names": "z"
            }
        },
        "Circle": {
            "doc": "I am a circle, useful for making shapes on @Stage.",
            "names": ["Circle"],
            "radius": {
                "doc": "The radius of the circle",
                "names": "radius"
            },
            "x": {
                "doc": "The horizontal center of the circle.",
                "names": "x"
            },
            "y": {
                "doc": "The vertical center of the circle.",
                "names": "y"
            },
            "z": {
                "doc": "The depth position of the circle.",
                "names": "z"
            }
        },
        "Polygon": {
            "doc": "I am a 'regular' polygon with equal length sides and angles, useful for making shapes on @Stage.",
            "names": ["Polygon"],
            "radius": {
                "doc": "The radius of the polygon",
                "names": "radius"
            },
            "sides": {
                "doc": "The number of sides of the polygon",
                "names": "sides"
            },
            "x": {
                "doc": "The horizontal center of the polygon.",
                "names": "x"
            },
            "y": {
                "doc": "The vertical center of the polygon.",
                "names": "y"
            },
            "z": {
                "doc": "The depth position of the polygon.",
                "names": "z"
            }
        },
        "Pose": {
            "doc": [
                "You know when someone strikes the most amazing way of standing, a pauses, and everyone looks? That's me. I capture a pose for @Output to be in, and am the building block of their movements.",
                "So much goes into a pose. Check out my many inputs to see what kinds of poses you might make!"
            ],
            "names": ["ðŸ¤ª", "Pose"],
            "duration": {
                "doc": "How long this pose should take to enter from a previous pose.",
                "names": "duration"
            },
            "style": {
                "doc": "The style of animation to use when moving to this pose.",
                "names": "style"
            },
            "color": {
                "doc": "The @Color a @Output should be in this pose, instead of it's default.",
                "names": "color"
            },
            "opacity": {
                "doc": "How transparent a @Output should be, between \\0\\ and \\1\\, instead of it's default. Helpful for fading in and out.",
                "names": "opacity"
            },
            "offset": {
                "doc": "A @Place indicating how offset from a @Output's place it should be, instead of it's default. Helpful for wiggling in place.",
                "names": "offset"
            },
            "rotation": {
                "doc": "How rotated a @Output should be, instead of it's default.",
                "names": "rotation"
            },
            "scale": {
                "doc": "How magnified a @Output should be relative to its original size, instead of it's default.",
                "names": "scale"
            },
            "flipx": {
                "doc": "Whether a @Output should be mirrored on the x-axis, instead of its default.",
                "names": "flipx"
            },
            "flipy": {
                "doc": "Whether a @Output should be mirrored on the y-axis, instead of it's default.",
                "names": "flipy"
            },
            "description": "$1[transparent $1|] $2[rotated $2 degrees|] $3[scaled $3|] $4[flipped horizontally|] $5[flipped vertically|] $6[shadow blurred $6 pixels]"
        },
        "Color": {
            "doc": [
                "I am a visible color, made of three essential dimensions.",
                "Here are some common colors around the color wheel, at medium brightness and high chroma:",
                "\\Color(50% 100 0Â°)\\",
                "\\Color(50% 100 30Â°)\\",
                "\\Color(50% 100 60Â°)\\",
                "\\Color(50% 100 90Â°)\\",
                "\\Color(50% 100 120Â°)\\",
                "\\Color(50% 100 150Â°)\\",
                "\\Color(50% 100 180Â°)\\",
                "\\Color(50% 100 210Â°)\\",
                "\\Color(50% 100 240Â°)\\",
                "\\Color(50% 100 270Â°)\\",
                "\\Color(50% 100 300Â°)\\",
                "\\Color(50% 100 330Â°)\\"
            ],
            "names": ["ðŸŒˆ", "Color"],
            "lightness": {
                "doc": "How light I should be from \\0\\ to \\1\\, from black at \\0\\, to grey at \\0.5\\, to white at \\1\\.",
                "names": ["lightness", "l"]
            },
            "chroma": {
                "doc": "How much color I should have, from \\0\\ to \\âˆž\\. No color means grey, higher numbers mean the more color.",
                "names": ["chroma", "c"]
            },
            "hue": {
                "doc": "What color I should be, on a color wheel, from megenta \\0\\, red \\30\\, green \\120\\, to blue \\270\\.",
                "names": ["hue", "h"]
            }
        },
        "Sequence": {
            "doc": [
                "Oh. My. Gosh. Director, you look amazing today! Do you want to dance with me? It's easy.",
                "You just need to give me a @Map, where each key represents what percent along we are in the dance, and each value of those keys is a @Pose to be.",
                "There are /so/ many different ways you can animate with this! For example, here's a simple one:",
                "\\Phrase('hi' resting:Sequence({0%: Pose(rotation: 360Â°) 100%: Pose(rotation: 0Â°)})\\",
                "This says, /at the beginning (0%), start at tilt 360, and end at tilt 0/. That'll spin us around in circles forever, since I'm set as the @Phrase's rest pose!",
                "Try your own creative dances by playing with other inputs."
            ],
            "names": ["ðŸ’ƒ", "Sequence"],
            "poses": {
                "doc": "A @Map of percentages between 0% and 100%, each paired with a @Pose. You don't have to provide all the percents; I will smoothly move a @Output between the ones you give me.",
                "names": "poses"
            },
            "duration": {
                "doc": "How long should I do this dance? If I'm to repeat it, I won't add any time to the duration, I'll just dance faster.",
                "names": ["â³", "duration"]
            },
            "style": {
                "doc": "The style should I use to for the dance.",
                "names": "style"
            },
            "count": {
                "doc": "How many times the sequence should repeat before it is done. This is really helpful for when I enter stage, move on stage, or exit on stage, but when for a rest sequence, it's ignored, since I can rest forever.",
                "names": "count"
            }
        },
        "Place": {
            "doc": "I'm a location on @Stage. All my inputs are optional, because I'm at the center by default.",
            "names": ["ðŸ“", "Place"],
            "x": { "doc": "A position on the x-axis.", "names": "x" },
            "y": { "doc": "A position on the y-axis", "names": "y" },
            "z": { "doc": "A position on the z-axis", "names": "z" },
            "rotation": {
                "doc": "Rotation at this position",
                "names": ["ðŸ“", "rotation"]
            }
        },
        "Velocity": {
            "doc": "I'm a location on @Stage. All my inputs are optional, because I'm at the center by default.",
            "names": ["ðŸ’¨", "Velocity"],
            "x": {
                "doc": "How many meters to move each second on the x-axis.",
                "names": "x"
            },
            "y": {
                "doc": "How many meters to move each second on the y-axis.",
                "names": "y"
            },
            "angle": {
                "doc": "How many degrees to rotate each second",
                "names": ["angle", "Â°"]
            }
        },
        "Matter": {
            "doc": "I'm physical properties of output, which influence how I interact with other output on stage.",
            "names": ["âš›ï¸", "Matter"],
            "mass": { "doc": "A weight, in kilograms", "names": "mass" },
            "bounciness": {
                "doc": "How much of my energy to keep on collision, 0 means none, 1 means all of it.",
                "names": "bounciness"
            },
            "friction": {
                "doc": "How much to keep sliding; 0 means none, 1 means forever.",
                "names": "friction"
            },
            "roundedness": {
                "doc": "How much to round the corners of the output; 0 means none and 1 means 100% of its size, making the sizes circular.",
                "names": "roundedness"
            },
            "text": {
                "doc": "Whether it can collide with other output.",
                "names": "text"
            },
            "shapes": {
                "doc": "Whether it can collide with other shapes.",
                "names": "ground"
            }
        },
        "Aura": {
            "doc": [
                "I am an AURA. I make @Phrase GLOW! Like this:",
                "\\Phrase(\n\t'I am GLOWING!' \n\taura: Aura(Color(50% 100 118Â°) 0.1m 0m 0.1m\n)\\"
            ],
            "names": ["ðŸ”®", "Aura"],
            "color": {
                "doc": "The @Color the @Aura should be.",
                "names": "color"
            },
            "blur": {
                "doc": "How blurry the @Aura should be. \\0m\\ means not blurry at all.",
                "names": "blur"
            },
            "offsetX": {
                "doc": "How far left or right I should appear. \\0m\\ is directly under.",
                "names": "offsetX"
            },
            "offsetY": {
                "doc": "How far up or down I should appear.\\0m\\ is directly under.",
                "names": "offsetY"
            }
        },
        "Stage": {
            "doc": [
                "HI. STAGE HERE. TELL ME WHAT TO SHOW AND I WILL SHOW IT.",
                "\\Stage([Phrase('stufffffff')])\\",
                "IF YOU WANT, GIVE ME A BACKGROUND @Color AND I WILL LIGHT THE STAGE ACCORDINGLY.",
                "\\Stage([Phrase('stufffffff')] Color(0% 0 0Â°) color: Color(100% 0 0Â°))\\",
                "YOU MAY ALSO GIVE ME A FRAME BORDER AND I WILL CROP.",
                "\\Stage([Phrase('stufffffff')] Color(0% 0 0Â°) Rectangle(-1m -1m 1m 1m) color: Color(100% 0 0Â°))\\"
            ],
            "names": ["ðŸŽ­", "Stage"],
            "content": {
                "doc": "The list of @Output to show on stage.",
                "names": "content"
            },
            "frame": {
                "doc": "The shape and size of frame to place around the stage, hiding everything outside it.",
                "names": "frame"
            },
            "size": {
                "doc": "LIKE @Group/size",
                "names": "size"
            },
            "face": {
                "doc": "LIKE @Group/face",
                "names": "face"
            },
            "place": {
                "doc": "IF I WERE A CAMERA, THIS IS WHERE I AM LOOKING",
                "names": "place"
            },
            "name": {
                "doc": ["SAME AS @Phrase/name!"],
                "names": "name"
            },
            "selectable": {
                "doc": "SAME AS @Phrase/selectable!",
                "names": "selectable"
            },
            "color": {
                "doc": "SAME AS @Group/color",
                "names": "color"
            },
            "background": {
                "doc": "SAME AS @Group/background",
                "names": "background"
            },
            "opacity": {
                "doc": "SAME AS @Group/opacity",
                "names": "opacity"
            },
            "offset": {
                "doc": "SAME AS @Group/offset",
                "names": "offset"
            },
            "rotation": {
                "doc": "SAME AS @Group/rotation",
                "names": ["ðŸ“", "rotation"]
            },
            "scale": {
                "doc": "SAME AS @Group/scale",
                "names": "scale"
            },
            "flipx": {
                "doc": "SAME AS @Group/flipx",
                "names": "flipx"
            },
            "flipy": {
                "doc": "SAME AS @Group/flipy",
                "names": "flipy"
            },
            "entering": {
                "doc": "SAME AS @Group/entering",
                "names": "entering"
            },
            "resting": {
                "doc": "SAME AS @Group/resting!",
                "names": "resting"
            },
            "moving": {
                "doc": "SAME AS @Group/moving!",
                "names": "moving"
            },
            "exiting": {
                "doc": "SAME AS @Group/exiting!",
                "names": "exiting"
            },
            "duration": {
                "doc": "SAME AS @Phrase/duration!",
                "names": ["â³", "duration"]
            },
            "style": {
                "doc": "SAME AS @Phrase/style!",
                "names": "style"
            },
            "gravity": {
                "doc": "The gravity to apply to output whose's place is in @Motion.",
                "names": "gravity"
            },
            "description": "stage $1[$1|] of $2[$2|] phrases $3[$3 frame|] $4"
        },
        "Easing": {
            "straight": "straight",
            "cautious": "cautious",
            "pokey": "pokey",
            "zippy": "zippy"
        },
        "sequence": {
            "sway": {
                "doc": "I create a @Sequence that sways back and forth around a @Output's center.",
                "names": ["sway"],
                "angle": {
                    "doc": "How much to tilt in the sway.",
                    "names": ["angle"]
                }
            },
            "bounce": {
                "doc": "I create a @Sequence that bounces @Output a given height.",
                "names": ["bounce"],
                "height": { "doc": "How high to bounce.", "names": ["height"] }
            },
            "spin": {
                "doc": "I create a @Sequence that rotates @Output around its center.",
                "names": ["spin"]
            },
            "fadein": {
                "doc": "I create a @Sequence that fades @Output in from invisible to visible.",
                "names": ["fadein"]
            },
            "popup": {
                "doc": "I create a @Sequence that makes @Output scale in quickly than shrink to its normal size.",
                "names": ["popup"]
            },
            "shake": {
                "doc": "I create a @Sequence that makes it look like a @Output is scared.",
                "names": ["shake"]
            }
        },
        "Source": {
            "names": "Source",
            "doc": [
                "You know how projects can have more than one @Source file? I let you create a @Source based on your project's logic. This is really helpful if you want to save some data between different evaluations of your project.",
                "For example, imagine you wanted to make a simple counter that counts up by one each time you press a mouse button. You might use this to remember how many times you did something.",
                "\\â†“ count\n[\n\tPhrase(`\\count\\ times!`)\n\tSource('count' count â€¦ âˆ† Button() â€¦ count + 1 )\n]\\",
                "Try copying it, making a new @Source called /count/ and typing 0 in it, to start the count at 0. This little project will get the value in the /count/ source and each time the mouse button is pressed, edits the /count/ @Source with to be the current /count/ value plus /1/."
            ],
            "name": {
                "names": "name",
                "doc": "The name of the source file to create or update."
            },
            "value": {
                "names": "value",
                "doc": "The data value that the source file should be created or updated with."
            },
            "DynamicEditLimitException": {
                "description": "dynamic source edit limit",
                "explanation": "This project saved data to @Source files too many times, too quickly. Make sure it only updates @Source in response to an input, and not too fast."
            },
            "ReadOnlyEditException": {
                "description": "read only source edit",
                "explanation": "This project remembers data, but you don't have rights to edit it. Copy it if you want to try it."
            },
            "EmptySourceNameException": {
                "description": "empty source name",
                "explanation": "The @Source given had an empty name, so we couldn't save it."
            },
            "ProjectSizeLimitException": {
                "description": "project size limit",
                "explanation": "This project has too much text, so we can't save it."
            }
        }
    },
    "ui": {
        "font": {
            "app": "Noto Sans",
            "code": "Noto Sans Mono"
        },
        "phrases": {
            "welcome": "hello"
        },
        "widget": {
            "confirm": {
                "cancel": "cancel"
            },
            "dialog": {
                "close": "close"
            },
            "loading": {
                "message": "Loading font faces and text, thanks for waiting!"
            },
            "home": "go to home page"
        },
        "tile": {
            "toggle": {
                "fullscreen": {
                    "on": "exit full screen",
                    "off": "expand to full screen"
                },
                "show": {
                    "on": "hide",
                    "off": "show"
                }
            },
            "label": {
                "output": "stage",
                "palette": "palette",
                "docs": "guide",
                "source": "source"
            },
            "button": {
                "collapse": "collapse window"
            }
        },
        "project": {
            "error": {
                "unknown": "This performance doesn't exist or isn't public."
            },
            "button": {
                "showCollaborators": "show collaborators dialog",
                "removeCollaborator": "remove collaborator",
                "copy": "copy project to clipboard as text",
                "addSource": "create a new $source",
                "duplicate": "copy this project",
                "revert": "revert to original code",
                "focusOutput": "focus keyboard on the stage",
                "focusSource": "focus on the next source",
                "focusDocs": "focus on the documentation",
                "focusPalette": "focus on the palette",
                "focusCycle": "focus on the next tile",
                "unsaved": "show save error"
            },
            "field": {
                "name": {
                    "description": "edit project name",
                    "placeholder": "name"
                }
            },
            "help": "show keyboard shortcuts",
            "collapsed": "All of your windows are collapsed! You can find them in the toolbar below",
            "save": {
                "projectsNotSavedLocally": "There was a problem saving projects in your browser.",
                "projectsCannotNotSaveLocally": "Your browser doesn't support saving projects.",
                "projectContainedPII": "To protect your privacy, a project with potentially personally identifiable information was not saved online. Check the project to see if the information is identifying.",
                "projectsNotLoadingOnline": "Unable to load online projects.",
                "projectNotSavedOnline": "Unable to save projects online.",
                "settingsUnsaved": "Unable to save settings online."
            },
            "dialog": {
                "unsaved": "Unsaved work..."
            }
        },
        "gallery": {
            "untitled": "Untitled",
            "undescribed": "No description",
            "subheader": {
                "curators": {
                    "header": "Curators",
                    "explanation": "Creators who manage this gallery."
                },
                "creators": {
                    "header": "Creators",
                    "explanation": "Creators who contribute to this gallery."
                },
                "delete": {
                    "header": "Delete",
                    "explanation": "Deleting this gallery will not delete its projects. The gallery will be deleted forever."
                }
            },
            "confirm": {
                "delete": {
                    "description": "delete gallery",
                    "prompt": "delete"
                },
                "remove": {
                    "description": "remove project from gallery",
                    "prompt": "remove"
                }
            },
            "error": {
                "unknown": "This gallery doesn't exist or isn't public."
            },
            "field": {
                "name": {
                    "description": "Gallery name",
                    "placeholder": "name"
                },
                "description": {
                    "description": "Gallery description",
                    "placeholder": "Describe your gallery. What is its theme, goals, or community?"
                }
            }
        },
        "source": {
            "label": "program editor",
            "empty": [
                "Let's get started! You can â€¦",
                "â€¢ Open ðŸ“• and drag ðŸ–±ï¸ us to this program.",
                "â€¢ Type $1 and choose us from the menu.",
                "â€¢ Type us with the âŒ¨ï¸.",
                "â€¢ Browse the <galleries@://galleries> for inspiration.",
                "If you're stuck, <learn more@://learn>."
            ],
            "overwritten": "Received a more recent version!",
            "confirm": {
                "delete": {
                    "description": "delete this $source",
                    "prompt": "delete"
                }
            },
            "toggle": {
                "blocks": {
                    "on": "hide block backgrounds",
                    "off": "show block backgrounds"
                },
                "localized": {
                    "on": "show localized text",
                    "off": "show all text"
                },
                "glyphs": {
                    "on": "collapse the matching glyphs",
                    "off": "expand the matching glyphs"
                }
            },
            "button": {
                "selectOutput": "show this output on stage",
                "expandSequence": "expand this collapsed code"
            },
            "field": {
                "name": {
                    "description": "edit source name",
                    "placeholder": "name"
                }
            },
            "menu": {
                "label": "autocomplete menu",
                "show": "show autocomplete menu",
                "back": "leave submenu"
            },
            "cursor": {
                "priorLine": "move cursor to line before",
                "nextLine": "move cursor to line after",
                "priorInline": "move cursor to position before",
                "nextInline": "move cursor to position after",
                "lineStart": "move cursor to start of line",
                "lineEnd": "move cursor to end of line",
                "sourceStart": "move cursor to start of source",
                "sourceEnd": "move cursor to end of source",
                "priorNode": "select neighbor before",
                "nextNode": "select neighbor after",
                "parent": "select container",
                "selectAll": "select program",
                "incrementLiteral": "increase number, text, or Boolean",
                "decrementLiteral": "decrease number, text, or Boolean",
                "insertSymbol": "insert $1",
                "insertTab": "insert tab",
                "insertTrue": "insert true",
                "insertFalse": "insert false",
                "insertNone": "insert none symbol",
                "insertNotEqual": "insert not equal",
                "insertProduct": "insert product symbol",
                "insertQuotient": "insert quotient symbol",
                "insertDegree": "insert degree symbol",
                "insertFunction": "insert function",
                "insertLessOrEqual": "insert less than or equal to",
                "insertGreaterOrEqual": "insert greater than or equal to",
                "insertType": "insert type symbol",
                "insertStream": "insert stream symbol",
                "insertChange": "insert change symbol",
                "insertConvert": "insert convert symbol",
                "insertPrevious": "insert previous symbol",
                "insertTable": "insert table open symbol",
                "insertTableClose": "insert table close symbol",
                "insertBorrow": "insert borrow",
                "insertShare": "insert share",
                "insertLine": "insert line break",
                "backspace": "delete selection or prior symbol",
                "delete": "delete selection or next symbol",
                "cut": "cut selection",
                "copy": "copy selection",
                "paste": "paste contents of keyboard",
                "parenthesize": "parenthesize selection",
                "enumerate": "enumerate selection",
                "type": "type characters",
                "undo": "undo previous edit",
                "redo": "redo undone edit",
                "search": "search for special characters to insert",
                "tidy": "tidy spacing",
                "elide": "toggle elision"
            }
        },
        "annotations": {
            "label": "conflicts and help",
            "cursor": "This is *$1*$2[ and they are of type $2|].    $3[ They're inside a *$3*.|]",
            "cursorParent": "They're inside a *$1*$2[ of type $2|].",
            "learn": "/Learn more/",
            "evaluating": "Oh fun, let's evaluate!",
            "space": "This is space! Who knew nothing could say so much?",
            "button": {
                "resolution": "Resolve this conflict"
            }
        },
        "output": {
            "label": "program output",
            "toggle": {
                "grid": {
                    "on": "hide grid lines",
                    "off": "show grid lines"
                },
                "fit": {
                    "on": "control zoom manually",
                    "off": "fit zoom to content"
                },
                "paint": {
                    "off": "place output",
                    "on": "paint output"
                }
            },
            "field": {
                "key": {
                    "description": "listening to key presses",
                    "placeholder": "message"
                }
            },
            "button": {
                "submit": "submit this chat message"
            }
        },
        "timeline": {
            "label": "timeline",
            "slider": "time slider",
            "button": {
                "play": "evaluate the program to the end, responding to inputs in real time",
                "pause": "pause the program, enabling stepping forward and backwards",
                "backStep": "step back one",
                "backNode": "step to previous evaluation of cursor",
                "backInput": "back one input",
                "out": "step out of this function",
                "forwardStep": "step forward one",
                "forwardNode": "step to next evaluation of cursor",
                "forwardInput": "step forward to next stream input",
                "present": "to the end",
                "start": "to the beginning",
                "reset": "restart performance"
            }
        },
        "docs": {
            "label": "docuemntation browser",
            "link": "show concept $1 in documentation",
            "learn": "learn more â€¦",
            "nodoc": "Who am I? What am I? What is my purpose?",
            "button": {
                "home": "return home",
                "back": "return to previous"
            },
            "field": {
                "search": "search for concepts with words"
            },
            "header": {
                "inputs": "Inputs",
                "interfaces": "Interfaces",
                "properties": "Properties",
                "functions": "Functions",
                "conversions": "Conversions"
            }
        },
        "dialog": {
            "share": {
                "header": "Sharing",
                "explanation": "Control who can edit and see this project.",
                "subheader": {
                    "collaborators": {
                        "header": "Collaborators",
                        "explanation": "Collaborators can view and edit this project. Only project owners can modify collaborators."
                    },
                    "gallery": {
                        "header": "Gallery",
                        "explanation": "Add this project in a gallery alongside other creators, or create a gallery on your <projects@://projects> page. If you add a project to a public gallery, your project will become public."
                    },
                    "public": {
                        "header": "Public/Private",
                        "explanation": "Public projects and galleries can be seen by anyone in the world. Our goal is for this content to bring affirmation and joy, and publicly sharing is a way to do that. But it also means following some rules. You promise that your project does not:"
                    },
                    "pii": {
                        "header": "Personal Information",
                        "explanation": "Sharing personally identifiable information (PII) publicly can put creators at risk, so we detect possible PII and warn creators to either remove the sensitive data or mark it as non-sensitive.\n\nBelow is a list of possible PII in this project you have marked as non-sensitive. You can click the button next to it to mark it as sensitive again, but doing so means that your project won't be saved online anymore."
                    }
                },
                "field": {
                    "emailOrUsername": {
                        "placeholder": "email or username",
                        "description": "email or username of the person who you want to give edit access"
                    }
                },
                "mode": {
                    "public": {
                        "label": "visibility",
                        "modes": ["private", "public"]
                    }
                },
                "error": {
                    "unknown": "We don't know a creator with this email.",
                    "anonymous": "You must be logged in to share."
                },
                "button": {
                    "submit": "Share the project with this email address",
                    "sensitive": {
                        "tip": "Mark this text as sensitive again",
                        "label": "sensitive"
                    }
                },
                "options": {
                    "gallery": "gallery chooser"
                }
            },
            "settings": {
                "header": "Settings",
                "explanation": "Change layout, device, and theme settings.",
                "button": {
                    "show": "show settings dialog"
                },
                "mode": {
                    "layout": {
                        "label": "layout",
                        "modes": ["automatic", "horizontal", "vertical", "free"]
                    },
                    "animate": {
                        "label": "animations",
                        "modes": [
                            "off",
                            "on",
                            "half speed",
                            "third speed",
                            "quarter speed"
                        ]
                    },
                    "dark": {
                        "label": "theme",
                        "modes": [
                            "light colors",
                            "dark colors",
                            "use device setting"
                        ]
                    },
                    "space": {
                        "label": "space indicator",
                        "modes": [
                            "show space and tab indicators explicitly",
                            "do not show space and tab indicators"
                        ]
                    },
                    "writing": {
                        "label": "writing layout",
                        "modes": [
                            "horizontal, left to right",
                            "vertical, right to left",
                            "vertical, left to right"
                        ]
                    }
                },
                "options": {
                    "mic": "selected microphone",
                    "camera": "selected camera"
                }
            },
            "locale": {
                "header": "Language",
                "explanation": "Choose your languages and regions.",
                "subheader": {
                    "selected": "Selected",
                    "supported": "Available",
                    "coming": "Coming Soon",
                    "help": "Help us translate â€¦"
                },
                "button": {
                    "show": "change locale",
                    "replace": "replace with this locale",
                    "add": "add this locale",
                    "remove": "remove this locale"
                }
            },
            "help": {
                "header": "Shortcuts",
                "explanation": "Use these keyboard commands for more efficient editing.",
                "subheader": {
                    "moveCursor": "Move",
                    "editCode": "Edit",
                    "insertCode": "Insert",
                    "debug": "Debug"
                }
            }
        },
        "palette": {
            "label": "palette",
            "labels": {
                "mixed": "mixed",
                "computed": "computed",
                "default": "default",
                "inherited": "inherited",
                "notSequence": "not a sequence",
                "notContent": "not a content list",
                "format": "format",
                "weight": "weight",
                "light": "light",
                "normal": "normal",
                "bold": "bold",
                "extra": "extra",
                "italic": "italic",
                "underline": "underline"
            },
            "button": {
                "revert": "revert to default",
                "set": "edit this property",
                "addPhrase": "add a phrase after this",
                "addGroup": "add a group after this",
                "addShape": "add a shape after this",
                "addMotion": "set place to Motion stream",
                "addPlacement": "set place to Placement stream",
                "remove": "remove this content",
                "up": "move this content up",
                "down": "move this content down",
                "edit": "edit this content",
                "sequence": "convert to Sequence",
                "createPhrase": "create a Phrase, showing the existing value as text",
                "createGroup": "create a Group, wrapping any existing Phrase",
                "createStage": "create a Stage, wrapping any existing Group or Phrase"
            },
            "prompt": {
                "offerPhrase": "What a gorgeous value you made! Shall I show it on @Stage?",
                "offerGroup": "What a wonderful @Phrase you made. Do you want to bring them together into a @Group, to get them arranged?",
                "offerStage": "VERY GOOD @Program. ADD ME TO CONTROL LIGHTING. COLORS. FRAMES.",
                "pauseToEdit": "If you â¸ï¸ the stage, you can select a ðŸ’¬, ðŸ”³, or ðŸŽ­ to edit!",
                "editing": "Edit me!"
            },
            "field": {
                "coordinate": "edit coordinate",
                "text": "edit text"
            },
            "sequence": {
                "button": {
                    "add": "add pose",
                    "remove": "remove pose",
                    "up": "move pose up",
                    "down": "move pose down"
                },
                "field": {
                    "percent": "edit percent"
                }
            }
        },
        "save": {
            "saving": "saving",
            "saved": "saved online",
            "local": "saved in browser",
            "unsaved": "unsaved"
        },
        "page": {
            "unknown": {
                "header": "Eep!",
                "message": "Where is this place? Can we go home?"
            },
            "landing": {
                "call": ["Hi! Want to bring words to life with us? ðŸ˜Š"],
                "value": "Learn to code by animating words, emojis, and symbols from the world's languages, whatever your abilities.",
                "description": "Wordplay is an innovative programming language ðŸ–¥ï¸ with block and text editing ðŸ“, playful inputs like time ðŸ•¦, sound ðŸŽ¤, webpages ðŸ”—, and physics ðŸŒŽ, instant time-travel debugging âª, and comprehensive documentation ðŸ—‚ï¸. All in a growing list of the world's languages ðŸŒ, following the latest web accessibility standards â™¿ï¸. Share with friends, private groups, or the world â†—ï¸. Free forever from the <University of Washington Information School@https://ischool.uw.edu/>.",
                "beta": [
                    "Wordplay is in *beta*. That means that functionality might change or not work as intended, and localizations might be incomplete. Report bugs and share ideas in <Discord@https://discord.gg/Jh2Qq9husy>, or <GitHub@https://github.com/wordplaydev/wordplay/issues>. See our <1.0 plans@https://github.com/wordplaydev/wordplay/milestones/1.0> and <contribute@https://github.com/wordplaydev/wordplay/wiki/contribute> if you can!"
                ],
                "link": {
                    "learn": "A dramatic tutorial of cast of characters",
                    "projects": "Create and share peformances",
                    "galleries": "Experience others' performances",
                    "rights": "Responsibilities, ours and yours",
                    "about": "Why does this place exist?"
                }
            },
            "learn": {
                "header": "Learn",
                "error": "We weren't able to find a tutorial for this language.",
                "button": {
                    "next": "next pause in dialog",
                    "previous": "previous pause in dialog"
                },
                "options": {
                    "lesson": "current lesson"
                }
            },
            "projects": {
                "header": "Projects",
                "projectprompt": "Ready to say something? Create a project or work on one. If you get stuck, keep <learning@://learn>.",
                "archiveheader": "Archived",
                "archiveprompt": "These are projects you've archived. Only owners can permanently delete or unarchive them. Archived projects will be permanently deleted 30 days after they were last edited.",
                "galleriesheader": "Galleries",
                "galleryprompt": "Create and curate galleries to share a collection of projects with others.",
                "add": {
                    "header": "New Project",
                    "explanation": "Choose a template to create a new project."
                },
                "button": {
                    "newproject": "new project",
                    "editproject": "edit this project",
                    "newgallery": "new gallery",
                    "unarchive": "unarchive this project"
                },
                "confirm": {
                    "archive": {
                        "description": "archive this performance",
                        "prompt": "archive"
                    },
                    "delete": {
                        "description": "permanently delete this performance",
                        "prompt": "delete forever"
                    }
                },
                "error": {
                    "noaccess": "We couldn't reach the internet.",
                    "nogalleryedits": "You must be logged in to create and change galleries.",
                    "newgallery": "We couldn't create a new gallery.",
                    "nodeletes": "You must be logged in to delete archived projects.",
                    "delete": "Oops, we couldn't delete the project!"
                }
            },
            "galleries": {
                "header": "Galleries",
                "prompt": "These are performances that others have made. Experience them, study them, or adapt them into your own statement.",
                "examples": "Examples"
            },
            "about": {
                "header": "About",
                "content": [
                    "Have you ever felt like coding was just for English-fluent, non-disabled Westerners who grew up with computers?",
                    "Yeah, us too.",
                    "This isn't an accident. Since the dawn of computing, programming languages have been design and built by mostly the same group of people -- mostly white, cis, English-speaking men in academia and industry in the US and Europe, and a few incredible woman mathematicians. They did their work in a time of post-colonial, winner-take-all power, and programming languages were a key tool for securing that power.",
                    "This history has led to a vision of computation that is primarily about speed, logic, profit, and domination.",
                    "This is an injustice. Because computing, for better and worse, now undergirds daily life in visible and invisible ways, and the people who have access to create with it are the ones most like its creators. The rest of humanity remains beholden to this power, because imagining anything different requires literacy, gatekept by language barriers, accesibility barriers, economic barriers, and inequities in public education.",
                    "*Wordplay* aspires to help change this. It's a programming platform designed to be global, supporting /all/ of the world's languages, but also be /about/ the world's languages. A platform on which everyone can create, with whatever abilities they have, to share interactive content that anyone can experience. For youth and young adults who want to express themselves through interactive words, emojis, and typography, playfully and artfully. Not with the goal of getting power for themselves, but to create a computational world that recognize the incredible strength and necessity of our beautiful differences.",
                    "We're a community of designers, educators, and developers trying to bring this vision to life. We are people of color, we are trans, we are queer, we are disabled, we are immigrants, we are refugees. We're centered at the <University of Washington@https://washington.edu> <Information School@https://ischool.uw.edu/> in Seattle, Washington, USA, a place that aspires to welcome everyone and undo the ableist and racist ravages of colonialism that continue today. Making this programming language and platform is a small part of that mission, offering a glimpse of a future of computing where /everyone/ belongs.",
                    "We'd love your help. Learn <how to contribute@https://github.com/wordplaydev/wordplay/wiki/contribute>, <donate@://donate>, or track our <progress@https://github.com/amyjko/wordplay/milestones>. Write our community organizer <Amy@https://amyjko.phd> if you have questions."
                ]
            },
            "login": {
                "header": "Login",
                "subtitle": "Create an account or login in to save your work online",
                "anonymous": "login",
                "prompt": {
                    "login": "Your performances are saving in this browser, but not online. If this is your device, that's okay! If it's not, others will have access to your projects, and you may lose them. To save them online and keep them private, log in or <create an account@://join>:",
                    "forgot": "*Forgot your password?* Unfortunately, we cannot recover your account since we do not gather contact information.",
                    "enter": "It looks like your login link came from a different browser or device. Can you enter your email again, just so we're sure it's you?",
                    "play": "You're logged in, we can save your projects online now! Want to create something?",
                    "tooyoung": "You must be 13 or older to login with an email.",
                    "passwordrule": "Passwords must be at least 10 characters long; if you're not using a password manager, choose three long words you'll remember.",
                    "passwordreminder": "It looks like you don't have an account yet. Enter your password again and make sure you've stored it safely and correctly, since it is not recoverable.",
                    "changeEmail": "Want to change your email? Submit a new one and we'll send a confirmation to the old one.",
                    "changePassword": "Want to change your password? Submit a new one and repeat it.",
                    "email": "Do you have an email-only account? Login by submit your email, and if there is account associated with it, we'll send you an email with sign-in link. New email-only accounts are not supported, to preserve privacy.",
                    "sent": "If this email is associated with an account, it will receive an email with a login link. It may take a few minutes to appear. If there is no account associated with this email, you will not receive anything.",
                    "logout": "Are you using a shared device and want to keep your projects private? Logout and we'll *delete your projects* from this device, but they will be saved online.",
                    "success": "Account created!",
                    "confirm": "Check your old email address to confirm you new address.",
                    "delete": "Want us to forget everything you've made here? This can't be undone.",
                    "reallyDelete": "Are you sure? Your account and settings will be deleted immediately and your projects will be scheduled for deletion. Collaborators on your projects will immediately lose access to them. Type your email or username to confirm that this is what you want.",
                    "name": "Pick an emoji to represent yourself to others."
                },
                "error": {
                    "expired": "This link expired.",
                    "invalid": "This link isn't valid.",
                    "email": "This email wasn't valid.",
                    "failure": "Unable to login :(",
                    "offline": "We couldn't reach the cloud â˜ï¸.",
                    "unchanged": "We couldn't change your email address, but we don't know why.",
                    "delete": "We couldn't delete your account, but we don't know why.",
                    "wrongPassword": "Not a valid username and password. Either your password is wrong, or someone else has this username.",
                    "tooMany": "You've tried and failed to log in too many times. You'll have to wait to try again."
                },
                "feedback": {
                    "changing": "Submitting new email...",
                    "deleting": "Okay, deleting your projects and settings...",
                    "updatedPassword": "Your password is updated.",
                    "match": "This must match your account's username."
                },
                "field": {
                    "email": {
                        "description": "edit login email",
                        "placeholder": "email"
                    },
                    "username": {
                        "description": "login username, don't use personally identifiable information",
                        "placeholder": "username"
                    },
                    "password": {
                        "description": "login password, at least 10 character",
                        "placeholder": "password"
                    },
                    "currentPassword": {
                        "description": "your current login password",
                        "placeholder": "current password"
                    },
                    "newPassword": {
                        "description": "your new password",
                        "placeholder": "new password"
                    }
                },
                "button": {
                    "logout": {
                        "tip": "logout of your account",
                        "label": "logout"
                    },
                    "login": "login with this email, sending a login link",
                    "updateEmail": "change your email",
                    "delete": {
                        "tip": "delete your account",
                        "label": "delete my dataâ€¦"
                    },
                    "reallyDelete": {
                        "tip": "delete your account forever",
                        "label": "delete it!!!"
                    },
                    "updatePassword": "submit new password"
                },
                "toggle": {
                    "reveal": {
                        "on": "Show password",
                        "off": "Hide password"
                    }
                }
            },
            "join": {
                "header": "Join",
                "prompt": {
                    "username": "Ready to create an account? First, choose a *username*. It must be at least 5 characters, can't be an email address, and shouldn't contain your name or other identifing information.",
                    "password": "Choose a password with at least *10 characters*. Enter it again to ensure you typed it correctly, and store it somewhere secure, like a password manager. *There is no way to recover your account* if you lose it, since we do not gather contact information."
                }
            },
            "rights": {
                "header": "Rights",
                "content": [
                    "Hi!",
                    "Let's set some expectations about your rights and ours (also in light of policy, such as the <COPPA@https://www.ecfr.gov/current/title-16/chapter-I/subchapter-C/part-312> and <GDPR@https://gdpr.eu/compliance-checklist-us-companies/>).",
                    "The first thing to know is that we are not a commercial entity. We are a community-based research project housed at a not-for-profit university. Our goal is to create a platform that brings you joy and helps us make discoveries about a more equitable and just world of computing. We have no interest in making money on this platform; any money we gather (usually through public funding) is used to sustain the platform, not to enrich anyone who works on it (or contributes to it).",
                    "Because we are not seeking profit, this also means that we can't make any promises about the reliability, availability, or longevity of this platform. That said, <Amy@https://amyjko.phd> is committed long term to sustaining it, and as a tenured professor, she's got a pretty stable gig.",
                    "That brings is to *data*. Here's what we gather and store in the cloud:",
                    "â€¢ Your *projects*. We store any projects you contribute and your changes to them, unless those projects appear to have personally identifiable information such as phone numbers, email addresses, usernames, tax identifiers, or addresses.",
                    "â€¢ Your *settings*. This includes the languages you choose, your animation preferences, and your tutorial progress. Everything else is stored on your device only.",
                    "â€¢ Aggregate *activity*. We track logins and the pages you visit, but not in a way that can identify you, track you across the site, or track you across other sites. We use Google Analytics in 'consent denied' mode, which only gathers minimal non-identifiable information about page views, without storing cookies, or sending IP address information to Google. We use this aggregate information to help raise funding by reporting how much the platform is being used.",
                    "We don't store anything else. Our <source@https://github.com/amyjko/wordplay/tree/main/src> is public, so anyone can verify this, and report any unintended tracking.",
                    "*You* own your data, not us. That means:",
                    "â€¢ You control who can access your projects. They are private by default, but you can share them with individuals, groups, or make them entirely public.",
                    "â€¢ You can fully delete any project or your own account at any time.",
                    "â€¢ You can get an export of any project or your whole account at any time.",
                    "Here's how we will and won't use your data:",
                    "â€¢ We won't share your data with anyone, unless explicitly required by law. It's always possible that your data is taken without out permission (a 'data breach'). If we discover that this has happened, we will notify you that this has happened using the email you've shared with us.",
                    "â€¢ We won't contact you via your email address unless you 1) make an account change that requires us to, 2) you explicitly give us consent to reach out, or 3) in the case of data breach above.",
                    "â€¢ We may analyze projects on the platform to understand what everyone is making and how they are making it. We may share these aggregated, anonymized insights in academic publications. We will only do this under the supervision of an institutional review board, as mandated by U.S. federal law.",
                    "Finally, a note about speech. You can say anything you want on this platform in *private*. Projects are private by default, and if you share them with specific email addresses, they are still considered private. We won't moderate anything in private projects.",
                    "But making a project *public*, or including it in a public gallery, is a privilege. This is a platform made for love, affirmation, respect, and dignity. Therefore, we expect that none of your *public* content will:"
                ],
                "consequences": [
                    "If we find a project or gallery that violates these rules, we will warn creators before they view it, or block it from being viewed. If you repeatedly violate these rules, you'll lose the privilege of posting publicly."
                ]
            },
            "donate": {
                "header": "Donate",
                "prompt": "Enable more accessible, global programming",
                "content": [
                    "Wordplay is a free, community-based project supported by the <University of Washington@https://washington.edu>. We rely on gifts from people who believe in our mission of accessible, language-inclusive, educational programming languages.",
                    "Here are our current costs:",
                    "â€¢ We compensate University of Washington undergraduates, especially those who are disabled or whose first language was not English, to evolve and maintain the project. This is about 90% of our costs.",
                    "â€¢ We give stipends to teachers who we collaborate with to develop multilingual, accessible curricula.",
                    "â€¢ We pay Google for <Firebase@https://firebase.google.com/> bandwidth and storage, and <Workspace@https://workspace.google.com/> services.",
                    "â€¢ We pay <Squarespace@https://www.squarespace.com/> annually for the domain.",
                    "Our current costs, assuming 5 undergraduates at $$20 USD//hour, 10 hours//week during the academic year (36 weeks) and 2 undergraduates during the summer (12 weeks), plus cloud services, are about $$60K USD per year.",
                    "If 2,400 people gave $$25 USD per year, that would cover our current costs, with any excess going to compensation more students and teachers.",
                    "Can you be one of those 2,400 people? If so, here's our University of Washington giving link:"
                ]
            }
        },
        "edit": {
            "node": "$1$2[, type $2|]",
            "before": "before $1[$1|end]",
            "inside": "in $1, between $2[$2|start] and $3[$3|end]",
            "between": "between $1 and $2",
            "line": "empty line between $1[$1|start] and $2[$2|end]",
            "conflicts": "$1 conflicts",
            "assign": "/$2[Eager to join|Considers leaving]â€¦/",
            "append": "/Eager to insertâ€¦/",
            "remove": "/Considers leavingâ€¦/",
            "replace": "/Wants to step inâ€¦/",
            "wrap": "parentheize",
            "unwrap": "unwrap",
            "bind": "name this expression"
        },
        "template": {
            "unwritten": "TBD",
            "unparsable": "Unparsable template: $1"
        }
    },
    "moderation": {
        "warning": {
            "header": "Warning",
            "explanation": "A moderator judged that this content may:"
        },
        "blocked": {
            "header": "Blocked",
            "explanation": "A moderator judged that this content may:"
        },
        "unmoderated": {
            "header": "Note",
            "explanation": "This content hasn't been moderated yet. It may:"
        },
        "moderate": {
            "header": "Moderate",
            "explanation": "Review this project and decide if it's content does any of the following. If it does, content will be warned or blocked. You can skip if you're unsure."
        },
        "flags": {
            "violence": "Incite, encourage, or celebrate violence, harm, or self harm to anyone.",
            "dehumanization": "Dehumanize individuals or groups based on their race, ethnicity, national origin, caste, sexual orientation, gender, religion, age, ability, or appearance.",
            "disclosure": "Reveal private information about other people such as names, contact information, or physical addresses",
            "misinformation": "Contain false, misleading, deceptive, or manipulative information"
        },
        "progress": "*$1* moderated, *$2* remaining",
        "button": {
            "submit": {
                "tip": "Save these moderation settings",
                "label": "save"
            },
            "skip": {
                "tip": "Skip this project",
                "label": "skip"
            }
        }
    },
    "gallery": {
        "games": {
            "name": "Games",
            "description": "Interactive games with words and symbols."
        },
        "visualizations": {
            "name": "Visualizations",
            "description": "Visualizations of and via text."
        },
        "motion": {
            "name": "Motion",
            "description": "Examples of movement and collisions."
        },
        "av": {
            "name": "Audio/Video",
            "description": "Using volume, pitch, and video as input."
        },
        "tools": {
            "name": "Tools",
            "description": "Simple utilities and applications."
        }
    }
}
