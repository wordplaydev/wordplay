import Project from './Project';
import type LocaleText from '../../locale/LocaleText';
import type { SerializedProject } from '@db/projects/ProjectSchemas';
import type LocalesDatabase from '../LocalesDatabase';

// Remember this many project edits.
const PROJECT_HISTORY_LIMIT = 1000;

export enum ChangeType {
    Edit = 'edited',
    UndoRedo = 'undoredo',
}

export enum PersistenceType {
    /** It should not be editable, or saved in local or cloud databases */
    None = 'none',
    /** It should be saved locally, enabling editability, but it won't be persisted in the cloud */
    Local = "local'",
    /** It should be saved locally and in the cloud, when possible */
    Online = 'online',
}

/**
 * Projects that have been generated by a source persistence too many times in
 * a row likely have infinite recursion. Halt them.
 * */
export const MaxDynamicEdits = 16;

/**
 * The time after which we automatically checkpoint the source history. Currently up to every minute.
 */
const CheckpointTime = 60 * 1000;

/**
 * An class representing a project and its history, and a Svelte store for reactivity
 * on changes to the project.
 */
export class ProjectHistory {
    /** The id of the project being tracked */
    readonly id: string;

    /** A Svelte state of the current version of the project. The little ! indicates that it can't be undefined. */
    private current: Project = $state()!;
    /**
     * Previous versions of the project.
     * It always contains the current version of the project and is therefore never empty.
     * There is one history for the entire project; no per-source history.
     * History is not persisted, it's session-only.
     */
    private history: SerializedProject[] = $state([]);

    /**  The index of the current project in the history. */
    private index: number;

    /** The type of change recently made to the project, so that editors know how to handle caret positions.  */
    private change: ChangeType = ChangeType.Edit;

    /** True if this was successfully saved in the remote database. */
    private saved = false;

    /** True if this should be persisted locally in databases */
    private persist: PersistenceType;

    /** The number of consecutive dynamic persists, to help prevent infinite persistence by projects. */
    private lastDynamicEdit = 0;
    private consecutiveDynamicEdits = 0;

    /** True if the last edit was an overwrite */
    private overwrite = false;

    /** The last epoch time we saved an edit of this project. */
    private lastSave: number | undefined = undefined;

    /** A reference to the locales database so necessary locales can be loaded */
    private locales: LocalesDatabase;

    constructor(
        project: Project,
        persist: PersistenceType,
        saved: boolean,
        locales: LocalesDatabase,
    ) {
        this.id = project.getID();
        this.current = project;
        this.history.push(project.serialize());
        this.index = 0;
        this.persist = persist;
        this.saved = saved;
        this.locales = locales;
    }

    /** Revise this project history to have all of the specified locales. */
    withLocales(locales: LocaleText[]) {
        this.current = this.current.withLocales(locales);
    }

    getCurrent() {
        return this.current;
    }

    edit(
        project: Project,
        remember: boolean,
        overwrite = false,
        /** Whether the edit should be treated as one that is happening in rapid succession, to avoid saving too much history. */
        dynamic = false,
    ): boolean {
        // If its dynamic and the last dynamic was less than 200 milliseconds ago, increment the consecutive count, otherwise reset.
        if (dynamic && performance.now() - this.lastDynamicEdit < 200)
            this.consecutiveDynamicEdits++;
        else this.consecutiveDynamicEdits = 0;
        this.lastDynamicEdit = performance.now();

        // If we've exceeded the limit, return false.
        if (this.consecutiveDynamicEdits >= MaxDynamicEdits) return false;

        // When was the last time we checkpointed the source history? If never, remember the time.
        const now = Date.now();
        if (this.lastSave === undefined) this.lastSave = now;
        // If the checkpoint time has elapsed since the last edit, remember the current version before updating this version.
        else if (
            now - this.lastSave > CheckpointTime &&
            this.current.latestCheckpointIsDifferentFrom(project)
        ) {
            project = project.withCheckpoint();
            this.lastSave = Date.now();
        }

        // Is the undo pointer before the end? Trim the future before we add the future.
        this.history.splice(
            this.index + 1,
            this.history.length - this.index - 1,
        );

        // If we're remembering the last change, append the new project version.
        if (remember) this.history = [...this.history, project.serialize()];
        // Otherwise, replace the latest version.
        else this.history[this.history.length - 1] = project.serialize();

        // Mark this as an edit change.
        this.change = ChangeType.Edit;

        // Reset the index to the end.
        this.index = this.history.length - 1;

        // Mark it as not saved.
        this.saved = false;

        // Update overwrite
        this.overwrite = overwrite;

        // Trim the history if we've exceeded our limit.
        if (this.history.length > PROJECT_HISTORY_LIMIT)
            this.history.splice(0, PROJECT_HISTORY_LIMIT - this.history.length);

        // Ping the store, so everyone knows about the edit.
        this.current = project;

        // Note whether we've exceeded max dynamic edits.
        return true;
    }

    isUndoable() {
        return this.index > 0;
    }

    isRedoable() {
        return this.index < this.history.length - 1;
    }

    wasOverwritten() {
        return this.overwrite;
    }

    async undoRedo(direction: -1 | 1): Promise<Project | undefined> {
        // In the present? Do nothing.
        if (direction > 0 && this.index === this.history.length - 1)
            return undefined;
        // No more history? Do nothing.
        else if (direction < 0 && this.index === 0) return undefined;

        // Move the index back a step in time
        this.index += direction;

        const newProject: Project = await Project.deserialize(
            this.locales,
            this.history[this.index],
        );

        // Change the current project to the historical project.
        // Since we use the time of the project to determine overwrites, give it a new time
        // so the projects database doesn't overwrite it.
        this.current = newProject.withNewTime();

        // Set the change type to undo/redo.
        this.change = ChangeType.UndoRedo;

        // Mark unsaved
        this.saved = false;

        // Reset overwrite.
        this.overwrite = false;

        return newProject;
    }

    isUnsaved() {
        return !this.saved;
    }

    markSaved() {
        this.saved = true;
    }

    wasRestored() {
        return this.change === ChangeType.UndoRedo;
    }

    getPersisted() {
        return this.persist;
    }

    setPersist(mode: PersistenceType) {
        this.persist = mode;
    }
}
