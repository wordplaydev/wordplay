import { get, writable, type Writable } from 'svelte/store';
import Project from '../models/Project';
import type Locale from '../locale/Locale';
import type { SerializedProject } from '@models/ProjectSchemas';
import type LocalesDatabase from './LocalesDatabase';

// Remember this many project edits.
const PROJECT_HISTORY_LIMIT = 1000;

export enum ChangeType {
    Edit = 'edited',
    UndoRedo = 'undoredo',
}

export enum PersistenceType {
    /** It should not be editable, or saved in local or cloud databases */
    None = 'none',
    /** It should be saved locally, enabling editability, but it won't be persisted in the cloud */
    Local = "local'",
    /** It should be saved locally and in the cloud, when possible */
    Online = 'online',
}

/**
 * Projects that have been generated by a source persistence too many times in
 * a row likely have infinite recursion. Halt them.
 * */
export const MAX_DYNAMIC_EDITS = 16;

/**
 * An class representing a project and its history, and a Svelte store for reactivity
 * on changes to the project.
 */
export class ProjectHistory {
    /** The id of the project being tracked */
    readonly id: string;
    /** A Svelte store of the current version of the project. */
    private current: Writable<Project>;
    /**
     * Previous versions of the project.
     * It always contains the current version of the project and is therefore never empty.
     * There is one history for the entire project; no per-source history.
     * History is not persisted, it's session-only.
     */
    private history: SerializedProject[] = [];

    /**  The index of the current project in the history. */
    private index: number;

    /** The type of change recently made to the project, so that editors know how to handle caret positions.  */
    private change: ChangeType = ChangeType.Edit;

    /** True if this was successfully saved in the remote database. */
    private saved = false;

    /** True if this should be persisted locally in databases */
    private persist: PersistenceType;

    /** The number of consecutive dynamic persists, to help prevent infinite persistence by projects. */
    private lastDynamicEdit = 0;
    private consecutiveDynamicEdits = 0;

    /** True if the last edit was an overwrite */
    private overwrite = false;

    /** A reference to the locales database so necessary locales can be loaded */
    private locales: LocalesDatabase;

    constructor(
        project: Project,
        persist: PersistenceType,
        saved: boolean,
        locales: LocalesDatabase,
    ) {
        this.id = project.getID();
        this.current = writable(project);
        this.history.push(project.serialize());
        this.index = 0;
        this.persist = persist;
        this.saved = saved;
        this.locales = locales;
    }

    /** Revise this project history to have all of the specified locales. */
    withLocales(locales: Locale[]) {
        this.current.set(get(this.current).withLocales(locales));
    }

    getCurrent() {
        return get(this.current);
    }

    getStore() {
        return this.current;
    }

    edit(
        project: Project,
        remember: boolean,
        overwrite = false,
        dynamic = false,
    ): boolean {
        // If its dynamic and the last dynamic was less than 200 milliseconds ago, increment the consecutive count, otherwise reset.
        if (dynamic && performance.now() - this.lastDynamicEdit < 200)
            this.consecutiveDynamicEdits++;
        else this.consecutiveDynamicEdits = 0;
        this.lastDynamicEdit = performance.now();

        // If we've exceeded the limit, return false.
        if (this.consecutiveDynamicEdits >= MAX_DYNAMIC_EDITS) return false;

        // Is the undo pointer before the end? Trim the future before we add the future.
        this.history.splice(
            this.index + 1,
            this.history.length - this.index - 1,
        );

        // If we're remembering the last change, append the new project version.
        if (remember) this.history = [...this.history, project.serialize()];
        // Otherwise, replace the latest version.
        else this.history[this.history.length - 1] = project.serialize();

        // Mark this as an edit change.
        this.change = ChangeType.Edit;

        // Reset the index to the end.
        this.index = this.history.length - 1;

        // Mark it as not saved.
        this.saved = false;

        // Update overwrite
        this.overwrite = overwrite;

        // Trim the history if we've exceeded our limit.
        if (this.history.length > PROJECT_HISTORY_LIMIT)
            this.history.splice(0, PROJECT_HISTORY_LIMIT - this.history.length);

        // Ping the store, so everyone knows about the edit.
        this.current.set(project);

        // Note whether we've exceeded max dynamic edits.
        return true;
    }

    ping() {
        this.current.set(this.getCurrent());
    }

    isUndoable() {
        return this.index > 0;
    }

    isRedoable() {
        return this.index < this.history.length - 1;
    }

    wasOverwritten() {
        return this.overwrite;
    }

    async undoRedo(direction: -1 | 1): Promise<Project | undefined> {
        // In the present? Do nothing.
        if (direction > 0 && this.index === this.history.length - 1)
            return undefined;
        // No more history? Do nothing.
        else if (direction < 0 && this.index === 0) return undefined;

        // Move the index back a step in time
        this.index += direction;

        const newProject: Project = await Project.deserialize(
            this.locales,
            this.history[this.index],
        );

        // Change the current project to the historical project.
        this.current.set(newProject);

        // Set the change type to undo/redo.
        this.change = ChangeType.UndoRedo;

        // Mark unsaved
        this.saved = false;

        // Reset overwrite.
        this.overwrite = false;

        return newProject;
    }

    isUnsaved() {
        return !this.saved;
    }

    markSaved() {
        this.saved = true;
    }

    wasRestored() {
        return this.change === ChangeType.UndoRedo;
    }

    getPersisted() {
        return this.persist;
    }

    setPersist(mode: PersistenceType) {
        this.persist = mode;
    }
}
